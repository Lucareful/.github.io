<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link href="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/themes/black/pace-theme-loading-bar.css" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet"><link href="/css/main.css?v=5.1.4" rel="stylesheet"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/L.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/L.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="QuerySet集合,"><meta name="description" content="从数据库中查询出来的结果一般是一个集合，这个集合叫做 QuerySet。一、QuerySet何时被提交在内部，创建、过滤、切片和传递一个QuerySet不会真实操作数据库，在你对查询集提交之前，不会发生任何实际的数据库操作。可以使用下列方法对QuerySet提交查询操作：迭代QuerySet是可迭代的，在首次迭代查询集时执行实际的数据库查询。 例如， 下面的语句会将数据库中所有Entry的head"><meta name="keywords" content="QuerySet集合"><meta property="og:type" content="article"><meta property="og:title" content="Django的QuerySet详解"><meta property="og:url" content="http://yoursite.com/2020/10/10/django的querySet详解/index.html"><meta property="og:site_name" content="Luenci"><meta property="og:description" content="从数据库中查询出来的结果一般是一个集合，这个集合叫做 QuerySet。一、QuerySet何时被提交在内部，创建、过滤、切片和传递一个QuerySet不会真实操作数据库，在你对查询集提交之前，不会发生任何实际的数据库操作。可以使用下列方法对QuerySet提交查询操作：迭代QuerySet是可迭代的，在首次迭代查询集时执行实际的数据库查询。 例如， 下面的语句会将数据库中所有Entry的head"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2020-12-01T15:04:45.577Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Django的QuerySet详解"><meta name="twitter:description" content="从数据库中查询出来的结果一般是一个集合，这个集合叫做 QuerySet。一、QuerySet何时被提交在内部，创建、过滤、切片和传递一个QuerySet不会真实操作数据库，在你对查询集提交之前，不会发生任何实际的数据库操作。可以使用下列方法对QuerySet提交查询操作：迭代QuerySet是可迭代的，在首次迭代查询集时执行实际的数据库查询。 例如， 下面的语句会将数据库中所有Entry的head"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"always",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/2020/10/10/django的querySet详解/"><title>Django的QuerySet详解 | Luenci</title><script color="0,0,255" opacity="0.7" zindex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><canvas class="fireworks" style="position:fixed;left:0;top:0;z-index:1;pointer-events:none"></canvas><script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script><script src="/js/src/fireworks.js"></script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Luenci</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/10/django的querySet详解/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Luenci"><meta itemprop="description" content><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Luenci"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Django的QuerySet详解</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-10-10T20:58:06+08:00">2020-10-10 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python的web框架/" itemprop="url" rel="index"><span itemprop="name">python的web框架</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2020/10/10/django的querySet详解/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2020/10/10/django的querySet详解/" itemprop="commentCount"></span></a></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">9.1k </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">37</span></div></div></header><div class="post-body" itemprop="articleBody"><p>从数据库中查询出来的结果一般是一个集合，这个集合叫做 QuerySet。</p><h1 id="一、QuerySet何时被提交"><a href="#一、QuerySet何时被提交" class="headerlink" title="一、QuerySet何时被提交"></a>一、QuerySet何时被提交</h1><ul><li>在内部，创建、过滤、切片和传递一个QuerySet不会真实操作数据库，在你对查询集提交之前，不会发生任何实际的数据库操作。可以使用下列方法对QuerySet提交查询操作：</li></ul><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><ul><li>QuerySet是可迭代的，在首次迭代查询集时执行实际的数据库查询。 例如， 下面的语句会将数据库中所有Entry的headline打印出来：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> Entry.objects.all():</span><br><span class="line">	print(e.headline)</span><br></pre></td></tr></table></figure><ul><li>切片：如果使用切片的”step“参数，Django 将执行数据库查询并返回一个列表。</li></ul><h2 id="Pickling-缓存"><a href="#Pickling-缓存" class="headerlink" title="Pickling/缓存"></a>Pickling/缓存</h2><ul><li><p>repr()</p></li><li><p>len()：当你对QuerySet调用len()时， 将提交数据库操作。</p></li><li><p>list()：对QuerySet调用list()将强制提交操作entry_list = list(Entry.objects.all())</p></li><li><p>bool()</p><ul><li><p>测试布尔值，像这样：</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> Entry.objects.filter(headline=<span class="string">"Test"</span>):</span><br><span class="line">  print(<span class="string">"There is at least one Entry with the headline Test"</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>注：如果你需要知道是否存在至少一条记录（而不需要真实的对象），使用exists() 将更加高效。</p><h1 id="二、QuerySet"><a href="#二、QuerySet" class="headerlink" title="二、QuerySet"></a>二、QuerySet</h1><p>下面是对于QuerySet的正式定义：</p><ul><li>class QuerySet(model=None, query=None, using=None)[source]</li></ul><p>QuerySet类具有两个公有属性用于内省：</p><ul><li>ordered：如果QuerySet是排好序的则为True，否则为False。</li><li>db：如果现在执行，则返回使用的数据库。</li></ul><a id="more"></a><h1 id="三、返回新QuerySets的API"><a href="#三、返回新QuerySets的API" class="headerlink" title="三、返回新QuerySets的API"></a>三、返回新QuerySets的API</h1><ul><li>以下的方法都将返回一个新的QuerySets。重点是加粗的几个API，其它的使用场景很少。</li></ul><h2 id="方法名-解释"><a href="#方法名-解释" class="headerlink" title="方法名 解释"></a><strong>方法名 解释</strong></h2><ul><li><p>filter() 过滤查询对象。</p></li><li><p>exclude() 排除满足条件的对象</p></li><li><p>annotate() 使用聚合函数</p></li><li><p>order_by() 对查询集进行排序</p></li><li><p>reverse() 反向排序</p></li><li><p>distinct() 对查询集去重</p></li><li><p>values() 返回包含对象具体值的字典的QuerySet</p></li><li><p>values_list() 与values()类似，只是返回的是元组而不是字典。</p></li><li><p>dates() 根据日期获取查询集</p></li><li><p>datetimes() 根据时间获取查询集</p></li><li><p>none() 创建空的查询集</p></li><li><p>all() 获取所有的对象</p></li><li><p>union() 并集</p></li><li><p>intersection() 交集</p></li><li><p>difference() 差集</p></li><li><p>select_related() 附带查询关联对象</p></li><li><p>prefetch_related()预先查询</p></li><li><p>extra() 附加SQL查询</p></li><li><p>defer() 不加载指定字段</p></li><li><p>only() 只加载指定的字段</p></li><li><p>using() 选择数据库</p></li><li><p>select_for_update()锁住选择的对象，直到事务结束。</p></li><li><p>raw() 接收一个原始的SQL查询</p></li></ul><h3 id="1-filter"><a href="#1-filter" class="headerlink" title="1. filter()"></a>1. filter()</h3><p><code>filter(**kwargs)</code></p><ul><li><p>返回满足查询参数的对象集合。</p></li><li><p>查找的参数（**kwargs）应该满足下文字段查找中的格式。多个参数之间是和AND的关系。</p></li></ul><h3 id="2-exclude"><a href="#2-exclude" class="headerlink" title="2. exclude()"></a>2. exclude()</h3><p><code>exclude(**kwargs)</code></p><ul><li><p>返回一个新的<code>QuerySet</code>，它包含<code>不满足给定的查找参数的对象</code>。</p></li><li><p>查找的参数（**kwargs）应该满足下文字段查找中的格式。多个参数通过<code>AND连接</code>，然后所有的内容放入<code>NOT()</code>中。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的示例排除所有pub_date晚于2005-1-3且headline为“Hello” 的记录：</span></span><br><span class="line"></span><br><span class="line">Entry.objects.exclude(pub_date__gt=[datetime.date](<span class="number">2005</span>, <span class="number">1</span>, <span class="number">3</span>), headline=<span class="string">'Hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的示例排除所有pub_date晚于2005-1-3或者headline 为“Hello” 的记录：</span></span><br><span class="line"></span><br><span class="line">Entry.objects.exclude(pub_date__gt=[datetime.date](<span class="number">2005</span>, <span class="number">1</span>, <span class="number">3</span>)).exclude(headline=<span class="string">'Hello'</span>)</span><br></pre></td></tr></table></figure><h3 id="3-annotate"><a href="#3-annotate" class="headerlink" title="3. annotate()"></a>3. annotate()</h3><p><code>annotate(args, *kwargs)</code></p><ul><li><p>使用提供的聚合表达式查询对象。</p></li><li><p>表达式可以是简单的值、对模型（或任何关联模型）上的字段的引用或者聚合表达式（<code>平均值、总和等</code>）。</p></li><li><p>annotate()的每个参数都是一个annotation，它将添加到返回的QuerySet每个对象中。</p></li><li><p>关键字参数指定的Annotation将使用关键字作为Annotation 的别名。 匿名参数的别名将基于聚合函数的名称和模型的字段生成。 只有引用单个字段的聚合表达式才可以使用匿名参数。 其它所有形式都必须用关键字参数。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如，如果正在操作一个Blog列表，你可能想知道每个Blog有多少Entry：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = Blog.objects.annotate(Count(<span class="string">'entry'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># The name of the first blog</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q[<span class="number">0</span>].name</span><br><span class="line"></span><br><span class="line"><span class="string">'Blogasaurus'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The number of entries on the first blog</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q[<span class="number">0</span>].entry__count</span><br><span class="line"><span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Blog模型本身没有定义entry__count属性，但是通过使用一个关键字参数来指定聚合函数，可以控制Annotation的名称：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = Blog.objects.annotate(number_of_entries=Count(<span class="string">'entry'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># The number of entries on the first blog, using the name provided</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q[<span class="number">0</span>].number_of_entries</span><br><span class="line"></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><h3 id="4-order-by"><a href="#4-order-by" class="headerlink" title="4. order_by()"></a>4. order_by()</h3><p><code>order_by(*fields)</code></p><ul><li>默认情况下，根据模型的Meta类中的ordering属性对QuerySet中的对象进行排序</li></ul><p><code>Entry.objects.filter(pub_date__year=2005).order_by(&#39;-pub_date&#39;, &#39;headline&#39;)</code></p><ul><li><p>上面的结果将按照pub_date降序排序，然后再按照headline升序排序。”-pub_date”前面的负号表示降序顺序。 升序是默认的。 要随机排序，使用”?”，如下所示：</p></li><li><p>Entry.objects.order_by(‘?’)</p></li></ul><blockquote><p>注：order_by(‘?’)可能耗费资源且很慢，这取决于使用的数据库。</p></blockquote><ul><li><p>若要按照另外一个模型中的字段排序，可以使用查询关联模型的语法。即通过字段的名称后面跟两个下划线（__），再加上新模型中的字段的名称，直到希望连接的模型。 像这样：</p></li><li><p>Entry.objects.order_by(‘blog__name’, ‘headline’)</p></li><li><p>如果排序的字段与另外一个模型关联，Django将使用关联的模型的默认排序，或者如果没有指定Meta.ordering将通过关联的模型的主键排序。 例如，因为Blog模型没有指定默认的排序：</p></li><li><p>Entry.objects.order_by(‘blog’)</p></li></ul><p>与以下相同：</p><p><code>Entry.objects.order_by(&#39;blog__id&#39;)</code></p><ul><li><p>如果Blog设置了ordering = [‘name’]，那么第一个QuerySet将等同于：</p></li><li><p>Entry.objects.order_by(‘blog__name’)</p></li><li><p>还可以通过调用表达式的<code>desc()</code>或者<code>asc()</code>方法：</p></li><li><p>Entry.objects.order_by(Coalesce(‘summary’, ‘headline’).desc())</p></li></ul><p>考虑下面的情况，指定一个多值字段来排序（例如，一个ManyToManyField 字段或者ForeignKey 字段的反向关联）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span><span class="params">(Model)</span>:</span></span><br><span class="line"></span><br><span class="line">parent = models.ForeignKey(</span><br><span class="line"></span><br><span class="line"><span class="string">'self'</span>,</span><br><span class="line"></span><br><span class="line">on_delete=models.CASCADE,</span><br><span class="line"></span><br><span class="line">related_name=<span class="string">'children'</span>,</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">date = models.DateField()</span><br><span class="line"></span><br><span class="line">Event.objects.order_by(<span class="string">'children__date'</span>)</span><br></pre></td></tr></table></figure><ul><li><p>在这里，每个Event可能有多个排序数据；具有多个children的每个Event将被多次返回到order_by()创建的新的QuerySet中。 换句话说，用order_by()方法对QuerySet对象进行操作会返回一个扩大版的新QuerySet对象。因此，使用多值字段对结果进行排序时要格外小心。</p></li><li><p>没有方法指定排序是否考虑大小写。 对于大小写的敏感性，Django将根据数据库中的排序方式排序结果。</p></li><li><p>可以通过Lower将一个字段转换为小写来排序，它将达到大小写一致的排序：</p></li><li><p><code>Entry.objects.order_by(Lower(&#39;headline&#39;).desc())</code></p></li><li><p>可以通过检查QuerySet.ordered属性来知道查询是否是排序的。</p></li><li><p>每个<code>order_by()</code>都将清除前面的任何排序。 例如下面的查询将按照pub_date排序，而不是headline：</p></li><li><p><code>Entry.objects.order_by(&#39;headline&#39;).order_by(&#39;pub_date&#39;)</code></p></li></ul><h3 id="5-reverse"><a href="#5-reverse" class="headerlink" title="5. reverse()"></a>5. reverse()</h3><p><code>reverse()</code></p><ul><li><p>反向排序QuerySet中返回的元素。 第二次调用reverse()将恢复到原有的排序。</p></li><li><p>如要获取QuerySet中最后五个元素，可以这样做：</p></li><li><p>my_queryset.reverse()[:5]</p></li><li><p>这与Python直接使用负索引有点不一样。 <code>Django不支持负索引，只能曲线救国</code>。</p></li></ul><h3 id="6-distinct"><a href="#6-distinct" class="headerlink" title="6. distinct()"></a>6. distinct()</h3><p><code>distinct(*fields)</code></p><ul><li><p>去除查询结果中重复的行。</p></li><li><p>默认情况下，QuerySet不会去除重复的行。当查询跨越多张表的数据时，QuerySet可能得到重复的结果，这时候可以使用<code>distinct()</code>进行去重。</p></li></ul><h3 id="7-values"><a href="#7-values" class="headerlink" title="7. values()"></a>7. values()</h3><p><code>values(fields, *expressions)</code></p><ul><li><p>返回一个包含数据的字典的queryset，而不是模型实例。</p></li><li><p>每个字典表示一个对象，键对应于模型对象的属性名称。</p></li></ul><p>下面的例子将values() 与普通的模型对象进行比较：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表中包含的是Blog对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.filter(name__startswith=<span class="string">'Beatles'</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&lt;Blog: Beatles Blog&gt;]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表中包含的是数据字典</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.filter(name__startswith=<span class="string">'Beatles'</span>).values()</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'name'</span>: <span class="string">'Beatles Blog'</span>, <span class="string">'tagline'</span>: <span class="string">'All the latest Beatles news.'</span>&#125;]&gt;</span><br><span class="line"></span><br><span class="line">该方法接收可选的位置参数*fields，它指定values()应该限制哪些字段。如果指定字段，每个字典将只包含指定的字段的键/值。如果没有指定字段，每个字典将包含数据库表中所有字段的键和值。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.values()</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'name'</span>: <span class="string">'Beatles Blog'</span>, <span class="string">'tagline'</span>: <span class="string">'All the latest Beatles news.'</span>&#125;]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.values(<span class="string">'id'</span>, <span class="string">'name'</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'name'</span>: <span class="string">'Beatles Blog'</span>&#125;]&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">values()方法还有关键字参数**expressions，这些参数将传递给annotate()：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models.functions <span class="keyword">import</span> Lower</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.values(lower_name=Lower(<span class="string">'name'</span>))</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">'lower_name'</span>: <span class="string">'beatles blog'</span>&#125;]&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在values()子句中的聚合应用于相同values()子句中的其他参数之前。 如果需要按另一个值分组，请将其添加到较早的values()子句中。 像这样：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.values(<span class="string">'author'</span>, entries=Count(<span class="string">'entry'</span>))</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">'author'</span>: <span class="number">1</span>, <span class="string">'entries'</span>: <span class="number">20</span>&#125;, &#123;<span class="string">'author'</span>: <span class="number">1</span>, <span class="string">'entries'</span>: <span class="number">13</span>&#125;]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.values(<span class="string">'author'</span>).annotate(entries=Count(<span class="string">'entry'</span>))</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">'author'</span>: <span class="number">1</span>, <span class="string">'entries'</span>: <span class="number">33</span>&#125;]&gt;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">如果你有一个字段foo是一个ForeignKey，默认的foo_id参数返回的字典中将有一个叫做foo 的键，因为这是保存实际值的那个隐藏的模型属性的名称。 当调用foo_id并传递字段的名称，传递foo 或values()都可以，得到的结果是相同的。像这样：</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values()</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">'blog_id'</span>: <span class="number">1</span>, <span class="string">'headline'</span>: <span class="string">'First Entry'</span>, ...&#125;, ...]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values(<span class="string">'blog'</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">'blog'</span>: <span class="number">1</span>&#125;, ...]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values(<span class="string">'blog_id'</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">'blog_id'</span>: <span class="number">1</span>&#125;, ...]&gt;</span><br><span class="line"></span><br><span class="line">当values()与distinct()一起使用时，注意排序可能影响最终的结果。</span><br><span class="line">如果values()子句位于extra()调用之后，extra()中的select参数定义的字段必须显式包含在values()调用中。 values( 调用后面的extra( 调用将忽略选择的额外的字段。在values()之后调用only()和defer()不太合理，所以将引发一个NotImplementedError。可以通过ManyToManyField、ForeignKey 和 OneToOneFiel 属性反向引用关联的模型的字段：</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.values(<span class="string">'name'</span>, <span class="string">'entry__headline'</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">'name'</span>: <span class="string">'My blog'</span>, <span class="string">'entry__headline'</span>: <span class="string">'An entry'</span>&#125;,&#123;<span class="string">'name'</span>: <span class="string">'My blog'</span>, <span class="string">'entry__headline'</span>: <span class="string">'Another entry'</span>&#125;, ...]&gt;</span><br></pre></td></tr></table></figure><h3 id="8-values-list"><a href="#8-values-list" class="headerlink" title="8. values_list()"></a>8. values_list()</h3><p><code>values_list(*fields, flat=False)</code></p><ul><li>与values()类似，只是在迭代时返回的是元组而不是字典。每个元组包含传递给values_list()调用的相应字段或表达式的值，因此第一个项目是第一个字段等。 像这样：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values_list(<span class="string">'id'</span>, <span class="string">'headline'</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [(<span class="number">1</span>, <span class="string">'First entry'</span>), ...]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models.functions <span class="keyword">import</span> Lower</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values_list(<span class="string">'id'</span>, Lower(<span class="string">'headline'</span>))</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [(<span class="number">1</span>, <span class="string">'first entry'</span>), ...]&gt;</span><br></pre></td></tr></table></figure><ul><li>如果只传递一个字段，还可以传递<code>flat</code>参数。 如果为True，它表示返回的结果为单个值而不是元组。 如下所示：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values_list(<span class="string">'id'</span>).order_by(<span class="string">'id'</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet[(<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,), ...]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values_list(<span class="string">'id'</span>, flat=<span class="literal">True</span>).order_by(<span class="string">'id'</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...]&gt;</span><br></pre></td></tr></table></figure><ul><li><p>如果有多个字段，传递flat将发生错误。</p></li><li><p>如果不传递任何值给values_list()，它将返回模型中的所有字段，以在模型中定义的顺序。</p></li><li><p>常见的情况是获取某个模型实例的特定字段值。可以使用values_list()，然后调用get()：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values_list(<span class="string">'headline'</span>, flat=<span class="literal">True</span>).get(pk=<span class="number">1</span>)</span><br><span class="line"><span class="string">'First entry'</span></span><br></pre></td></tr></table></figure><ul><li>values()和values_list()都用于特定情况下的优化：检索数据子集，而无需创建模型实例。</li><li>注意通过ManyToManyField进行查询时的行为：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Author.objects.values_list(<span class="string">'name'</span>, <span class="string">'entry__headline'</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [(<span class="string">'Noam Chomsky'</span>, <span class="string">'Impressions of Gaza'</span>),(<span class="string">'George Orwell'</span>, <span class="string">'Why Socialists Do Not Believe in Fun'</span>),</span><br><span class="line">(<span class="string">'George Orwell'</span>, <span class="string">'In Defence of English Cooking'</span>),(<span class="string">'Don Quixote'</span>, <span class="literal">None</span>)]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似地，当查询反向外键时，对于没有任何作者的条目，返回None。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values_list(<span class="string">'authors'</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [(<span class="string">'Noam Chomsky'</span>,), (<span class="string">'George Orwell'</span>,), (<span class="literal">None</span>,)]&gt;</span><br></pre></td></tr></table></figure><h3 id="9-dates"><a href="#9-dates" class="headerlink" title="9. dates()"></a>9. dates()</h3><p><code>dates(field, kind, order=&#39;ASC&#39;)</code></p><ul><li><p>返回一个QuerySet，表示QuerySet内容中特定类型的所有可用日期的datetime.date对象列表。</p></li><li><p>field参数是模型的DateField的名称。 kind参数应为”year”，”month”或”day”。 结果列表中的每个datetime.date对象被截取为给定的类型。</p></li><li><p>“year” 返回对应该field的所有不同年份值的列表。</p></li><li><p>“month”返回字段的所有不同年/月值的列表。</p></li><li><p>“day”返回字段的所有不同年/月/日值的列表。</p></li><li><p>order参数默认为’ASC’，或者’DESC’。 它指定如何排序结果。</p></li></ul><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.dates(<span class="string">'pub_date'</span>, <span class="string">'year'</span>)</span><br><span class="line"></span><br><span class="line">[[datetime.date](<span class="number">2005</span>, <span class="number">1</span>, <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.dates(<span class="string">'pub_date'</span>, <span class="string">'month'</span>)</span><br><span class="line"></span><br><span class="line">[[datetime.date](<span class="number">2005</span>, <span class="number">3</span>, <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.dates(<span class="string">'pub_date'</span>, <span class="string">'day'</span>)</span><br><span class="line"></span><br><span class="line">[[datetime.date](<span class="number">2005</span>, <span class="number">3</span>, <span class="number">20</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.dates(<span class="string">'pub_date'</span>, <span class="string">'day'</span>, order=<span class="string">'DESC'</span>)</span><br><span class="line"></span><br><span class="line">[[datetime.date](<span class="number">2005</span>, <span class="number">2</span>, <span class="number">20</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.filter(headline__contains=<span class="string">'Lennon'</span>).dates(<span class="string">'pub_date'</span>, <span class="string">'day'</span>)</span><br><span class="line"></span><br><span class="line">[[datetime.date](<span class="number">2005</span>, <span class="number">3</span>, <span class="number">20</span>)]</span><br></pre></td></tr></table></figure><h3 id="10-datetimes"><a href="#10-datetimes" class="headerlink" title="10. datetimes()"></a>10. datetimes()</h3><p><code>datetimes(field_name, kind, order=&#39;ASC&#39;, tzinfo=None)</code></p><ul><li><p>返回QuerySet，为datetime.datetime对象的列表，表示QuerySet内容中特定种类的所有可用日期。</p></li><li><p>field_name应为模型的DateTimeField的名称。</p></li><li><p>kind参数应为”hour”，”minute”，”month”，”year”，”second”或”day”。</p></li><li><p>结果列表中的每个datetime.datetime对象被截取到给定的类型。</p></li><li><p>order参数默认为’ASC’，或者’DESC’。 它指定如何排序结果。</p></li><li><p>tzinfo参数定义在截取之前将数据时间转换到的时区。</p></li></ul><h3 id="11-none"><a href="#11-none" class="headerlink" title="11. none()"></a>11. none()</h3><p><code>none()</code></p><ul><li>调用none()将创建一个不返回任何对象的查询集，并且在访问结果时不会执行任何查询。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.none()</span><br><span class="line"></span><br><span class="line">&lt;QuerySet []&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models.query <span class="keyword">import</span> EmptyQuerySet</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(Entry.objects.none(), EmptyQuerySet)</span><br><span class="line"></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="12-all"><a href="#12-all" class="headerlink" title="12. all()"></a>12. all()</h3><p><code>all()</code></p><ul><li>返回当前QuerySet（或QuerySet子类）的副本。通常用于获取全部QuerySet对象。</li></ul><h3 id="13-union"><a href="#13-union" class="headerlink" title="13. union()"></a>13. union()</h3><p><code>union(*other_qs, all=False)</code></p><ul><li><p>Django中的新功能1.11。也就是集合中并集的概念！</p></li><li><p>使用SQL的UNION运算符组合两个或更多个QuerySet的结果。例如：</p></li></ul><p><code>qs1.union(qs2, qs3)</code></p><ul><li>默认情况下，UNION操作符仅选择不同的值。 要允许重复值，请使用all=True参数。</li></ul><h3 id="14-intersection"><a href="#14-intersection" class="headerlink" title="14. intersection()"></a>14. intersection()</h3><ul><li><p>intersection(*other_qs)</p></li><li><p>Django中的新功能1.11。也就是集合中<code>交集</code>的概念！</p></li><li><p>使用SQL的INTERSECT运算符返回两个或更多个QuerySet的共有元素。例如：</p></li></ul><p><code>qs1.intersection(qs2, qs3)</code></p><h3 id="15-difference"><a href="#15-difference" class="headerlink" title="15. difference()"></a>15. difference()</h3><p><code>difference(*other_qs)</code></p><ul><li><p>Django中的新功能1.11。也就是集合中<code>差集</code>的概念！</p></li><li><p>使用SQL的EXCEPT运算符只保留QuerySet中的元素，但不保留其他QuerySet中的元素。例如：</p></li></ul><p><code>qs1.difference(qs2, qs3)</code></p><h3 id="16-select-related"><a href="#16-select-related" class="headerlink" title="16. select_related()"></a>16. select_related()</h3><p><code>select_related(*fields)</code></p><ul><li><p>沿着外键关系查询关联的对象的数据。这会生成一个复杂的查询并引起性能的损耗，但是在以后使用外键关系时将不需要再次数据库查询。</p></li><li><p>下面的例子解释了普通查询和select_related()查询的区别。 下面是一个标准的查询：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问数据库。</span></span><br><span class="line"></span><br><span class="line">e = Entry.objects.get(id=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次访问数据库以得到关联的Blog对象。</span></span><br><span class="line"></span><br><span class="line">b = [e.blog]</span><br><span class="line"></span><br><span class="line">下面是一个select_related查询：</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问数据库。</span></span><br><span class="line"></span><br><span class="line">e = Entry.objects.select_related(<span class="string">'blog'</span>).get(id=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不会访问数据库，因为e.blog已经在前面的查询中获得了。</span></span><br><span class="line"></span><br><span class="line">b = [e.blog]</span><br><span class="line"></span><br><span class="line">select_related()可用于objects任何的查询集：</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find all the blogs with entries scheduled to be published in the future.</span></span><br><span class="line"></span><br><span class="line">blogs = set()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> Entry.objects.filter(pub_date__gt=[timezone.now]()).select_related(<span class="string">'blog'</span>):</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有select_related()，下面的语句将为每次循环迭代生成一个数据库查询,以获得每个entry关联的blog。</span></span><br><span class="line"></span><br><span class="line">blogs.add([e.blog])</span><br><span class="line"></span><br><span class="line">filter()和select_related()的顺序不重要。 下面的查询集是等同的：</span><br><span class="line"></span><br><span class="line">Entry.objects.filter(pub_date__gt=[timezone.now].select_related(<span class="string">'blog'</span>)</span><br><span class="line"></span><br><span class="line">Entry.objects.select_related(<span class="string">'blog'</span>).filter(pub_date__gt=[timezone.now]())</span><br></pre></td></tr></table></figure><p>可以沿着外键查询。 如果有以下模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">class City(models.Model):</span><br><span class="line">    # ...</span><br><span class="line">    pass</span><br><span class="line">class Person(models.Model):</span><br><span class="line">    # ...</span><br><span class="line">    hometown = models.ForeignKey(</span><br><span class="line">        City,</span><br><span class="line">        on_delete=models.SET_NULL,</span><br><span class="line">        blank=True,</span><br><span class="line">        null=True,</span><br><span class="line">    )</span><br><span class="line">class Book(models.Model):</span><br><span class="line">    # ...</span><br><span class="line">    author = models.ForeignKey(Person, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><p>调用Book.objects.select_related(‘author__hometown’).get(id=4)将缓存相关的Person 和相关的City：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">b = Book.objects.select_related(<span class="string">'author__hometown'</span>).get(id=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p = [b.author] <span class="comment"># Doesn't hit the database.</span></span><br><span class="line"></span><br><span class="line">c = p.hometown <span class="comment"># Doesn't hit the database.</span></span><br><span class="line"></span><br><span class="line">b = Book.objects.get(id=<span class="number">4</span>) <span class="comment"># No select_related() in this example.</span></span><br><span class="line"></span><br><span class="line">p = [b.author] <span class="comment"># Hits the database.</span></span><br><span class="line"></span><br><span class="line">c = p.hometown <span class="comment"># Hits the database.</span></span><br></pre></td></tr></table></figure><ul><li><p>在传递给select_related()的字段中，可以使用<code>任何ForeignKey</code>和<code>OneToOneField</code>。</p></li><li><p>在传递给select_related()的字段中，还可以反向引用OneToOneField。也就是说，可以回溯到定义OneToOneField 的字段。 此时，可以使用关联对象字段的related_name，而不要指定字段的名称。</p></li></ul><h3 id="17-prefetch-related"><a href="#17-prefetch-related" class="headerlink" title="17. prefetch_related()"></a>17. prefetch_related()</h3><p><code>prefetch_related(*lookups)</code></p><ul><li><p>在单个批处理中自动检索每个指定查找的相关对象。</p></li><li><p>与select_related类似，但是策略是完全不同的。</p></li></ul><p>假设有这些模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">class Topping(models.Model):</span><br><span class="line">    name = models.CharField(max_length=30)</span><br><span class="line">class Pizza(models.Model):</span><br><span class="line">    name = models.CharField(max_length=50)</span><br><span class="line">    toppings = models.ManyToManyField(Topping)</span><br><span class="line">    def __str__(self):              # __unicode__ on Python 2</span><br><span class="line">        return &quot;%s (%s)&quot; % (</span><br><span class="line">            self.name,</span><br><span class="line">            &quot;, &quot;.join(topping.name for topping in self.toppings.all()),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>并运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pizza.objects.all()</span><br><span class="line"></span><br><span class="line">[<span class="string">"Hawaiian (ham, pineapple)"</span>, <span class="string">"Seafood (prawns, smoked salmon)"</span></span><br></pre></td></tr></table></figure><ul><li><p>问题是每次QuerySet要求Pizza.objects.all()查询数据库，因此<code>self.toppings.all()</code>将在<code>Pizza Pizza.__str__()</code>中的每个项目的<code>Toppings</code>表上运行查询。</p></li><li><p>可以使用prefetch_related减少为只有两个查询：</p></li></ul><p><code>Pizza.objects.all().prefetch_related(&#39;toppings&#39;)</code></p><ul><li><p>这意味着现在每次<code>self.toppings.all()</code>被调用，不会再去数据库查找，而是在一个预取的QuerySet缓存中查找。</p></li><li><p>还可以使用正常连接语法来执行相关字段的相关字段。 假设在上面的例子中增加一个额外的模型：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">	pizzas = models.ManyToManyField(Pizza, related_name=<span class="string">'restaurants'</span>)</span><br><span class="line"></span><br><span class="line">	best_pizza = models.ForeignKey(Pizza, related_name=<span class="string">'championed_by'</span>)</span><br></pre></td></tr></table></figure><p>以下是合法的：</p><p><code>Restaurant.objects.prefetch_related(&#39;pizzas__toppings&#39;)</code></p><ul><li>这将预取所有属于餐厅的比萨饼，和所有属于那些比萨饼的配料。 这将导致总共3个查询 - 一个用于餐馆，一个用于比萨饼，一个用于配料。</li></ul><p><code>Restaurant.objects.prefetch_related(&#39;best_pizza__toppings&#39;)</code></p><ul><li><p>这将获取最好的比萨饼和每个餐厅最好的披萨的所有配料。 这将在3个表中查询 - 一个为餐厅，一个为“最佳比萨饼”，一个为配料。</p></li><li><p>当然，也可以使用best_pizza来获取select_related关系，以将查询数减少为2：</p></li></ul><p><code>Restaurant.objects.select_related(&#39;best_pizza&#39;).prefetch_related(&#39;best_pizza__toppings&#39;)</code></p><h3 id="18-extra"><a href="#18-extra" class="headerlink" title="18. extra()"></a>18. extra()</h3><p><code>extra(select=None, where=None, params=None, tables=None, order_by=None, select_params=None)</code></p><ul><li>有些情况下，Django的查询语法难以简单的表达复杂的WHERE子句，对于这种情况,可以在<code>extra()</code>生成的SQL从句中注入新子句。使用这种方法作为最后的手段，这是一个旧的API，在将来的某个时候可能被弃用。仅当无法使用其他查询方法表达查询时才使用它。</li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">qs.extra(</span><br><span class="line">	select=&#123;<span class="string">'val'</span>: <span class="string">"select col from sometable where othercol = %s"</span>&#125;,</span><br><span class="line">	select_params=(someparam,),</span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>相当于：</p><p><code>qs.annotate(val=RawSQL(&quot;select col from sometable where othercol = %s&quot;, (someparam,)))</code></p><h3 id="19-defer"><a href="#19-defer" class="headerlink" title="19. defer()"></a>19. defer()</h3><p><code>defer(*fields)</code></p><ul><li><p>在一些复杂的数据建模情况下，模型可能包含大量字段，其中一些可能包含大尺寸数据（例如文本字段），将它们转换为Python对象需要花费很大的代价。</p></li><li><p>当最初获取数据时不知道是否需要这些特定字段的情况下，如果正在使用查询集的结果，可以告诉Django不要从数据库中检索它们。</p></li><li><p>通过传递字段名称到defer()实现不加载：</p></li></ul><p><code>Entry.objects.defer(&quot;headline&quot;, &quot;body&quot;)</code></p><ul><li><p>具有延迟加载字段的查询集仍将返回模型实例。</p></li><li><p>每个延迟字段将在你访问该字段时从数据库中检索（每次只检索一个，而不是一次检索所有的延迟字段）。</p></li><li><p>可以多次调用defer()。 每个调用都向延迟集添加新字段：</p></li></ul><h4 id="延迟body和headline两个字段。"><a href="#延迟body和headline两个字段。" class="headerlink" title="延迟body和headline两个字段。"></a>延迟body和headline两个字段。</h4><p><code>Entry.objects.defer(&quot;body&quot;).filter(rating=5).defer(&quot;headline&quot;)</code></p><ul><li><p>字段添加到延迟集的顺序无关紧要。对已经延迟的字段名称再次defer()没有问题（该字段仍将被延迟）。</p></li><li><p>可以使用标准的双下划线符号来分隔关联的字段，从而加载关联模型中的字段：</p></li></ul><p><code>Blog.objects.select_related().defer(&quot;entry__headline&quot;, &quot;entry__body&quot;)</code></p><ul><li>如果要清除延迟字段集，将None作为参数传递到defer()：</li></ul><h4 id="立即加载所有的字段。"><a href="#立即加载所有的字段。" class="headerlink" title="立即加载所有的字段。"></a>立即加载所有的字段。</h4><ul><li><p>my_queryset.defer(None)</p></li><li><p>defer()方法（及其兄弟，only()）仅适用于高级用例，它们提供了数据加载的优化方法。</p></li></ul><h3 id="20-only"><a href="#20-only" class="headerlink" title="20. only()"></a>20. only()</h3><p><code>only(*fields)</code></p><ul><li><p>only()方法与defer()相反。</p></li><li><p>如果有一个模型几乎所有的字段需要延迟，使用only()指定补充的字段集可以使代码更简单。</p></li><li><p>假设有一个包含字段biography、age和name的模型。 以下两个查询集是相同的，就延迟字段而言：</p><ul><li>Person.objects.defer(“age”, “biography”)</li><li>Person.objects.only(“name”)</li></ul></li></ul><p>每当你调用only()时，它将替换立即加载的字段集。因此，对only()的连续调用的结果是只有最后一次调用的字段被考虑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This will defer all fields except the headline.</span></span><br><span class="line"></span><br><span class="line">Entry.objects.only(<span class="string">"body"</span>, <span class="string">"rating"</span>).only(<span class="string">"headline"</span>)</span><br><span class="line"></span><br><span class="line">由于defer()以递增方式动作（向延迟列表中添加字段），因此你可以结合only()和defer()调用：</span><br><span class="line"></span><br><span class="line"><span class="comment"># Final result is that everything except "headline" is deferred.</span></span><br><span class="line"></span><br><span class="line">Entry.objects.only(<span class="string">"headline"</span>, <span class="string">"body"</span>).defer(<span class="string">"body"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Final result loads headline and body immediately (only() replaces any</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># existing set of fields).</span></span><br><span class="line"></span><br><span class="line">Entry.objects.defer(<span class="string">"body"</span>).only(<span class="string">"headline"</span>, <span class="string">"body"</span>)</span><br></pre></td></tr></table></figure><p>当对具有延迟字段的实例调用save()时，仅保存加载的字段。</p><h3 id="21-using"><a href="#21-using" class="headerlink" title="21. using()"></a>21. using()</h3><p><code>using(alias)</code></p><ul><li>如果正在使用多个数据库，这个方法用于指定在哪个数据库上查询QuerySet。方法的唯一参数是数据库的别名，定义在DATABASES。</li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># queries the database with the 'default' alias.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># queries the database with the 'backup' alias</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.using(<span class="string">'backup'</span>)</span><br></pre></td></tr></table></figure><h3 id="22-select-for-update"><a href="#22-select-for-update" class="headerlink" title="22. select_for_update()"></a>22. select_for_update()</h3><p><code>select_for_update(nowait=False, skip_locked=False)</code></p><ul><li>返回一个锁住行直到事务结束的查询集，如果数据库支持，它将生成一个SELECT … FOR UPDATE语句。</li></ul><p>例如：</p><p><code>entries = Entry.objects.select_for_update().filter(author=request.user)</code></p><ul><li><p>所有匹配的行将被锁定，直到事务结束。这意味着可以通过锁防止数据被其它事务修改。</p></li><li><p>一般情况下如果其他事务锁定了相关行，那么本查询将被阻塞，直到锁被释放。使用select_for_update(nowait=True)将使查询不阻塞。如果其它事务持有冲突的锁,那么查询将引发DatabaseError异常。也可以使用select_for_update(skip_locked=True)忽略锁定的行。nowait和skip_locked是互斥的。</p></li><li><p>目前，postgresql，oracle和mysql数据库后端支持select_for_update()。但是，MySQL不支持nowait和skip_locked参数。</p></li></ul><h3 id="23-raw"><a href="#23-raw" class="headerlink" title="23. raw()"></a>23. raw()</h3><p>raw(raw_query, params=None, translations=None)</p><p>接收一个原始的SQL查询，执行它并返回一个django.db.models.query.RawQuerySet实例。</p><p>这个RawQuerySet实例可以迭代，就像普通的QuerySet一样。</p><h1 id="四、不返回QuerySets的API"><a href="#四、不返回QuerySets的API" class="headerlink" title="四、不返回QuerySets的API"></a>四、不返回QuerySets的API</h1><ul><li>以下的方法不会返回QuerySets，但是作用非常强大，尤其是粗体显示的方法，需要背下来。</li></ul><h2 id="方法名-解释-1"><a href="#方法名-解释-1" class="headerlink" title="方法名 解释"></a><strong>方法名 解释</strong></h2><p>get() 获取单个对象</p><p>create() 创建对象，无需save()</p><p>get_or_create() 查询对象，如果没有找到就新建对象</p><p>update_or_create() 更新对象，如果没有找到就创建对象</p><p>bulk_create()</p><p>批量创建对象</p><p>count() 统计对象的个数</p><p>in_bulk()</p><p>根据主键值的列表，批量返回对象</p><p>iterator()</p><p>获取包含对象的迭代器</p><p>latest() 获取最近的对象</p><p>earliest() 获取最早的对象</p><p>first() 获取第一个对象</p><p>last() 获取最后一个对象</p><p>aggregate() 聚合操作</p><p>exists() 判断queryset中是否有对象</p><p>update() 批量更新对象</p><p>delete() 批量删除对象</p><p>as_manager() 获取管理器</p><h3 id="1-get"><a href="#1-get" class="headerlink" title="1. get()"></a>1. get()</h3><p><code>get(**kwargs)</code></p><ul><li><p>返回按照查询参数匹配到的单个对象，参数的格式应该符合Field lookups的要求。</p></li><li><p>如果匹配到的对象个数不只一个的话，触发MultipleObjectsReturned异常</p></li><li><p>如果根据给出的参数匹配不到对象的话，触发DoesNotExist异常。例如：</p></li></ul><p><code>Entry.objects.get(id=&#39;foo&#39;) # raises Entry.DoesNotExist</code></p><ul><li>DoesNotExist异常从django.core.exceptions.ObjectDoesNotExist继承，可以定位多个DoesNotExist异常。 例如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> ObjectDoesNotExist</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	e = Entry.objects.get(id=<span class="number">3</span>)</span><br><span class="line">	b = Blog.objects.get(id=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> ObjectDoesNotExist:</span><br><span class="line">	print(<span class="string">"Either the entry or blog doesn't exist."</span>)</span><br></pre></td></tr></table></figure><ul><li>如果希望查询器只返回一行，则可以使用get()而不使用任何参数来返回该行的对象：</li></ul><p><code>entry = Entry.objects.filter(...).exclude(...).get()</code></p><h3 id="2-create"><a href="#2-create" class="headerlink" title="2. create()"></a>2. create()</h3><p><code>create(**kwargs)</code></p><ul><li>在一步操作中<code>同时创建</code>并且<code>保存对象</code>的便捷方法.</li></ul><p><code>p = Person.objects.create(first_name=&quot;Bruce&quot;, last_name=&quot;Springsteen&quot;)</code></p><p>等于:</p><p><code>p = Person(first_name=&quot;Bruce&quot;, last_name=&quot;Springsteen&quot;)</code></p><p><code>p.save(force_insert=True)</code></p><ul><li>参数force_insert表示强制创建对象。如果model中有一个你手动设置的主键，并且这个值已经存在于数据库中, 调用create()将会失败并且触发IntegrityError因为主键必须是唯一的。如果你手动设置了主键，做好异常处理的准备。</li></ul><h3 id="3-get-or-create"><a href="#3-get-or-create" class="headerlink" title="3. get_or_create()"></a>3. get_or_create()</h3><p><code>get_or_create(defaults=None, **kwargs)</code></p><ul><li><p>通过kwargs来查询对象的便捷方法（如果模型中的所有字段都有默认值，可以为空），如果该对象不存在则创建一个新对象。</p></li><li><p>该方法返回一个由(object, created)组成的元组，元组中的object 是一个查询到的或者是被创建的对象， created是一个表示是否创建了新的对象的布尔值。</p></li></ul><p>对于下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">  obj = Person.objects.get(first_name=<span class="string">'John'</span>, last_name=<span class="string">'Lennon'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Person.DoesNotExist:</span><br><span class="line"></span><br><span class="line">  obj = Person(first_name=<span class="string">'John'</span>, last_name=<span class="string">'Lennon'</span>, birthday=date(<span class="number">1940</span>, <span class="number">10</span>, <span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">  obj.save()</span><br></pre></td></tr></table></figure><p>如果模型的字段数量较大的话，这种模式就变的非常不易用了。 上面的示例可以用get_or_create()重写 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj, created = Person.objects.get_or_create(</span><br><span class="line">  first_name=<span class="string">'John'</span>,</span><br><span class="line">  last_name=<span class="string">'Lennon'</span>,</span><br><span class="line">  defaults=&#123;<span class="string">'birthday'</span>: date(<span class="number">1940</span>, <span class="number">10</span>, <span class="number">9</span>)&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>任何传递给get_or_create()的关键字参数，除了一个可选的defaults，都将传递给get()调用。 如果查找到一个对象，返回一个包含匹配到的对象以及False 组成的元组。 如果查找到的对象超过一个以上，将引发MultipleObjectsReturned。如果查找不到对象，get_or_create()将会实例化并保存一个新的对象，返回一个由新的对象以及True组成的元组。新的对象将会按照以下的逻辑创建:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">params = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items() <span class="keyword">if</span> <span class="string">'__'</span> <span class="keyword">not</span> <span class="keyword">in</span> k&#125;</span><br><span class="line"></span><br><span class="line">params.update(&#123;k: v() <span class="keyword">if</span> callable(v) <span class="keyword">else</span> v <span class="keyword">for</span> k, v <span class="keyword">in</span> defaults.items()&#125;)</span><br><span class="line"></span><br><span class="line">obj = self.model(**params)</span><br><span class="line"></span><br><span class="line">obj.save()</span><br></pre></td></tr></table></figure><ul><li><p>它表示从非’defaults’ 且不包含双下划线的关键字参数开始。然后将defaults的内容添加进来，覆盖必要的键，并使用结果作为关键字参数传递给模型类。</p></li><li><p>如果有一个名为defaults__exact的字段，并且想在get_or_create()时用它作为精确查询，只需要使用defaults，像这样：</p></li></ul><p><code>Foo.objects.get_or_create(defaults__exact=&#39;bar&#39;, defaults={&#39;defaults&#39;: &#39;baz&#39;})</code></p><ul><li><p>当你使用手动指定的主键时，get_or_create()方法与create()方法有相似的错误行为 。 如果需要创建一个对象而该对象的主键早已存在于数据库中，IntegrityError异常将会被触发。</p></li><li><p>这个方法假设进行的是原子操作，并且正确地配置了数据库和正确的底层数据库行为。如果数据库级别没有对get_or_create中用到的kwargs强制要求唯一性（unique和unique_together），方法容易导致竞态条件，可能会有相同参数的多行同时插入。（简单理解，kwargs必须指定的是主键或者unique属性的字段才安全。）</p></li><li><p>最后建议只在Django视图的POST请求中使用get_or_create()，因为这是一个具有修改性质的动作，不应该使用在GET请求中，那样不安全。</p></li><li><p>可以通过ManyToManyField属性和反向关联使用get_or_create()。在这种情况下，应该限制查询在关联的上下文内部。 否则，可能导致完整性问题。</p></li></ul><p>例如下面的模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chapter</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">  title = models.CharField(max_length=<span class="number">255</span>, unique=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">  title = models.CharField(max_length=<span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">  chapters = models.ManyToManyField(Chapter)</span><br></pre></td></tr></table></figure><p>可以通过Book的chapters字段使用get_or_create()，但是它只会获取该Book内部的上下文：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>book = Book.objects.create(title=<span class="string">"Ulysses"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>book.chapters.get_or_create(title=<span class="string">"Telemachus"</span>)</span><br><span class="line"></span><br><span class="line">(&lt;Chapter: Telemachus&gt;, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>book.chapters.get_or_create(title=<span class="string">"Telemachus"</span>)</span><br><span class="line"></span><br><span class="line">(&lt;Chapter: Telemachus&gt;, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Chapter.objects.create(title=<span class="string">"Chapter 1"</span>)</span><br><span class="line"></span><br><span class="line">&lt;Chapter: Chapter <span class="number">1</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>book.chapters.get_or_create(title=<span class="string">"Chapter 1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Raises IntegrityError</span></span><br></pre></td></tr></table></figure><ul><li>发生这个错误是因为尝试通过Book “Ulysses”获取或者创建“Chapter 1”，但是它不能，因为它与这个book不关联，但因为title 字段是唯一的它仍然不能创建。</li></ul><p>在Django1.11在defaults中增加了对可调用值的支持。</p><h3 id="4-update-or-create"><a href="#4-update-or-create" class="headerlink" title="4. update_or_create()"></a>4. update_or_create()</h3><p><code>update_or_create(defaults=None, **kwargs)</code></p><p>类似前面的get_or_create()。</p><ul><li><p>通过给出的kwargs来更新对象的便捷方法， 如果没找到对象，则创建一个新的对象。defaults是一个由 (field, value)对组成的字典，用于更新对象。defaults中的值可以是可调用对象（也就是说函数等）。</p></li><li><p>该方法返回一个由(object, created)组成的元组,元组中的object是一个创建的或者是被更新的对象， created是一个标示是否创建了新的对象的布尔值。</p></li><li><p>update_or_create方法尝试通过给出的kwargs 去从数据库中获取匹配的对象。 如果找到匹配的对象，它将会依据defaults 字典给出的值更新字段。</p></li></ul><p>像下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">defaults = &#123;<span class="string">'first_name'</span>: <span class="string">'Bob'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">  obj = Person.objects.get(first_name=<span class="string">'John'</span>, last_name=<span class="string">'Lennon'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> key, value <span class="keyword">in</span> defaults.items():</span><br><span class="line"></span><br><span class="line">  setattr(obj, key, value)</span><br><span class="line"></span><br><span class="line">  obj.save()</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Person.DoesNotExist:</span><br><span class="line"></span><br><span class="line">  new_values = &#123;<span class="string">'first_name'</span>: <span class="string">'John'</span>, <span class="string">'last_name'</span>: <span class="string">'Lennon'</span>&#125;</span><br><span class="line"></span><br><span class="line">  new_values.update(defaults)</span><br><span class="line"></span><br><span class="line">  obj = Person(**new_values)</span><br><span class="line"></span><br><span class="line">	obj.save()</span><br></pre></td></tr></table></figure><p>如果模型的字段数量较大的话，这种模式就变的非常不易用了。 上面的示例可以用update_or_create() 重写:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj, created = Person.objects.update_or_create(</span><br><span class="line"></span><br><span class="line">first_name=<span class="string">'John'</span>, last_name=<span class="string">'Lennon'</span>,</span><br><span class="line"></span><br><span class="line">defaults=&#123;<span class="string">'first_name'</span>: <span class="string">'Bob'</span>&#125;,</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><p>kwargs中的名称如何解析的详细描述可以参见get_or_create()。</p></li><li><p>和get_or_create()一样，这个方法也容易导致竞态条件，如果数据库层级没有前置唯一性会让多行同时插入。</p></li></ul><p>在Django1.11在defaults中增加了对可调用值的支持。</p><h3 id="5-bulk-create"><a href="#5-bulk-create" class="headerlink" title="5. bulk_create()"></a>5. bulk_create()</h3><p><code>bulk_create(objs, batch_size=None)</code></p><ul><li>以高效的方式（通常只有1个查询，无论有多少对象）将提供的对象列表插入到数据库中：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.bulk_create([</span><br><span class="line"></span><br><span class="line"><span class="meta">... </span>Entry(headline=<span class="string">'This is a test'</span>),</span><br><span class="line"></span><br><span class="line"><span class="meta">... </span>Entry(headline=<span class="string">'This is only a test'</span>),</span><br><span class="line"></span><br><span class="line"><span class="meta">... </span>])</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li><p>不会调用模型的save()方法，并且不会发送pre_save和post_save信号。</p></li><li><p>不适用于多表继承场景中的子模型。</p></li><li><p>如果模型的主键是AutoField，则不会像save()那样检索并设置主键属性，除非数据库后端支持。</p></li><li><p>不适用于多对多关系。</p></li><li><p>batch_size参数控制在单个查询中创建的对象数。</p></li></ul><h3 id="6-count"><a href="#6-count" class="headerlink" title="6. count()"></a>6. count()</h3><p><code>count()</code></p><ul><li>返回在数据库中对应的QuerySet对象的个数。count()永远不会引发异常。</li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回总个数.</span></span><br><span class="line"></span><br><span class="line">Entry.objects.count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回包含有'Lennon'的对象的总数</span></span><br><span class="line"></span><br><span class="line">Entry.objects.filter(headline__contains=<span class="string">'Lennon'</span>).count()</span><br></pre></td></tr></table></figure><h3 id="7-in-bulk"><a href="#7-in-bulk" class="headerlink" title="7. in_bulk()"></a>7. in_bulk()</h3><p><code>in_bulk(id_list=None)</code></p><ul><li>获取主键值的列表，并返回将每个主键值映射到具有给定ID的对象的实例的字典。 如果未提供列表，则会返回查询集中的所有对象。</li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.in_bulk([<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">&#123;<span class="number">1</span>: &lt;Blog: Beatles Blog&gt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.in_bulk([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">&#123;<span class="number">1</span>: &lt;Blog: Beatles Blog&gt;, <span class="number">2</span>: &lt;Blog: Cheddar Talk&gt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.in_bulk([])</span><br><span class="line"></span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.in_bulk()</span><br><span class="line"></span><br><span class="line">&#123;<span class="number">1</span>: &lt;Blog: Beatles Blog&gt;, <span class="number">2</span>: &lt;Blog: Cheddar Talk&gt;, <span class="number">3</span>: &lt;Blog: Django Weblog&gt;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果向in_bulk()传递一个空列表，会得到一个空的字典。</p></li><li><p>在旧版本中，id_list是必需的参数，现在是一个可选参数。</p></li></ul><h3 id="8-iterator"><a href="#8-iterator" class="headerlink" title="8. iterator()"></a>8. iterator()</h3><p><code>iterator()</code></p><ul><li><p>提交数据库操作，获取QuerySet，并返回一个迭代器。</p></li><li><p>QuerySet通常会在内部缓存其结果，以便在重复计算时不会导致额外的查询。而iterator()将直接读取结果，不在QuerySet级别执行任何缓存。对于返回大量只需要访问一次的对象的QuerySet，这可以带来更好的性能，显著减少内存使用。</p></li></ul><blockquote><p>请注意，在已经提交了的iterator()上使用QuerySet会强制它再次提交数据库操作，进行重复查询。此外，使用iterator()会导致先前的prefetch_related()调用被忽略，因为这两个一起优化没有意义。</p></blockquote><h3 id="9-latest"><a href="#9-latest" class="headerlink" title="9. latest()"></a>9. latest()</h3><p><code>latest(field_name=None)</code></p><ul><li><p>使用日期字段field_name，按日期返回最新对象。</p></li><li><p>下例根据Entry的’pub_date’字段返回最新发布的entry：</p><p><code>Entry.objects.latest(&#39;pub_date&#39;)</code></p></li><li><p>如果模型的Meta指定了get_latest_by，则可以将latest()参数留给earliest()或者field_name。 默认情况下，Django将使用get_latest_by中指定的字段。</p></li><li><p>earliest()和latest()可能会返回空日期的实例,可能需要过滤掉空值：</p></li></ul><p><code>Entry.objects.filter(pub_date__isnull=False).latest(&#39;pub_date&#39;)</code></p><h3 id="10-earliest"><a href="#10-earliest" class="headerlink" title="10. earliest()"></a>10. earliest()</h3><p>earliest(field_name=None)</p><p>类同latest()。</p><h3 id="11-first"><a href="#11-first" class="headerlink" title="11. first()"></a>11. first()</h3><p><code>first()</code></p><ul><li>返回结果集的第一个对象, 当没有找到时返回None。如果QuerySet没有设置排序,则将会自动按主键进行排序。例如：</li></ul><p><code>p = Article.objects.order_by(&#39;title&#39;, &#39;pub_date&#39;).first()</code></p><ul><li>first()是一个简便方法，下面的例子和上面的代码效果是一样：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	p = Article.objects.order_by(<span class="string">'title'</span>, <span class="string">'pub_date'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">	p = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="12-last"><a href="#12-last" class="headerlink" title="12. last()"></a>12. last()</h3><p><code>last()</code></p><p>工作方式类似first()，只是返回的是查询集中最后一个对象。</p><h3 id="13-aggregate"><a href="#13-aggregate" class="headerlink" title="13. aggregate()"></a>13. aggregate()</h3><p><code>aggregate(args, *kwargs)</code></p><ul><li><p>返回汇总值的字典（平均值，总和等）,通过QuerySet进行计算。每个参数指定返回的字典中将要包含的值。</p></li><li><p>使用关键字参数指定的聚合将使用关键字参数的名称作为Annotation 的名称。 匿名参数的名称将基于聚合函数的名称和模型字段生成。 复杂的聚合不可以使用匿名参数，必须指定一个关键字参数作为别名。</p></li></ul><p>例如，想知道Blog Entry 的数目：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count</span><br><span class="line"></span><br><span class="line">q = Blog.objects.aggregate(Count(<span class="string">'entry'</span>))</span><br><span class="line">&#123;<span class="string">'entry__count'</span>: <span class="number">16</span>&#125;</span><br></pre></td></tr></table></figure><p>通过使用关键字参数来指定聚合函数，可以控制返回的聚合的值的名称：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q = Blog.objects.aggregate(number_of_entries=Count(<span class="string">'entry'</span>))</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">'number_of_entries'</span>: <span class="number">16</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="14-exists"><a href="#14-exists" class="headerlink" title="14. exists()"></a>14. exists()</h3><p>exists()</p><ul><li><p>如果QuerySet包含任何结果，则返回True，否则返回False。</p></li><li><p>查找具有唯一性字段（例如primary_key）的模型是否在一个QuerySet中的最高效的方法是：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry = Entry.objects.get(pk=<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> some_queryset.filter(pk=entry.pk).exists():</span><br><span class="line"></span><br><span class="line">	print(<span class="string">"Entry contained in queryset"</span>)</span><br></pre></td></tr></table></figure><p>它将比下面的方法快很多，这个方法要求对QuerySet求值并迭代整个QuerySet：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> entry <span class="keyword">in</span> some_queryset:</span><br><span class="line">	print(<span class="string">"Entry contained in QuerySet"</span>)</span><br></pre></td></tr></table></figure><p>若要查找一个QuerySet是否包含任何元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> some_queryset.exists():</span><br><span class="line">	print(<span class="string">"There is at least one object in some_queryset"</span>)</span><br><span class="line">将快于：</span><br><span class="line"><span class="keyword">if</span> some_queryset:</span><br><span class="line">	print(<span class="string">"There is at least one object in some_queryset"</span>)</span><br></pre></td></tr></table></figure><h3 id="15-update"><a href="#15-update" class="headerlink" title="15. update()"></a>15. update()</h3><p><code>update(**kwargs)</code></p><ul><li><p>对指定的字段执行批量更新操作，并返回匹配的行数（如果某些行已具有新值，则可能不等于已更新的行数）。</p></li><li><p>例如，要对2010年发布的所有博客条目启用评论，可以执行以下操作：</p></li></ul><p><code>Entry.objects.filter(pub_date__year=2010).update(comments_on=False)</code></p><ul><li>可以同时更新多个字段 （没有多少字段的限制）。 例如同时更新comments_on和headline字段：</li></ul><p><code>Entry.objects.filter(pub_date__year=2010).update(comments_on=False, headline=&#39;This is old&#39;)</code></p><p>update()方法<code>无需save</code>操作。唯一限制是它只能更新模型主表中的列，而不是关联的模型，例如不能这样做：</p><p><code>Entry.objects.update(blog__name=&#39;foo&#39;) # Won&#39;t work!</code></p><p>仍然可以根据相关字段进行过滤：</p><p><code>Entry.objects.filter(blog__id=1).update(comments_on=True)</code></p><p>update()方法返回受影响的行数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.filter(id=<span class="number">64</span>).update(comments_on=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.filter(slug=<span class="string">'nonexistent-slug'</span>).update(comments_on=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.filter(pub_date__year=<span class="number">2010</span>).update(comments_on=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">132</span></span><br></pre></td></tr></table></figure><p>如果你只是更新一下对象，不需要为对象做别的事情，最有效的方法是调用update()，而不是将模型对象加载到内存中。 例如，不要这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e = Entry.objects.get(id=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">e.comments_on = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">e.save()</span><br></pre></td></tr></table></figure><p>建议如下操作：</p><p><code>Entry.objects.filter(id=10).update(comments_on=False)</code></p><p>用update()还可以防止在加载对象和调用save()之间的短时间内数据库中某些内容可能发生更改的竞争条件。</p><p>如果想更新一个具有自定义save()方法的模型的记录，请循环遍历它们并调用save()，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> Entry.objects.filter(pub_date__year=<span class="number">2010</span>):</span><br><span class="line">  e.comments_on = <span class="literal">False</span></span><br><span class="line">  e.save()</span><br></pre></td></tr></table></figure><h3 id="16-delete"><a href="#16-delete" class="headerlink" title="16. delete()"></a>16. delete()</h3><p><code>delete()</code></p><ul><li><p>批量删除QuerySet中的所有对象，并返回删除的对象个数和每个对象类型的删除次数的字典。</p></li><li><p>delete()动作是立即执行的。</p></li><li><p>不能在QuerySet上调用delete()。</p></li><li><p>例如，要删除特定博客中的所有条目：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b = Blog.objects.get(pk=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Delete all the entries belonging to this Blog.</span></span><br><span class="line">Entry.objects.filter(blog=b).delete()</span><br><span class="line">(<span class="number">4</span>, &#123;<span class="string">'weblog.Entry'</span>: <span class="number">2</span>, <span class="string">'weblog.Entry_authors'</span>: <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure><p>默认情况下，Django的ForeignKey使用SQL约束ON DELETE CASCADE，任何具有指向要删除的对象的外键的对象将与它们一起被删除。 像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">blogs = Blog.objects.all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># This will delete all Blogs and all of their Entry objects.</span></span><br><span class="line">blogs.delete()</span><br><span class="line">(<span class="number">5</span>, &#123;<span class="string">'weblog.Blog'</span>: <span class="number">1</span>, <span class="string">'weblog.Entry'</span>: <span class="number">2</span>, <span class="string">'weblog.Entry_authors'</span>: <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure><p>这种级联的行为可以通过的ForeignKey的on_delete参数自定义。（什么时候要改变这种行为呢？比如日志数据，就不能和它关联的主体一并被删除！）</p><p>delete()会为所有已删除的对象（包括级联删除）发出<code>pre_delete</code>和<code>post_delete</code>信号。</p><h3 id="17-as-manager"><a href="#17-as-manager" class="headerlink" title="17. as_manager()"></a>17. as_manager()</h3><p><code>classmethod as_manager()</code></p><ul><li>一个类方法，返回Manager的实例与QuerySet的方法的副本</li></ul></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------　　　　本文结束　<i class="fa fa-heart"></i>　感谢您的阅读　　　　-------------</div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/QuerySet集合/" rel="tag"># QuerySet集合</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2020/10/06/轮询、长轮询、websocket/" rel="next" title="轮询、长轮询、websocket"><i class="fa fa-chevron-left"></i> 轮询、长轮询、websocket</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2020/10/10/设计模式/" rel="prev" title="设计模式概要">设计模式概要 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Luenci"><p class="site-author-name" itemprop="name">Luenci</p><p class="site-description motion-element" itemprop="description">Debug Myself</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">71</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">32</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">55</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Lucareful/" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/Luenci379" target="_blank" title="CSDN"><i class="fa fa-fw fa-edit"></i>CSDN</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/lu-er-ye-70-61/activities" target="_blank" title="知乎"><i class="fa fa-fw fa-feed"></i>知乎</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://hexo.io/zh-cn/index.html" title="Hexo" target="_blank">Hexo</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、QuerySet何时被提交"><span class="nav-number">1.</span> <span class="nav-text">一、QuerySet何时被提交</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代"><span class="nav-number">1.1.</span> <span class="nav-text">迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pickling-缓存"><span class="nav-number">1.2.</span> <span class="nav-text">Pickling/缓存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、QuerySet"><span class="nav-number">2.</span> <span class="nav-text">二、QuerySet</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、返回新QuerySets的API"><span class="nav-number">3.</span> <span class="nav-text">三、返回新QuerySets的API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#方法名-解释"><span class="nav-number">3.1.</span> <span class="nav-text">方法名 解释</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-filter"><span class="nav-number">3.1.1.</span> <span class="nav-text">1. filter()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-exclude"><span class="nav-number">3.1.2.</span> <span class="nav-text">2. exclude()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-annotate"><span class="nav-number">3.1.3.</span> <span class="nav-text">3. annotate()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-order-by"><span class="nav-number">3.1.4.</span> <span class="nav-text">4. order_by()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-reverse"><span class="nav-number">3.1.5.</span> <span class="nav-text">5. reverse()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-distinct"><span class="nav-number">3.1.6.</span> <span class="nav-text">6. distinct()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-values"><span class="nav-number">3.1.7.</span> <span class="nav-text">7. values()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-values-list"><span class="nav-number">3.1.8.</span> <span class="nav-text">8. values_list()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-dates"><span class="nav-number">3.1.9.</span> <span class="nav-text">9. dates()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-datetimes"><span class="nav-number">3.1.10.</span> <span class="nav-text">10. datetimes()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-none"><span class="nav-number">3.1.11.</span> <span class="nav-text">11. none()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-all"><span class="nav-number">3.1.12.</span> <span class="nav-text">12. all()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-union"><span class="nav-number">3.1.13.</span> <span class="nav-text">13. union()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-intersection"><span class="nav-number">3.1.14.</span> <span class="nav-text">14. intersection()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-difference"><span class="nav-number">3.1.15.</span> <span class="nav-text">15. difference()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-select-related"><span class="nav-number">3.1.16.</span> <span class="nav-text">16. select_related()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-prefetch-related"><span class="nav-number">3.1.17.</span> <span class="nav-text">17. prefetch_related()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-extra"><span class="nav-number">3.1.18.</span> <span class="nav-text">18. extra()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-defer"><span class="nav-number">3.1.19.</span> <span class="nav-text">19. defer()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#延迟body和headline两个字段。"><span class="nav-number">3.1.19.1.</span> <span class="nav-text">延迟body和headline两个字段。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#立即加载所有的字段。"><span class="nav-number">3.1.19.2.</span> <span class="nav-text">立即加载所有的字段。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-only"><span class="nav-number">3.1.20.</span> <span class="nav-text">20. only()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-using"><span class="nav-number">3.1.21.</span> <span class="nav-text">21. using()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-select-for-update"><span class="nav-number">3.1.22.</span> <span class="nav-text">22. select_for_update()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-raw"><span class="nav-number">3.1.23.</span> <span class="nav-text">23. raw()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、不返回QuerySets的API"><span class="nav-number">4.</span> <span class="nav-text">四、不返回QuerySets的API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#方法名-解释-1"><span class="nav-number">4.1.</span> <span class="nav-text">方法名 解释</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-get"><span class="nav-number">4.1.1.</span> <span class="nav-text">1. get()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-create"><span class="nav-number">4.1.2.</span> <span class="nav-text">2. create()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-get-or-create"><span class="nav-number">4.1.3.</span> <span class="nav-text">3. get_or_create()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-update-or-create"><span class="nav-number">4.1.4.</span> <span class="nav-text">4. update_or_create()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-bulk-create"><span class="nav-number">4.1.5.</span> <span class="nav-text">5. bulk_create()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-count"><span class="nav-number">4.1.6.</span> <span class="nav-text">6. count()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-in-bulk"><span class="nav-number">4.1.7.</span> <span class="nav-text">7. in_bulk()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-iterator"><span class="nav-number">4.1.8.</span> <span class="nav-text">8. iterator()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-latest"><span class="nav-number">4.1.9.</span> <span class="nav-text">9. latest()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-earliest"><span class="nav-number">4.1.10.</span> <span class="nav-text">10. earliest()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-first"><span class="nav-number">4.1.11.</span> <span class="nav-text">11. first()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-last"><span class="nav-number">4.1.12.</span> <span class="nav-text">12. last()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-aggregate"><span class="nav-number">4.1.13.</span> <span class="nav-text">13. aggregate()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-exists"><span class="nav-number">4.1.14.</span> <span class="nav-text">14. exists()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-update"><span class="nav-number">4.1.15.</span> <span class="nav-text">15. update()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-delete"><span class="nav-number">4.1.16.</span> <span class="nav-text">16. delete()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-as-manager"><span class="nav-number">4.1.17.</span> <span class="nav-text">17. as_manager()</span></a></li></ol></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共154.3k字</span></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Luenci</span><br><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次 </span><span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人次</span><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("09/20/2018 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/js/src/utils.js?v=5.1.4"></script><script src="/js/src/motion.js?v=5.1.4"></script><script src="/js/src/affix.js?v=5.1.4"></script><script src="/js/src/schemes/pisces.js?v=5.1.4"></script><script src="/js/src/scrollspy.js?v=5.1.4"></script><script src="/js/src/post-details.js?v=5.1.4"></script><script src="/js/src/bootstrap.js?v=5.1.4"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '1yc5oJblYhuDOVUJ71pHwrTW-gzGzoHsz',
        appKey: 'yOAm4FuYux7D9hI5MOGRvqDw',
        placeholder: '请在此输入您的留言',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });</script><script>// Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><a href="https://github.com/Lucareful" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#fff;color:#151513;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>