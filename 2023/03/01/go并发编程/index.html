<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/L.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/L.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luenci.me","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="预备知识 unsafe.Pointer  unsafe.Pointer 是一种特殊意义的指针，它可以包含任意类型的地址，有点类似于 C 语言里的 void* 指针，全能型的。  对unsafe.Pointer 又爱又恨，你会有效使用它吗？  unsafe 是关注 Go 程序操作类型安全的包。  unsafe.Pointer 可以让你无视 Go 的类型系统，完成任何类型与内建的 uintptr 类型">
<meta property="og:type" content="article">
<meta property="og:title" content="golang并发编程">
<meta property="og:url" content="https://luenci.me/2023/03/01/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Luenci">
<meta property="og:description" content="预备知识 unsafe.Pointer  unsafe.Pointer 是一种特殊意义的指针，它可以包含任意类型的地址，有点类似于 C 语言里的 void* 指针，全能型的。  对unsafe.Pointer 又爱又恨，你会有效使用它吗？  unsafe 是关注 Go 程序操作类型安全的包。  unsafe.Pointer 可以让你无视 Go 的类型系统，完成任何类型与内建的 uintptr 类型">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/luenci/RepoImg/raw/master/img/202108281355882.png">
<meta property="og:image" content="https://gitee.com/luenci/RepoImg/raw/master/img/202108281347706.png">
<meta property="article:published_time" content="2023-03-01T10:40:32.075Z">
<meta property="article:modified_time" content="2023-03-01T10:40:32.075Z">
<meta property="article:author" content="Luenci">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/luenci/RepoImg/raw/master/img/202108281355882.png">

<link rel="canonical" href="https://luenci.me/2023/03/01/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<script>
  window.addEventListener('DOMContentLoaded', () => {
    'use strict';
    
      if (NexT.utils.hasMobileUA()) return;
    
    let time, hidden, visible, title = document.title;
    let favicon = document.querySelector('link[rel="icon"]');
    
      hidden = '404,φ(*￣0￣),Waiting for you.';
      visible = '200,(✿◡‿◡),Welcome back!';
    
    let random = t => t[Math.floor(Math.random() * t.length)];
    const change = () => {
      if (document.hidden) {
        favicon.setAttribute('href', '/images/L.png');
        
          document.title = hidden;
        
        clearTimeout(time);
      } else {
        favicon.setAttribute('href', '/images/L.png');
        
          document.title = visible;
        
        time = setTimeout(() => {
          document.title = title;
        }, 2019);
      }
    }
    document.addEventListener('visibilitychange', change, false);
  });
</script>

  <title>golang并发编程 | Luenci</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Luenci" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">

  <div class="container use-motion">
    <div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/Lucareful" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z">
    </path>
    <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Luenci</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luenci.me/2023/03/01/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Luenci">
      <meta itemprop="description" content="Debug Myself">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luenci">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          golang并发编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-01 10:40:32" itemprop="dateCreated datePublished" datetime="2023-03-01T10:40:32+00:00">2023-03-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="far fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/03/01/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/03/01/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>30 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1>预备知识</h1>
<h2 id="unsafe-Pointer">unsafe.Pointer</h2>
<blockquote>
<p>unsafe.Pointer 是一种特殊意义的指针，它可以包含任意类型的地址，有点类似于 C 语言里的 void* 指针，全能型的。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/137060307">对unsafe.Pointer 又爱又恨，你会有效使用它吗？</a></p>
<blockquote>
<p>unsafe 是关注 Go 程序操作类型安全的包。</p>
</blockquote>
<p><code>unsafe.Pointer</code> 可以让你无视 Go 的类型系统，完成任何类型与内建的 uintptr 类型之间的转化。根据文档，unsafe.Pointer 可以实现四种其他类型不能的操作：</p>
<ul>
<li>任何类型的指针都可以转化为一个 unsafe.Pointer</li>
<li>一个 unsafe.Pointer 可以转化成任何类型的指针</li>
<li>一个 uintptr 可以转化成一个 unsafe.Pointer</li>
<li>一个 unsafe.Pointer 可以转化成一个 uintptr</li>
</ul>
<p>两种只能借助 unsafe 包才能完成的操作：</p>
<ul>
<li>使用 unsafe.Pointer 实现两种类型间转换</li>
<li>使用 unsafe.Pointer 处理系统调用。</li>
</ul>
<h2 id="CAS比较并交换-Compare-And-Swap">CAS比较并交换----Compare And Swap</h2>
<p><a target="_blank" rel="noopener" href="https://studygolang.com/articles/23289">Go 的一个 CAS 操作使用场景</a></p>
<ul>
<li>在并发执行的多个 routine R1,R2…Rn 的中，同一时间只允许唯一一个 routine 执行某一个操作，并且其他 routine 需要非阻塞的知道自己无权操作并返回的时候，可以使用 CAS 操作。</li>
</ul>
<blockquote>
<p>大方向：任务编排用 <code>Channel</code>，共享资源保护用传统<code>并发原语</code></p>
</blockquote>
<h1>互斥锁实现机制</h1>
<blockquote>
<p>使用互斥锁，限定临界区只能同时由一个线程持有。</p>
</blockquote>
<ul>
<li>临界区
<ul>
<li>在并发编程中，如果程序中的一部分会被并发访问或修改，那么，为了避免并发访问导致的意想不到的结果，这部分程序需要被保护起来，这部分被保护起来的程序，就叫做临界区。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/202108281355882.png" alt="image-20210828135504575"></p>
<p>在 Go 标准库中，它提供了 Mutex 来实现互斥锁这个功能。</p>
<ul>
<li>共享资源。并发地读写共享资源，会出现数据竞争（data race）的问题，所以需要 Mutex、RWMutex 这样的并发原语来保护。</li>
<li>任务编排。需要 goroutine 按照一定的规律执行，而 goroutine 之间有相互等待或者依赖的顺序关系，我们常常使用 WaitGroup 或者 Channel 来实现。</li>
<li>消息传递。信息交流以及不同的 goroutine 之间的线程安全的数据交流，常常使用 Channel 来实现。</li>
</ul>
<span id="more"></span>
<h2 id="简单的计数器例子-Counter">简单的计数器例子 Counter</h2>
<p>方法一：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">   <span class="comment">// 互斥锁保护计数器</span></span><br><span class="line">   <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">   wg.Add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++&#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="comment">// 对变量 count 进行加法操作</span></span><br><span class="line">         <span class="comment">// count++ 不是一个原子操作，它至少包含几个步骤，</span></span><br><span class="line">         <span class="comment">// 比如读取变量 count 的当前值，</span></span><br><span class="line">         <span class="comment">// 对这个值加 1，把结果再保存到 count 中。</span></span><br><span class="line">         <span class="comment">// 因为不是原子操作，就可能有并发的问题。</span></span><br><span class="line">         <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++&#123;</span><br><span class="line">mu.Lock()</span><br><span class="line">count++</span><br><span class="line">            mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待 10 个 goroutine 完成</span></span><br><span class="line">   wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;结果为&quot;</span>, count)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二（推荐）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span>&#123;</span><br><span class="line">   id    <span class="type">int</span></span><br><span class="line">   name  <span class="type">string</span></span><br><span class="line">   mu    sync.Mutex</span><br><span class="line">   count <span class="type">uint</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(c *Counter)</span></span>Inc() &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line">c.count++</span><br><span class="line">   c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(c *Counter)</span></span>Count()<span class="type">uint</span>&#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main2</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> counter Counter</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">   wg.Add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++&#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++&#123;</span><br><span class="line">counter.Inc()<span class="comment">// 受到 mutex 保护的方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;结果为&quot;</span>, counter.count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等待的goroutine们是以FIFO排队的</p>
<ul>
<li>
<p>1）当Mutex处于正常模式时，若此时没有新goroutine与队头goroutine竞争，则队头goroutine获得。若有新goroutine竞争大概率新goroutine获得。</p>
</li>
<li>
<p>2）当队头goroutine竞争锁失败1ms后，它会将Mutex调整为饥饿模式。进入饥饿模式后，锁的所有权会直接从解锁goroutine移交给队头goroutine，此时新来的goroutine直接放入队尾。</p>
</li>
<li>
<p>3）当一个goroutine获取锁后，如果发现自己满足下列条件中的任何一个</p>
<ul>
<li>它是队列中最后一个</li>
<li>它等待锁的时间少于1ms</li>
</ul>
<p>将锁切换回正常模式</p>
</li>
</ul>
<h2 id="mutex-注意点">mutex 注意点</h2>
<ul>
<li>Unlock 方法可以被任意的 goroutine 调用释放锁，即使是没持有这个互斥锁的 goroutine，也可以进行这个操作。这是因为，Mutex 本身并没有包含持有这把锁的 goroutine 的信息，所以，Unlock 也不会对此进行检查。Mutex 的这个设计一直保持至今。</li>
</ul>
<h2 id="Mutex常见错误">Mutex常见错误</h2>
<blockquote>
<p>Mutex 常见的错误场景有 4 类，分别是 Lock/Unlock 不是成对出现、Copy 已使用的 Mutex、重入和死锁。</p>
</blockquote>
<p>可重入的概念</p>
<ul>
<li>当一个线程获取锁时，如果没有其它线程拥有这个锁，那么，这个线程就成功获取到这个锁。之后，如果其它线程再请求这个锁，就会处于阻塞等待的状态。但是，如果拥有这把锁的线程再请求这把锁的话，不会阻塞，而是成功返回，所以叫可重入锁（有时候也叫做递归锁）。只要你拥有这把锁，你可以可着劲儿地调用，比如通过递归实现一些算法，调用者不会阻塞或者死锁。</li>
</ul>
<p>死锁</p>
<ul>
<li>两个或两个以上的进程（或线程，goroutine）在执行过程中，因争夺共享资源而处于一种互相等待的状态，如果没有外部干涉，它们都将无法推进下去，此时，我们称系统处于死锁状态或系统产生了死锁。</li>
</ul>
<p>避免死锁，只要破坏这四个条件中的一个或者几个，就可以了。</p>
<ul>
<li>互斥： 至少一个资源是被排他性独享的，其他线程必须处于等待状态，直到资源被释放。</li>
<li>持有和等待：goroutine 持有一个资源，并且还在请求其它 goroutine 持有的资源，也就是咱们常说的“吃着碗里，看着锅里”的意思。</li>
<li>不可剥夺：资源只能由持有它的 goroutine 来释放。</li>
<li>环路等待：一般来说，存在一组等待进程，P={P1，P2，…，PN}，P1 等待 P2 持有的资源，P2 等待 P3 持有的资源，依此类推，最后是 PN 等待 P1 持有的资源，这就形成了一个环路等待的死结。</li>
</ul>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/202108281347706.png" alt="image-20210828135540673"></p>
<h2 id="Mutex小结">Mutex小结</h2>
<h2 id="RWMutex-—-读写锁">RWMutex — 读写锁</h2>
<p>标准库中的 RWMutex 是一个 <code>reader/writer</code> 互斥锁。RWMutex在某一时刻只能由任意数量的 reader 持有，或者是只被单个的 writer 持有。RWMutex 的方法也很少，总共有 5 个。</p>
<ul>
<li>
<p>Lock/Unlock：写操作时调用的方法。如果锁已经被 reader 或者 writer 持有，那么，Lock 方法会一直阻塞，直到能获取到锁；Unlock 则是配对的释放锁的方法。</p>
</li>
<li>
<p>RLock/RUnlock：读操作时调用的方法。如果锁已经被 writer 持有的话，RLock 方法会一直阻塞，直到能获取到锁，否则就直接返回；而 RUnlock 是 reader 释放锁的方法。</p>
</li>
<li>
<p>RLocker：这个方法的作用是为读操作返回一个 Locker 接口的对象。它的 Lock 方法会调用 RWMutex 的 RLock 方法，它的 Unlock 方法会调用 RWMutex 的 RUnlock 方法。</p>
<p>RWMutex 的零值是未加锁的状态，所以，当你使用 RWMutex 的时候，无论是声明变量，还是嵌入到其它 struct 中，都不必显式地初始化。</p>
</li>
</ul>
<blockquote>
<p>如果你遇到可以明确区分 reader 和 writer goroutine 的场景，且有大量的并发读、少量的并发写，并且有强烈的性能需求，你就可以考虑使用读写锁 RWMutex 替换 Mutex。</p>
</blockquote>
<h2 id="RWMutex-的实现原理">RWMutex 的实现原理</h2>
<p>RWMutex 是很常见的并发原语，很多编程语言的库都提供了类似的并发类型。RWMutex 一般都是基于互斥锁、条件变量（condition variables）或者信号量（semaphores）等并发原语来实现。Go 标准库中的 RWMutex 是基于 Mutex 实现的。</p>
<ul>
<li>readers-writers 问题一般有三类，基于对读和写操作的优先级，读写锁的设计和实现也分成三类。Read-preferring：读优先的设计可以提供很高的并发性，但是，在竞争激烈的情况下可能会导致写饥饿。这是因为，如果有大量的读，这种设计会导致只有所有的读都释放了锁之后，写才可能获取到锁。</li>
<li>Write-preferring：写优先的设计意味着，如果已经有一个 writer 在等待请求锁的话，它会阻止新来的请求锁的 reader 获取到锁，所以优先保障 writer。当然，如果有一些 reader 已经请求了锁的话，新请求的 writer 也会等待已经存在的 reader 都释放锁之后才能获取。所以，写优先级设计中的优先权是针对新来的请求而言的。这种设计主要避免了 writer 的饥饿问题。</li>
<li>不指定优先级：这种设计比较简单，不区分 reader 和 writer 优先级，某些场景下这种不指定优先级的设计反而更有效，因为第一类优先级会导致写饥饿，第二类优先级可能会导致读饥饿，这种不指定优先级的访问不再区分读写，大家都是同一个优先级，解决了饥饿的问题。</li>
</ul>
<p>Go 标准库中的 RWMutex 设计是 Write-preferring 方案。一个正在阻塞的 Lock 调用会排除新的 reader 请求到锁。</p>
<h2 id="RWMutex的锁">RWMutex的锁</h2>
<p>RWMutex 是⼀个多 writer 多 reader 的读写锁，所以同时可能有多个 writer 和 reader。那 么，为了避免 writer 之间的竞争，RWMutex 就会使用⼀个 Mutex 来保证 writer 的互斥。</p>
<ul>
<li>在 Lock 方法中，是先获取内部互斥锁，才会修改的其他字段；</li>
<li>在 Unlock 方法中，是先修改的其他字段，才会释放内部互斥锁，这样才能保证字段的修改也受到互斥锁的保护。</li>
</ul>
<blockquote>
<p>使用读写锁最需要注意的⼀点就是尽量避免重入，重入带来的死锁⾮常隐蔽，⽽且难以 诊断。</p>
</blockquote>
<h1>WaitGroup：协同等待，任务编排利器</h1>
<h2 id="WaitGroup基本用法">WaitGroup基本用法</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Add(delta <span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Done()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait()</span><br></pre></td></tr></table></figure>
<ul>
<li>Add，用来设置 WaitGroup 的计数值；</li>
<li>Done，用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1)；</li>
<li>Wait，调用这个方法的 goroutine 会⼀直阻塞，直到 WaitGroup 的计数值变为 0。</li>
</ul>
<h2 id="WaitGroup数据结构">WaitGroup数据结构</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 避免复制使用的⼀个技巧，可以告诉vet⼯具违反了复制使用的规则</span></span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 64bit(8bytes)的值分成两段，⾼32bit是计数值，低32bit是waiter的计数</span></span><br><span class="line">    <span class="comment">// 另外32bit是用作信号量的</span></span><br><span class="line">    <span class="comment">// 因为64bit值的原子操作需要64bit对⻬，但是32bit编译器不⽀持，所以数组中的元素在不同的架构</span></span><br><span class="line">    <span class="comment">// 总之，会找到对⻬的那64bit作为state，其余的32bit做信号量</span></span><br><span class="line">    state1 [<span class="number">3</span>]<span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到state的地址和信号量的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> state() (statep *<span class="type">uint64</span>, semap *<span class="type">uint32</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="type">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 如果地址是64bit对⻬的，数组前两个元素做state，后⼀个元素做信号量</span></span><br><span class="line"><span class="keyword">return</span> (*<span class="type">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class="number">2</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果地址是32bit对⻬的，数组后两个元素用来做state，它可以用来做64bit的原子操作，第</span></span><br><span class="line"><span class="keyword">return</span> (*<span class="type">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class="number">1</span>])), &amp;wg.state1[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>WaitGroup 是可以重用的。只要 WaitGroup 的计数值恢复到零值的状态，那么它就可以被看作是新创建的 WaitGroup，被重复使用</p>
</blockquote>
<h2 id="小结">小结</h2>
<ul>
<li>不重用 WaitGroup。新建⼀个 WaitGroup 不会带来多⼤的资源开销，重用反⽽更容易出 错。</li>
<li>保证所有的 Add 方法调用都在 Wait 之前。</li>
<li>不传递负数给 Add 方法，只通过 Done 来给计数值减 1。</li>
<li>不做多余的 Done 方法调用，保证 Add 的计数值和 Done 方法调用的数量是⼀样的。</li>
<li>不遗漏 Done 方法的调用，否则会导致 Wait hang 住⽆法返回。</li>
</ul>
<h1>Cond</h1>
<p>Go 标准库提供 Cond 原语的目的是，为等待 / 通知场景下的并发问题提供⽀持。</p>
<h2 id="Cond-的基本用法">Cond 的基本用法</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NeWCond</span><span class="params">(l Locker)</span></span> *Cond</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait()</span><br></pre></td></tr></table></figure>
<ul>
<li>⾸先，Cond 关联的 Locker 实例可以通过 c.L 访问，它内部维护着⼀个先入先出的等待队 列。</li>
<li>Signal 方法，允许调用者 Caller 唤醒⼀个等待此 Cond 的 goroutine。如果此时没有等待的goroutine，显然⽆需通知 waiter；如果 Cond 等待队列中有⼀个或者多个等待的goroutine，则需要从等待队列中移除第⼀个 goroutine 并把它唤醒。在其他编程语言中，⽐如 Java 语⾔中，Signal 方法也被叫做 notify 方法。
<ul>
<li>调用 Signal 方法时，不强求你⼀定要持有 c.L 的锁。</li>
</ul>
</li>
<li>Broadcast 方法，允许调用者 Caller 唤醒所有等待此 Cond 的 goroutine。如果此时没有等待的 goroutine，显然⽆需通知 waiter；如果 Cond 等待队列中有⼀个或者多个等待的goroutine，则清空所有等待的 goroutine，并全部唤醒。在其他编程语⾔中，⽐如 Java 语⾔中，Broadcast 方法也被叫做 notifyAll 方法。
<ul>
<li>同样地，调用 Broadcast 方法时，也不强求你⼀定持有 c.L 的锁。</li>
</ul>
</li>
<li>Wait 方法，会把调用者 Caller 放入 Cond 的等待队列中并阻塞，直到被 Signal 或者Broadcast 的方法从等待队列中移除并唤醒。
<ul>
<li>调用 Wait 方法时必须要持有 c.L 的锁。</li>
</ul>
</li>
</ul>
<h2 id="案例">案例</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">  <span class="keyword">var</span> ready <span class="type">int</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++ &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">      time.Sleep(time.Duration(rand.Int63n(<span class="number">10</span>)) * time.Second)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加锁更改等待条件</span></span><br><span class="line">      c.L.Lock()</span><br><span class="line">      ready++</span><br><span class="line">      c.L.Unlock()</span><br><span class="line">      log.Printf(<span class="string">&quot;运动员#%d 准备就绪\\n&quot;</span>, i)</span><br><span class="line">      <span class="comment">// 广播唤醒所有的等待着</span></span><br><span class="line">      c.Broadcast()</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c.L.Lock()</span><br><span class="line">  <span class="keyword">for</span> ready!= <span class="number">10</span>&#123;</span><br><span class="line">    c.Wait()</span><br><span class="line">    log.Printf(<span class="string">&quot;裁判员被唤醒一次&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  c.L.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有运动员是否准备就绪</span></span><br><span class="line">  log.Println(<span class="string">&quot;所有运动员准备就绪，比赛开始！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结-2">小结</h2>
<ul>
<li>Cond 是为等待 / 通知场景下的并发问题提供⽀持的。它提供了条件变量的三个基本方法Signal、Broadcast 和 Wait，为并发的 goroutine 提供等待 / 通知机制。</li>
<li>使用 Cond 之所以容易出错，就是 Wait 调用需要加锁，以及被唤醒后⼀定要检查条件是否真 的已经满⾜。你需要牢记这两点。</li>
<li>WaitGroup和 Cond 的区别：WaitGroup 是主 goroutine 等待确定数量的子 goroutine 完成任务；⽽ Cond 是等待某个条件满⾜，这个条件的修改可以被任意多的 goroutine 更新，⽽且 Cond的 Wait 不关⼼也不知道其他 goroutine 的数量，只关⼼等待条件。⽽且 Cond 还有单个通知的机制，也就是 Signal 方法。</li>
</ul>
<h1>Once</h1>
<p>Once可以用来执行且仅仅执行⼀次动作，常常用于单例对象的初始化场景。</p>
<h2 id="使用场景">使用场景</h2>
<p>sync.Once 只暴露了⼀个方法 Do，你可以多次调用 Do 方法，但是只有第⼀次调用 Do 方法 时 f 参数才会执行，这⾥的 f 是⼀个⽆参数⽆返回值的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Once 常常用来初始化单例资源，或者并发访问只需初始化⼀次的共享资源，或者在测试的时候初始化⼀次测试资源。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> once sync.Once</span><br><span class="line">  </span><br><span class="line">  f1:=<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;f1 exce！&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  once.Do(f1)</span><br><span class="line">  </span><br><span class="line">  f2 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;f2 exce&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  once.Do(f2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结-3">小结</h2>
<blockquote>
<p>⼀旦你遇到只需要初始化⼀次的场景，⾸先想到的就应该是 Once 并发原语。</p>
</blockquote>
<h1>Pool</h1>
<p>Go 标准库中提供了⼀个通用的 Pool 数据结构，也就是 sync.Pool，我们使用它可以创建池化的对象。但是它池化的对象可能会被垃圾回收掉。</p>
<ul>
<li>sync.Pool 数据类型用来保存⼀组可独立访问的临时对象。
<ul>
<li>也就是说，它池化的对象会在未来的某个时候被毫无预兆地移除掉。而且，如果没有别的对象引用这个被移除的对象的话，这个被移除的对象就会被垃圾回收掉。</li>
</ul>
</li>
</ul>
<h3 id="注意点">注意点</h3>
<ul>
<li>
<ol>
<li>sync.Pool 本身就是线程安全的，多个 goroutine 可以并发地调用它的方法存取对象；</li>
</ol>
</li>
<li>
<ol>
<li>sync.Pool 不可在使用之后再复制使用。</li>
</ol>
</li>
</ul>
<h2 id="方法介绍">方法介绍</h2>
<p>1.New</p>
<ul>
<li>Pool struct 包含⼀个 New 字段，这个字段的类型是函数 func() interface{}。当调用 Pool 的 Get 方法从池中获取元素，没有更多的空闲元素可返回时，就会调用这个 New 方法来创建新 的元素。如果你没有设置 New 字段，没有更多的空闲元素可返回时，Get 方法将返回 nil，表 明当前没有可用的元素。 有趣的是，New 是可变的字段。这就意味着，你可以在程序运行的时候改变创建元素的方 法。当然，很少有⼈会这么做，因为⼀般我们创建元素的逻辑都是⼀致的，要创建的也是同⼀ 类的元素，所以你在使用 Pool 的时候也没必要玩⼀些“花活”，在程序运行时更改 New 的 值。</li>
</ul>
<p>2.Get</p>
<ul>
<li>如果调用这个方法，就会从 Pool取⾛⼀个元素，这也就意味着，这个元素会从 Pool 中移除， 返回给调用者。不过，除了返回值是正常实例化的元素，Get 方法的返回值还可能会是⼀个 nil（Pool.New 字段没有设置，⼜没有空闲元素可以返回），所以你在使用的时候，可能需要 判断。</li>
</ul>
<p>3.Put</p>
<ul>
<li>这个方法用于将⼀个元素返还给 Pool，Pool 会把这个元素保存到池中，并且可以复用。但如 果 Put ⼀个 nil 值，Pool 就会忽略这个值。</li>
</ul>
<h2 id="推荐的三方pool">推荐的三方pool</h2>
<ul>
<li><code>gammazero/workerpool</code>：gammazero/workerpool 可以⽆限制地提交任务，提供了更便利的 Submit 和 SubmitWait 方法提交任务，还可以提供当前的 worker 数和任务数以及关闭 Pool 的功能。</li>
<li><code>ivpusic/grpool</code>：grpool 创建 Pool 的时候需要提供 Worker 的数量和等待执行的任务的 最⼤数量，任务的提交是直接往 Channel 放入任务。</li>
<li><code>dpaks/goworkers</code>：dpaks/goworkers 提供了更便利的 Submit 方法提交任务以及Worker 数、任务数等查询方法、关闭 Pool 的方法。它的任务的执行结果需要在ResultChan 和 ErrChan 中去获取，没有提供阻塞的方法，但是它可以在初始化的时候设置 Worker 的数量和任务数。</li>
</ul>
<h2 id="pool可能造成的问题">pool可能造成的问题</h2>
<ul>
<li>内存泄漏
<ul>
<li>在使用 sync.Pool 回收 buffer 的时候，⼀定要检查回收的对象的⼤⼩。如果 buffer 太⼤，就 不要回收了，否则就太浪费了</li>
</ul>
</li>
<li>内存浪费
<ul>
<li>要做到物尽其用，尽可能不浪费的话，我们可以将 buffer 池分成⼏层</li>
<li>⼩于 512 byte的元素的 buffer 占⼀个池子；其次，⼩于 1K byte ⼤⼩的元素占⼀个池子；再次，⼩于 4Kbyte ⼤⼩的元素占⼀个池子。这样分成⼏个池子以后，就可以根据需要，到所需⼤⼩的池子中获取 buffer 了。</li>
</ul>
</li>
</ul>
<h2 id="小结-4">小结</h2>
<ul>
<li>Pool 是⼀个通用的概念，也是解决对象重用和预先分配的⼀个常用的优化⼿段。即使你⾃⼰ 没在项目中直接使用过，但肯定在使用其它库的时候，就享受到应用 Pool 的好处了，⽐如数 据库的访问、http API 的请求等等。</li>
<li>我们⼀般不会在程序⼀开始的时候就开始考虑优化，⽽是等项目开发到⼀个阶段，或者快结束 的时候，才全⾯地考虑程序中的优化点，⽽ Pool 就是常用的⼀个优化⼿段。如果你发现程序 中有⼀种 GC 耗时特别⾼，有⼤量的相同类型的临时对象，不断地被创建销毁，这时，你就可 以考虑看看，是不是可以通过池化的⼿段重用这些对象。</li>
<li>另外，在分布式系统或者微服务框架中，可能会有⼤量的并发 Client 请求，如果 Client 的耗 时占⽐很⼤，你也可以考虑池化 Client，以便重用。</li>
<li>如果你发现系统中的 goroutine 数量⾮常多，程序的内存资源占用⽐较⼤，⽽且整体系统的耗 时和 GC 也⽐较⾼，我建议你看看，是否能够通过 Worker Pool 解决⼤量 goroutine 的问 题，从⽽降低这些指标。</li>
</ul>
<h1>Context：信息穿透上下文</h1>
<p>在 API之间或者方法调用之间，所传递的除了业务参数之外的额外信息。</p>
<h2 id="context使用场景">context使用场景</h2>
<ul>
<li>上下⽂信息传递 （request-scoped），⽐如处理 http 请求、在请求处理链路上传递信 息；</li>
<li>控制子 goroutine 的运行；</li>
<li>超时控制的方法调用；</li>
<li>可以取消的方法调用。</li>
</ul>
<h2 id="context-接口函数">context 接口函数</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Deadline 方法会返回这个 Context 被取消的截⽌⽇期。如果没有设置截⽌⽇期，ok 的值是 false。后续每次调用这个对象的 Deadline 方法时，都会返回和第⼀次调用相同的结果。</li>
<li>Done 方法返回⼀个 Channel 对象。在 Context 被取消时，此 Channel 会被 close，如果没 被取消，可能会返回 nil。后续的 Done 调用总是返回相同的结果。当 Done 被 close 的时 候，你可以通过 ctx.Err 获取错误信息。Done 这个方法名其实起得并不好，因为名字太过笼 统，不能明确反映 Done 被 close 的原因，因为 cancel、timeout、deadline 都可能导致</li>
<li>Done 被 close，不过，目前还没有⼀个更合适的方法名称。
<ul>
<li>如果 Done 没有被 close，Err 方法返回 nil；如果 Done 被 close，Err 方法会返回 Done 被 close 的原因。</li>
</ul>
</li>
<li>Value 返回此 ctx 中和指定的 key 相关联的 value。</li>
</ul>
<p>Context 中实现了 2 个常用的生成顶层 Context 的方法。</p>
<ul>
<li><code>context.Background()</code>：返回⼀个⾮ nil 的、空的 Context，没有任何值，不会被 cancel，不会超时，没有截⽌⽇期。⼀般用在主函数、初始化、测试以及创建根 Context 的时候</li>
<li><code>context.TODO()</code>：返回⼀个⾮ nil 的、空的 Context，没有任何值，不会被 cancel，不会超时，没有截⽌⽇期。当你不清楚是否该用 Context，或者目前还不知道要传递⼀些什么上下⽂信息的时候，就可以使用这个方法。</li>
</ul>
<h2 id="关于Context的一些约定规定">关于Context的一些约定规定</h2>
<ul>
<li>
<ol>
<li>⼀般函数使用 Context 的时候，会把这个参数放在第⼀个参数的位置。从来不把 nil 当Context 类型的参数值，可以使用 context.Background() 创建⼀个空的上下⽂对象，也不要使用 nil。</li>
</ol>
</li>
<li>2.Context 只用来临时做函数之间的上下⽂透传，不能持久化 Context 或者把 Context ⻓久存。<strong>把 Context 持久化到数据库、本地⽂件或者全局变量、缓存中都是错误的用法</strong>。</li>
<li>3.key 的类型不应该是字符串类型或者其它内建类型，否则容易在包之间使用 Context 时候产生冲突。使用 WithValue 时，key 的类型应该是⾃⼰定义的类型。</li>
<li>4.常常使用 struct{}作为底层类型定义 key 的类型。对于 exported key 的静态类型，常常是接⼝或者指针。这样可以尽量减少内存分配。</li>
</ul>
<h2 id="应用场景">应用场景</h2>
<p>main函数返回时，所有的goroutine都会被直接打断，程序退出。除此之外如果想通过编程的方法让一个goroutine中断其他goroutine的执行，只能是通过在多个goroutine间通过context上下文对象同步取消信号的方式来实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">      ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;goroutine exit&quot;</span>)</span><br><span class="line">      &#125;()</span><br><span class="line">      <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;()</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">      cancel()</span><br><span class="line">      time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1>atomic 原子操作</h1>
<p>原子操作，是因为⼀个原子在执行的时候，其它线程不会看到执行⼀半的操作结果。在其它线程看来，原子操作要么执行完了，要么还没有执行，就像⼀个最⼩的粒子 - 原子⼀样，不可分割</p>
<h2 id="atomic-提供的方法">atomic 提供的方法</h2>
<ul>
<li>atomic 操作的对象是⼀个地址，你需要把可寻址的变量的地址作为参数传递给方法，⽽不是把变量的值传递给方法。</li>
</ul>
<h2 id="Add">Add</h2>
<p>Add 方法就是给第⼀个参数地址中的值增加⼀个 delta 值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddInt32 atomically adds delta to *addr and returns the new value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt32</span><span class="params">(addr *<span class="type">int32</span>, delta <span class="type">int32</span>)</span></span> (<span class="built_in">new</span> <span class="type">int32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddUint32 atomically adds delta to *addr and returns the new value.</span></span><br><span class="line"><span class="comment">// To subtract a signed positive constant value c from x, do AddUint32(&amp;x, ^uint32(c-1)).</span></span><br><span class="line"><span class="comment">// In particular, to decrement x, do AddUint32(&amp;x, ^uint32(0)).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint32</span><span class="params">(addr *<span class="type">uint32</span>, delta <span class="type">uint32</span>)</span></span> (<span class="built_in">new</span> <span class="type">uint32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddInt64 atomically adds delta to *addr and returns the new value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt64</span><span class="params">(addr *<span class="type">int64</span>, delta <span class="type">int64</span>)</span></span> (<span class="built_in">new</span> <span class="type">int64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddUint64 atomically adds delta to *addr and returns the new value.</span></span><br><span class="line"><span class="comment">// To subtract a signed positive constant value c from x, do AddUint64(&amp;x, ^uint64(c-1)).</span></span><br><span class="line"><span class="comment">// In particular, to decrement x, do AddUint64(&amp;x, ^uint64(0)).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint64</span><span class="params">(addr *<span class="type">uint64</span>, delta <span class="type">uint64</span>)</span></span> (<span class="built_in">new</span> <span class="type">uint64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddUintptr atomically adds delta to *addr and returns the new value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, delta <span class="type">uintptr</span>)</span></span> (<span class="built_in">new</span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure>
<p>CAS （CompareAndSwap）</p>
<p>这个方法会⽐较当前 addr 地址⾥的值是不是 old，如果不等于 old，就返回 false；如果等于old，就把此地址的值替换成 new 值，返回 true。这就相当于“判断相等才替换”。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt32</span><span class="params">(addr *<span class="type">int32</span>, old, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt64</span><span class="params">(addr *<span class="type">int64</span>, old, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint32</span><span class="params">(addr *<span class="type">uint32</span>, old, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint64</span><span class="params">(addr *<span class="type">uint64</span>, old, <span class="built_in">new</span> <span class="type">uint64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, old, <span class="built_in">new</span> <span class="type">uintptr</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapPointer</span><span class="params">(addr *unsafe.Pointer, old, <span class="built_in">new</span> unsafe.Pointer)</span></span> (swapped <span class="type">bool</span>)</span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> *addr == old &#123;</span><br><span class="line">  *addr = <span class="built_in">new</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="Swap">Swap</h2>
<p>如果不需要⽐较旧值，只是⽐较粗暴地替换的话，就可以使用 Swap 方法，它替换后还可以 返回旧值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SwapInt32 atomically stores new into *addr and returns the previous *addr value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt32</span><span class="params">(addr *<span class="type">int32</span>, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> (old <span class="type">int32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SwapInt64 atomically stores new into *addr and returns the previous *addr value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt64</span><span class="params">(addr *<span class="type">int64</span>, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (old <span class="type">int64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SwapUint32 atomically stores new into *addr and returns the previous *addr value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUint32</span><span class="params">(addr *<span class="type">uint32</span>, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> (old <span class="type">uint32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SwapUint64 atomically stores new into *addr and returns the previous *addr value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUint64</span><span class="params">(addr *<span class="type">uint64</span>, <span class="built_in">new</span> <span class="type">uint64</span>)</span></span> (old <span class="type">uint64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SwapUintptr atomically stores new into *addr and returns the previous *addr value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, <span class="built_in">new</span> <span class="type">uintptr</span>)</span></span> (old <span class="type">uintptr</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SwapPointer atomically stores new into *addr and returns the previous *addr value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapPointer</span><span class="params">(addr *unsafe.Pointer, <span class="built_in">new</span> unsafe.Pointer)</span></span> (old unsafe.Pointer)</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old = *addr</span><br><span class="line">*addr = <span class="built_in">new</span></span><br><span class="line"><span class="keyword">return</span> old</span><br></pre></td></tr></table></figure>
<h2 id="Load">Load</h2>
<p>Load 方法会取出 addr 地址中的值，即使在多处理器、多核、有 CPU cache 的情况下，这个操作也能保证 Load 是⼀个原子操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoadInt32 atomically loads *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt32</span><span class="params">(addr *<span class="type">int32</span>)</span></span> (val <span class="type">int32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadInt64 atomically loads *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt64</span><span class="params">(addr *<span class="type">int64</span>)</span></span> (val <span class="type">int64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadUint32 atomically loads *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint32</span><span class="params">(addr *<span class="type">uint32</span>)</span></span> (val <span class="type">uint32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadUint64 atomically loads *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint64</span><span class="params">(addr *<span class="type">uint64</span>)</span></span> (val <span class="type">uint64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadUintptr atomically loads *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUintptr</span><span class="params">(addr *<span class="type">uintptr</span>)</span></span> (val <span class="type">uintptr</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadPointer atomically loads *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadPointer</span><span class="params">(addr *unsafe.Pointer)</span></span> (val unsafe.Pointer)</span><br></pre></td></tr></table></figure>
<h2 id="Store">Store</h2>
<p>Store 方法会把⼀个值存入到指定的 addr 地址中，即使在多处理器、多核、有 CPU cache的情况下，这个操作也能保证 Store 是⼀个原子操作。别的 goroutine 通过 Load 读取出来，不会看到存取了⼀半的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StoreInt32 atomically stores val into *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt32</span><span class="params">(addr *<span class="type">int32</span>, val <span class="type">int32</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StoreInt64 atomically stores val into *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt64</span><span class="params">(addr *<span class="type">int64</span>, val <span class="type">int64</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StoreUint32 atomically stores val into *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint32</span><span class="params">(addr *<span class="type">uint32</span>, val <span class="type">uint32</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StoreUint64 atomically stores val into *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint64</span><span class="params">(addr *<span class="type">uint64</span>, val <span class="type">uint64</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StoreUintptr atomically stores val into *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, val <span class="type">uintptr</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StorePointer atomically stores val into *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StorePointer</span><span class="params">(addr *unsafe.Pointer, val unsafe.Pointer</span></span></span><br></pre></td></tr></table></figure>
<h2 id="Value-类型">Value 类型</h2>
<p>它可以原子地存取对象类型，但也只能存取，不能 CAS 和 Swap，常常用在配置变更等场景中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Value must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">  v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Load() (x <span class="keyword">interface</span>&#123;&#125;) &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Store(x <span class="keyword">interface</span>&#123;&#125;) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<h1>Channel：解决并发问题</h1>
<p>CSP允许使用进程组件来描述系统，它们独⽴运行，并且只通过消息传递的方式通信。</p>
<h2 id="Channel-的应用场景">Channel 的应用场景</h2>
<blockquote>
<p>执行业务处理的 goroutine 不要通过共享内存的方式通信，⽽是要通过 Channel 通信的方式分享数据</p>
</blockquote>
<ul>
<li>“communicate by sharing memory”是传统的并发编程处理方式，就是指，共享的数据需要用锁进行保护，goroutine 需要获取到锁，才能并发访问数据。</li>
<li>“share memory by communicating”则是类似于 CSP 模型的方式，通过通信的方式，⼀个goroutine 可以把数据的“所有权”交给另外⼀个 goroutine（虽然 Go 中没有“所有权”的概念，但是从逻辑上说，你可以把它理解为是所有权的转移）。</li>
</ul>
<p>五大应用场景</p>
<ul>
<li><code>数据交流</code>：当作并发的 buffer 或者 queue，解决生产者 - 消费者问题。多个 goroutine 可以并发当作生产者（Producer）和消费者（Consumer）。</li>
<li><code>数据传递</code>：⼀个 goroutine 将数据交给另⼀个 goroutine，相当于把数据的拥有权 (引用)托付出去。</li>
<li><code>信号通知</code>：⼀个 goroutine 可以将信号 (closing、closed、data ready 等) 传递给另⼀个或者另⼀组 goroutine 。</li>
<li><code>任务编排</code>：可以让⼀组 goroutine 按照⼀定的顺序并发或者串行的执行，这就是编排的功能。</li>
<li><code>锁</code>：利用 Channel 也可以实现互斥锁的机制。</li>
</ul>
<h2 id="channel-基本用法">channel 基本用法</h2>
<blockquote>
<p><code>&lt;-</code> v有个规则，总是尽量和左边的 chan 结合（The &lt;- operator associates with the leftmost chan possible:</p>
</blockquote>
<ul>
<li>nil 是 chan 的零值，是⼀种特殊的 chan，对值是 nil 的 chan 的发送接收调用者总是会阻塞</li>
</ul>
<h2 id="关于channel的选择">关于channel的选择</h2>
<ul>
<li>
<ol>
<li>共享资源的并发访问使用传统并发原语；</li>
</ol>
</li>
<li>
<ol>
<li>复杂的任务编排和消息传递使用 Channel；</li>
</ol>
</li>
<li>
<ol>
<li>消息通知机制使用 Channel，除非只想 signal ⼀个 goroutine，才使用 Cond；</li>
</ol>
</li>
<li>
<ol>
<li>简单等待所有任务的完成用 WaitGroup，也有 Channel 的推崇者用 Channel，都可以；</li>
</ol>
</li>
<li>
<ol>
<li>需要和 Select 语句结合，使用 Channel；</li>
</ol>
</li>
<li>
<ol>
<li>需要和超时配合时，使用 Channel 和 Context。</li>
</ol>
</li>
</ul>
<h2 id="chan-的编排方式">chan 的编排方式</h2>
<p>Or-Done 模式、扇入模式、扇出模式、Stream 和 map-reduce</p>
<h3 id="Or-Done-模式">Or-Done 模式</h3>
<p>Or-Done 模式是信号通知模式中更宽泛的⼀种模式</p>
<p>我们会使用“信号通知”实现某个任务执行完成后的通知机制，在实现时，我们为这个任务定义 ⼀个类型为 chan struct{}类型的 done 变量，等任务结束后，我们就可以 close 这个变量， 然后，其它 receiver 就会收到这个通知。 这是有⼀个任务的情况，如果有多个任务，只要有任意⼀个任务执行完，我们就想获得这个信 号，这就是 Or-Done 模式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or or-done 模式 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">or</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">  <span class="comment">// 特殊情况，只有零个,1个或2个 chan</span></span><br><span class="line">  <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line">    <span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line">    <span class="comment">// fmt.Println(&quot;执行&quot;)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(channels) &gt; <span class="number">2</span> &#123;</span><br><span class="line">      m := <span class="built_in">len</span>(channels) / <span class="number">2</span></span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-or(channels[:m]...):</span><br><span class="line">      <span class="keyword">case</span> &lt;-or(channels[m:]...):</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">return</span> orDone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sig</span><span class="params">(after time.Duration)</span></span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">    time.Sleep(after)</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// orSelect 反射⽅式 实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">orSelect</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">  <span class="comment">// 特殊情况，只有零个,1个或2个 chan</span></span><br><span class="line">  <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line">    <span class="comment">// 利用反射构建SelectCase</span></span><br><span class="line">    <span class="keyword">var</span> cases []reflect.SelectCase</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> channels &#123;</span><br><span class="line">      cases = <span class="built_in">append</span>(cases, reflect.SelectCase&#123;</span><br><span class="line">        Dir:  reflect.SelectRecv,</span><br><span class="line">        Chan: reflect.ValueOf(c),</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 随机选取一个可用 case</span></span><br><span class="line">    reflect.Select(cases)</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> orDone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  start := time.Now()</span><br><span class="line"></span><br><span class="line">  &lt;-orSelect(</span><br><span class="line">    sig(<span class="number">10</span>*time.Second),</span><br><span class="line">    sig(<span class="number">20</span>*time.Second),</span><br><span class="line">    sig(<span class="number">30</span>*time.Second),</span><br><span class="line">    sig(<span class="number">40</span>*time.Second),</span><br><span class="line">    sig(<span class="number">50</span>*time.Second),</span><br><span class="line">    sig(<span class="number">01</span>*time.Second),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">&quot;done after %v&quot;</span>, time.Since(start))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="扇入模式">扇入模式</h3>
<p>扇入借鉴了数字电路的概念，它定义了单个逻辑们能够接受的数字信号输入最⼤量的术语。⼀ 个逻辑们可以有多个输入，⼀个输出。</p>
<ul>
<li>在软件⼯程中，<strong>模块的扇入是指有多少个上级模块调用它</strong>。</li>
<li>而对于我们这里的 <code>Channel</code> 扇入模式来说，就是指有多个源 <code>Channel</code> 输入、⼀个目的<code> Channel</code> 输出的情况。</li>
</ul>
<p>扇入比就是源 Channel 数量比1。</p>
<ul>
<li>每个源 Channel 的元素都会发送给目标 Channel，相当于目标 Channel 的 receiver 只需要 监听目标 Channel，就可以接收所有发送给源 Channel 的数据。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扇入模式 反射实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanInReflect</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">  out:= <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">    <span class="comment">// 构造 SelectCases slice</span></span><br><span class="line">    <span class="keyword">var</span> cases []reflect.SelectCase</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> channels&#123;</span><br><span class="line">      cases = <span class="built_in">append</span>(cases, reflect.SelectCase&#123;</span><br><span class="line">        Dir:  reflect.SelectRecv,</span><br><span class="line">        Chan: reflect.ValueOf(c),</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 循环，从 cases 中选择一个可用的</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(cases)&gt;<span class="number">0</span>&#123;</span><br><span class="line">      i,v,ok:=reflect.Select(cases)</span><br><span class="line">      <span class="keyword">if</span> !ok&#123; <span class="comment">// chan 关闭</span></span><br><span class="line">        cases = <span class="built_in">append</span>(cases[:i],cases[i+<span class="number">1</span>:]...)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      out &lt;-v.Interface()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanInRec</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  <span class="keyword">switch</span> <span class="built_in">len</span>(channels)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    c:= <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> mergeTow(channels[<span class="number">0</span>], channels[<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    m:=<span class="built_in">len</span>(channels)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> mergeTow(</span><br><span class="line">      fanInRec(channels[:m]...),</span><br><span class="line">      fanInRec(channels[m:]...))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个 chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTow</span><span class="params">(a,b &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">    <span class="keyword">for</span> a!= <span class="literal">nil</span> || b !=<span class="literal">nil</span>&#123;</span><br><span class="line">      <span class="keyword">select</span>&#123;</span><br><span class="line">      <span class="keyword">case</span> v,ok := &lt;-a:</span><br><span class="line">        <span class="keyword">if</span> !ok &#123; <span class="comment">// a 已关闭，设置为nil</span></span><br><span class="line">          a=<span class="literal">nil</span></span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        c &lt;- v</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">case</span> v,ok := &lt;-b:</span><br><span class="line">        <span class="keyword">if</span> !ok &#123; <span class="comment">// b已关闭，设置为nil</span></span><br><span class="line">        b=<span class="literal">nil</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        c &lt;- v</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sigs</span><span class="params">(after time.Duration)</span></span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">    time.Sleep(after)</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  start := time.Now()</span><br><span class="line"></span><br><span class="line">  &lt;-fanInReflect(</span><br><span class="line">    sigs(<span class="number">10</span>*time.Second),</span><br><span class="line">    sigs(<span class="number">02</span>*time.Second),</span><br><span class="line">    sigs(<span class="number">03</span>*time.Second),</span><br><span class="line">    sigs(<span class="number">04</span>*time.Second),</span><br><span class="line">    sigs(<span class="number">05</span>*time.Second),</span><br><span class="line">    sigs(<span class="number">01</span>*time.Second),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">&quot;done after %v&quot;</span>, time.Since(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扇出模式">扇出模式</h3>
<p>扇出模式是和扇入模式相反的。</p>
<p>扇出模式只有⼀个输入源 <code>Channel</code>，有多个目标 <code>Channel</code>，扇出比就是 1比目标 <code>Channel </code>数 的值，经常用在设计模式中的观察者模式中（观察者设计模式定义了对象间的⼀种⼀对多的 组合关系。这样⼀来，⼀个对象的状态发⽣变化时，所有依赖于它的对象都会得到通知并⾃动 刷新）。在观察者模式中，数据变动后，多个观察者都会收到这个变更信号。</p>

    </div>

    
    
    <div>
  
  <div style="text-align:center;color: #ccc;font-size:14px;">------ 😸 本文结束, 感谢您的阅读 😸 ------</div>
  
</div>
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Golang/" rel="tag"># Golang</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/01/hadoop%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/" rel="prev" title="大数据之Hadoop">
      <i class="fa fa-chevron-left"></i> 大数据之Hadoop
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/03/01/goroutineVspython%E5%8D%8F%E7%A8%8B/" rel="next" title="goroutine VS python 协程">
      goroutine VS python 协程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">预备知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#unsafe-Pointer"><span class="nav-number">1.1.</span> <span class="nav-text">unsafe.Pointer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2-Compare-And-Swap"><span class="nav-number">1.2.</span> <span class="nav-text">CAS比较并交换----Compare And Swap</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">互斥锁实现机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E6%95%B0%E5%99%A8%E4%BE%8B%E5%AD%90-Counter"><span class="nav-number">2.1.</span> <span class="nav-text">简单的计数器例子 Counter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mutex-%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">2.2.</span> <span class="nav-text">mutex 注意点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mutex%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><span class="nav-number">2.3.</span> <span class="nav-text">Mutex常见错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mutex%E5%B0%8F%E7%BB%93"><span class="nav-number">2.4.</span> <span class="nav-text">Mutex小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RWMutex-%E2%80%94-%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">2.5.</span> <span class="nav-text">RWMutex — 读写锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RWMutex-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">2.6.</span> <span class="nav-text">RWMutex 的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RWMutex%E7%9A%84%E9%94%81"><span class="nav-number">2.7.</span> <span class="nav-text">RWMutex的锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">3.</span> <span class="nav-text">WaitGroup：协同等待，任务编排利器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#WaitGroup%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">WaitGroup基本用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WaitGroup%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.</span> <span class="nav-text">WaitGroup数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">3.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">4.</span> <span class="nav-text">Cond</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Cond-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">Cond 的基本用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B"><span class="nav-number">4.2.</span> <span class="nav-text">案例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="nav-number">4.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">5.</span> <span class="nav-text">Once</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.1.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="nav-number">5.2.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">6.</span> <span class="nav-text">Pool</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">6.0.1.</span> <span class="nav-text">注意点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="nav-number">6.1.</span> <span class="nav-text">方法介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A8%E8%8D%90%E7%9A%84%E4%B8%89%E6%96%B9pool"><span class="nav-number">6.2.</span> <span class="nav-text">推荐的三方pool</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pool%E5%8F%AF%E8%83%BD%E9%80%A0%E6%88%90%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">6.3.</span> <span class="nav-text">pool可能造成的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="nav-number">6.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">7.</span> <span class="nav-text">Context：信息穿透上下文</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#context%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">7.1.</span> <span class="nav-text">context使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#context-%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">7.2.</span> <span class="nav-text">context 接口函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EContext%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BA%A6%E5%AE%9A%E8%A7%84%E5%AE%9A"><span class="nav-number">7.3.</span> <span class="nav-text">关于Context的一些约定规定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">7.4.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">8.</span> <span class="nav-text">atomic 原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#atomic-%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">8.1.</span> <span class="nav-text">atomic 提供的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Add"><span class="nav-number">8.2.</span> <span class="nav-text">Add</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Swap"><span class="nav-number">8.3.</span> <span class="nav-text">Swap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Load"><span class="nav-number">8.4.</span> <span class="nav-text">Load</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Store"><span class="nav-number">8.5.</span> <span class="nav-text">Store</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Value-%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.6.</span> <span class="nav-text">Value 类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">9.</span> <span class="nav-text">Channel：解决并发问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">9.1.</span> <span class="nav-text">Channel 的应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#channel-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">9.2.</span> <span class="nav-text">channel 基本用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Echannel%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">9.3.</span> <span class="nav-text">关于channel的选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chan-%E7%9A%84%E7%BC%96%E6%8E%92%E6%96%B9%E5%BC%8F"><span class="nav-number">9.4.</span> <span class="nav-text">chan 的编排方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Or-Done-%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.4.1.</span> <span class="nav-text">Or-Done 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%87%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.4.2.</span> <span class="nav-text">扇入模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%87%E5%87%BA%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.4.3.</span> <span class="nav-text">扇出模式</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Luenci"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Luenci</p>
  <div class="site-description" itemprop="description">Debug Myself</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">122</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">88</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Lucareful" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Lucareful" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/Luenci379" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;Luenci379" rel="noopener" target="_blank"><i class="fab fa-c fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/lu-er-ye-70-61/activities" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;lu-er-ye-70-61&#x2F;activities" rel="noopener" target="_blank"><i class="fa fa-zhihu fa-fw"></i>知乎</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lucarful@gmail.com" title="E-Mail → mailto:lucarful@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://hexo.io/" title="https:&#x2F;&#x2F;hexo.io" rel="noopener" target="_blank">Hexo</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://theme-next.js.org/" title="https:&#x2F;&#x2F;theme-next.js.org&#x2F;" rel="noopener" target="_blank">NexT</a>
        </li>
    </ul>
  </div>

  <div class="links-of-recent-posts motion-element">
    <div class="links-of-recent-posts-title">
      <i class="fa fa-history fa-fw"></i>
      最近文章
    </div>
    <ul class="links-of-recent-posts-list">
        <li class="links-of-recent-posts-item">
          <a href="/2023/03/01/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/" title="2023&#x2F;03&#x2F;01&#x2F;鸭子类型&#x2F;">鸭子类型介绍</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/2023/03/01/%E5%88%86%E5%B8%83%E5%BC%8F12%E9%97%AE/" title="2023&#x2F;03&#x2F;01&#x2F;分布式12问&#x2F;">分布式12问</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/2023/03/01/%E8%81%8A%E8%81%8A%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%20OpenTracing/" title="2023&#x2F;03&#x2F;01&#x2F;聊聊链路追踪 OpenTracing&#x2F;">聊聊链路追踪 OpenTracing</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/2023/03/01/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%92%8C%E7%83%AD%E6%9B%B4%E6%96%B0/" title="2023&#x2F;03&#x2F;01&#x2F;配置中心和热更新&#x2F;">服务配置和热更新</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/2023/03/01/%E6%B5%85%E6%9E%90%20Golang,make,new,=,var%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F/" title="2023&#x2F;03&#x2F;01&#x2F;浅析 Golang,make,new,&#x3D;,var声明变量&#x2F;">Go 变量声明指南</a>
        </li>
    </ul>
  </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Luenci</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">283k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">17:08</span>
</div>

<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt = new Date("08/9/2018 17:38:00"); //在此处修改你的建站时间
        now.setTime(now.getTime() + 250);
        days = (now - grt) / 1000 / 60 / 60 / 24;
        dnum = Math.floor(days);
        hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
        hnum = Math.floor(hours);
        if (String(hnum).length == 1) {
            hnum = "0" + hnum;
        }
        minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
        mnum = Math.floor(minutes);
        if (String(mnum).length == 1) {
            mnum = "0" + mnum;
        }
        seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
        snum = Math.round(seconds);
        if (String(snum).length == 1) {
            snum = "0" + snum;
        }
        document.getElementById("timeDate").innerHTML =
            "本站已运行 " + dnum + " 天 ";
        document.getElementById("times").innerHTML =
            hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
    setInterval("createtime()", 250);
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        访客数：<span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        阅读量：<span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="[object Object]"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '1yc5oJblYhuDOVUJ71pHwrTW-gzGzoHsz',
      appKey     : 'yOAm4FuYux7D9hI5MOGRvqDw',
      placeholder: "请在此输入您的留言",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

  
  

  <script async src="/js/cursor/firework.js"></script>

</body>
</html>
