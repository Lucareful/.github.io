<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Golang的goroutine模型概述和调度 | Luenci</title>
<meta name="keywords" content="GPM调度器">
<meta name="description" content="G-P-M 模型概述

每一个OS线程都有一个固定大小的内存块(一般会是2MB)来做栈，这个栈会用来存储当前正在被调用或挂起(指在调用其它函数时)的函数的内部变量。
这个固定大小的栈同时很大又很小。因为2MB的栈对于一个小小的Goroutine来说是很大的内存浪费，而对于一些复杂的任务（如深度嵌套的递归）来说又显得太小。因此，Go语言做了它自己的『线程』。
在Go语言中，每一个Goroutine是一个独立的执行单元，相较于每个OS线程固定分配2M内存的模式，Goroutine的栈采取了动态扩容方式， 初始时仅为2KB，随着任务执行按需增长，最大可达1GB（64位机器最大是1G，32位机器最大是256M），且完全由Golang自己的调度器 Go Scheduler 来调度。
此外，GC还会周期性地将不再使用的内存回收，收缩栈空间。 因此，Go程序可以同时并发成千上万个Goroutine是得益于它强劲的调度器和高效的内存模型。


任何用户线程最终肯定都是要交由OS线程来执行

​    Goroutine（称为G）也不例外，但是G并不直接绑定OS线程运行，而是由Goroutine Scheduler中的 P - Logical Processor （逻辑处理器）来作为两者的『中介』。
P 可以看作是一个抽象的资源或者一个上下文，一个P绑定一个OS线程，在Golang的实现里把OS线程抽象成一个数据结构。
M，G实际上是由M通过P来进行调度运行的，但是在G的层面来看，P提供了G运行所需的一切资源和环境，因此在G看来P就是运行它的 “CPU”，由 G、P、M 这三种由Go抽象出来的实现，最终形成了Go调度器的基本结构：
G: Goroutine


G有以下状态


非GC状态

idle:_Gidle for idle，意思是这个goroutine刚被创建出来，还未被进行初始化。
runnable: _Grunnable for runnable意思是这个goroutine已经在运行队列，在这种情况下，goroutine还未执行用户代码，M的执行栈还不是goroutine自己的
running: _Grunning for running，意思是goroutine可能正在执行用户代码，M的执行栈已经由该goroutine所拥有，此时对象g不在运行队列中。这个状态值要待分配给M和P之后，交由M和P来设定
syscall, waiting, dead, copystack



对应的GC状态

scan, scanrunnable, scan running, scansyscall, scanwaiting
_Gscan系列，用于标记正在被GC扫描的状态，这些状态是由_Gscan=0x1000再加上_GRunnable, _Grunning, _Gsyscall和_Gwaiting的枚举值所产生的，这么做的好处是直接通过简单的运算即可知道被Scan之前的状态。当被标记为这系列的状态时，这些goroutine都不会执行用户代码，并且它们的执行栈都是被做该GC的goroutine所拥有。不过_Gscanrunning状态有点特别，这个标记是为了阻止正在运行的goroutine切换成其它状态，并告诉这个G自己扫描自己的堆栈。正是这种巧妙的方式，使得Go语言的GC十分高效。





每个Goroutine对应一个G结构体，G 存储 Goroutine的运行堆栈、状态以及任务函数，可重用。


G并非执行体，每个G需要绑定到P才能被调度执行。


P: Processor

表示逻辑处理器， 对G来说，P相当于CPU核，G只有绑定到P(在P的local run中)才能被调度。对M来说，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，P的数量决定了系统内最大可并行的G的数量（前提：物理CPU核数 &gt;= P的数量），P的数量由用户设置的GoMAXPROCS决定，但是不论GoMAXPROCS设置为多大，P的数量最大为256。
golang runtime是有个sysmon的协程，他会轮询的检测所有的P上下文队列，**只要 G-M 的线程长时间在阻塞状态，那么就重新创建一个线程去从runtime P队列里获取任务。先前的阻塞的线程会被游离出去了，当他完成阻塞操作后会触发相关的callback回调，并加入回线程组里。**简单说，如果你没有特意配置runtime.SetMaxThreads，那么在没有可复用的线程的情况下，会一直创建新线程。

M: Machine
​    OS线程抽象，代表着真正执行计算的资源。


在绑定有效的P后，进入schedule循环；而schedule循环的机制大致是从Global队列、P的Local队列以及wait队列中获取G，切换到G的执行栈上并执行G的函数，调用Goexit做清理工作并回到M，如此反复。


M并不保留G状态，这是G可以跨M调度的基础，M的数量是不定的，由Go Runtime调整，为了防止创建过多OS线程导致系统调度不过来，目前默认最大限制为10000个。


在绝大多数时候，其实P的数量和M的数量是相等。 每创建一个p, 就会创建一个对应的M只有少数情况下，M的数量会大于P


work-stealing 的调度算法

每个P维护一个G的本地队列；
当一个G被创建出来，或者变为可执行状态时，就把他放到P的可执行队列中；
当一个G在M里执行结束后，P会从队列中把该G取出；如果此时P的队列为空，即没有其他G可以执行， M就随机选择另外一个P，从其可执行的G队列中取走一半。


">
<meta name="author" content="Luenci">
<link rel="canonical" href="http://localhost:1313/articles/1/01/golang%E7%9A%84goroutine%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0%E5%92%8C%E8%B0%83%E5%BA%A6/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.54405a410796490bc874ab6181fac9b675753cc2b91375d8f882566459eca428.css" integrity="sha256-VEBaQQeWSQvIdKthgfrJtnV1PMK5E3XY&#43;IJWZFnspCg=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/articles/1/01/golang%E7%9A%84goroutine%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0%E5%92%8C%E8%B0%83%E5%BA%A6/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Luenci (Alt + H)">Luenci</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/index.xml" title="RSS Feed">
                    <span>RSS Feed</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Golang的goroutine模型概述和调度
    </h1>
    <div class="post-meta">Luenci

</div>
  </header> 
  <div class="post-content"><h1 id="g-p-m-模型概述">G-P-M 模型概述<a hidden class="anchor" aria-hidden="true" href="#g-p-m-模型概述">#</a></h1>
<ul>
<li>每一个OS线程都有一个固定大小的内存块(一般会是<code>2MB</code>)来做栈，这个栈会用来存储当前正在被调用或挂起(指在调用其它函数时)的函数的内部变量。</li>
<li>这个固定大小的栈同时很大又很小。因为<code>2MB</code>的栈对于一个小小的<code>Goroutine</code>来说是很大的内存浪费，而对于一些复杂的任务（如深度嵌套的递归）来说又显得太小。因此，Go语言做了它自己的『线程』。</li>
<li>在Go语言中，每一个Goroutine是一个独立的执行单元，相较于每个OS线程固定分配<code>2M</code>内存的模式，Goroutine的栈采取了动态扩容方式， <strong>初始时仅为<code>2KB</code></strong>，随着任务执行按需增长，最大可达<code>1GB</code>（64位机器最大是<code>1G</code>，32位机器最大是<code>256M</code>），且完全由Golang自己的调度器 Go Scheduler 来调度。</li>
<li>此外，<code>GC</code>还会周期性地将不再使用的内存回收，收缩栈空间。 因此，Go程序可以同时并发成千上万个Goroutine是得益于它<strong>强劲的调度器和高效的内存模型</strong>。</li>
</ul>
<blockquote>
<p><strong>任何用户线程最终肯定都是要交由OS线程来执行</strong></p>
</blockquote>
<p>​    Goroutine（称为G）也不例外，但是G并不直接绑定OS线程运行，而是由Goroutine Scheduler中的 <code>P - Logical Processor </code>（逻辑处理器）来作为两者的<code>『中介』</code>。</p>
<p>P 可以看作是一个抽象的资源或者一个上下文，一个P绑定一个OS线程，在Golang的实现里把OS线程抽象成一个数据结构。</p>
<p><strong>M，G实际上是由M通过P来进行调度运行的</strong>，但是在G的层面来看，<strong>P提供了G运行所需的一切资源和环境</strong>，因此在G看来P就是运行它的 “CPU”，由 G、P、M 这三种由Go抽象出来的实现，最终形成了Go调度器的基本结构：</p>
<h2 id="g-goroutine">G: Goroutine<a hidden class="anchor" aria-hidden="true" href="#g-goroutine">#</a></h2>
<ul>
<li>
<p>G有以下状态</p>
<ul>
<li>
<p>非<code>GC</code>状态</p>
<ul>
<li><code>idle</code>:<code>_Gidle for idle</code>，意思是这个goroutine刚被创建出来，还未被进行初始化。</li>
<li><code>runnable</code>: <code>_Grunnable for runnable</code>意思是这个goroutine已经在运行队列，在这种情况下，goroutine还未执行用户代码，M的执行栈还不是goroutine自己的</li>
<li><code>running</code>: <code>_Grunning for running</code>，意思是goroutine可能正在执行用户代码，M的执行栈已经由该goroutine所拥有，此时对象g不在运行队列中。这个状态值要待分配给M和P之后，交由M和P来设定</li>
<li><code>syscall</code>, <code>waiting</code>, <code>dead</code>, <code>copystack</code></li>
</ul>
</li>
<li>
<p>对应的<code>GC</code>状态</p>
<ul>
<li><code>scan</code>, <code>scanrunnable</code>, <code>scan running</code>, <code>scansyscall</code>, <code>scanwaiting</code></li>
<li><code>_Gscan</code>系列，用于标记正在被<code>GC</code>扫描的状态，这些状态是由<code>_Gscan=0x1000</code>再加上<code>_GRunnable</code>, <code>_Grunning</code>, <code>_Gsyscall</code>和<code>_Gwaiting</code>的枚举值所产生的，这么做的好处是直接通过简单的运算即可知道被Scan之前的状态。当被标记为这系列的状态时，这些<code>goroutine</code>都不会执行用户代码，并且它们的执行栈都是被做该<code>GC</code>的<code>goroutine</code>所拥有。不过<code>_Gscanrunning</code>状态有点特别，这个标记是为了阻止正在运行的<code>goroutine</code>切换成其它状态，并告诉这个G自己扫描自己的堆栈。正是这种巧妙的方式，使得<code>Go</code>语言的<code>GC</code>十分高效。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>每个Goroutine对应一个G结构体，G 存储 Goroutine的运行堆栈、状态以及任务函数，可重用。</p>
</li>
<li>
<p>G并非执行体，每个G需要绑定到P才能被调度执行。</p>
</li>
</ul>
<h2 id="p-processor">P: Processor<a hidden class="anchor" aria-hidden="true" href="#p-processor">#</a></h2>
<ul>
<li>表示逻辑处理器， 对G来说，P相当于CPU核，G只有绑定到P(<code>在P的local run中</code>)才能被调度。对M来说，<code>P</code>提供了相关的执行环境(<code>Context</code>)，如内存分配状态(<code>mcache</code>)，任务队列(<code>G</code>)等，<strong>P的数量决定了系统内最大可并行的G的数量（前提：物理CPU核数 &gt;= P的数量），P的数量由用户设置的<code>GoMAXPROCS</code>决定，但是不论<code>GoMAXPROCS</code>设置为多大，P的数量最大为256</strong>。</li>
<li><code>golang runtime</code>是有个<code>sysmon</code>的协程，他会轮询的检测所有的<code>P上下文队列</code>，**只要 G-M 的线程长时间在阻塞状态，那么就重新创建一个线程去从runtime P队列里获取任务。先前的阻塞的线程会被游离出去了，当他完成阻塞操作后会触发相关的callback回调，并加入回线程组里。**简单说，如果你没有特意配置<code>runtime.SetMaxThreads</code>，那么在没有可复用的线程的情况下，会一直创建新线程。</li>
</ul>
<h2 id="m-machine">M: Machine<a hidden class="anchor" aria-hidden="true" href="#m-machine">#</a></h2>
<p>​    OS线程抽象，<strong>代表着真正执行计算的资源</strong>。</p>
<ul>
<li>
<p>在绑定有效的P后，进入schedule循环；而schedule循环的机制大致是从Global队列、P的Local队列以及wait队列中获取G，切换到G的执行栈上并执行G的函数，调用<code>Goexit</code>做清理工作并回到M，如此反复。</p>
</li>
<li>
<p>M并不保留G状态，这是G可以跨M调度的基础，M的数量是不定的，由Go Runtime调整，为了防止创建过多OS线程导致系统调度不过来，目前默认最大限制为10000个。</p>
</li>
<li>
<p>在绝大多数时候，其实<code>P</code>的数量和<code>M</code>的数量是相等。 每创建一个<code>p</code>, 就会创建一个对应的<code>M</code>只有少数情况下，<code>M</code>的数量会大于<code>P</code></p>
</li>
</ul>
<h1 id="work-stealinghttpssupertechcsailmitedupapersstealpdf-的调度算法"><em><a href="https://supertech.csail.mit.edu/papers/steal.pdf">work-stealing</a></em> 的调度算法<a hidden class="anchor" aria-hidden="true" href="#work-stealinghttpssupertechcsailmitedupapersstealpdf-的调度算法">#</a></h1>
<ul>
<li>每个P维护一个G的本地队列；</li>
<li>当一个G被创建出来，或者变为可执行状态时，就把他放到P的可执行队列中；</li>
<li>当一个G在M里执行结束后，P会从队列中把该G取出；如果此时P的队列为空，即没有其他G可以执行， M就随机选择另外一个P，从其可执行的G队列中取走一半。</li>
</ul>
<p><img loading="lazy" src="https://gitee.com/luenci/RepoImg/raw/master/img/202108091238404.png" alt="image-20210809113044316"  />
</p>
<h1 id="g-p-m-模型调度">G-P-M 模型调度<a hidden class="anchor" aria-hidden="true" href="#g-p-m-模型调度">#</a></h1>
<p>​    Go调度器工作时会维护两种用来保存G的任务队列：</p>
<ul>
<li>一种是一个Global任务队列</li>
<li>一种是每个P维护的Local任务队列</li>
</ul>
<p>当通过Go关键字创建一个新的Goroutine的时候，它会优先被放入P的本地队列。</p>
<p>​    为了运Goroutine，M需要持有（绑定）一个P，接着M会启动一个OS线程，循环从P的本地队列里取出一个Goroutine并执行。</p>
<p>当然还有上文提及的 work-stealing调度算法:</p>
<p>​    当M执行完了当前P的Local队列里的所有G后，P也不会就这么在那躺尸啥都不干，它会<strong>先尝试从Global队列寻找G</strong>来执行，如果Global队列为空，它会随机挑选另外一个P，从它的队列里中拿走一半的G到自己的队列中执行。</p>
<h2 id="用户态阻塞唤醒"><strong>用户态阻塞/唤醒</strong><a hidden class="anchor" aria-hidden="true" href="#用户态阻塞唤醒">#</a></h2>
<p>​    当<code>Goroutine</code>因为<code>channel</code>操作或者<code>network I/O</code>而阻塞时（实际上<code>Golang</code>已经用<code>netpoller</code>实现了<code>Goroutine</code>网络<code>I/O</code>阻塞不会导致<code>M</code>被阻塞，仅阻塞<code>G</code>，这里仅仅是举个栗子），对应的<code>G</code>会被放置到某个<code>wait</code>队列(如<code>channel</code>的<code>waitq</code>)，该G的状态由<code>_Gruning</code>变为<code>_Gwaitting</code>，而M会跳过该G尝试获取并执行下一个G，如果此时没有<code>runnable</code>的<code>G</code>供<code>M</code>运行，那么M将解绑P，并进入<code>sleep</code>状态；</p>
<p>当阻塞的<code>G</code>被另一端的<code>G2</code>唤醒时（比如<code>channel</code>的可读/写通知），G被标记为<code>runnable</code>，尝试加入<code>G2</code>所在P的<code>runnext</code>，然后再是P的<code>Local</code>队列和<code>Global</code>队列。</p>
<h2 id="系统调用阻塞">系统调用阻塞<a hidden class="anchor" aria-hidden="true" href="#系统调用阻塞">#</a></h2>
<p>​    当G被阻塞在某个系统调用上时，此时G会阻塞在<code>_Gsyscall</code>状态，M也处于 <code>block on syscall</code> 状态，此时的M可被抢占调度：执行该G的M会与P解绑，而<code>P</code>则尝试与其它<code>idle</code>的M绑定，继续执行其它<code>G</code>。</p>
<p>​    如果没有其它<code>idle</code>的M，但<code>P</code>的<code>Local</code>队列中仍然有<code>G</code>需要执行，则创建一个新的M；当系统调用完成后，<code>G</code>会重新尝试获取一个<code>idle</code>的<code>P</code>进入它的<code>Local</code>队列恢复执行，如果没有<code>idle</code>的<code>P</code>，<code>G</code>会被标记为<code>runnable</code>加入到<code>Global</code>队列。</p>
<h2 id="管理协程">管理协程<a hidden class="anchor" aria-hidden="true" href="#管理协程">#</a></h2>
<p>​    上面说到go语言自己定义一个结构体，叫协程。自己在用户态控制多个协程（结构体）的调度和执行，那它是怎么实现的呢？</p>
<ul>
<li>
<p>go引入了P(Processor)的概念。一个P表示一个逻辑处理器，用于调度G。称之为逻辑处理器，一般与物理处理器对应</p>
</li>
<li>
<p>M(Machine)，可以理解成一个线程，真正执行P的线程。</p>
</li>
</ul>
<p>G、P、M之间的关系如下图：</p>
<p><img loading="lazy" src="https://gitee.com/luenci/RepoImg/raw/master/img/202108091238161.png" alt="image-20210809113107322"  />
</p>
<p>每一个P都有一个对应的G队列，P绑定了线程<code>M0</code>正在执行协程<code>G0</code>，当遇到阻塞事件的时候，runtime会为P绑定一个新的线程<code>M1</code>，执行新的新的线程</p>
<h1 id="参考链接">参考链接<a hidden class="anchor" aria-hidden="true" href="#参考链接">#</a></h1>
<blockquote>
<p><a href="https://juejin.cn/post/6927264515193045000#heading-10">Go协程管理</a></p>
<p><a href="https://segmentfault.com/a/1190000022871460">Go 调度模型 GPM</a></p>
</blockquote>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/gpm%E8%B0%83%E5%BA%A6%E5%99%A8/">GPM调度器</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:1313/">Luenci</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
