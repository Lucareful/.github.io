<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>python解释器的GIL锁 | Luenci</title>
<meta name="keywords" content="GIL锁">
<meta name="description" content="GlL锁定义 Gll锁：Global Interpreter Lock，又称：全局解释器锁 任何Python线程执行前，必须先获得GlL锁，然后，每执行100条字节码，解释器就自动释放GL锁，让别的线程有机会执行。这个GlL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。 GlL不是Python特性 GlL是Pythn解释器（Cpyth">
<meta name="author" content="Luenci">
<link rel="canonical" href="http://localhost:1313/articles/1/01/python%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84gil%E9%94%81/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.54405a410796490bc874ab6181fac9b675753cc2b91375d8f882566459eca428.css" integrity="sha256-VEBaQQeWSQvIdKthgfrJtnV1PMK5E3XY&#43;IJWZFnspCg=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/articles/1/01/python%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84gil%E9%94%81/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Luenci (Alt + H)">Luenci</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/index.xml" title="RSS Feed">
                    <span>RSS Feed</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      python解释器的GIL锁
    </h1>
    <div class="post-meta">Luenci

</div>
  </header> 
  <div class="post-content"><h2 id="gll锁定义">GlL锁定义<a hidden class="anchor" aria-hidden="true" href="#gll锁定义">#</a></h2>
<p>Gll锁：Global Interpreter Lock，又称：全局解释器锁</p>
<blockquote>
<p>任何Python线程执行前，必须先获得GlL锁，然后，每执行100条字节码，解释器就自动释放GL锁，让别的线程有机会执行。这个GlL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
</blockquote>
<h2 id="gll不是python特性">GlL不是Python特性<a hidden class="anchor" aria-hidden="true" href="#gll不是python特性">#</a></h2>
<p>GlL是Pythn解释器（Cpython）时引入的概念，在JPython、PyPy中没有GlL。GIL并不是Python的语言缺陷。是解释器层级的锁，跟Python语言特性无关</p>
<blockquote>
<p>言外之意，就是全局解释器就是为了锁定整个解释器内部的全局资源，每个线程想要运行首先获取GlL，而GlL本身又是一把互斥锁，造成所有线程只能一个一个one-by-one-并发-交替的执行。</p>
</blockquote>
<h2 id="gll存在的原因">GlL存在的原因<a hidden class="anchor" aria-hidden="true" href="#gll存在的原因">#</a></h2>
<ul>
<li>
<p>早期计算机都是单核设计</p>
</li>
<li>
<p>CPython在执行多线程的时候并不是线程安全的，所以为了程序的稳定性，加一把全局解释锁，能够确保任何时候都只有一个Python线程执行</p>
</li>
</ul>
<blockquote>
<p>GlL产生的背景在CPython解释内部运行多个线程的时候，每个线程都需要解释器内部申请相应的全局资源，由于C语言本身比较底层造成CPython在管理所有全局资源的时候并不能应对所有线程同时的资源请求，因此为了防止资源竞争而发生错误，对所有线程申请全局资源增加了限制-全局解释器锁。</p>
</blockquote>
<!-- raw HTML omitted -->
<h2 id="gll锁什么时候释放">GlL锁什么时候释放？<a hidden class="anchor" aria-hidden="true" href="#gll锁什么时候释放">#</a></h2>
<ul>
<li>在当前线程执行超时后会自动释放</li>
<li>在当前线程执行阻塞操作时会自动释放</li>
<li>当前执行完成时</li>
</ul>
<p>Guido对GIL锁的看法：https://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235</p>
<h2 id="关于gil面试题">关于GIL面试题<a hidden class="anchor" aria-hidden="true" href="#关于gil面试题">#</a></h2>
<ul>
<li>
<p>描述Python GL的概意，以及它对python多线程的影响？编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否可比单线程性能有提升，并解释原因。</p>
</li>
<li>
<p>Python语言和GlL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机（解释器），难以移除GlL。</p>
</li>
<li>
<p>GlIL：全局解释器锁。每个线程在执行的过程都需要先获取GlL，保证同一时刻只有一个线程可以执行代码。</p>
</li>
<li>
<p>线程释放GL锁的情况：</p>
<ul>
<li>在IO操作等可能会引起阻塞的system call之前，可以暂时释放GIL，但在执行完毕后，必须重新获取GlL</li>
<li>Python 3.x使用计时器（执行时间达到阔值后，当前线程释放GlL）或Python 2.x，tickets计数达到100</li>
</ul>
</li>
<li>
<p>Python使用多进程是可以利用多核的CPU资源的。</p>
</li>
<li>
<p>多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁</p>
</li>
</ul>
<blockquote>
<p>严重问题：既然CPython解释存在GL是否意味每个线程在全局变量就不用加Lock互斥锁了呢？这是一个严重错误的想法，为什么用户操作全局数据还需要加Lock，因为GlL的释放时机我们无法控制-操作非常可能并没有完成，而不像Lock那样我们用完才释放（操作完整）</p>
</blockquote>
<p>举例</p>
<blockquote>
<p>线程1取出全局变量g_number==0一直加到20000，但是还没有来得及将20000写入g_number中，就超时了自动释放GIL 而线程2取出g_number==19999加到39999由于超时自动释放GlL此时线程2获取到GIL继续着未完成的事业将20000写入g_number….这就是之前的多线程案例没有加互斥锁的情况晨终结果是140w东右的盾因</p>
</blockquote>
<h2 id="gil锁解决方案">GIL锁解决方案<a hidden class="anchor" aria-hidden="true" href="#gil锁解决方案">#</a></h2>
<h3 id="解决方案一不推荐">解决方案一（不推荐）：<a hidden class="anchor" aria-hidden="true" href="#解决方案一不推荐">#</a></h3>
<ul>
<li>我们换一个解释器执行程序就行了（jython：用JAVA写的python解释器）</li>
</ul>
<h3 id="解决方案二推荐">解决方案二（推荐）<a hidden class="anchor" aria-hidden="true" href="#解决方案二推荐">#</a></h3>
<ul>
<li>使用多进程替换多线程multiprocessing是一个多进程模块，开多个进程，每个进程都带一个GlL，就相当于多线程来用了。</li>
</ul>
<h3 id="解决方案三推荐">解决方案三（推荐）<a hidden class="anchor" aria-hidden="true" href="#解决方案三推荐">#</a></h3>
<ul>
<li>使用python语言的特性：胶水.
我们让子线程部分用c来写，就ok。（实质上也相当于那部分代码绕过了cython解释器）第一步，编写C语言文件：
测试代码，C语言写的死循环，文件名为test2.c：</li>
</ul>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">Loop</span>(){
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">while</span>(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后我们把将其编译成.so文件（share object）需要执行如下命令(Linux下)：</p>
<pre tabindex="0"><code>gcc test.c -shared -o libtets.so
</code></pre><blockquote>
<p>-shared：将其编译成so文件</p>
<p>-o：表示output，用来输出的文件名</p>
<p>库文件是以lib开头</p>
<p>编译过后，在当前的文件夹下就会生成一个.so文件</p>
</blockquote>
<p>第二步，编写python文件04-04_GIL锁解决方案.py：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> ctypes <span style="color:#ff79c6">import</span> threading
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#加载动态库</span>
</span></span><span style="display:flex;"><span>my_lib<span style="color:#ff79c6">=</span>ctypes，cdll<span style="color:#ff79c6">.</span>LoadLibrary（<span style="color:#f1fa8c">&#34;./libtest2.so&#34;</span>）
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#创建子线程</span>
</span></span><span style="display:flex;"><span>t<span style="color:#ff79c6">=</span>threading<span style="color:#ff79c6">.</span>Thread（target<span style="color:#ff79c6">=</span>my_lib<span style="color:#ff79c6">.</span>Loop）
</span></span><span style="display:flex;"><span>t<span style="color:#ff79c6">.</span>start（）
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#主线程</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">while</span> <span style="color:#ff79c6">True</span>：<span style="color:#ff79c6">pass</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>第三步，执行pvthon文件就可避开Cpython解释器的GIL锁</p>
<h3 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h3>
<ul>
<li>GIL锁称为：“全局解释器锁“，是CPytrton解释器中的锁机制，也是历史遗留问题</li>
<li>要提升多线程执行效率，解决方案：
<ul>
<li>更换解释器</li>
<li>改为进程替换多线程</li>
<li>子线程使用C语言实现（绕过GL锁）</li>
</ul>
</li>
<li>必须要知道的是：
<ul>
<li>CPU密集型不太适合多线程</li>
<li>I/O密集型适合多线程（Gil锁会释放）</li>
</ul>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/gil%E9%94%81/">GIL锁</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:1313/">Luenci</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
