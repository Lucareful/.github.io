<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Posts | Luenci</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - Luenci">
<meta name="author" content="Luenci">
<link rel="canonical" href="http://localhost:1313/articles/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.54405a410796490bc874ab6181fac9b675753cc2b91375d8f882566459eca428.css" integrity="sha256-VEBaQQeWSQvIdKthgfrJtnV1PMK5E3XY&#43;IJWZFnspCg=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/articles/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/articles/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Luenci (Alt + H)">Luenci</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/index.xml" title="RSS Feed">
                    <span>RSS Feed</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">list, tuple, dictionary, set的底层细节（python）
    </h2>
  </header>
  <div class="entry-content">
    <p>list, tuple, dictionary, set的底层细节 列表实现细节 python中的列表的英文名是list，因此很容易和其它语言(C&#43;&#43;, Java等)标准库中常见的链表混淆。事实上CPython的列表根本不是列表（可能换成英文理解起来容易些：python中的list不是list）。在CPython中，列表被实现为长度可变的数组。可参考《Python高级编程（第2版）》 从细节上看，Python中的列表是由对其它对象的引用组成的连续数...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to list, tuple, dictionary, set的底层细节（python）" href="http://localhost:1313/articles/1/01/list-tuple-dictionary-set%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%86%E8%8A%82python/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">浅谈Python垃圾回收机制
    </h2>
  </header>
  <div class="entry-content">
    <p>目前垃圾回收比较通用的解决办法有三种，引用计数，标记清除以及分代回收。 引用计数 引用计数也是一种最直观，最简单的垃圾收集技术。 在 Python 中，大多数对象的生命周期都是通过对象的引用计数来管理的。 其原理非常简单，我们为每个对象维护一个 ref 的字段用来记录对象被引用的次数，每当对象被创建或者被引用时将该对象的引用次数加一，当对象的引用被销毁时该对象的引用次数减一，当对象的引用次数减到零时说明程序中已经没有任何对象持...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to 浅谈Python垃圾回收机制" href="http://localhost:1313/articles/1/01/%E6%B5%85%E8%B0%88python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Python的asyncio(协程)
    </h2>
  </header>
  <div class="entry-content">
    <p> 本文转载自:https://pythonav.com/wiki/detail/6/91/
1.协程 协程（Coroutine），也可以被称为微线程，是一种用户态内的上下文切换技术。简而言之，其实就是通过一个线程实现代码块相互切换执行。例如：
1 2 3 4 5 6 7 8 9 10 11 12 def func1(): print(1) ... print(2) def func2(): print(3) ... print(4) func1() func2() 上述代码是普通的函数定义和执行，按流程分别执行两个函数中的代码，并先后会输出：1、2、3、4。但如果介入协程技术那么就可以实现函数见代码切换执行，最终输入：1、3、2、4 。
在Python中有多种方式可以实现协程，例如：
greenlet，是一个第三方模块，用于实现协程代码（Gevent协程就是基于greenlet实现） yield，生成器，借助生成器的特点也可以实现协程代码。 asyncio，在Python3.4中引入的模块用于编写协程代码。 async &amp; awiat，在Python3.5中引入的两个关键字，结合asyncio模块可以更方便的编写协程代码。 1.1 greenlet greentlet是一个第三方模块，需要提前安装 pip3 install greenlet才能使用。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from greenlet import greenlet def func1(): print(1) # 第1步：输出 1 gr2.switch() # 第3步：切换到 func2 函数 print(2) # 第6步：输出 2 gr2.switch() # 第7步：切换到 func2 函数，从上一次执行的位置继续向后执行 def func2(): print(3) # 第4步：输出 3 gr1.switch() # 第5步：切换到 func1 函数，从上一次执行的位置继续向后执行 print(4) # 第8步：输出 4 gr1 = greenlet(func1) gr2 = greenlet(func2) gr1.switch() # 第1步：去执行 func1 函数 注意：switch中也可以传递参数用于在切换执行时相互传递值。
1.2 yield 基于Python的生成器的yield和yield form关键字实现协程代码。
1 2 3 4 5 6 7 8 9 10 11 12 def func1(): yield 1 yield from func2() yield 2 def func2(): yield 3 yield 4 f1 = func1() for item in f1: print(item) 注意：yield form关键字是在Python3.3中引入的。
1.3 asyncio 在Python3.4之前官方未提供协程的类库，一般大家都是使用greenlet等其他来实现。在Python3.4发布后官方正式支持协程，即：asyncio模块。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import asyncio @asyncio.coroutine def func1(): print(1) yield from asyncio.sleep(2) # 遇到IO耗时操作，自动化切换到tasks中的其他任务 print(2) @asyncio.coroutine def func2(): print(3) yield from asyncio.sleep(2) # 遇到IO耗时操作，自动化切换到tasks中的其他任务 print(4) tasks = [asyncio.ensure_future( func1() ), asyncio.ensure_future( func2() )] loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks)) 注意：基于asyncio模块实现的协程比之前的要更厉害，因为他的内部还集成了遇到IO耗时操作自动切花的功能。
1.4 async &amp; awit async &amp; awit 关键字在Python3.5版本中正式引入，基于他编写的协程代码其实就是 上一示例 的加强版，让代码可以更加简便。
Python3.8之后 @asyncio.coroutine 装饰器就会被移除，推荐使用async &amp; awit 关键字实现协程代码。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 import asyncio async def func1(): print(1) await asyncio.sleep(2) print(2) async def func2(): print(3) await asyncio.sleep(2) print(4) tasks = [ asyncio.ensure_future(func1()), asyncio.ensure_future(func2())] loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks)) 1.5 小结 关于协程有多种实现方式，目前主流使用是Python官方推荐的asyncio模块和async&amp;await关键字的方式，例如：在tonado、sanic、fastapi、django3 中均已支持。
接下来，我们也会针对 asyncio模块 &#43; async &amp; await 关键字进行更加详细的讲解。
...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to Python的asyncio(协程)" href="http://localhost:1313/articles/1/01/python%E7%9A%84asyncio%E5%8D%8F%E7%A8%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">回溯算法和LRU
    </h2>
  </header>
  <div class="entry-content">
    <p>回溯算法实现（DFS） 回溯算法其实就是我们常说的 DFS 算法，本质上就是一种暴力穷举算法 递归遍历二叉树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def back_track(nums, track, res): # 结束条件 if len(nums)== len(track): # res.extend(track) # 正常 res.append(track)# 不正常 return None # 遍历选择列表 for num in nums: if num in track: continue track.append(num) back_track(nums, track.copy(), res) track.pop() return None if __name__ == &#39;__main__&#39;: nums =[1, 2, 3] track =[] res =[] back_track(nums, track, res) print(res) 某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to 回溯算法和LRU" href="http://localhost:1313/articles/1/01/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%92%8Clru/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Django的logger配置
    </h2>
  </header>
  <div class="entry-content">
    <p>Django日志配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 LOGGING = { &#39;version&#39;: 1, &#39;disable_existing_loggers&#39;: False, &#39;formatters&#39;: { &#39;verbose&#39;: { &#39;format&#39;: &#39;%(levelname)s %(asctime)s %(pathname)s %(module)s %(lineno)s %(process)d %(thread)d %(message)s&#39; } }, &#39;loggers&#39;: { &#39;django&#39;: { &#39;handlers&#39;: [&#39;default&#39;], &#39;propagate&#39;: True, &#39;level&#39;: &#39;DEBUG&#39;, &#39;filters&#39;: [&#39;special&#39;] } }, &#39;handlers&#39;: { &#39;default&#39;: { &#39;level&#39;: &#39;DEBUG&#39;, &#39;class&#39;: &#39;logging.handlers.RotatingFileHandler&#39;, &#39;filename&#39;: &#39;/var/logs/django/default.log&#39;, &#39;maxBytes&#39;: 1024 * 1024 * 5, &#39;backupCount&#39;: 5, &#39;formatter&#39;: &#39;verbose&#39;, &#39;filters&#39;: [&#39;special&#39;] } }, &#39;filters&#39;: { # 过滤器 &#39;special&#39;: { # 使用自定义的web.my_logging.ContextFilter，别名special，可以接受其他的参数 &#39;()&#39;: &#39;web.my_logging.ContextFilter&#39; } }, } 配置分析说明 version 保留字。
disable_existing_loggers 是否禁用已经存在的logger实例。
如果LOGGING 中的disable_existing_loggers 键为True（默认值），那么默认配置中的所有logger 都将禁用。
Logger 的禁用与删除不同；logger 仍然存在，但是将默默丢弃任何传递给它的信息，也不会传播给上一级logger。所以，你应该非常小心使用&#39;disable_existing_loggers&#39;: True；它可能不是你想要的。你可以设置disable_existing_loggers 为False，并重新定义部分或所有的默认loggers；或者你可以设置LOGGING_CONFIG 为 None，并 自己处理logging 配置。
Logging 的配置属于Django setup() 函数的一部分。所以，你可以肯定在你的项目代码中logger 是永远可用的。
formatters 定义输出的日志格式。 常用的格式化属性：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 %(name)s Logger的名字 %(levelname)s 文本形式的日志级别 %(message)s 用户输出的消息 %(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒 %(levelno)s 数字形式的日志级别 %(pathname)s 调用日志输出函数的模块的完整路径名，可能没有 %(filename)s 调用日志输出函数的模块的文件名 %(module)s 调用日志输出函数的模块名 %(funcName)s 调用日志输出函数的函数名 %(lineno)d 调用日志输出函数的语句所在的代码行 %(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示 %(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数 %(thread)d 线程ID。可能没有 %(threadName)s 线程名。可能没有 %(process)d 进程ID。可能没有 其他格式化属性请参 LogRecord attributes
...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to Django的logger配置" href="http://localhost:1313/articles/1/01/django%E7%9A%84logger%E9%85%8D%E7%BD%AE/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">鸭子类型介绍
    </h2>
  </header>
  <div class="entry-content">
    <p>鸭子类型 定义 鸭子类型（英语：duck typing）在程序设计中是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由&#34;当前方法和属性的集合“决定。这个概念的名字来源于由詹姆斯·惠特科姆·莱利提出的鸭子测试（见下面的“历史”章节），“鸭子测试”可以这样表述： ​ “当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to 鸭子类型介绍" href="http://localhost:1313/articles/1/01/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">RESTful风格
    </h2>
  </header>
  <div class="entry-content">
    <p>RESTful设计方法 原文参考自哔哩哔哩: https://www.bilibili.com/video/BV1k5411p7Kp 1. 域名 应该尽量将API部署在专用域名之下。 1 https://api.example.com 如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。 1 https://example.org/api/ 2. 版本（Versioning） 应该将API的版本号放入URL。 1 2 3 4 5 http://www.example.com/app/1.0/foo http://www.example.com/app/1.1/foo http://www.example.com/app/2.0/foo 另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。 因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to RESTful风格" href="http://localhost:1313/articles/1/01/restful%E9%A3%8E%E6%A0%BC/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">同源和跨域
    </h2>
  </header>
  <div class="entry-content">
    <p>原文:同源策略、跨域解决方案 一、同源策略 1、先来说说什么是源 • 源（origin）就是协议、域名和端口号。 以上url中的源就是：http://www.company.com:80 若地址里面的协议、域名和端口号均相同则属于同源。 以下是相对于 http://www.a.com/test/index.html 的同源检测 • http://www.a.com/dir/page.html —-成功 • http://www.child.a.com/test/index.html —-失败，域名不同 • https://www.a.com/test/index.html —-失败，协议不同 • http://www.a.com:8080/test/index.html —-失败，端口号不同 2.什么是同源策略？ 同源...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to 同源和跨域" href="http://localhost:1313/articles/1/01/%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Django信号量初探
    </h2>
  </header>
  <div class="entry-content">
    <p>django的信号量 原文链接:https://juejin.cn/post/6844903674049724424
一、关于django信号量 Django包含一个&#34;信号调度程序&#34;，它有助于在框架中的其他位置发生操作时通知分离的应用程序。简而言之，信号允许某些发送者通知一组接收器已经发生了某些动作。当许多代码可能对同一事件感兴趣时，它们特别有用.
二、django中内置的信号量 1、Model的信号量
pre_init # django的modal执行其构造方法前，自动触发
post_init # django的modal执行其构造方法后，自动触发
pre_save # django的modal对象保存前，自动触发
post_save # django的modal对象保存后，自动触发
pre_delete # django的modal对象删除前，自动触发
post_delete # django的modal对象删除后，自动触发
m2m_changed # django的modal中使用m2m字段操作第三张表（add,remove,clear）前后，自动触发
class_prepared # 程序启动时，检测已注册的app中modal类，对于每一个类，自动触发
1 2 3 4 5 6 7 8 from django.db.models.signals import class_prepared from django.db.models.signals import pre_init from django.db.models.signals import post_init from django.db.models.signals import pre_save from django.db.models.signals import post_save from django.db.models.signals import pre_delete from django.db.models.signals import post_delete from django.db.models.signals import m2m_changed 2、Management的信号量
pre_migrate # 执行migrate命令前，自动触发
post_migrate # 执行migrate命令后，自动触发
1 2 from django.db.models.signals import pre_migrate from django.db.models.signals import post_migrate 3、Request/Response的信号量
request_started # 请求到来前，自动触发
request_finished # 请求结束后，自动触发
got_request_exception # 请求异常后，自动触发
1 2 3 from django.core.signals import request_finished from django.core.signals import request_started from django.core.signals import got_request_exception 4、Test的信号量
setting_changed # 使用test测试修改配置文件时，自动触发
template_rendered # 使用test测试渲染模板时，自动触发
1 2 from django.test.signals import setting_changed from django.test.signals import template_rendered 5、Database的信号量
connection_created # 创建数据库连接时，自动触发
1 from django.db.backends.signals import connection_created ...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to Django信号量初探" href="http://localhost:1313/articles/1/01/django%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%88%9D%E6%8E%A2/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">行为型模式
    </h2>
  </header>
  <div class="entry-content">
    <p>行为型模式 行为型模式，顾名思义，它主要关注的是对象的责任。
它们关注对象之间的交互以及对象的响应性 对象应该能够交互，同时仍然保持松散耦合 观察者模式 在观察者设计模式中，对象（主题）维护了一个依赖（观察者）列表，以便主题可以使用观察者定义的任何方法通知所有观察者它所发生的变化。
它定义了对象之间的一对多的依赖关系，从而使得一个对象中的任何更改都将自动通知给其他对象 它封装了主题的核心组件 UML图 主题(Subject):类Subject需要了解Observe。Subject类具有许多方法，诸如register()和deregister()等，Observer可以通过这些方法注册到Subject类中。因此，一个Subject可以处理多个Observe。 观察者(Observe)：它为关注主题的对象定义了一个接口。它定义了Observe需要实现的各个方法，以便在主题发生变化时能够获得相应的通知。 具体观察者(ConcreteObserver):它用来保存应该与Subject的状态保持一致的状态。它实现了Observe接口以保持其状态与主题中的变化相一致。 代码案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #!/usr/bin/env python # -*- coding: utf-8 -*- class Subject(object): def __init__(self): self.__observer = [] def register(self, observer): self.__observer.append(observer) def notifyAll(self, *args, **kwargs): for observer in self.__observer: observer.notify(self, *args, **kwargs) class Observer1(object): def __init__(self, subject): subject.register(self) def notify(self, subject, *args): print(f&#34;{type(self).__name__}:: Got, {args} from {subject}&#34;) class Observer2(object): def __init__(self, subject): subject.register(self) def notify(self, subject, *args): print(f&#34;{type(self).__name__}:: Got, {args} from {subject}&#34;) if __name__ == &#39;__main__&#39;: subject = Subject() observer1 = Observer1(subject) observer2 = Observer2(subject) subject.notifyAll(&#34;notify~~~&#34;) 观察者模式的优点和缺点 优点：
它使得彼此交互的对象之间保持送耦合 它使得我们可以在无需对主题或观察者进行任何修改的情况下高效地发送数据到其他对象 可以随时添加/删除观察者 缺点：
观察者接口必须由具体观察者实现，这涉及继承。无法进行组合，因为观察者接口可以实例化 如果实现不当的话，观察者可能会增加复杂性，并导致性能降低 在软件应用程序中，通知有时可能是不可靠的，并导致竞争条件或不一致性 ...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to 行为型模式" href="http://localhost:1313/articles/1/01/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="http://localhost:1313/articles/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:1313/">Luenci</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
