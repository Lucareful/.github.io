<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Posts | Luenci</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - Luenci">
<meta name="author" content="Luenci">
<link rel="canonical" href="http://localhost:1313/articles/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.54405a410796490bc874ab6181fac9b675753cc2b91375d8f882566459eca428.css" integrity="sha256-VEBaQQeWSQvIdKthgfrJtnV1PMK5E3XY&#43;IJWZFnspCg=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/articles/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/articles/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Luenci (Alt + H)">Luenci</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/index.xml" title="RSS Feed">
                    <span>RSS Feed</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Giweights 介绍
    </h2>
  </header>
  <div class="entry-content">
    <p>Giweights 介绍 https://icloudnative.io/posts/what-is-giweights/
基础设施即代码 在理解 Giweights 之前，我们需要先理解什么是基础设施即代码。
基础设施即代码（Infrastructure as Code, IaC），顾名思义，表示使用代码（而非手动流程）来定义基础设施，研发人员可以像对待应用软件一样对待基础设施，例如：
可以创建包含基础架构规范的声明式配置文件，从而便于编辑和分发配置。 可以确保每次配置的环境都完全相同。 可以进行版本控制，所有的变更都会被记录下来，方便溯源。 可以将基础设施划分为若干个模块化组件，并通过自动化以不同的方式进行组合。 当然，广义上的 IaC 不仅仅只关于基础设施，还包含了网络、安全、配置等等，所以广义上的 IaC 又叫 X as Code。
​	比如你想在 AWS 中创建服务器，配置网络，部署 Kubernetes 集群以及各种工作负载，你只需要定义好 Terraform 或 Ansible 的声明式配置，以及 Kubernetes 的配置清单即可，免去一切繁杂的手动操作。
Giweights 是什么 ​	Giweights = IaC &#43; Git &#43; CI/CD，即基于 IaC 的版本化 CI/CD。它的核心是使用 Git 仓库来管理基础设施和应用的配置，并且以 Git 仓库作为基础设施和应用的单一事实来源，你从其他地方修改配置（比如手动改线上配置）一概不予通过。
​	Git 仓库中的声明式配置描述了目标环境当前所需基础设施的期望状态，借助于 Giweights，如果集群的实际状态与 Git 仓库中定义的期望状态不匹配，Kubernetes reconcilers 会根据期望状态来调整当前的状态，最终使实际状态符合期望状态。
​	另一方面，现代应用的开发更多关注的是迭代速度和规模，拥有成熟 DevOps 文化的组织每天可以将代码部署到生成环境中数百次，DevOps 团队可以通过版本控制、代码审查以及自动测试和部署的 CI/CD 流水线等最佳实践来实现这一目标，这就是 Giweights 干的事情。
Giweights vs DevOps ​	从广义上来看，Giweights 与 DevOps 并不冲突，Giweights 是一种技术手段，而 DevOps 是一种文化。Giweights 是一种实现持续交付（Continuous Delivery）、持续部署（Continuous Deployment）和基础设施即代码（IaC）的工具和框架，它是支持 DevOps 文化的。
从狭义上来看，Giweights 与 DevOps 有以下几个区别：
​	首先，Giweights 是以目标为导向的。它使用 Git 来维护期望状态，并不断调整实际状态，最终与期望状态相匹配。而 DevOps 更多关注的是最佳实践，这些实践可以普遍应用于企业的每一个流程。
​	其次，Giweights 采取声明式的操作方法，而 DevOps 同时接受声明式和命令式的方法，所以 DevOps 除了适用于容器环境之外，还适用于虚拟机和裸机环境。
​	最后，Giweights 重新定义了云原生场景下的 CI/CD，它以 Git 作为中心的不可变状态声明，以加快持续部署速度。
...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to Giweights 介绍" href="http://localhost:1313/articles/1/01/giweights-%E4%BB%8B%E7%BB%8D/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Linux 网络模型
    </h2>
  </header>
  <div class="entry-content">
    <p>linux 网络模型 概念说明 在进行解释之前，首先要说明几个概念：
用户空间和内核空间 进程切换 进程的阻塞 文件描述符 缓存 I/O 用户空间与内核空间 ​	现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。
​	针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间。
而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。
进程切换 ​	为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。
从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：
保存处理机上下文，包括程序计数器和其他寄存器。 更新PCB信息。 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。 选择另一个进程执行，并更新其PCB。 更新内存管理的数据结构。 恢复处理机上下文。 总而言之就是很耗资源，具体的可以参考这篇文章：进程切换
进程的阻塞 ​	正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。
文件描述符fd ​	文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。
​	文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。
缓存 I/O ​	缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的**页缓存（ page cache ）**中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。
缓存 I/O 的缺点： 数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。
IO拷贝 DMA 负责内核间的 IO 传输，CPU 负责内核和应用间的 IO 传输。
更多详情见：一文彻底揭秘操作系统之「零拷贝」！ - 腾讯云开发者社区-腾讯云 (tencent.com)
CPU COPY ​	通过计算机的组成原理我们知道, 内存的读写操作是需要 CPU 的协调数据总线,地址总线和控制总线来完成的因此在&#34;拷贝&#34;发生的时候,往往需要 CPU 暂停现有的处理逻辑,来协助内存的读写，这种我们称为 CPU COPY。CPU COPY 不但占用了 CPU 资源,还占用了总线的带宽。
DMA COPY ​	DMA(DIRECT MEMORY ACCESS) 是现代计算机的重要功能，它有一个重要特点：当需要与外设进行数据交换时, CPU 只需要初始化这个动作便可以继续执行其他指令,剩下的数据传输的动作完全由DMA来完成可以看到 DMA COPY 是可以避免大量的 CPU 中断的
...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to Linux 网络模型" href="http://localhost:1313/articles/1/01/linux-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">CMDB 介绍
    </h2>
  </header>
  <div class="entry-content">
    <p>CMDB介绍 CMDB含义 CMDB代表配置管理数据库，通常被称为任何ITSM系统的心脏。
​	简而言之，CMDB是一个存储库，用于存储有关构成IT基础架构的组件的信息。 这些组件通常称为CI（可配置项）。 据ITIL称，CI是为交付IT服务而需要进行管理的任何资产。
通常，CMDB包括CI的列表，它们的属性以及它们之间的关系。
CMDB的核心功能之一是支持服务管理流程，主要包括：事件，问题，变更，发布和资产管理。
...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to CMDB 介绍" href="http://localhost:1313/articles/1/01/cmdb-%E4%BB%8B%E7%BB%8D/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">分布式12问
    </h2>
  </header>
  <div class="entry-content">
    <p>分布式12问 原文转载自：分布式夺命12连问 (qq.com) 分布式理论 1. 说说CAP原则？ CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）这3个基本需求，最多只能同时满足其中的2个。 CAP原则 选项 描述 Consistency（一致性） 指数据在多个副本之间能够保持一致的特性（严格的一致性） Avai...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to 分布式12问" href="http://localhost:1313/articles/1/01/%E5%88%86%E5%B8%83%E5%BC%8F12%E9%97%AE/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Tekton 入门
    </h2>
  </header>
  <div class="entry-content">
    <p>Tekton 入门 术语解释 Cloud Native ​	云原生是一种软件开发方法，其中应用程序被分解为微服务，这些微服务被打包到容器中，容器在云中动态编排以优化资源利用
Continuous Delivery ​	持续交付是一种软件开发实践，团队可以安全、快速、可持续地向用户发布软件变更。
Tekton ​	Tekton 是一个用于创建持续交付系统的开源 kubernetes 原生的框架。你可以使用 tekton 跨多个云提供商或混合环境构建，测试和部署。Tekton 通过抽象出复杂的kubenetes概念和实现细节来简化应用程序管理。它提供了用于声明持续交付管道的 Kubernetes 自定义资源。
基本构建块 其中Task、TaskRun、Pipeline、PipelineRun、PipelineResource、Condition作为其核心CRD，这里主要介绍它们。
Task： 定义构建任务，它由一系列有序steps构成。每个step可以定义输入和输出，且可以将上一个step的输出作为下一个step的输入。每个step都会由一个container来执行。
是 Tekton 中不可分割的最小单位，正如同 Pod 在 Kubernetes 中的概念一样 TaskRun： Task用于定义具体要做的事情，并不会真正的运行，而TaskRun就是真正的执行者，并且会提供执行所需需要的参数，一个TaskRun就是一个Pod。
Pipeline： 顾名思义就是流水线，它由一系列Tasks组成。就像Task中的step一样，上一个Task的输出可以作为下一个Task的输入。
PipelineRun： Pipeline的实际执行，创建后会创建Pod来执行Task，一个PipelineRun中有多个Task。
PipelineResource： 主要用于定义Pipeline的资源，常见的如Git地址、Docker镜像等。
Condition： 它主要是在Pipeline中用于判断的，Task的执行与否通过Condition的判断结果来决定。
Tips： PipelineResource和Condition都会被废弃。但是在低版本中还是会继续使用，所以这里会简单介绍一下。
...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to Tekton 入门" href="http://localhost:1313/articles/1/01/tekton-%E5%85%A5%E9%97%A8/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">GO 三方库源码阅读姿势
    </h2>
  </header>
  <div class="entry-content">
    <p>GO 三方库源码阅读姿势 参考内容：极客专栏：手把手带你写一个web框架
阅读顺序 库函数 &gt; 结构定义 &gt; 结构函数。
​	简单来说，就是当你在阅读一个代码库的时候，不应该从上到下阅读整个代码文档，而应 该先阅读整个代码库提供的对外库函数(function)，再读这个库提供的结构 (struct/class)，最后再阅读每个结构函数(method)
查看库函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 go doc net/http(三方库名称) | grep &#34;^func&#34; func CanonicalHeaderKey(s string) string func DetectContentType(data []byte) string func Error(w ResponseWriter, error string, code int) func Get(url string) (resp *Response, err error) func Handle(pattern string, handler Handler) func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) func Head(url string) (resp *Response, err error) func ListenAndServe(addr string, handler Handler) error func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser func NewRequest(method, url string, body io.Reader) (*Request, error) func NewRequestWithContext(ctx context.Context, method, url string, body io.Reader) (*Request, error) func NotFound(w ResponseWriter, r *Request) func ParseHTTPVersion(vers string) (major, minor int, ok bool) func ParseTime(text string) (t time.Time, err error) func Post(url, contentType string, body io.Reader) (resp *Response, err error) func PostForm(url string, data url.Values) (resp *Response, err error) func ProxyFromEnvironment(req *Request) (*url.URL, error) func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error) func ReadRequest(b *bufio.Reader) (*Request, error) func ReadResponse(r *bufio.Reader, req *Request) (*Response, error) func Redirect(w ResponseWriter, r *Request, url string, code int) func Serve(l net.Listener, handler Handler) error func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, ...) func ServeFile(w ResponseWriter, r *Request, name string) func ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error func SetCookie(w ResponseWriter, cookie *Cookie) func StatusText(code int) string ​	在这个库提供的方法中，我们去掉一些 New 和 Set 开头的函数，因为你从命名上可以看出，这些函数是对某个对象或者属性的设置。
剩下的函数大致可以分成三类:
为服务端提供创建 HTTP 服务的函数，名字中一般包含 Serve 字样，比如 Serve、 ServeFile、ListenAndServe 等。
为客户端提供调用 HTTP 服务的类库，以 HTTP 的 method 同名，比如 Get、Post、 Head 等。
提供中转代理的一些函数，比如 ProxyURL、ProxyFromEnvironment 等。
查看结构定义(模块) ​	我们过一遍这个库提供的所有 struct，看看核心模块有哪些，同样使用 go doc:
1 go doc net/http | grep &#34;^type&#34;| grep struct ​	可以看到整个库最核心的几个结构:
1 2 3 4 5 6 7 8 9 10 type Client struct{ ... } type Cookie struct{ ... } type MaxBytesError struct{ ... } type ProtocolError struct{ ... } type PushOptions struct{ ... } type Request struct{ ... } type Response struct{ ... } type ServeMux struct{ ... } type Server struct{ ... } type Transport struct{ ... } 看结构的名字或者 go doc 查看结构说明文档，能逐渐了解它们的功能:
Client 负责构建 HTTP 客户端;
Server 负责构建 HTTP 服务端;
ServerMux 负责 HTTP 服务端路由;
Transport、Request、Response、Cookie 负责客户端和服务端传输对应的不同模块。
​	现在通过库方法(function)和结构体(struct)，我们对整个库的结构和功能有大致印象 了。整个库承担了两部分功能，一部分是构建 HTTP 客户端，一部分是构建 HTTP 服务 端。
​	构建的 HTTP 服务端除了提供真实服务之外，也能提供代理中转服务，它们分别由 Client 和 Server 两个数据结构负责。除了这两个最重要的数据结构之外，HTTP 协议的每个部 分，比如请求、返回、传输设置等都有具体的数据结构负责。
...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to GO 三方库源码阅读姿势" href="http://localhost:1313/articles/1/01/go-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%A7%BF%E5%8A%BF/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">k8s架构介绍
    </h2>
  </header>
  <div class="entry-content">
    <p>K8s 架构 参考文章：Kubernetes源码剖析
架构概览 ​	Kubernetes 系统架构遵循客户端 / 服务端 （ C/S ） 架构 ， 系统架构分为 Master 和 Node 两部分 ， Master 作为服务端 ， Node 作为客户端 。 Kubernetes 系统具有多个 Master 服务端 ， 可以实现高可用 。 在默认的情况下 ， 一个 Master 服务端即可完成所有工作 。
服务端也被称为主控节点 ， 它在集群中主要负责如下任务 。
集群的 “ 大脑 ” ， 负责管理所有节点 (Node）。 负责调度 Pod 在哪些节点上运行 。 负责控制集群运行过程中的所有状态 。 Node 客户端也被称为工作节点 ， 它在集群中主要负责如下任务 。
负责管理所有容器 （ container ) 。 负责监控 / 上报所有 Pod 的运行状态 。 组件概览 ...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to k8s架构介绍" href="http://localhost:1313/articles/1/01/k8s%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">k8s核心数据结构（1）
    </h2>
  </header>
  <div class="entry-content">
    <p>Kubernetes 核心数据结构（1） 参考书籍：《Kubernetes源码剖析-郑旭东著》
K8s 是一个完全以资源为中心的系统
Group、Version、Resource 核心数据结构 ​	Kuberetes 系统虽然有相当复杂和众多的 功能，但它本质 上是一个资源控制系统——注册、管理、调度资源 并维护资源的状态。
​	Kuberetes 将资源再次分组和版本化，形成 Group（资源组）、Version（资源版本）、Resource（资源）
Group: 被称为资源组，在Kubernetes API Server 中也可称其为 APIGroup。 Version: 被称为资源版本，在Kubernetes API Server 中也可称其为 APIVersions。 Resource: 被称为资源，在Kubernetes API Server 中也可称其为 APIResource。 Kind: 资源种类，描述 Resource 的种类，与 Resource 为同一级别。 ​
​	Kubernetes 系统支持多个Group，每个Group 支持多个Version，每个Version 支 持多个Resource，其中部分资源同时会拥有自己的子资源(即SubResource )。例如， Deployment资源拥有Status 子资源。 ​	资源组、资源版本、资源、子资源的完整表现形式&lt;group&gt;/&lt;version&gt;/&lt;resource&gt;/ &lt;subresource&gt;。以常用的 Deployment 资源为例，其完整表现形式为apps/v1/deployments/status
​	另外资源对象(Resource Object )在本书中也是 一个常用概念，由“ 资源组&#43; 资源版本&#43;资源种类” 组成，并在实例化后表达一个资源对象，例如 Deployment 资源实例化后拥有资源组、资源版本及资源种类，其表现形式为&lt;group&gt;/&lt;version&gt;, Kind=&lt;kind&gt;，例如apps/v1, Kind=Deployment.
​	每一个资源都拥有一定数量的资源操作方法(即 Verbs )，资源操作方法用于 Etcd 集群存储中对资源对象的增、删、改、查操作。目前 Kubemetes 系统支持8 种资源操作方法，分别是 create、delete、delete、collection、get、list、patch、update、watch 操作方法。
​	每一个资源都至少有两个版本，分别是外部版本(External Version)和内部版本 ( Internal Version )。外部版本用于对外暴露给用户请求的接又所使用的资源对象。内部版本不对外暴露，仅在Kubernetes API Server 内部使用。
​	Kubernetes 资源也可分为两种， 分别是Kubernetes Resource (Kubermetes 内罝资源 ) 和 Custom Resource( 自 定 义 资 源 )。 开 发 者 通 过 C R D ( 即 Custom Resource Definitions )可实现自定义资源，它允许用户将自己定义的资源添加到 Kubernetes 系统中，并像使用 Kubernetes 内置资源 一样使用它们。
...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to k8s核心数据结构（1）" href="http://localhost:1313/articles/1/01/k8s%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">k8s核心数据结构（2）
    </h2>
  </header>
  <div class="entry-content">
    <p>K8s 核心数据结构（2） 参考书籍：《Kubernetes源码剖析-郑旭东著》
Kubernetes 内置资源概览 资源组 资源种类 说明 apiextensions.k8s.io CustomResourceDefinition 自定义资源类型 ， 由 APIExtensions Server 负责管理该资源类型 apiregistration.k8s.io APIService 聚合资源类型，由 AggregatorServer 负责管理该资源类 admissionregistration.k8s.io MutatingWebhookConfiguration 变更准入控制器资源类型( Webhook) ValidatingWebhookConfiguration 验证准入控制器资源类型 ( Webhook) apps ControllerRevision 记录资源对象所有的历史版本的资源类型 DaemonSet 在 Pod 资源对象的基础上提供守护进程的资源类型 Deployment 在 Pod资源对象的基础上提供支持无状态服务的资源类型 ReplicaSet 在 Pod 资源对象的基础上提供一组 Pod 副本的资源类型 StatefulSet 在 Pod资源对象的基础上提供支持有状态服务的资源类型 auditregistration.k8s.io AuditSink 审计资源类型 authentication.k8s.io TokenReview 认证资源类型 authorization.k8s.io LocalSubjectAccessReview 授权检查用户是否可以在指定的命名空间中执行操作 SelfSubjectAccessReview 授权检查用户是否可以执行操作(若不指定 spec.namespace，则在所有的命名空间中执行操作） SelfSubjectRulesReview 授权枚举用户可以在指定的命名空间中执行一组操作 SubjectAccessReview 授 权检查用户是否可以执行操作 autoscaling HorizontalPodAutoscaler 在 Pod 资源对象的基础上提供水平自动伸缩资源类型 batch Job 提供一次性任务的资源类型 CronJob 提供定时任务的资源类型 certificates.k8s.io CertificateSigningRequest 提供证书管理的资源类型 coordination.k8s.io Leases 提供领导者选举机制的资源类型 core ComponentStatus 该资源类型已被奔用，其用于提供获取 Kuberetes 组件运行状况的资源类型 ConfigMap 提供容器内应用程序配置管理的资源类型 Endpoints 提供将外部服务器映射为内部服务的资源类型 Event 提供 Kubernetes 集群事件管理的资源类型 LimitRange 为命名空间中的每种资源对象设置资源(硬件资源)使 用限制 Namespace 提供资源对象所在的命名空间的资源类型 Node 提供 Kubernetes 集群中管理工作节点的资源类型。每个节点都有一个唯一标识符 PersistentVolume 提供 PV 存储的资源类型 PersistentVolumeClaim 提供 PVC 存储的资源类型 Pod 提供容器集合管理的资源类型 PodTemplate 提供用于描述预定义 Pod 资源对象副本数模板的资源类型 ReplicationController 在 Pod资源对象的基础上提供副本数保持不变的资源类型 ResourceQuota 提供每个命名空间配额限制的资源类型 Secret 提供存储密码 、Token 、密钥等敏感数据的资源类型 Service 提供负载均衡器为 Pod 资源对象的代理服务的资源类型 ServiceAccount 提供 ServiceAccount 认证的资源类型 events.k8s.io Event 提供Kuberetes集群事件管理的资源类型 networking.k8s.io RuntimeClass 提供容器运行时功能的资源类型 Ingress 提供 从Kubernetes 集群外部访问集群内部服务管理的资源类型 node.k8s.io RuntimeClass 提供容器运行时功能的资源类型 policy Evictions 在 Pod 资源对象的基础上提供驱逐策略的资源类型 PodDisruptionBudget 提供限制同时中断 Pod 的数量 ，以保证集群的高可用性 PodSecurityPolicy 提供控制 Pod 资源安全相关策略的资源类型 rbac.authorization.k8s.io ClusterRole 提供 RBAC 集群角色的资源类型 ClusterRoleBinding 提供 RBAC 集群角色鄉定的资源类型 Role 提供 RBAC 角色的资源类型 RoleBinding 提供 RBAC 角色绑定的资源类型 scheduling.k8s.io PriorityClass 提供 Pod 资源对象优先级管理的资源类型 settings.k8s.10 PodPreset 在创建 Pod 资源对象时，可以将特定信息注入 Pod 资源对象中 storage.k8s.io StorageClass 提供动态设置PV存储参数的资源类 VolumeAttachment 供触发 CSI ControllerPublish 和 ControllerUnpublish 操作的资源类型 ...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to k8s核心数据结构（2）" href="http://localhost:1313/articles/1/01/k8s%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Prometheus 入门实操
    </h2>
  </header>
  <div class="entry-content">
    <p>Prometheus 入门实操 参考文章：Prometheus监控Linux主机 - 吕振江 - 博客园 (cnblogs.com) 安装 1 2 3 4 5 6 7 8 9 # 下载 wget https://github.com/prometheus/prometheus/releases/download/v2.44.0/prometheus-2.44.0.linux-amd64.tar.gz # 解压 tar zxf prometheus-2.44.0.linux-amd64.tar.gz # 移动 mv prometheus-2.24.1.linux-amd64/* /usr/local/prometheus # 将本机上报 sed -i &#39;s/localhost/你的主机ip/g&#39; /usr/local/prometheus/prometheus.yml 启动(systemed，守护进程) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 cat &lt;&lt;EOF &gt; /usr/lib/systemd/system/prometheus.service [Unit] Description=prometheus After=network.target [Service] Type=simple ExecStart=/usr/local/prometheus/prometheus --config.file=/usr/local/prometheus/prometheus.yml --storage.tsdb.path=/usr/local/prometheus/data/ --web.enable-lifecycle --storage.tsdb.retention.time=30d Restart=on-failure [Install] WantedBy=multi-user.target EOF systemctl daemon-reload systemctl start prometheus systemctl status prometheus &amp;&amp; systemctl enable prometheus 访问 Ip:9090 管理接口 1 2 3 4 5 6 7 8 9 10 11 12 $ curl http://ip:9090/-/healthy Prometheus is Healthy. # 健...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to Prometheus 入门实操" href="http://localhost:1313/articles/1/01/prometheus-%E5%85%A5%E9%97%A8%E5%AE%9E%E6%93%8D/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/articles/page/5/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:1313/articles/page/7/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:1313/">Luenci</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
