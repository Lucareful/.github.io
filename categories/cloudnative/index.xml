<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CloudNative on Luenci</title>
    <link>http://localhost:1313/categories/cloudnative/</link>
    <description>Recent content in CloudNative on Luenci</description>
    <generator>Hugo -- 0.129.0</generator>
    <language>en-us</language>
    <atom:link href="http://localhost:1313/categories/cloudnative/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>云计算和云原生概念浅析</title>
      <link>http://localhost:1313/articles/1/01/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%92%8C%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A6%82%E5%BF%B5%E6%B5%85%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/articles/1/01/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%92%8C%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A6%82%E5%BF%B5%E6%B5%85%E6%9E%90/</guid>
      <description>&lt;h1 id=&#34;云计算定义&#34;&gt;云计算定义&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;一种能够跨网络、按需提供基础架构、服务、平台和应用的交付方式，正在快速取代原本通过硬布线连接进行资源共享的方式。          &amp;ndash;  redhat&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;云计算解决的问题主要是&lt;strong&gt;物理资源上云，通过虚拟化技术来将底层资源池化，达到弹性、可控等目的&lt;/strong&gt;。然而大多数传统应用并不是面向云环境来构建的，这里面包含了大量开发需求（开发框架、类库、后段服务等），就导致了云端的强大能力没有被完全发挥出来。因此，摒弃传统的应用技术架构，基于云的特点重新构建云原生应用，成为企业上云的下一个阶段。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;
&lt;p&gt;云计算是指在云中&lt;strong&gt;运行工作负载&lt;/strong&gt;，而云是一种能够抽象、汇集和共享整个网络中的可扩展资源的 IT 环境。云计算和云本身都不属于技术的范畴。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;云计算是指在云中运行工作负载的功能。&lt;/li&gt;
&lt;li&gt;而云是一种环境，是运行应用的地方。&lt;/li&gt;
&lt;li&gt;技术则是指用于构建和使用云的软件和硬件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;云计算为云原生提供了物理基础，做个不太精确的比喻:&amp;ldquo;云计算是电脑硬件，云原生是应用&amp;rdquo;.&lt;/p&gt;
&lt;h1 id=&#34;云原生&#34;&gt;云原生&lt;/h1&gt;
&lt;h2 id=&#34;公有云私有云和混和云&#34;&gt;公有云，私有云和混和云&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;根据服务模式对云计算的分类包括：基础设施作为服务（iaas），平台作为服务（paas），软件作为服务（saas）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据云计算的资源归属对象，它可以分为公共云和私有云两大类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公共云（公共云）是一种向公众提供计算资源的服务。一般通过互联网使用，成本低，公共云的核心属性是&lt;strong&gt;共享资源服务&lt;/strong&gt;。公共云的优点是低成本和良好的可扩展性。缺点是用户对云资源、数据安全、网络性能和匹配等问题缺乏控制。&lt;/li&gt;
&lt;li&gt;私有云是为拥有基础设施并控制如何在其上部署应用程序的单个客户而构建的。用户可以在企业数据中心防火墙或安全托管站点中部署私有云。&lt;strong&gt;私有云的核心属性是专有资源&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;混合云不是一个独立的概念。它是一种混合云服务模式，通过标准化手段或专有技术将公共和私人云结合起来。简单地说，混合云是一种云服务模式，既有公共云，也有私人云。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Service Mesh 介绍</title>
      <link>http://localhost:1313/articles/1/01/service-mesh-%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/articles/1/01/service-mesh-%E4%BB%8B%E7%BB%8D/</guid>
      <description>&lt;h1 id=&#34;service-mesh-介绍&#34;&gt;Service Mesh 介绍&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Service Mesh 是微服务时代的 TCP/IP 协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​    &lt;strong&gt;一种控制应用程序的不同部分如何相互共享数据的方法&lt;/strong&gt;。与其他用于管理此通信的系统不同，服务网格是内置于应用中的专用基础结构层。这个可见的基础结构层可以记录应用的不同部分的交互程度（或交互程度），因此随着应用的增长，优化通信和避免停机变得更加容易。														&amp;ndash; redhat&lt;/p&gt;
&lt;p&gt;​    Buoyant的CEO William Morgan，也就是Service Mesh这个词的发明人，对Service Mesh的定义：&lt;/p&gt;
&lt;p&gt;​    服务网格是一个&lt;strong&gt;基础设施层&lt;/strong&gt;，用于处理服务间通信。云原生应用有着复杂的服务拓扑，服务网格保证&lt;strong&gt;请求在这些拓扑中可靠地穿梭&lt;/strong&gt;。在实际应用当中，服务网格通常是由一系列轻量级的&lt;strong&gt;网络代理&lt;/strong&gt;组成的，&lt;strong&gt;它们与应用程序部署在一起，但对应用程序透明。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;演化进程&#34;&gt;演化进程&lt;/h2&gt;
&lt;h3 id=&#34;时代0&#34;&gt;时代0&lt;/h3&gt;
&lt;p&gt;开发人员想象中，不同服务间通信的方式，抽象表示如下：&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/v2-2a182cea5ab0f7d625776a9446cd596b_1440w.jpg&#34; alt=&#34;img&#34;  /&gt;
&lt;/p&gt;
&lt;h3 id=&#34;时代1原始通信时代&#34;&gt;时代1：原始通信时代&lt;/h3&gt;
&lt;p&gt;​     然而现实远比想象的复杂，在实际情况中，通信需要底层能够传输字节码和电子信号的物理层来完成，在TCP协议出现之前，服务需要自己处理网络通信所面临的丢包、乱序、重试等一系列流控问题，&lt;strong&gt;因此服务实现中，除了业务逻辑外，还夹杂着对网络传输问题的处理逻辑。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/v2-1443e6bebd93d5e6bb1c18197676d29b_1440w.jpg&#34; alt=&#34;img&#34;  /&gt;
&lt;/p&gt;</description>
    </item>
    <item>
      <title>聊聊链路追踪 OpenTracing</title>
      <link>http://localhost:1313/articles/1/01/%E8%81%8A%E8%81%8A%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA-opentracing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/articles/1/01/%E8%81%8A%E8%81%8A%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA-opentracing/</guid>
      <description>&lt;h1 id=&#34;聊聊链路追踪-opentracing&#34;&gt;聊聊链路追踪 &lt;code&gt;OpenTracing&lt;/code&gt;&lt;/h1&gt;
&lt;h2 id=&#34;什么是-tracing&#34;&gt;什么是 Tracing&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/img/logging-metrics-tracing.o.png&#34; alt=&#34;Logging Metrics Tracing&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;对 Tracing 的定义是，在软件工程中，Tracing 指使用特定的日志记录程序的执行信息，与之相近的还有两个概念，它们分别是 Logging 和 Metrics。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Logging：用于记录离散的事件，包含程序执行到某一点或某一阶段的详细信息。&lt;/li&gt;
&lt;li&gt;Metrics：可聚合的数据，且通常是固定类型的时序数据，包括 Counter、Gauge、Histogram 等。&lt;/li&gt;
&lt;li&gt;Tracing：记录单个请求的处理流程，其中包括服务调用和处理时长等信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时这三种定义相交的情况也比较常见。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Logging &amp;amp; Metrics：可聚合的事件。例如分析某对象存储的 &lt;code&gt;Nginx&lt;/code&gt; 日志，统计某段时间内 GET、PUT、DELETE、OPTIONS 操作的总数。&lt;/li&gt;
&lt;li&gt;Metrics &amp;amp; Tracing：单个请求中的可计量数据。例如 &lt;code&gt;SQL&lt;/code&gt; 执行总时长、&lt;code&gt;gRPC&lt;/code&gt; 调用总次数。&lt;/li&gt;
&lt;li&gt;Tracing &amp;amp; Logging：请求阶段的标签数据。例如在 Tracing 的信息中标记详细的错误原因。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对每种分析需求，我们都有非常强大的集中式分析工具。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Logging：&lt;a href=&#34;https://www.elastic.co/&#34;&gt;ELK&lt;/a&gt;，近几年势头最猛的日志分析服务，无须多言。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Metrics：&lt;a href=&#34;https://prometheus.io/&#34;&gt;Prometheus&lt;/a&gt;，第二个加入 &lt;code&gt;CNCF&lt;/code&gt; 的开源项目，非常好用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tracing：&lt;a href=&#34;http://opentracing.io/&#34;&gt;OpenTracing&lt;/a&gt; 和 &lt;a href=&#34;https://www.jaegertracing.io/&#34;&gt;Jaeger&lt;/a&gt;，Jaeger 是 &lt;code&gt;Uber &lt;/code&gt;开源的一个兼容 &lt;code&gt;OpenTracing&lt;/code&gt; 标准的分布式追踪服务。目前 Jaeger 也加入了 &lt;code&gt;CNCF&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;
&lt;p&gt;​	分布式追踪系统大体分为三个部分，数据采集、数据持久化、数据展示。数据采集是指在代码中埋点，设置请求中要上报的阶段，以及设置当前记录的阶段隶属于哪个上级阶段。数据持久化则是指将上报的数据落盘存储，例如 Jaeger 就支持多种存储后端，可选用 &lt;code&gt;Cassandra&lt;/code&gt; 或者 &lt;code&gt;Elasticsearch&lt;/code&gt;。数据展示则是前端根据 Trace ID 查询与之关联的请求阶段，并在界面上呈现。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/img/request-demonstration.o.png&#34; alt=&#34;Request Demonstration&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;上图是一个请求的流程例子，请求从客户端发出，到达负载均衡，再依次进行认证、计费，最后取到目标资源。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/img/opentracing-demonstration.o.png&#34; alt=&#34;OpenTracing Demonstration&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;请求过程被采集之后，会以上图的形式呈现，横坐标是时间，圆角矩形是请求的执行的各个阶段。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Tekton 入门</title>
      <link>http://localhost:1313/articles/1/01/tekton-%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/articles/1/01/tekton-%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;h1 id=&#34;tekton-入门&#34;&gt;Tekton 入门&lt;/h1&gt;
&lt;h2 id=&#34;术语解释&#34;&gt;术语解释&lt;/h2&gt;
&lt;h3 id=&#34;cloud-native&#34;&gt;Cloud Native&lt;/h3&gt;
&lt;p&gt;​	云原生是一种软件开发方法，其中应用程序被分解为微服务，这些微服务被打包到容器中，容器在云中动态编排以优化资源利用&lt;/p&gt;
&lt;h3 id=&#34;continuous-delivery&#34;&gt;Continuous Delivery&lt;/h3&gt;
&lt;p&gt;​	持续交付是一种软件开发实践，团队可以安全、快速、可持续地向用户发布软件变更。&lt;/p&gt;
&lt;h3 id=&#34;tekton&#34;&gt;Tekton&lt;/h3&gt;
&lt;p&gt;​	Tekton 是一个用于创建持续交付系统的开源 kubernetes 原生的框架。你可以使用 tekton 跨多个云提供商或混合环境构建，测试和部署。Tekton 通过抽象出复杂的kubenetes概念和实现细节来简化应用程序管理。它提供了用于声明持续交付管道的 Kubernetes 自定义资源。&lt;/p&gt;
&lt;h2 id=&#34;基本构建块&#34;&gt;基本构建块&lt;/h2&gt;
&lt;p&gt;    其中Task、TaskRun、Pipeline、PipelineRun、PipelineResource、Condition作为其核心CRD，这里主要介绍它们。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Task：&lt;/strong&gt; 定义构建任务，它由一系列有序steps构成。每个step可以定义输入和输出，且可以将上一个step的输出作为下一个step的输入。每个step都会由一个container来执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是 Tekton 中不可分割的最小单位，正如同 Pod 在 Kubernetes 中的概念一样&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TaskRun：&lt;/strong&gt; Task用于定义具体要做的事情，并不会真正的运行，而TaskRun就是真正的执行者，并且会提供执行所需需要的参数，一个TaskRun就是一个Pod。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Pipeline：&lt;/strong&gt; 顾名思义就是流水线，它由一系列Tasks组成。就像Task中的step一样，上一个Task的输出可以作为下一个Task的输入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PipelineRun：&lt;/strong&gt; Pipeline的实际执行，创建后会创建Pod来执行Task，一个PipelineRun中有多个Task。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PipelineResource：&lt;/strong&gt; 主要用于定义Pipeline的资源，常见的如Git地址、Docker镜像等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Condition：&lt;/strong&gt; 它主要是在Pipeline中用于判断的，Task的执行与否通过Condition的判断结果来决定。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt; PipelineResource和Condition都会被废弃。但是在低版本中还是会继续使用，所以这里会简单介绍一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/img/image-20230301151952643.png&#34; alt=&#34;image-20230301151952643&#34;  /&gt;
&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
