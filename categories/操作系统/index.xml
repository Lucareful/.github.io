<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>操作系统 on Luenci</title>
    <link>http://localhost:1313/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
    <description>Recent content in 操作系统 on Luenci</description>
    <generator>Hugo -- 0.129.0</generator>
    <language>en-us</language>
    <atom:link href="http://localhost:1313/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>深入理解堆、栈、CPU密集型 和 I/O 密集型任务</title>
      <link>http://localhost:1313/articles/1/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A0%86%E6%A0%88cpu%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%92%8C-i/o-%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/articles/1/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A0%86%E6%A0%88cpu%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%92%8C-i/o-%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1/</guid>
      <description>&lt;h1 id=&#34;关于堆栈cpu密集型-和-io-密集型知识&#34;&gt;关于堆、栈、CPU密集型 和 I/O 密集型知识&lt;/h1&gt;
&lt;h2 id=&#34;程序中的内存分配方式cc&#34;&gt;程序中的内存分配方式（c/c++）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;1、栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其
操作方式类似于数据结构中的栈。&lt;/li&gt;
&lt;li&gt;2、堆区（heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回
收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链。&lt;/li&gt;
&lt;li&gt;3、全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的
全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另
一块区域。 - 程序结束后由系统释放。&lt;/li&gt;
&lt;li&gt;4、文字常量区：常量字符串就是放在这里的。 程序结束后由系统释放&lt;/li&gt;
&lt;li&gt;5、程序代码区：存放函数体的二进制代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;python的堆栈解析&#34;&gt;python的堆栈解析&lt;/h2&gt;
&lt;p&gt;因为是动态语言**，python中的所有变量内容都存在堆（heap）中**，而&lt;strong&gt;变量名只是堆中内容的引用，存放在栈（stack）中&lt;/strong&gt;，便于用户去间接操作堆中的数据。&lt;/p&gt;
&lt;p&gt;堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；&lt;/li&gt;
&lt;li&gt;（2）空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；&lt;/li&gt;
&lt;li&gt;（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。&lt;/li&gt;
&lt;li&gt;（4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由&lt;code&gt;malloc&lt;/code&gt;函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。&lt;/li&gt;
&lt;li&gt;（5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。&lt;/li&gt;
&lt;li&gt;（6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
