<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.129.0"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Luenci</title>

<meta name="description" content="">
<meta name="author" content="Luenci">
<link rel="canonical" href="http://localhost:1313/en/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.915833180a767872e4396fd52d4545da5155352ef4bbb9809554b52b14467e03.css" integrity="sha256-kVgzGAp2eHLkOW/VLUVF2lFVNS70u7mAlVS1KxRGfgM=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/images/L.png">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/images/L.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/images/L.png">
<link rel="apple-touch-icon" href="http://localhost:1313/L.png">
<link rel="mask-icon" href="http://localhost:1313/L.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/en/index.xml">
<link rel="alternate" type="application/json" href="http://localhost:1313/en/index.json">
<link rel="alternate" hreflang="en" href="http://localhost:1313/en/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="Luenci" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://localhost:1313/en/" /><meta property="og:site_name" content="(〃&#39;▽&#39;〃)" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Luenci"/>
<meta name="twitter:description" content=""/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "Luenci",
  "url": "http://localhost:1313/en/",
  "description": "",
  "thumbnailUrl": "http://localhost:1313/images/L.png",
  "sameAs": [
      "https://github.com/Lucareful", "mailto:lucarful@gmail.com", "https://twitter.com/luenci", "https://weibo.com/u/7474747474", "index.xml"
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/en/" accesskey="h" title="Luenci (Alt + H)">
                <img src="http://localhost:1313/images/avatar.jpg" alt="" aria-label="logo"
                    height="35">Luenci</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/en/search" title="🔍搜索">
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/en/" title="🏠主页">
                    <span class="active">🏠主页</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/en/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/en/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/en/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/en/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/en/links" title="🤝友链">
                    <span>🤝友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Go面向对象相关知识
    </h2>
  </header>
  <div class="entry-content">
    <p>Go面向对象相关知识 类的封装和绑定方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package main import &#34;fmt&#34; // go语言没有class关键字生成类 // 使用struct声明类 type Person struct { // 成员属性 name string age int gender string } // 类外边绑定方法 // 类的方法，可以使用自己的成员 // 使用指针可以修改类的成员变量等 func (p *Person) Eat() { fmt.Println(&#34;使用 *Person 指针 修改前&#34;) fmt.Println(p.name &#43; &#34; is eating&#34;) p.name = &#34;luenci&#34; fmt.Println(&#34;使用 *Person 指针 修改后&#34;) fmt.Println(p.name &#43; &#34; is eating&#34;) } func (p Person) Eat2() { fmt.Println(&#34;使用 Person 不是指针 修改前&#34;) fmt.Println(p.name &#43; &#34; is eating&#34;) p.name = &#34;luenci&#34; fmt.Println(&#34;使用 Person 不是指针 修改后&#34;) fmt.Println(p.name &#43; &#34; is eating&#34;) } func main() { lynn := Person{ name: &#34;lynn&#34;, age: 20, gender: &#34;girl&#34;, } lynn.Eat() lynn.Eat2() } 类的继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package main import &#34;fmt&#34; type Human struct { name string sex string age int } type Student struct { hum Human // 包含 Human类型的变量 是嵌套类 school string } type Teacher struct { Human // 直接声明Human类型，没有定义变量 类继承 school string } // 类外面绑定方法 func (h *Human) Eat() { fmt.Println(h.name &#43; &#34; is eating&#34;) } func main() { st1 := Student{ hum: Human{ name: &#34;lynn&#34;, sex: &#34;girl&#34;, age: 20, }, school: &#34;一中&#34;, } fmt.Println(&#34;st1&#34;, st1) fmt.Println(&#34;st1 name&#34;, st1.hum.name) t1 := Teacher{} t1.school = &#34;一中&#34; t1.name = &#34;lynn&#34; t1.sex = &#34;girl&#34; t1.age = 20 fmt.Println(&#34;t1&#34;, t1) fmt.Println(&#34;t1 name&#34;, t1.name) // 继承的时候虽然我们没有声明变量名称，但是默认自动会给类型创建一个同名字段 // 这是为了能在子类中操作父类，因为：子类父类可能出现同名字段 fmt.Println(&#34;t1 age&#34;, t1.Human.age) } 类成员访问权限（字段大小写）...</p>
  </div>
  <footer class="entry-footer">5 min&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to Go面向对象相关知识" href="http://localhost:1313/en/posts/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">管道和go程
    </h2>
  </header>
  <div class="entry-content">
    <p>管道和go程 goroutine（go程） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( &#34;fmt&#34; &#34;time&#34; ) func display(num int) { count := 1 for { fmt.Println(&#34;============&gt; 这是子go程：&#34;, num, &#34;当前count值&#34;, count) count&#43;&#43; } } func main() { // 启动子go程 for i := 0; i &lt; 3; i&#43;&#43; { go display(i) } // 主go程 count := 1 for { fmt.Println(&#34;============&gt; 这是主go程：&#34;, count) count&#43;&#43; time.Sleep(1 * time.Second) } } 提前退出go程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( &#34;fmt&#34; &#34;runtime&#34; &#34;time&#34; ) // GOEXIT ===&gt; 提前退出go程 // return ===&gt; 返回当前函数 // exit ===&gt; 退出当前进程 func main() { go func() { func() { fmt.Println(&#34;子go程内部的函数!&#34;) //return // 退出当前函数 //os.Exit(-1) // 退出进程 runtime.Goexit() // 退出当前go程 }() fmt.Println(&#34;子go程结束！&#34;) }() // 主go程需要等待子go程退出 fmt.Println(&#34;主go程~&#34;) time.Sleep(5 * time.Second) fmt.Println(&#34;OVER!&#34;) } 无缓冲管道 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package main import ( &#34;fmt&#34; &#34;time&#34; ) /* 当通道在多个协程之间传输的是指向数据的指针是，且读写操作是由不同的协程操作，则需要提供额外的同步动作。 */ func main() { // 当涉及到多go程时，c语言使用互斥量，上锁来保持资源同步，避免资源竞争问题 // go语言更好的解决方案是管道、通道 // 使用通道不需要手动进行加锁 //sync.RWMutex{} // 创建管道 关键字 chan numChan := make(chan int) // 装数字的管道，无缓冲通道，未声明空间 //numChan := make(chan int, 10) // 有缓冲通道 // 创建两个go程，父写，子读 // 发现子go程没有发生资源抢夺 // 子go程1 go func() { for i := 0; i &lt; 25; i&#43;&#43; { // 只能 &lt;- 数据流向 data := &lt;-numChan fmt.Println(&#34;子go程1 读取data&#34;, data) } }() // 子go程2 go func() { for i := 0; i &lt; 25; i&#43;&#43; { data := &lt;-numChan fmt.Println(&#34;子go程2 读取data&#34;, data) } }() // 父go程 for i := 0; i &lt; 50; i&#43;&#43; { // 向管道中写入数据 numChan &lt;- i fmt.Println(&#34;====&gt; 主go程，写入数据&#34;, i) } time.Sleep(5 * time.Second) } ...</p>
  </div>
  <footer class="entry-footer">5 min&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to 管道和go程" href="http://localhost:1313/en/posts/%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95%E7%AE%A1%E9%81%93%E5%92%8Cgo%E7%A8%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">consul服务发现
    </h2>
  </header>
  <div class="entry-content">
    <p>consul服务发现 Consul是由HashiCorp开发的一个支持多数据中心的分布式服务发现和键值对存储服务的开源软件，被大量应用于基于微服务的软件架构当中。
服务发现流程图 服务发现，也可以看做一个“服务”，是给“服务”提供服务的 服务发现种类 consul：常用于go-micro中 mdns：go-micro中默认的服务发现 etcd：k8s内嵌的服务发现 zookeeper：java中常用 Consul关键特性 服务发现：consul提供服务，服务端主动向consul发起注册。 健康检查：定时发送消息，类似于“心跳包”，保证客户端获取到的一定是健康的服务。 键值存储：consul提供，但常用于redis。 多数据中心：可以轻松加入集群。 Consul 参数 安装好 Consul 后，在启动程序之前，需要掌握一些配置参数，通过掌握这些参数，可以一次性的成功运行 Consul 服务器集群，常用的参数如下： 参数名称 用途 -server 此标志用于控制代理是运行于服务器/客户端模式，每个 Consul 集群至少有一个服务器，正常情况下不超过5个，使用此标记的服务器参与 Raft一致性算法、选举等事务性工作 -http-port=8500 consul自带的一个web访问端口，默认为8500 -client 表示 Consul 绑定客户端接口的IP地址，默认值为：127.0.0.1，当你有多块网卡的时候，最好指定IP地址，不要使用默认值 -bootstrap-expect 预期的服务器集群的数量，整数，如 -bootstrap-expect=3，表示集群服务器数量为3台，设置该参数后，Consul将等待指定数量的服务器全部加入集群可用后，才开始引导集群正式开始工作，此参数必须与 -server 一起使用 -data-dir 存储数据的目录，该目录在 Consul 程序重启后数据不会丢失，指定此目录时，应确保运行 Consul 程序的用户对该目录具有读写权限 -config-dir=XX 所有服务主动注册的配置文件 - node 当前服务器在集群中的名称，该值在整个 Consul 集群中必须唯一，默认值为当前主机名称 - bind Consul 在当前服务器侦听的地址，如果您有多块网卡，请务必指定一个IP地址（IPv4/IPv6)，默认值为：0.0.0.0，也可用使用[::] ...</p>
  </div>
  <footer class="entry-footer">4 min&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to consul服务发现" href="http://localhost:1313/en/posts/consul%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">json、结构体标签和rpc入门
    </h2>
  </header>
  <div class="entry-content">
    <p>json、结构体标签和rpc入门 json使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import ( &#34;encoding/json&#34; &#34;fmt&#34; &#34;reflect&#34; ) // 将 结构体 --&gt; 字符串 编码 // 将 字符串 --&gt; 结构体 解码 // 结构体的成员须大写，不然不参与编码 type Student struct { Name string Sex string Age int Score int } func main() { st1 := Student{ Name: &#34;luenci&#34;, Sex: &#34;man&#34;, Age: 22, Score: 99, } // 编码 序列化 encodeInfo, err := json.Marshal(st1) if err != nil { fmt.Println(&#34;序列化发生错误,error&#34;, err) return } fmt.Println(reflect.TypeOf(encodeInfo)) fmt.Println(string(encodeInfo)) // 解码 反序列化 var st2 Student if err := json.Unmarshal([]byte(encodeInfo), &amp;st2); err != nil { fmt.Println(&#34;反序列化发生错误,&#34;, err) return } fmt.Println(st2.Name) } ...</p>
  </div>
  <footer class="entry-footer">3 min&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to json、结构体标签和rpc入门" href="http://localhost:1313/en/posts/json%E7%BB%93%E6%9E%84%E4%BD%93%E6%A0%87%E7%AD%BE%E5%92%8Crpc%E5%85%A5%E9%97%A8/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">深入理解堆、栈、CPU密集型 和 I/O 密集型任务
    </h2>
  </header>
  <div class="entry-content">
    <p>关于堆、栈、CPU密集型 和 I/O 密集型知识 程序中的内存分配方式（c/c&#43;&#43;） 1、栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其 操作方式类似于数据结构中的栈。 2、堆区（heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回 收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链。 3、全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的 全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另 一块区域。 - 程序结束后由系统释放。 4、文字常量区：常量字符串就是放在这里的。 程序结束后由系统释放 5、程序代码区：存放函数体的二进制代码。 python的堆栈解析 因为是动态语言**，python中的所有变量内容都存在堆（heap）中**，而变量名只是堆中内容的引用，存放在栈（stack）中，便于用户去间接操作堆中的数据。
堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：
（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏； （2）空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB； （3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。 （4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由malloc函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。 （5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C&#43;&#43;提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。 （6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。 ...</p>
  </div>
  <footer class="entry-footer">6 min&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to 深入理解堆、栈、CPU密集型 和 I/O 密集型任务" href="http://localhost:1313/en/posts/%E5%85%B3%E4%BA%8E%E5%A0%86%E6%A0%88cpu%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%92%8C-io-%E5%AF%86%E9%9B%86%E5%9E%8B%E7%9F%A5%E8%AF%86/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">goroutine VS python 协程
    </h2>
  </header>
  <div class="entry-content">
    <p>协程概念 协程，其实可以理解为一种特殊的程序调用。特殊的是在执行过程中，在子程序（或者说函数）内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。
它有两个特征：
可中断，这里的中断不是普通的函数调用，而是类似CPU的中断，CPU在这里直接释放转到其他程序断点继续执行。 可恢复，等到合适的时候，可以恢复到中断的地方继续执行。 和进程线程的区别 上面两个特点就导致了它相对于线程和进程切换来说极高的执行效率，为什么这么说呢？我们先老生常谈地说一下进程和线程。
进程是操作系统资源分配的基本单位，线程是操作系统调度和执行的最小单位。 这两句应该是我们最常听到的两句话，拆开来说，
进程是程序的启动实例，拥有代码和打开的文件资源、数据资源、独立的内存空间。 线程从属于进程，是程序的实际执行者，一个进程至少包含一个主线程，也可以有更多的子线程，线程拥有自己的栈空间。无论是进程还是线程，都是由操作系统所管理和切换的。 我们再来看协程，它又叫做微线程，但其实它和进程还有线程完全不是一个维度上的概念。
进程和线程的切换完全是用户无感，由操作系统控制，从用户态到内核态再到用户态。 而协程的切换完全是程序代码控制的，在用户态的切换，就像函数回调的消耗一样，在线程的栈内即可完成。 ...</p>
  </div>
  <footer class="entry-footer">3 min&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to goroutine VS python 协程" href="http://localhost:1313/en/posts/goroutinevspython%E5%8D%8F%E7%A8%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Golang的goroutine模型概述和调度
    </h2>
  </header>
  <div class="entry-content">
    <p>G-P-M 模型概述 每一个OS线程都有一个固定大小的内存块(一般会是2MB)来做栈，这个栈会用来存储当前正在被调用或挂起(指在调用其它函数时)的函数的内部变量。 这个固定大小的栈同时很大又很小。因为2MB的栈对于一个小小的Goroutine来说是很大的内存浪费，而对于一些复杂的任务（如深度嵌套的递归）来说又显得太小。因此，Go语言做了它自己的『线程』。 在Go语言中，每一个Goroutine是一个独立的执行单元，相较于每个OS线程固定分配2M内存的模式，Goroutine的栈采取了动态扩容方式， 初始时仅为2KB，随着任务执行按需增长，最大可达1GB（64位机器最大是1G，32位机器最大是256M），且完全由Golang自己的调度器 Go Scheduler 来调度。 此外，GC还会周期性地将不再使用的内存回收，收缩栈空间。 因此，Go程序可以同时并发成千上万个Goroutine是得益于它强劲的调度器和高效的内存模型。 任何用户线程最终肯定都是要交由OS线程来执行
​ Goroutine（称为G）也不例外，但是G并不直接绑定OS线程运行，而是由Goroutine Scheduler中的 P - Logical Processor （逻辑处理器）来作为两者的『中介』。
P 可以看作是一个抽象的资源或者一个上下文，一个P绑定一个OS线程，在Golang的实现里把OS线程抽象成一个数据结构。
M，G实际上是由M通过P来进行调度运行的，但是在G的层面来看，P提供了G运行所需的一切资源和环境，因此在G看来P就是运行它的 “CPU”，由 G、P、M 这三种由Go抽象出来的实现，最终形成了Go调度器的基本结构：
G: Goroutine G有以下状态
非GC状态
idle:_Gidle for idle，意思是这个goroutine刚被创建出来，还未被进行初始化。 runnable: _Grunnable for runnable意思是这个goroutine已经在运行队列，在这种情况下，goroutine还未执行用户代码，M的执行栈还不是goroutine自己的 running: _Grunning for running，意思是goroutine可能正在执行用户代码，M的执行栈已经由该goroutine所拥有，此时对象g不在运行队列中。这个状态值要待分配给M和P之后，交由M和P来设定 syscall, waiting, dead, copystack 对应的GC状态
scan, scanrunnable, scan running, scansyscall, scanwaiting _Gscan系列，用于标记正在被GC扫描的状态，这些状态是由_Gscan=0x1000再加上_GRunnable, _Grunning, _Gsyscall和_Gwaiting的枚举值所产生的，这么做的好处是直接通过简单的运算即可知道被Scan之前的状态。当被标记为这系列的状态时，这些goroutine都不会执行用户代码，并且它们的执行栈都是被做该GC的goroutine所拥有。不过_Gscanrunning状态有点特别，这个标记是为了阻止正在运行的goroutine切换成其它状态，并告诉这个G自己扫描自己的堆栈。正是这种巧妙的方式，使得Go语言的GC十分高效。 每个Goroutine对应一个G结构体，G 存储 Goroutine的运行堆栈、状态以及任务函数，可重用。
G并非执行体，每个G需要绑定到P才能被调度执行。
P: Processor 表示逻辑处理器， 对G来说，P相当于CPU核，G只有绑定到P(在P的local run中)才能被调度。对M来说，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，P的数量决定了系统内最大可并行的G的数量（前提：物理CPU核数 &gt;= P的数量），P的数量由用户设置的GoMAXPROCS决定，但是不论GoMAXPROCS设置为多大，P的数量最大为256。 golang runtime是有个sysmon的协程，他会轮询的检测所有的P上下文队列，**只要 G-M 的线程长时间在阻塞状态，那么就重新创建一个线程去从runtime P队列里获取任务。先前的阻塞的线程会被游离出去了，当他完成阻塞操作后会触发相关的callback回调，并加入回线程组里。**简单说，如果你没有特意配置runtime.SetMaxThreads，那么在没有可复用的线程的情况下，会一直创建新线程。 M: Machine ​ OS线程抽象，代表着真正执行计算的资源。
在绑定有效的P后，进入schedule循环；而schedule循环的机制大致是从Global队列、P的Local队列以及wait队列中获取G，切换到G的执行栈上并执行G的函数，调用Goexit做清理工作并回到M，如此反复。
M并不保留G状态，这是G可以跨M调度的基础，M的数量是不定的，由Go Runtime调整，为了防止创建过多OS线程导致系统调度不过来，目前默认最大限制为10000个。
在绝大多数时候，其实P的数量和M的数量是相等。 每创建一个p, 就会创建一个对应的M只有少数情况下，M的数量会大于P
work-stealing 的调度算法 每个P维护一个G的本地队列； 当一个G被创建出来，或者变为可执行状态时，就把他放到P的可执行队列中； 当一个G在M里执行结束后，P会从队列中把该G取出；如果此时P的队列为空，即没有其他G可以执行， M就随机选择另外一个P，从其可执行的G队列中取走一半。 ...</p>
  </div>
  <footer class="entry-footer">7 min&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to Golang的goroutine模型概述和调度" href="http://localhost:1313/en/posts/golang%E7%9A%84gpm%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0%E5%92%8C%E8%B0%83%E5%BA%A6/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">高并发,高可用,高性能
    </h2>
  </header>
  <div class="entry-content">
    <p> 原文链接：https://juejin.cn/post/6844903944955625479
一、高并发 简介 高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。 高并发相关常用的一些指标有响应时间（Response Time），吞吐量（Throughput），每秒查询率QPS（Query Per Second），并发用户数等。
响应时间：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。 吞吐量：单位时间内处理的请求数量。 QPS：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。 并发用户数：同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。 如何提高并发能力 垂直扩展
（Scale Up）
增强单机硬件性能（优先）：例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T，扩充系统内存如128G。 提升单机架构性能：例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间。 总结：管是提升单机硬件性能，还是提升单机架构性能，都有一个致命的不足：单机性能总是有极限的。所以互联网分布式架构设计高并发终极解决方案还是水平扩展。 水平扩展
（Scale Out）
只要增加服务器数量，就能线性扩充系统性能。水平扩展对系统架构设计是有要求的，难点在于：如何在架构各层进行可水平扩展的设计。 二、高性能 简介 简单的说，高性能（High Performance）就是指程序处理速度快，所占内存少，cpu占用率低。 高并发和高性能是紧密相关的，提高应用的性能，是肯定可以提高系统的并发能力的。 应用性能优化的时候，对于计算密集型和IO密集型还是有很大差别，需要分开来考虑。 增加服务器资源（CPU、内存、服务器数量），绝大部分时候是可以提高应用的并发能力和性能 （前提是应用能够支持多任务并行计算，多服务器分布式计算才行），但也是要避免其中的一些问题，才可以更好的更有效率的利用服务器资源。 提高性能的注意事项 避免因为IO阻塞让CPU闲置，导致CPU的浪费。 避免多线程间增加锁来保证同步，导致并行系统串行化。 免创建、销毁、维护太多进程、线程，导致操作系统浪费资源在调度上。 避免分布式系统中多服务器的关联，比如：依赖同一个mysql，程序逻辑中使用分布式锁，导致瓶颈在mysql，分布式又变成串行化运算。 ...</p>
  </div>
  <footer class="entry-footer">4 min&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to 高并发,高可用,高性能" href="http://localhost:1313/en/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8%E9%AB%98%E6%80%A7%E8%83%BD/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">初探架构设计
    </h2>
  </header>
  <div class="entry-content">
    <p> 架构设计的主要目的是为了解决软件系统复杂度带来的问题
架构、框架、组件、模块、系统 OLAP（Online Analytical Processing）在线分析处理
架构是顶层设计；框架是面向编程或配置的半成品；组件是从技术维度上的复用；模块是从业务维度上职责的划分；系统是相互协同可运行的实体。
架构设计的目的 明确“架构设计是为了解决软件复杂度”原则后 “这么多需求，从哪里开始下手进行架构设计呢？” — 通过熟悉和理解需求，识别系统复杂性所在的地方，然后针对这些复杂点进行架构设计。 “架构设计要考虑高性能、高可用、高扩展……这么多高 XX，全部设计完成估计要 1 个月，但老大只给了 1 周时间” —架构设计并不是要面面俱到，不需要每个架构都具备高性能、高可用、高扩展等特点，而是要识别出复杂点然后有针对性地解决问题。 “业界 A 公司的架构是 X，B 公司的方案是 Y，两个差别比较大，该参考哪一个呢？” —理解每个架构方案背后所需要解决的复杂点，然后才能对比自己的业务复杂点，参考复杂点相似的方案。 其次，遵循这条准则能够让“老鸟”架构师有的放矢，而不是贪大求全。技术人员往往都希望自己能够做出最牛的东西，架构师也不例外，尤其是一些“老鸟”架构师，为了证明自己的技术牛，可能会陷入贪大求全的焦油坑而无法自拔。
例如：“我们的系统一定要做到每秒 TPS 10 万”。
“淘宝的架构是这么做的，我们也要这么做”。
“Docker 现在很流行，我们的架构应该将 Docker 应用进来”。
以上这些想法，如果拿“架构设计是为了解决软件复杂度”这个原则来衡量，就很容易判断。
“我们的系统一定要做到每秒 TPS 10 万” —如果系统的复杂度不是在性能这部分，TPS 做到 10 万并没有什么用。 “淘宝的架构是这么做的，我们也要这么做” —淘宝的架构是为了解决淘宝业务的复杂度而设计的，淘宝的业务复杂度并不就是我们的业务复杂度，绝大多数业务的用户量都不可能有淘宝那么大。 “Docker 现在很流行，我们的架构应该将 Docker 应用进来 —Docker 不是万能的，只是为了解决资源重用和动态分配而设计的，如果我们的系统复杂度根本不是在这方面，引入 Docker 没有什么意义。 ...</p>
  </div>
  <footer class="entry-footer">8 min&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to 初探架构设计" href="http://localhost:1313/en/posts/%E5%88%9D%E6%8E%A2%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">golang常见错误之defer和迭代
    </h2>
  </header>
  <div class="entry-content">
    <p>defer 解析 作用域 向 defer 关键字传入的函数会在函数返回之前运行。假设我们在 for 循环中多次调用 defer 关键字： 1 2 3 4 5 6 7 8 9 10 11 12 func main() { for i := 0; i &lt; 5; i&#43;&#43; { defer...</p>
  </div>
  <footer class="entry-footer">4 min&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to golang常见错误之defer和迭代" href="http://localhost:1313/en/posts/defergoroutine%E8%BF%AD%E4%BB%A3/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">golang并发编程
    </h2>
  </header>
  <div class="entry-content">
    <p>预备知识 unsafe.Pointer unsafe.Pointer 是一种特殊意义的指针，它可以包含任意类型的地址，有点类似于 C 语言里的 void* 指针，全能型的。
对unsafe.Pointer 又爱又恨，你会有效使用它吗？
unsafe 是关注 Go 程序操作类型安全的包。
unsafe.Pointer 可以让你无视 Go 的类型系统，完成任何类型与内建的 uintptr 类型之间的转化。根据文档，unsafe.Pointer 可以实现四种其他类型不能的操作：
任何类型的指针都可以转化为一个 unsafe.Pointer 一个 unsafe.Pointer 可以转化成任何类型的指针 一个 uintptr 可以转化成一个 unsafe.Pointer 一个 unsafe.Pointer 可以转化成一个 uintptr 两种只能借助 unsafe 包才能完成的操作：
使用 unsafe.Pointer 实现两种类型间转换 使用 unsafe.Pointer 处理系统调用。 CAS比较并交换—-Compare And Swap Go 的一个 CAS 操作使用场景
在并发执行的多个 routine R1,R2…Rn 的中，同一时间只允许唯一一个 routine 执行某一个操作，并且其他 routine 需要非阻塞的知道自己无权操作并返回的时候，可以使用 CAS 操作。 大方向：任务编排用 Channel，共享资源保护用传统并发原语
互斥锁实现机制 使用互斥锁，限定临界区只能同时由一个线程持有。
临界区 在并发编程中，如果程序中的一部分会被并发访问或修改，那么，为了避免并发访问导致的意想不到的结果，这部分程序需要被保护起来，这部分被保护起来的程序，就叫做临界区。 在 Go 标准库中，它提供了 Mutex 来实现互斥锁这个功能。
共享资源。并发地读写共享资源，会出现数据竞争（data race）的问题，所以需要 Mutex、RWMutex 这样的并发原语来保护。 任务编排。需要 goroutine 按照一定的规律执行，而 goroutine 之间有相互等待或者依赖的顺序关系，我们常常使用 WaitGroup 或者 Channel 来实现。 消息传递。信息交流以及不同的 goroutine 之间的线程安全的数据交流，常常使用 Channel 来实现。 ...</p>
  </div>
  <footer class="entry-footer">22 min&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to golang并发编程" href="http://localhost:1313/en/posts/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">golang中的nil
    </h2>
  </header>
  <div class="entry-content">
    <p>深入理解golang中的nil nil is (a) zero 什么是零值（zero value） 1 2 3 4 5 6 7 8 9 10 11 12 // go中的零值 bool -&gt; false numbers -&gt; 0 string -&gt; &#34;&#34; pointers -&gt; nil // point to nothing...</p>
  </div>
  <footer class="entry-footer">2 min&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to golang中的nil" href="http://localhost:1313/en/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3golang%E4%B8%AD%E7%9A%84nil/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">云计算和云原生概念浅析
    </h2>
  </header>
  <div class="entry-content">
    <p>云计算定义 一种能够跨网络、按需提供基础架构、服务、平台和应用的交付方式，正在快速取代原本通过硬布线连接进行资源共享的方式。 – redhat
云计算解决的问题主要是物理资源上云，通过虚拟化技术来将底层资源池化，达到弹性、可控等目的。然而大多数传统应用并不是面向云环境来构建的，这里面包含了大量开发需求（开发框架、类库、后段服务等），就导致了云端的强大能力没有被完全发挥出来。因此，摒弃传统的应用技术架构，基于云的特点重新构建云原生应用，成为企业上云的下一个阶段。 特点 云计算是指在云中运行工作负载，而云是一种能够抽象、汇集和共享整个网络中的可扩展资源的 IT 环境。云计算和云本身都不属于技术的范畴。
云计算是指在云中运行工作负载的功能。 而云是一种环境，是运行应用的地方。 技术则是指用于构建和使用云的软件和硬件 云计算为云原生提供了物理基础，做个不太精确的比喻:“云计算是电脑硬件，云原生是应用”.
云原生 公有云，私有云和混和云 根据服务模式对云计算的分类包括：基础设施作为服务（iaas），平台作为服务（paas），软件作为服务（saas）。 根据云计算的资源归属对象，它可以分为公共云和私有云两大类。
公共云（公共云）是一种向公众提供计算资源的服务。一般通过互联网使用，成本低，公共云的核心属性是共享资源服务。公共云的优点是低成本和良好的可扩展性。缺点是用户对云资源、数据安全、网络性能和匹配等问题缺乏控制。 私有云是为拥有基础设施并控制如何在其上部署应用程序的单个客户而构建的。用户可以在企业数据中心防火墙或安全托管站点中部署私有云。私有云的核心属性是专有资源。 混合云不是一个独立的概念。它是一种混合云服务模式，通过标准化手段或专有技术将公共和私人云结合起来。简单地说，混合云是一种云服务模式，既有公共云，也有私人云。 ...</p>
  </div>
  <footer class="entry-footer">9 min&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to 云计算和云原生概念浅析" href="http://localhost:1313/en/posts/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%92%8C%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Golang指针详解
    </h2>
  </header>
  <div class="entry-content">
    <p>Golang指针 原文来自:https://www.cnblogs.com/-wenli/p/12682477.html
*类型:普通指针类型，用于传递对象地址，不能进行指针运算。 unsafe.Pointer:通用指针类型，用于转换不同类型的指针，不能进行指针运算，不能读取内存存储的值（必须转换到某一类型的普通指针）。 uintptr:用于指针运算，GC 不把 uintptr 当指针，uintptr 无法持有对象。uintptr 类型的目标会被回收。 unsafe.Pointer 是桥梁，可以让任意类型的指针实现相互转换，也可以将任意类型的指针转换为 uintptr 进行指针运算。 unsafe.Pointer 不能参与指针运算，比如你要在某个指针地址上加上一个偏移量，Pointer是不能做这个运算的，那么谁可以呢?
就是uintptr类型了，只要将Pointer类型转换成uintptr类型，做完加减法后，转换成Pointer，通过*操作，取值，修改值，随意。 小结 unsafe.Pointer 可以让你的变量在不同的普通指针类型转来转去，也就是表示为任意可寻址的指针类型。而 uintptr 常用于与 unsafe.Pointer 打配合，用于做指针运算。
unsafe.Pointer unsafe 是关注 Go 程序操作类型安全的包。
unsafe.Pointer 可以让你无视 Go 的类型系统，完成任何类型与内建的 uintptr 类型之间的转化。
unsafe.Pointer称为通用指针，官方文档对该类型有四个重要描述：
（1）任何类型的指针都可以被转化为Pointer
（2）Pointer可以被转化为任何类型的指针
（3）uintptr可以被转化为Pointer
（4）Pointer可以被转化为uintptr
unsafe.Pointer是特别定义的一种指针类型（译注：类似C语言中的void类型的指针），在golang中是用于各种指针相互转换的桥梁，它可以包含任意类型变量的地址。 当然，我们不可以直接通过*p来获取unsafe.Pointer指针指向的真实变量的值，因为我们并不知道变量的具体类型。 和普通指针一样，unsafe.Pointer指针也是可以比较的，并且支持和nil常量比较判断是否为空指针。
uintptr uintptr是一个整数类型。
1 2 3 // uintptr is an integer type that is large enough to hold the bit pattern of // any pointer. type uintptr uintptr 即使uintptr变量仍然有效，由uintptr变量表示的地址处的数据也可能被GC回收，这个需要注意！
unsafe包 unsafe包只有两个类型，三个函数，但是功能很强大。
1 2 3 4 5 type ArbitraryType int type Pointer *ArbitraryType func Sizeof(x ArbitraryType) uintptr func Offsetof(x ArbitraryType) uintptr func Alignof(x ArbitraryType) uintptr ArbitraryType是int的一个别名，在Go中对ArbitraryType赋予特殊的意义。代表一个任意Go表达式类型。 Pointer是int指针类型的一个别名，在Go中可以把Pointer类型，理解成任何指针的父类型。 三个函数的参数均是ArbitraryType类型，就是接受任何类型的变量。
unsafe.Sizeof 接受任意类型的值(表达式)，返回其占用的字节数,这和c语言里面不同，c语言里面sizeof函数的参数是类型，而这里是一个表达式，比如一个变量。 unsafe.Offsetof：返回结构体中元素所在内存的偏移量。 Alignof 返回变量对齐字节数量Offsetof返回变量指定属性的偏移量，这个函数虽然接收的是任何类型的变量，但是有一个前提，就是变量要是一个struct类型，且还不能直接将这个struct类型的变量当作参数，只能将这个struct类型变量的属性当作参数。 ...</p>
  </div>
  <footer class="entry-footer">8 min&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to Golang指针详解" href="http://localhost:1313/en/posts/go-%E6%99%AE%E9%80%9A%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8Bunsafe.pointeruintptr%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">golang的组合和嵌套（面向接口编程）
    </h2>
  </header>
  <div class="entry-content">
    <p>官方关于golang的继承和重载的FAQ 原文部分来自：https://segmentfault.com/a/1190000022429780
关于类型继承 面向对象的编程，至少在最著名的语言中，涉及对类型之间关系的过多讨论，这些关系通常可以自动派生。Go 采取了不同的方法。
与其要求程序员提前声明两种类型是相关的，在 Go 中，类型会自动满足任何指定其方法子集的接口。除了减少簿记之外，这种方法还有真正的优势。类型可以同时满足多个接口，没有传统多重继承的复杂性。接口可以是非常轻量级的——具有一个甚至零个方法的接口可以表达一个有用的概念。如果出现新想法或用于测试，可以事后添加接口——无需注释原始类型。因为类型和接口之间没有明确的关系，所以没有要管理或讨论的类型层次结构。
可以使用这些想法来构建类似于类型安全的 Unix 管道的东西。例如，了解如何fmt.Fprintf 为任何输出启用格式化打印，而不仅仅是文件，或者bufio包如何与 文件 I/O 完全分离，或者image包如何生成压缩图像文件。所有这些想法都源于io.Writer表示单个方法 ( Write)的单个接口( )。而这只是皮毛。Go 的接口对程序的结构有着深远的影响。
这需要一些时间来适应，但这种隐式的类型依赖是 Go 最高效的事情之一。
​	–faq: https://golang.org/doc/faq#inheritance
关于重载的定义 如果不需要进行类型匹配，则方法分派会得到简化。使用其他语言的经验告诉我们，拥有多种名称相同但签名不同的方法有时很有用，但在实践中也可能会令人困惑和脆弱。仅按名称匹配并要求类型的一致性是 Go 类型系统中一个主要的简化决定。
关于运算符重载，它似乎更方便而不是绝对要求。同样，没有它，事情会更简单。
​	– faq:https://golang.org/doc/faq#overloading
从一个案例引入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 type ShapeInterface interface { Area() float64 GetName() string PrintArea() } type Shape struct { name string } func (s *Shape) GetName() string { return s.name } func (s *Shape) Area() float64 { return 0.0 } func (s *Shape) PrintArea() { fmt.Printf(&#34;%s : Area %v\r\n&#34;, s.GetName(), s.Area()) } // Rectangle 矩形求面积 type Rectangle struct { Shape w, h float64 } func (r *Rectangle) Area() float64 { return r.w * r.h } // Circle 圆形 : 重新定义 Area 和PrintArea 方法 type Circle struct { Shape r float64 } func (c *Circle) Area() float64 { return c.r * c.r * math.Pi } func (c *Circle) PrintArea() { fmt.Printf(&#34;%s : Area %v\r\n&#34;, c.GetName(), c.Area()) } func main() { s := Shape{name: &#34;Shape&#34;} c := Circle{Shape: Shape{name: &#34;Circle&#34;}, r: 10} r := Rectangle{Shape: Shape{name: &#34;Rectangle&#34;}, w: 5, h: 4} listshape := []ShapeInterface{&amp;s, &amp;c, &amp;r} for _, si := range listshape { si.PrintArea() //!! 猜猜哪个Area()方法会被调用 !! } } out: Shape : Area 0 Circle : Area 314.1592653589793 Rectangle : Area 0 // 为啥这里没有调用 5 * 4 原因分析：Rectangle通过组合Shape获得的PrintArea()方法并没有去调用Rectangle实现的Area()方法，而是去调用了Shape的Area()方法。Circle是因为自己重写了PrintArea()所以在方法里调用到了自身的Area()。
...</p>
  </div>
  <footer class="entry-footer">5 min&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to golang的组合和嵌套（面向接口编程）" href="http://localhost:1313/en/posts/golang%E7%9A%84%E7%BB%84%E5%90%88%E5%92%8C%E5%B5%8C%E5%A5%97/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/en/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:1313/en/page/3/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:1313/en/">Luenci</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
