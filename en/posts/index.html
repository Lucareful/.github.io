<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Luenci</title>
<meta name=keywords content><meta name=description content="Posts - Luenci"><meta name=author content="Luenci"><link rel=canonical href=https://luenci.me/en/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://luenci.me/images/L.png><link rel=icon type=image/png sizes=16x16 href=https://luenci.me/images/L.png><link rel=icon type=image/png sizes=32x32 href=https://luenci.me/images/L.png><link rel=apple-touch-icon href=https://luenci.me/L.png><link rel=mask-icon href=https://luenci.me/L.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://luenci.me/en/posts/index.xml><link rel=alternate hreflang=en href=https://luenci.me/en/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://luenci.me/en/posts/"><meta property="og:site_name" content="(〃'▽'〃)"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://luenci.me/en/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://luenci.me/en/ accesskey=h title="Luenci (Alt + H)"><img src=https://luenci.me/images/avatar.jpg alt aria-label=logo height=35>Luenci</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://luenci.me/en/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://luenci.me/en/posts title=📚文章><span class=active>📚文章</span></a></li><li><a href=https://luenci.me/en/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://luenci.me/en/archives title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://luenci.me/en/tags title=🔖标签><span>🔖标签</span></a></li><li><a href=https://luenci.me/en/about title=🙋🏻‍♂️关于><span>🙋🏻‍♂️关于</span></a></li><li><a href=https://luenci.me/en/links title=🤝友链><span>🤝友链</span></a></li><li><a href=https://luenci.me/en/index.xml title=🪧RSS><span>🪧RSS</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://luenci.me/en/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Golang pprof 性能分析指南</h2></header><div class=entry-content><p>Golang pprof 性能分析指南 pprof 是一个用于可视化和分析分析数据的工具。
采样方式 方式名称 如何使用 优点 缺点 使用场景 runtime/pprof 手动调用【runtime.StartCPUProfile、runtime.SweightCPUProfile】等API来进行数据的采集。采集程序（非 Server）的指定区块的运行数据进行分析。 灵活性高、按需采集。 工具型应用（比如说定制化的分析小工具、集成到公司监控系统）。这种应用运行一段时间就结束。 net/http/pprof 通过http服务来获取Profile采样文件。 import _ "net/http/pprof"。基于 HTTP Server 运行，并且可以采集运行时数据进行分析。net/http/pprof中只是使用runtime/pprof包来进行封装了一下，并在http端口上暴露出来 简单易用 在线服务（一直运行着的程序） go test 通过命令go test -bench . -cpuprofile cpu.prof来进行采集数据。 针对性强、细化到函数 进行某函数的性能测试 指标解释 常用指标如下：
allocs：所有时刻的内存使用情况，包括正在使用的及已经回收的
block：导致在同步原语上发生阻塞的堆栈跟踪
cmdline： 当前程序的命令行的完整调用路径。
goroutine：目前的 goroutine 数量及运行情况
heap：当前时刻的内存使用情况
mutex：查看导致互斥锁的竞争持有者的堆栈跟踪
profile：默认进行 30s 的 CPU Profiling，得到一个分析用的 profile 文件
threadcreate：查看创建新 OS 线程的堆栈跟踪。
trance：当前程序执行的追踪，可以在秒数的 GET 参数中指定持续时间。在获取追踪文件后，请使用 go 工具的 trace 命令来调查追踪。（深入浅出 Go trace (qq.com)）
注意，默认情况下是不追踪block和mutex的信息的，如果想要看这两个信息，需要在代码中加上两行：
1 2 runtime.SetBlockProfileRate(1) // 开启对阻塞操作的跟踪，block runtime.SetMutexProfileFraction(1) // 开启对锁调用的跟踪，mutex ​ 注意，上文的所有信息都是实时的，如果你刷新一下，是可以看到数字在变化的。此时如果点击蓝色的连接，可以看到一些协程的栈信息，这些信息并不容易阅读。如果想要更加清晰的数据，需要将信息保存下来，在本地进行分析。
...</p></div><footer class=entry-footer><span title='2024-08-03 00:00:00 +0000 UTC'>2024-08-03</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;3033 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Golang pprof 性能分析指南" href=https://luenci.me/en/posts/golang-pprof-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>声明式和命令式编程</h2></header><div class=entry-content><p>声明式和命令式编程 声明式(declarative)是结果导向的，命令式(imperative)是过程导向的
命令式编程：命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。 声明式编程：告诉“机器”你想要的是什么(what)，让机器想出如何去做(how)。 声明式编程和命令式编程的代码例子 ​ 举个简单的例子，假设我们想让一个数组里的数值翻倍。 我们用命令式编程风格实现，像下面这样：
1 2 3 4 5 6 7 8 9 10 11 var numbers = [1,2,3,4,5] var doubled = [] for(var i = 0; i &lt; numbers.length; i++) { var newNumber = numbers[i] * 2 doubled.push(newNumber) } console.log(doubled) //=> [2,4,6,8,10] ​ 我们直接遍历整个数组，取出每个元素，乘以二，然后把翻倍后的值放入新数组，每次都要操作这个双倍数组，直到计算完所有元素。
而使用声明式编程方法，我们可以用 Array.map 函数，像下面这样：
1 2 3 4 5 6 7 var numbers = [1,2,3,4,5] var doubled = numbers.map(function(n) { return n * 2 }) console.log(doubled) //=> [2,4,6,8,10] ​ map 利用当前的数组创建了一个新数组，新数组里的每个元素都是经过了传入map的函数(这里是function(n) { return n*2 })的处理。
​ map函数所作的事情是将直接遍历整个数组的过程归纳抽离出来，让我们专注于描述我们想要的是什么(what)。注意，我们传入map的是一个纯函数；它不具有任何副作用(不会改变外部状态)，它只是接收一个数字，返回乘以二后的值。
​ 在一些具有函数式编程特征的语言里，对于list数据类型的操作，还有一些其他常用的声明式的函数方法。例如，求一个list里所有值的和，命令式编程会这样做：
1 2 3 4 5 6 7 8 9 var numbers = [1,2,3,4,5] var total = 0 for(var i = 0; i &lt; numbers.length; i++) { total += numbers[i] } console.log(total) //=> 15 而在声明式编程方式里，我们使用 reduce 函数：
1 2 3 4 5 6 7 var numbers = [1,2,3,4,5] var total = numbers.reduce(function(sum, n) { return sum + n }); console.log(total) //=> 15 ​ reduce 函数利用传入的函数把一个 list 运算成一个值。它以这个函数为参数，数组里的每个元素都要经过它的处理。每一次调用，第一个参数(这里是sum)都是这个函数处理前一个值时返回的结果，而第二个参数(n)就是当前元素。这样下来，每此处理的新元素都会合计到sum中，最终我们得到的是整个数组的和。
​ 同样，reduce 函数归纳抽离了我们如何遍历数组和状态管理部分的实现，提供给我们一个通用的方式来把一个 list 合并成一个值。我们需要做的只是指明我们想要的是什么
...</p></div><footer class=entry-footer><span title='2024-07-03 00:00:00 +0000 UTC'>2024-07-03</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;3491 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to 声明式和命令式编程" href=https://luenci.me/en/posts/%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%92%8C%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8B/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>golang的coredump调试入门</h2></header><div class=entry-content><p>core dump 概念 ​ core dump文件实际上是进程在某个时间点时的内存映像，当时进程使用的内存是啥样就会被原样保存下来存在文件系统的某个位置上，这个时间点一般是触发了SIGSEGV或者SIGABRT这两个信号的时候，当进程的内存映像保存完毕后进程就会异常终止，也就是大家喜闻乐见的“程序崩了”和“段错误：核心已转储”。
​ 因此 coredump 就像是程序出错崩溃后的“第一现场”，是用来排查错误的主要资源。
golang 程序生成 coredump 方法 设置环境变量和在代码里调用相关的标准库接口
​ 在这之前先用ulimit命令检测下系统当前能不能生成coredump：
1 2 $ ulimit -c unlimited ​ 如果是unlimited就表示可以，如果是0那就不会生成，需要修改ulimit的设置。
修改GOTRACEBACK环境变量 ​ GOTRACEBACK是用来控制panic发生时golang程序行为的，值是字符串，具体内容如下：
值 行为 none 不打印任何堆栈跟踪信息，不过崩溃的原因和哪行代码触发的panic还是会打印 single 只打印当前正在运行的触发panic的goroutine的堆栈以及runtime的堆栈；如果panic是runtime里发出的，则打印所有goroutine的堆栈跟踪信息 all 打印所有用户创建的goroutine的堆栈信息（不包含runtime的） system 在前面all的基础上把runtime相关的所有协程的堆栈信息也一起打印出来 crash 打印的内容和前面system一样，但还会额外生成对应操作系统上的 coredump 文件 ​ 将这个环境变量设置成crash就可以获得信息最全面的coredump文件。
设置编译参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( "fmt" "math/rand" ) func main() { arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} for { index := rand.Intn(11) fmt.Println(arr[index]) } } 1 go build -gcflags="all=-N -l" main.go ...</p></div><footer class=entry-footer>4 min&nbsp;·&nbsp;1511 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to golang的coredump调试入门" href=https://luenci.me/en/posts/golang%E7%9A%84coredump%E8%B0%83%E8%AF%95%E5%85%A5%E9%97%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>我的编程、热爱、生活</h2></header><div class=entry-content><p>我的编程、热爱、生活 ​ 2016年八月份的一个下午，高考选完专业（计算机科学与技术）后，我在笔记本上敲下了第一个 “九九乘法表” 的 c 语言程序。当控制台输出熟悉的点阵数字的时候，我的编程生涯从就这一刻就开始了。
...</p></div><footer class=entry-footer><span title='2024-07-05 00:00:00 +0000 UTC'>2024-07-05</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;1627 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to 我的编程、热爱、生活" href=https://luenci.me/en/posts/%E6%88%91%E7%9A%84%E7%BC%96%E7%A8%8B%E7%83%AD%E7%88%B1%E7%94%9F%E6%B4%BB/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>golang 构造方法入参出参最佳实践</h2></header><div class=entry-content><p>对上层保持简洁，对下层保持抽象 概念 接口 ​ 在 Golang 中，接口是一组方法签名。 当类型为接口中的所有方法提供定义时，它被称为实现接口。 它与 OOP(面向对...</p></div><footer class=entry-footer><span title='2024-06-28 00:00:00 +0000 UTC'>2024-06-28</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;2491 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to golang 构造方法入参出参最佳实践" href=https://luenci.me/en/posts/golang-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%85%A5%E5%8F%82%E5%87%BA%E5%8F%82%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>浅谈Python垃圾回收机制</h2></header><div class=entry-content><p>目前垃圾回收比较通用的解决办法有三种，引用计数，标记清除以及分代回收。 引用计数 引用计数也是一种最直观，最简单的垃圾收集技术。 在 Python 中，大多数对...</p></div><footer class=entry-footer><span title='2024-07-07 00:00:00 +0000 UTC'>2024-07-07</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;4744 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to 浅谈Python垃圾回收机制" href=https://luenci.me/en/posts/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>VictoriaMetricsn 原理入门</h2></header><div class=entry-content><p>VictoriaMetricsn 原理入门 简介 VictoriaMetrics，是一个快速高效、经济并且可扩展的监控解决方案和时序数据库。
​ 谈到VictoriaMetrics就必须要提到Prometheus，VictoriaMetrics是一个新兴的监控解决方案。它借助Prometheus强大的exporter生态、成熟的规范、服务发现等优点等，融入到Prometheus生态中。VictoriaMetrics官网很多兼容Prometheus参数解释都是直接跳转到Prometheus官网。
​ VictoriaMetrics可以作为Prometheus的长期远程存储方案，当然 VictoriaMetrics 也可以完全取代 Prometheus，因为 VictoriaMetrics 基本支持 Prometheus配置文件、PromQL、各类API、数据格式等等。
VictoriaMetrics 优点 远程存储：可作为单一或多个Prometheus的远程存储 安装简单：单节点架构一条命令就可以部署完毕（集群方式稍微复杂一些，但也很好理解） 兼容性：PromQL兼容和增强的MetricsQL Grafana兼容：VM可替换Grafana的Prometheus数据源（经测试，线上数据源直接替换后100%兼容） 低内存：更低的内存占用，官方对比Prometheus，可以释放7倍左右内存空间（线上对比大概4倍） 高压缩比：提供存储数据高压缩，官方说可以比Prometheus减少7倍的存储空间（线上对比大概是4~5倍） 高性能：查询性能比Prometheus更快 支持水平扩容&amp;HA：基于VM集群版实现 支持多租户：主要针对集群版 VictoriaMetrics 缺点 图形化做的不好，虽然有vmui，但功能很少 告警功能需要单独配置vmalert，而且vmalert只有api管理和查看，暂时没用图形界面 没有类似Prometheus的WAL日志，突然故障可能会丢失部分数据 ...</p></div><footer class=entry-footer><span title='2024-06-24 00:00:00 +0000 UTC'>2024-06-24</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;2797 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to VictoriaMetricsn 原理入门" href=https://luenci.me/en/posts/victoriametricsn-%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Redis五个使用场景</h2></header><div class=entry-content><p>Redis五个使用场景 原文转自：https://www.jdon.com/69107.html 1.缓存 最常见的用例是利用 Redis 进行缓存。这有助于...</p></div><footer class=entry-footer><span title='2024-07-11 00:00:00 +0000 UTC'>2024-07-11</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;364 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Redis五个使用场景" href=https://luenci.me/en/posts/redis%E4%BA%94%E4%B8%AA%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>what-happens-when（浏览器一次请求的历程）</h2></header><div class=entry-content><p>what-happens-when（浏览器一次请求的历程） 原文来自：alex/what-happens-when: An attempt to answer the age old interview question “What happens when you...</p></div><footer class=entry-footer><span title='2024-06-20 00:00:00 +0000 UTC'>2024-06-20</span>&nbsp;·&nbsp;19 min&nbsp;·&nbsp;9336 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to what-happens-when（浏览器一次请求的历程）" href=https://luenci.me/en/posts/what-happens-when/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Prometheus 概念入门</h2></header><div class=entry-content><p>Prometheus 概念入门 数据模型 ​ Prometheus 所有采集的监控数据均以指标（metric）的形式保存在内置的时间序列数据库当中（TSDB）：属于同一指标名称，同一标签集合的、有时间戳标记的数据流。除了存储的时间序列，Prometheus 还可以根据查询请求产生临时的、衍生的时间序列作为返回结果。
指标名称和标签 每一条时间序列由指标名称（Metrics Name）以及一组标签（键值对）唯一标识。其中指标的名称（metric name）可以反映被监控样本的含义（例如，http_requests_total — 表示当前系统接收到的 HTTP 请求总量），指标名称只能由 ASCII 字符、数字、下划线以及冒号组成，同时必须匹配正则表达式 [a-zA-Z_:][a-zA-Z0-9_:]*。
[info] 注意
冒号用来表示用户自定义的记录规则，不能在 exporter 中或监控对象直接暴露的指标中使用冒号来定义指标名称。
通过使用标签，Prometheus 开启了强大的多维数据模型：对于相同的指标名称，通过不同标签列表的集合，会形成特定的度量维度实例（例如：所有包含度量名称为 /api/tracks 的 http 请求，打上 method=POST 的标签，就会形成具体的 http 请求）。该查询语言在这些指标和标签列表的基础上进行过滤和聚合。改变任何度量指标上的任何标签值（包括添加或删除指标），都会创建新的时间序列。
标签的名称只能由 ASCII 字符、数字以及下划线组成并满足正则表达式 [a-zA-Z_][a-zA-Z0-9_]*。其中以 __ 作为前缀的标签，是系统保留的关键字，只能在系统内部使用。标签的值则可以包含任何 Unicode 编码的字符。
样本 在时间序列中的每一个点称为一个样本（sample），样本由以下三部分组成：
指标（metric）：指标名称和描述当前样本特征的 labelsets； 时间戳（timestamp）：一个精确到毫秒的时间戳； 样本值（value）： 一个 folat64 的浮点型数据表示当前样本的值。 ...</p></div><footer class=entry-footer><span title='2024-06-15 00:00:00 +0000 UTC'>2024-06-15</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;3087 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Prometheus 概念入门" href=https://luenci.me/en/posts/prometheus-%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>夜莺监控入门</h2></header><div class=entry-content><p>引子 监控系统必要性 ​ 作为运维者，第一个接触的基本上是监控平台，各种各样的监控，看各种各样的指标，好像没有监控就觉得不正常，那么为什么需要监控呢？
预防故障，例如当磁盘空间增长到一定的程度的时候，就会产生故障，这个时候监控系统的作用就是当达到一个阀值的时候，发出告警，然后进行处理。 预测变化趋势，例如我的分布式文件系统，每天数据增长1T空间，那么我总共有多少空间，剩余空间大小，是否要进行扩容等操作。 当故障发生的时候，能提供给我基本信息给与我排查的思路，例如redis不可读，是否能看到是哪个实例，能看到相关的日志信息，能测试是否刻读写，能查看哪个是master。 监控系统关键指标，例如对于web服务器来说，响应速度，来判断是否中间件有问题，是否数据库有问题，还是网络有问题；活跃的用户数，每天我的网站有多少用户访问；有多少新注册的用户。 简介 ​ 夜莺监控（ Nightingale ）是一款国产、开源云原生监控分析系统，采用 All-In-One 的设计，集数据采集、可视化、监控告警、数据分析于一体。于 2020 年 3 月 20 日，在 github 上发布 v1 版本，已累计迭代 60 多个版本。从 v5 版本开始与 Prometheus、VictoriaMetrics、Grafana、Telegraf、Datadog 等生态紧密协同集成，提供开箱即用的企业级监控分析和告警能力，已有众多企业选择将 Prometheus + AlertManager + Grafana 的组合方案升级为使用夜莺监控。夜莺监控，由滴滴开发和开源，并于 2022 年 5 月 11 日，捐赠予中国计算机学会开源发展委员会（CCF ODC），为 CCF ODC 成立后接受捐赠的第一个开源项目。夜莺监控的核心开发团队，也是Open-Falcon项目原核心研发人员。
产品介绍 开箱即用：支持 Docker、Helm Chart、云服务等多种部署方式；集数据采集、监控告警、可视化为一体；内置多种监控仪表盘、快捷视图、告警规则模板，导入即可快速使用；大幅降低云原生监控系统的建设成本、学习成本、使用成本 云原生：以交钥匙的方式快速构建企业级的云原生监控体系，支持 Categraf、Telegraf、Grafana-agent 等多种采集器，支持 Prometheus、VictoriaMetrics、M3DB、ElasticSearch 等多种数据库，兼容支持导入 Grafana 仪表盘，与云原生生态无缝集成 专业告警：可视化的告警配置和管理，支持丰富的告警规则，提供屏蔽规则、订阅规则的配置能力，支持告警多种送达渠道，支持告警自愈、告警事件管理等 灵活扩展、中心化管理：夜莺监控，可部署在 1 核 1G 的云主机，可在上百台机器集群化部署，可运行在 K8s 中；也可将时序库、告警引擎等组件下沉到各机房、各 Region，兼顾边缘部署和中心化统一管理，解决数据割裂，缺乏统一视图的难题 高性能、高可用：得益于夜莺的多数据源管理引擎，和夜莺引擎侧优秀的架构设计，借助于高性能时序库，可以满足数亿时间线的采集、存储、告警分析场景，节省大量成本；夜莺监控组件均可水平扩展，无单点，已在上千家企业部署落地，经受了严苛的生产实践检验 ​ Nightingale 可以接收各种采集器上报的监控数据，转存到时序库（可以支持Prometheus、M3DB、VictoriaMetrics、Thanos等），并提供告警规则、屏蔽规则、订阅规则的配置能力，提供监控数据的查看能力，提供告警自愈机制（告警触发之后自动回调某个webhook地址或者执行某个脚本），提供历史告警事件的存储管理、分组查看的能力。
...</p></div><footer class=entry-footer><span title='2024-06-10 00:00:00 +0000 UTC'>2024-06-10</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;4640 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to 夜莺监控入门" href=https://luenci.me/en/posts/%E5%A4%9C%E8%8E%BA%E7%9B%91%E6%8E%A7%E5%85%A5%E9%97%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>k8s 核心组件介绍</h2></header><div class=entry-content><p>Etcd 储存核心实现 ​ Eted 集群是分布式KV存储集群，提供了可靠的强一致性服务发现。Etcd 集群存储 Kubernetes 系统的集群状态和元数据，其中包括所有 Kubemetes 资源对象信...</p></div><footer class=entry-footer><span title='2024-06-08 00:00:00 +0000 UTC'>2024-06-08</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;1204 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to k8s 核心组件介绍" href=https://luenci.me/en/posts/k8s%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%80/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>kustomize 介绍</h2></header><div class=entry-content><p>kustomize 介绍 kustomize 是一个通过 kustomization 文件定制 kubernetes 对象的工具，它可以通过一些资源生成一些新的资源，也可以定制不同的资源的集合。 kustomize 术语 kustomization kustomization 指的是 kustomization.yaml 文件，或者指的是...</p></div><footer class=entry-footer><span title='2024-05-28 00:00:00 +0000 UTC'>2024-05-28</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;2060 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to kustomize 介绍" href=https://luenci.me/en/posts/kustomize%E4%BB%8B%E7%BB%8D/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Prometheus 入门实操</h2></header><div class=entry-content><p>Prometheus 入门实操 参考文章：Prometheus监控Linux主机 - 吕振江 - 博客园 (cnblogs.com) 安装 1 2 3 4 5 6 7 8 9 # 下载 wget https://github.com/prometheus/prometheus/releases/download/v2.44.0/prometheus-2.44.0.linux-amd64.tar.gz # 解压 tar zxf prometheus-2.44.0.linux-amd64.tar.gz # 移动 mv prometheus-2.24.1.linux-amd64/* /usr/local/prometheus # 将本机...</p></div><footer class=entry-footer>2 min&nbsp;·&nbsp;656 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Prometheus 入门实操" href=https://luenci.me/en/posts/prometheus-%E5%85%A5%E9%97%A8%E5%AE%9E%E6%93%8D/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>k8s核心数据结构（2）</h2></header><div class=entry-content><p>K8s 核心数据结构（2） 参考书籍：《Kubernetes源码剖析-郑旭东著》
Kubernetes 内置资源概览 资源组 资源种类 说明 apiextensions.k8s.io CustomResourceDefinition 自定义资源类型 ， 由 APIExtensions Server 负责管理该资源类型 apiregistration.k8s.io APIService 聚合资源类型，由 AggregatorServer 负责管理该资源类 admissionregistration.k8s.io MutatingWebhookConfiguration 变更准入控制器资源类型( Webhook) ValidatingWebhookConfiguration 验证准入控制器资源类型 ( Webhook) apps ControllerRevision 记录资源对象所有的历史版本的资源类型 DaemonSet 在 Pod 资源对象的基础上提供守护进程的资源类型 Deployment 在 Pod资源对象的基础上提供支持无状态服务的资源类型 ReplicaSet 在 Pod 资源对象的基础上提供一组 Pod 副本的资源类型 StatefulSet 在 Pod资源对象的基础上提供支持有状态服务的资源类型 auditregistration.k8s.io AuditSink 审计资源类型 authentication.k8s.io TokenReview 认证资源类型 authorization.k8s.io LocalSubjectAccessReview 授权检查用户是否可以在指定的命名空间中执行操作 SelfSubjectAccessReview 授权检查用户是否可以执行操作(若不指定 spec.namespace，则在所有的命名空间中执行操作） SelfSubjectRulesReview 授权枚举用户可以在指定的命名空间中执行一组操作 SubjectAccessReview 授 权检查用户是否可以执行操作 autoscaling HorizontalPodAutoscaler 在 Pod 资源对象的基础上提供水平自动伸缩资源类型 batch Job 提供一次性任务的资源类型 CronJob 提供定时任务的资源类型 certificates.k8s.io CertificateSigningRequest 提供证书管理的资源类型 coordination.k8s.io Leases 提供领导者选举机制的资源类型 core ComponentStatus 该资源类型已被奔用，其用于提供获取 Kuberetes 组件运行状况的资源类型 ConfigMap 提供容器内应用程序配置管理的资源类型 Endpoints 提供将外部服务器映射为内部服务的资源类型 Event 提供 Kubernetes 集群事件管理的资源类型 LimitRange 为命名空间中的每种资源对象设置资源(硬件资源)使 用限制 Namespace 提供资源对象所在的命名空间的资源类型 Node 提供 Kubernetes 集群中管理工作节点的资源类型。每个节点都有一个唯一标识符 PersistentVolume 提供 PV 存储的资源类型 PersistentVolumeClaim 提供 PVC 存储的资源类型 Pod 提供容器集合管理的资源类型 PodTemplate 提供用于描述预定义 Pod 资源对象副本数模板的资源类型 ReplicationController 在 Pod资源对象的基础上提供副本数保持不变的资源类型 ResourceQuota 提供每个命名空间配额限制的资源类型 Secret 提供存储密码 、Token 、密钥等敏感数据的资源类型 Service 提供负载均衡器为 Pod 资源对象的代理服务的资源类型 ServiceAccount 提供 ServiceAccount 认证的资源类型 events.k8s.io Event 提供Kuberetes集群事件管理的资源类型 networking.k8s.io RuntimeClass 提供容器运行时功能的资源类型 Ingress 提供 从Kubernetes 集群外部访问集群内部服务管理的资源类型 node.k8s.io RuntimeClass 提供容器运行时功能的资源类型 policy Evictions 在 Pod 资源对象的基础上提供驱逐策略的资源类型 PodDisruptionBudget 提供限制同时中断 Pod 的数量 ，以保证集群的高可用性 PodSecurityPolicy 提供控制 Pod 资源安全相关策略的资源类型 rbac.authorization.k8s.io ClusterRole 提供 RBAC 集群角色的资源类型 ClusterRoleBinding 提供 RBAC 集群角色鄉定的资源类型 Role 提供 RBAC 角色的资源类型 RoleBinding 提供 RBAC 角色绑定的资源类型 scheduling.k8s.io PriorityClass 提供 Pod 资源对象优先级管理的资源类型 settings.k8s.10 PodPreset 在创建 Pod 资源对象时，可以将特定信息注入 Pod 资源对象中 storage.k8s.io StorageClass 提供动态设置PV存储参数的资源类 VolumeAttachment 供触发 CSI ControllerPublish 和 ControllerUnpublish 操作的资源类型 ...</p></div><footer class=entry-footer><span title='2024-05-20 00:00:00 +0000 UTC'>2024-05-20</span>&nbsp;·&nbsp;24 min&nbsp;·&nbsp;11761 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to k8s核心数据结构（2）" href=https://luenci.me/en/posts/k8s%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://luenci.me/en/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><script src=https://sdk.jinrishici.com/v2/browser/jinrishici.js></script><script type=text/javascript>jinrishici.load(function(e){var t=document.querySelector(".poem_sentence"),n=document.querySelector(".poem_info");t.innerHTML=e.data.content,n.innerHTML="—— "+e.data.origin.author})</script><span><a id=running-time></a><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container><link rel=stylesheet href=//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css>👁️‍🗨️访客人数: <span id=busuanzi_value_site_uv></span>|
🌐访问量: <span id=busuanzi_value_site_pv></span></span></span><br><span>&copy; 2024 <a href=https://luenci.me/en/>Luenci</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a> 📖
<text class=poem_sentence></text><text class=poem_info></text></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})});const RunningTimerInterval=1e3,StartTime=new Date("10/11/2018 00:00:00");function prefixZero(e){return e<10&&(e="0"+e),e}function updateTime(){const r=new Date;let e=r.getTime()-StartTime.getTime();const t=24*60*60*1e3,n=Math.floor(e/t);e-=n*t;const s=60*60*1e3,o=Math.floor(e/s);e-=o*s;const i=60*1e3,a=Math.floor(e/i);e-=a*i;const c=Math.floor(e/1e3),l=document.getElementById("running-time");l.innerText="🕚: "+n+"天"+prefixZero(o)+"小时"+prefixZero(a)+"分"+prefixZero(c)+"秒"}document.addEventListener("DOMContentLoaded",()=>{let e=setInterval(updateTime,RunningTimerInterval)})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>