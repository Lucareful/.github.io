<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | Luenci</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - Luenci">
<meta name="author" content="Luenci">
<link rel="canonical" href="https://Lucareful.github.io/en/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://Lucareful.github.io/images/L.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://Lucareful.github.io/images/L.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://Lucareful.github.io/images/L.png">
<link rel="apple-touch-icon" href="https://Lucareful.github.io/L.png">
<link rel="mask-icon" href="https://Lucareful.github.io/L.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://Lucareful.github.io/en/posts/index.xml">
<link rel="alternate" hreflang="en" href="https://Lucareful.github.io/en/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://Lucareful.github.io/en/posts/" /><meta property="og:site_name" content="(〃&#39;▽&#39;〃)" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://Lucareful.github.io/en/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://Lucareful.github.io/en/" accesskey="h" title="Luenci (Alt + H)">
                <img src="https://Lucareful.github.io/images/avatar.jpg" alt="" aria-label="logo"
                    height="35">Luenci</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://Lucareful.github.io/en/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://Lucareful.github.io/en/posts" title="📚文章">
                    <span class="active">📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://Lucareful.github.io/en/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://Lucareful.github.io/en/archives" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://Lucareful.github.io/en/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://Lucareful.github.io/en/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
            <li>
                <a href="https://Lucareful.github.io/en/links" title="🤝友链">
                    <span>🤝友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://Lucareful.github.io/en/">Home</a></div>
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">k8s核心数据结构（1）
    </h2>
  </header>
  <div class="entry-content">
    <p>Kubernetes 核心数据结构（1） 参考书籍：《Kubernetes源码剖析-郑旭东著》
K8s 是一个完全以资源为中心的系统
Group、Version、Resource 核心数据结构 ​	Kuberetes 系统虽然有相当复杂和众多的 功能，但它本质 上是一个资源控制系统——注册、管理、调度资源 并维护资源的状态。
​	Kuberetes 将资源再次分组和版本化，形成 Group（资源组）、Version（资源版本）、Resource（资源）
Group: 被称为资源组，在Kubernetes API Server 中也可称其为 APIGroup。 Version: 被称为资源版本，在Kubernetes API Server 中也可称其为 APIVersions。 Resource: 被称为资源，在Kubernetes API Server 中也可称其为 APIResource。 Kind: 资源种类，描述 Resource 的种类，与 Resource 为同一级别。 ​
​	Kubernetes 系统支持多个Group，每个Group 支持多个Version，每个Version 支 持多个Resource，其中部分资源同时会拥有自己的子资源(即SubResource )。例如， Deployment资源拥有Status 子资源。 ​	资源组、资源版本、资源、子资源的完整表现形式&lt;group&gt;/&lt;version&gt;/&lt;resource&gt;/ &lt;subresource&gt;。以常用的 Deployment 资源为例，其完整表现形式为apps/v1/deployments/status
​	另外资源对象(Resource Object )在本书中也是 一个常用概念，由“ 资源组&#43; 资源版本&#43;资源种类” 组成，并在实例化后表达一个资源对象，例如 Deployment 资源实例化后拥有资源组、资源版本及资源种类，其表现形式为&lt;group&gt;/&lt;version&gt;, Kind=&lt;kind&gt;，例如apps/v1, Kind=Deployment.
​	每一个资源都拥有一定数量的资源操作方法(即 Verbs )，资源操作方法用于 Etcd 集群存储中对资源对象的增、删、改、查操作。目前 Kubemetes 系统支持8 种资源操作方法，分别是 create、delete、delete、collection、get、list、patch、update、watch 操作方法。
​	每一个资源都至少有两个版本，分别是外部版本(External Version)和内部版本 ( Internal Version )。外部版本用于对外暴露给用户请求的接又所使用的资源对象。内部版本不对外暴露，仅在Kubernetes API Server 内部使用。
​	Kubernetes 资源也可分为两种， 分别是Kubernetes Resource (Kubermetes 内罝资源 ) 和 Custom Resource( 自 定 义 资 源 )。 开 发 者 通 过 C R D ( 即 Custom Resource Definitions )可实现自定义资源，它允许用户将自己定义的资源添加到 Kubernetes 系统中，并像使用 Kubernetes 内置资源 一样使用它们。
...</p>
  </div>
  <footer class="entry-footer">19 min&nbsp;·&nbsp;9050 words&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to k8s核心数据结构（1）" href="https://Lucareful.github.io/en/posts/k8s%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">k8s架构介绍
    </h2>
  </header>
  <div class="entry-content">
    <p>K8s 架构 参考文章：Kubernetes源码剖析
架构概览 ​	Kubernetes 系统架构遵循客户端 / 服务端 （ C/S ） 架构 ， 系统架构分为 Master 和 Node 两部分 ， Master 作为服务端 ， Node 作为客户端 。 Kubernetes 系统具有多个 Master 服务端 ， 可以实现高可用 。 在默认的情况下 ， 一个 Master 服务端即可完成所有工作 。
服务端也被称为主控节点 ， 它在集群中主要负责如下任务 。
集群的 “ 大脑 ” ， 负责管理所有节点 (Node）。 负责调度 Pod 在哪些节点上运行 。 负责控制集群运行过程中的所有状态 。 Node 客户端也被称为工作节点 ， 它在集群中主要负责如下任务 。
负责管理所有容器 （ container ) 。 负责监控 / 上报所有 Pod 的运行状态 。 组件概览 ...</p>
  </div>
  <footer class="entry-footer">8 min&nbsp;·&nbsp;3734 words&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to k8s架构介绍" href="https://Lucareful.github.io/en/posts/k8s%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">GO 三方库源码阅读姿势
    </h2>
  </header>
  <div class="entry-content">
    <p>GO 三方库源码阅读姿势 参考内容：极客专栏：手把手带你写一个web框架
阅读顺序 库函数 &gt; 结构定义 &gt; 结构函数。
​	简单来说，就是当你在阅读一个代码库的时候，不应该从上到下阅读整个代码文档，而应 该先阅读整个代码库提供的对外库函数(function)，再读这个库提供的结构 (struct/class)，最后再阅读每个结构函数(method)
查看库函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 go doc net/http(三方库名称) | grep &#34;^func&#34; func CanonicalHeaderKey(s string) string func DetectContentType(data []byte) string func Error(w ResponseWriter, error string, code int) func Get(url string) (resp *Response, err error) func Handle(pattern string, handler Handler) func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) func Head(url string) (resp *Response, err error) func ListenAndServe(addr string, handler Handler) error func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser func NewRequest(method, url string, body io.Reader) (*Request, error) func NewRequestWithContext(ctx context.Context, method, url string, body io.Reader) (*Request, error) func NotFound(w ResponseWriter, r *Request) func ParseHTTPVersion(vers string) (major, minor int, ok bool) func ParseTime(text string) (t time.Time, err error) func Post(url, contentType string, body io.Reader) (resp *Response, err error) func PostForm(url string, data url.Values) (resp *Response, err error) func ProxyFromEnvironment(req *Request) (*url.URL, error) func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error) func ReadRequest(b *bufio.Reader) (*Request, error) func ReadResponse(r *bufio.Reader, req *Request) (*Response, error) func Redirect(w ResponseWriter, r *Request, url string, code int) func Serve(l net.Listener, handler Handler) error func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, ...) func ServeFile(w ResponseWriter, r *Request, name string) func ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error func SetCookie(w ResponseWriter, cookie *Cookie) func StatusText(code int) string ​	在这个库提供的方法中，我们去掉一些 New 和 Set 开头的函数，因为你从命名上可以看出，这些函数是对某个对象或者属性的设置。
剩下的函数大致可以分成三类:
为服务端提供创建 HTTP 服务的函数，名字中一般包含 Serve 字样，比如 Serve、 ServeFile、ListenAndServe 等。
为客户端提供调用 HTTP 服务的类库，以 HTTP 的 method 同名，比如 Get、Post、 Head 等。
提供中转代理的一些函数，比如 ProxyURL、ProxyFromEnvironment 等。
查看结构定义(模块) ​	我们过一遍这个库提供的所有 struct，看看核心模块有哪些，同样使用 go doc:
1 go doc net/http | grep &#34;^type&#34;| grep struct ​	可以看到整个库最核心的几个结构:
1 2 3 4 5 6 7 8 9 10 type Client struct{ ... } type Cookie struct{ ... } type MaxBytesError struct{ ... } type ProtocolError struct{ ... } type PushOptions struct{ ... } type Request struct{ ... } type Response struct{ ... } type ServeMux struct{ ... } type Server struct{ ... } type Transport struct{ ... } 看结构的名字或者 go doc 查看结构说明文档，能逐渐了解它们的功能:
Client 负责构建 HTTP 客户端;
Server 负责构建 HTTP 服务端;
ServerMux 负责 HTTP 服务端路由;
Transport、Request、Response、Cookie 负责客户端和服务端传输对应的不同模块。
​	现在通过库方法(function)和结构体(struct)，我们对整个库的结构和功能有大致印象 了。整个库承担了两部分功能，一部分是构建 HTTP 客户端，一部分是构建 HTTP 服务 端。
​	构建的 HTTP 服务端除了提供真实服务之外，也能提供代理中转服务，它们分别由 Client 和 Server 两个数据结构负责。除了这两个最重要的数据结构之外，HTTP 协议的每个部 分，比如请求、返回、传输设置等都有具体的数据结构负责。
...</p>
  </div>
  <footer class="entry-footer">3 min&nbsp;·&nbsp;1271 words&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to GO 三方库源码阅读姿势" href="https://Lucareful.github.io/en/posts/go%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%A7%BF%E5%8A%BF/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Tekton 入门
    </h2>
  </header>
  <div class="entry-content">
    <p>Tekton 入门 术语解释 Cloud Native ​	云原生是一种软件开发方法，其中应用程序被分解为微服务，这些微服务被打包到容器中，容器在云中动态编排以优化资源利用
Continuous Delivery ​	持续交付是一种软件开发实践，团队可以安全、快速、可持续地向用户发布软件变更。
Tekton ​	Tekton 是一个用于创建持续交付系统的开源 kubernetes 原生的框架。你可以使用 tekton 跨多个云提供商或混合环境构建，测试和部署。Tekton 通过抽象出复杂的kubenetes概念和实现细节来简化应用程序管理。它提供了用于声明持续交付管道的 Kubernetes 自定义资源。
基本构建块 其中Task、TaskRun、Pipeline、PipelineRun、PipelineResource、Condition作为其核心CRD，这里主要介绍它们。
Task： 定义构建任务，它由一系列有序steps构成。每个step可以定义输入和输出，且可以将上一个step的输出作为下一个step的输入。每个step都会由一个container来执行。
是 Tekton 中不可分割的最小单位，正如同 Pod 在 Kubernetes 中的概念一样 TaskRun： Task用于定义具体要做的事情，并不会真正的运行，而TaskRun就是真正的执行者，并且会提供执行所需需要的参数，一个TaskRun就是一个Pod。
Pipeline： 顾名思义就是流水线，它由一系列Tasks组成。就像Task中的step一样，上一个Task的输出可以作为下一个Task的输入。
PipelineRun： Pipeline的实际执行，创建后会创建Pod来执行Task，一个PipelineRun中有多个Task。
PipelineResource： 主要用于定义Pipeline的资源，常见的如Git地址、Docker镜像等。
Condition： 它主要是在Pipeline中用于判断的，Task的执行与否通过Condition的判断结果来决定。
Tips： PipelineResource和Condition都会被废弃。但是在低版本中还是会继续使用，所以这里会简单介绍一下。
...</p>
  </div>
  <footer class="entry-footer">4 min&nbsp;·&nbsp;1828 words&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to Tekton 入门" href="https://Lucareful.github.io/en/posts/tekton-%E5%85%A5%E9%97%A8/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">分布式12问
    </h2>
  </header>
  <div class="entry-content">
    <p>分布式12问 原文转载自：分布式夺命12连问 (qq.com) 分布式理论 1. 说说CAP原则？ CAP原则又称CAP定理，指的是在一个分布式系统中，Consiste...</p>
  </div>
  <footer class="entry-footer">22 min&nbsp;·&nbsp;10996 words&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to 分布式12问" href="https://Lucareful.github.io/en/posts/%E5%88%86%E5%B8%83%E5%BC%8F12%E9%97%AE/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">CMDB 介绍
    </h2>
  </header>
  <div class="entry-content">
    <p>CMDB介绍 CMDB含义 CMDB代表配置管理数据库，通常被称为任何ITSM系统的心脏。
​	简而言之，CMDB是一个存储库，用于存储有关构成IT基础架构的组件的信息。 这些组件通常称为CI（可配置项）。 据ITIL称，CI是为交付IT服务而需要进行管理的任何资产。
通常，CMDB包括CI的列表，它们的属性以及它们之间的关系。
CMDB的核心功能之一是支持服务管理流程，主要包括：事件，问题，变更，发布和资产管理。
...</p>
  </div>
  <footer class="entry-footer">5 min&nbsp;·&nbsp;2475 words&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to CMDB 介绍" href="https://Lucareful.github.io/en/posts/cmdb%E4%BB%8B%E7%BB%8D/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">回溯算法和LRU
    </h2>
  </header>
  <div class="entry-content">
    <p>回溯算法实现（DFS） 回溯算法其实就是我们常说的 DFS 算法，本质上就是一种暴力穷举算法 递归遍历二叉树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def...</p>
  </div>
  <footer class="entry-footer">2 min&nbsp;·&nbsp;592 words&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to 回溯算法和LRU" href="https://Lucareful.github.io/en/posts/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%92%8Clru/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Django的logger配置
    </h2>
  </header>
  <div class="entry-content">
    <p>Django日志配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 LOGGING = { &#39;version&#39;: 1, &#39;disable_existing_loggers&#39;: False, &#39;formatters&#39;: { &#39;verbose&#39;: { &#39;format&#39;: &#39;%(levelname)s %(asctime)s %(pathname)s %(module)s %(lineno)s %(process)d %(thread)d %(message)s&#39; } }, &#39;loggers&#39;: { &#39;django&#39;: { &#39;handlers&#39;: [&#39;default&#39;], &#39;propagate&#39;: True, &#39;level&#39;: &#39;DEBUG&#39;, &#39;filters&#39;: [&#39;special&#39;] } }, &#39;handlers&#39;: { &#39;default&#39;: { &#39;level&#39;: &#39;DEBUG&#39;, &#39;class&#39;: &#39;logging.handlers.RotatingFileHandler&#39;, &#39;filename&#39;: &#39;/var/logs/django/default.log&#39;, &#39;maxBytes&#39;: 1024 * 1024 * 5, &#39;backupCount&#39;: 5, &#39;formatter&#39;: &#39;verbose&#39;, &#39;filters&#39;: [&#39;special&#39;] } }, &#39;filters&#39;: { # 过滤器 &#39;special&#39;: { # 使用自定义的web.my_logging.ContextFilter，别名special，可以接受其他的参数 &#39;()&#39;: &#39;web.my_logging.ContextFilter&#39; } }, } 配置分析说明 version 保留字。
disable_existing_loggers 是否禁用已经存在的logger实例。
如果LOGGING 中的disable_existing_loggers 键为True（默认值），那么默认配置中的所有logger 都将禁用。
Logger 的禁用与删除不同；logger 仍然存在，但是将默默丢弃任何传递给它的信息，也不会传播给上一级logger。所以，你应该非常小心使用&#39;disable_existing_loggers&#39;: True；它可能不是你想要的。你可以设置disable_existing_loggers 为False，并重新定义部分或所有的默认loggers；或者你可以设置LOGGING_CONFIG 为 None，并 自己处理logging 配置。
Logging 的配置属于Django setup() 函数的一部分。所以，你可以肯定在你的项目代码中logger 是永远可用的。
formatters 定义输出的日志格式。 常用的格式化属性：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 %(name)s Logger的名字 %(levelname)s 文本形式的日志级别 %(message)s 用户输出的消息 %(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒 %(levelno)s 数字形式的日志级别 %(pathname)s 调用日志输出函数的模块的完整路径名，可能没有 %(filename)s 调用日志输出函数的模块的文件名 %(module)s 调用日志输出函数的模块名 %(funcName)s 调用日志输出函数的函数名 %(lineno)d 调用日志输出函数的语句所在的代码行 %(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示 %(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数 %(thread)d 线程ID。可能没有 %(threadName)s 线程名。可能没有 %(process)d 进程ID。可能没有 其他格式化属性请参 LogRecord attributes
...</p>
  </div>
  <footer class="entry-footer">4 min&nbsp;·&nbsp;1840 words&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to Django的logger配置" href="https://Lucareful.github.io/en/posts/django%E7%9A%84logger/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Linux 网络模型
    </h2>
  </header>
  <div class="entry-content">
    <p>linux 网络模型 概念说明 在进行解释之前，首先要说明几个概念：
用户空间和内核空间 进程切换 进程的阻塞 文件描述符 缓存 I/O 用户空间与内核空间 ​	现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。
​	针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间。
而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。
进程切换 ​	为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。
从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：
保存处理机上下文，包括程序计数器和其他寄存器。 更新PCB信息。 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。 选择另一个进程执行，并更新其PCB。 更新内存管理的数据结构。 恢复处理机上下文。 总而言之就是很耗资源，具体的可以参考这篇文章：进程切换
进程的阻塞 ​	正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。
文件描述符fd ​	文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。
​	文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。
缓存 I/O ​	缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的**页缓存（ page cache ）**中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。
缓存 I/O 的缺点： 数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。
IO拷贝 DMA 负责内核间的 IO 传输，CPU 负责内核和应用间的 IO 传输。
更多详情见：一文彻底揭秘操作系统之「零拷贝」！ - 腾讯云开发者社区-腾讯云 (tencent.com)
CPU COPY ​	通过计算机的组成原理我们知道, 内存的读写操作是需要 CPU 的协调数据总线,地址总线和控制总线来完成的因此在&#34;拷贝&#34;发生的时候,往往需要 CPU 暂停现有的处理逻辑,来协助内存的读写，这种我们称为 CPU COPY。CPU COPY 不但占用了 CPU 资源,还占用了总线的带宽。
DMA COPY ​	DMA(DIRECT MEMORY ACCESS) 是现代计算机的重要功能，它有一个重要特点：当需要与外设进行数据交换时, CPU 只需要初始化这个动作便可以继续执行其他指令,剩下的数据传输的动作完全由DMA来完成可以看到 DMA COPY 是可以避免大量的 CPU 中断的
...</p>
  </div>
  <footer class="entry-footer">21 min&nbsp;·&nbsp;10038 words&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to Linux 网络模型" href="https://Lucareful.github.io/en/posts/linux-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">鸭子类型介绍
    </h2>
  </header>
  <div class="entry-content">
    <p>鸭子类型 定义 鸭子类型（英语：duck typing）在程序设计中是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或...</p>
  </div>
  <footer class="entry-footer">6 min&nbsp;·&nbsp;2634 words&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to 鸭子类型介绍" href="https://Lucareful.github.io/en/posts/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">RESTful风格
    </h2>
  </header>
  <div class="entry-content">
    <p>RESTful设计方法 原文参考自哔哩哔哩: https://www.bilibili.com/video/BV1k5411p7Kp 1. 域名 应该尽量将API部署在专用域名之下。 1 https://api.example.com 如果确定API很简单，不会有进一步扩展，可以考虑放...</p>
  </div>
  <footer class="entry-footer">5 min&nbsp;·&nbsp;2182 words&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to RESTful风格" href="https://Lucareful.github.io/en/posts/restful%E9%A3%8E%E6%A0%BC%E4%BB%8B%E7%BB%8D/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">同源和跨域
    </h2>
  </header>
  <div class="entry-content">
    <p>原文:同源策略、跨域解决方案 一、同源策略 1、先来说说什么是源 • 源（origin）就是协议、域名和端口号。 以上url中的源就是：http://...</p>
  </div>
  <footer class="entry-footer">3 min&nbsp;·&nbsp;1051 words&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to 同源和跨域" href="https://Lucareful.github.io/en/posts/%E5%85%B3%E4%BA%8E%E8%B7%A8%E5%9F%9F%E5%92%8C%E5%90%8C%E6%BA%90/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Django信号量初探
    </h2>
  </header>
  <div class="entry-content">
    <p>django的信号量 原文链接:https://juejin.cn/post/6844903674049724424
一、关于django信号量 Django包含一个&#34;信号调度程序&#34;，它有助于在框架中的其他位置发生操作时通知分离的应用程序。简而言之，信号允许某些发送者通知一组接收器已经发生了某些动作。当许多代码可能对同一事件感兴趣时，它们特别有用.
二、django中内置的信号量 1、Model的信号量
pre_init # django的modal执行其构造方法前，自动触发
post_init # django的modal执行其构造方法后，自动触发
pre_save # django的modal对象保存前，自动触发
post_save # django的modal对象保存后，自动触发
pre_delete # django的modal对象删除前，自动触发
post_delete # django的modal对象删除后，自动触发
m2m_changed # django的modal中使用m2m字段操作第三张表（add,remove,clear）前后，自动触发
class_prepared # 程序启动时，检测已注册的app中modal类，对于每一个类，自动触发
1 2 3 4 5 6 7 8 from django.db.models.signals import class_prepared from django.db.models.signals import pre_init from django.db.models.signals import post_init from django.db.models.signals import pre_save from django.db.models.signals import post_save from django.db.models.signals import pre_delete from django.db.models.signals import post_delete from django.db.models.signals import m2m_changed 2、Management的信号量
pre_migrate # 执行migrate命令前，自动触发
post_migrate # 执行migrate命令后，自动触发
1 2 from django.db.models.signals import pre_migrate from django.db.models.signals import post_migrate 3、Request/Response的信号量
request_started # 请求到来前，自动触发
request_finished # 请求结束后，自动触发
got_request_exception # 请求异常后，自动触发
1 2 3 from django.core.signals import request_finished from django.core.signals import request_started from django.core.signals import got_request_exception 4、Test的信号量
setting_changed # 使用test测试修改配置文件时，自动触发
template_rendered # 使用test测试渲染模板时，自动触发
1 2 from django.test.signals import setting_changed from django.test.signals import template_rendered 5、Database的信号量
connection_created # 创建数据库连接时，自动触发
1 from django.db.backends.signals import connection_created ...</p>
  </div>
  <footer class="entry-footer">4 min&nbsp;·&nbsp;1767 words&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to Django信号量初探" href="https://Lucareful.github.io/en/posts/django%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">行为型模式
    </h2>
  </header>
  <div class="entry-content">
    <p>行为型模式 行为型模式，顾名思义，它主要关注的是对象的责任。
它们关注对象之间的交互以及对象的响应性 对象应该能够交互，同时仍然保持松散耦合 观察者模式 在观察者设计模式中，对象（主题）维护了一个依赖（观察者）列表，以便主题可以使用观察者定义的任何方法通知所有观察者它所发生的变化。
它定义了对象之间的一对多的依赖关系，从而使得一个对象中的任何更改都将自动通知给其他对象 它封装了主题的核心组件 UML图 主题(Subject):类Subject需要了解Observe。Subject类具有许多方法，诸如register()和deregister()等，Observer可以通过这些方法注册到Subject类中。因此，一个Subject可以处理多个Observe。 观察者(Observe)：它为关注主题的对象定义了一个接口。它定义了Observe需要实现的各个方法，以便在主题发生变化时能够获得相应的通知。 具体观察者(ConcreteObserver):它用来保存应该与Subject的状态保持一致的状态。它实现了Observe接口以保持其状态与主题中的变化相一致。 代码案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #!/usr/bin/env python # -*- coding: utf-8 -*- class Subject(object): def __init__(self): self.__observer = [] def register(self, observer): self.__observer.append(observer) def notifyAll(self, *args, **kwargs): for observer in self.__observer: observer.notify(self, *args, **kwargs) class Observer1(object): def __init__(self, subject): subject.register(self) def notify(self, subject, *args): print(f&#34;{type(self).__name__}:: Got, {args} from {subject}&#34;) class Observer2(object): def __init__(self, subject): subject.register(self) def notify(self, subject, *args): print(f&#34;{type(self).__name__}:: Got, {args} from {subject}&#34;) if __name__ == &#39;__main__&#39;: subject = Subject() observer1 = Observer1(subject) observer2 = Observer2(subject) subject.notifyAll(&#34;notify~~~&#34;) 观察者模式的优点和缺点 优点：
它使得彼此交互的对象之间保持送耦合 它使得我们可以在无需对主题或观察者进行任何修改的情况下高效地发送数据到其他对象 可以随时添加/删除观察者 缺点：
观察者接口必须由具体观察者实现，这涉及继承。无法进行组合，因为观察者接口可以实例化 如果实现不当的话，观察者可能会增加复杂性，并导致性能降低 在软件应用程序中，通知有时可能是不可靠的，并导致竞争条件或不一致性 ...</p>
  </div>
  <footer class="entry-footer">11 min&nbsp;·&nbsp;5423 words&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to 行为型模式" href="https://Lucareful.github.io/en/posts/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">结构型模式
    </h2>
  </header>
  <div class="entry-content">
    <p>结构型模式 结构型模式用于设计对象和类的结构，从而使它们之间可以互相协作以获取更大的结构。
结构型模式描述如何将对象和类组合成更大的结构 结构型模式是一种能够简化设计工作的模式，因为它能够找出更简单的方法来认识或表示实体之间的关系。在面向对象世界中，实体指的是对象或类 类模式可以通过继承来描述对象，从而提供更有用的程序接口，而对象模式则描述了如何将对象联系起来从而组合成更大的对象。结构型模式是类和对象模式的综合体 门面设计模式 它为子系统的一组接口提供一个统一的接口，并定义一个高级接口来帮助客户端通过更加简单的方式使用子系统 门面模式解决的问题是，如何用的单个接口对象来表示复杂的子系统。实际上它并不是封装子系统，而是对底层子系统进行组合 它促进了实现与多个客户端的解耦 UML图 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #!/usr/bin/env python # -*- coding: utf-8 -*- class EventManager(object): def __init__(self): print(&#34;Event Manager:: Let me talk to the folks\\n&#34;) def arrange(self): self.hotelier = Hotelier() self.hotelier.bookHotel() self.florist = Florist() self.florist.setFlowerRequirements() self.caterer = Caterer() self.caterer.setCuisine() self.musiccian = Musician() self.musiccian.setMusicType() class Hotelier(object): def __init__(self): print(&#34;Arranging the hotel for Marriage ?&#34;) def __isAvailable(self): print(&#34;Is the Hotel free for the event on given day?&#34;) return True def bookHotel(self): if self.__isAvailable(): print(&#34;Register the Booking \\n\\n&#34;) class Florist(object): def __init__(self): print(&#34;Flower Decorations for the Event ? --&#34;) def setFlowerRequirements(self): print(&#34;Carnations, Rose and Lilies would be used for Decorations\\n\\n&#34;) class Caterer(object): def __init__(self): print(&#34;Food Arrangements for the Event --&#34;) def setCuisine(self): print(&#34;Chinese &amp; Continental Cuisine to be served \\n\\n&#34;) class Musician(object): def __init__(self): print(&#34;Musical Arrangements for the Marriage --&#34;) def setMusicType(self): print() class You(object): def __init__(self): print(&#34;you::whoa Marriage Arrangements !&#34;) def askEventManager(self): print(&#34;you:: Let is Contact the Event Manager\\n\\n&#34;) em = EventManager() em.arrange() def __del__(self): print(&#34;All preparations done!&#34;) if __name__ == &#39;__main__&#39;: you = You() you.askEventManager() out： you::whoa Marriage Arrangements ! you:: Let is Contact the Event Manager Event Manager:: Let me talk to the folks Arranging the hotel for Marriage ? Is the Hotel free for the event on given day? Register the Booking Flower Decorations for the Event ? -- Carnations, Rose and Lilies would be used for Decorations Food Arrangements for the Event -- Chinese &amp; Continental Cuisine to be served Musical Arrangements for the Marriage -- All preparations done! 小结 EventManager类是简化接口的门面 EventManager 通过组合创建子系统对象，如Hotelier，Florist等。 ...</p>
  </div>
  <footer class="entry-footer">7 min&nbsp;·&nbsp;3087 words&nbsp;·&nbsp;Luenci</footer>
  <a class="entry-link" aria-label="post link to 结构型模式" href="https://Lucareful.github.io/en/posts/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://Lucareful.github.io/en/posts/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://Lucareful.github.io/en/posts/page/3/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>
            <a id="running-time"></a>
            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <span id="busuanzi_container">
                <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
                👁️‍🗨️访客人数: <span id="busuanzi_value_site_uv"></span>|
                🌐访问量: <span id="busuanzi_value_site_pv"></span>
            </span>
        </span>
        <br/>
        <span>&copy; 2024 <a href="https://Lucareful.github.io/en/">Luenci</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

    const RunningTimerInterval = 1000;
    const StartTime = new Date("10/11/2018 00:00:00");

    function prefixZero(num)
    {
        if (num < 10)
        {
            num = "0" + num;
        }
        return num;
    }

function updateTime()
{
    const currentTime = new Date();
    let runningTime = currentTime.getTime() - StartTime.getTime();

    const dayMs = 24 * 60 * 60 * 1000;
    const runningDays = Math.floor(runningTime / dayMs);

    runningTime -= runningDays * dayMs;

    const hourMs = 60 * 60 * 1000;
    const runningHours = Math.floor(runningTime / hourMs);

    runningTime -= runningHours * hourMs;

    const minuteMs = 60 * 1000;
    const runningMinutes = Math.floor(runningTime / minuteMs);

    runningTime -= runningMinutes * minuteMs;

    const runningSeconds = Math.floor(runningTime / 1000);

    

    const showTime = document.getElementById("running-time");

    showTime.innerText ="🕚: " +
        runningDays + "天" + prefixZero(runningHours) + "小时" + prefixZero(runningMinutes) + "分" + prefixZero(runningSeconds) + "秒";
    }

    document.addEventListener('DOMContentLoaded', () => { let RunningTimer = setInterval(updateTime, RunningTimerInterval); });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script></body>

</html>
