<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Luenci</title>
<meta name=keywords content><meta name=description content="Posts - Luenci"><meta name=author content="Luenci"><link rel=canonical href=https://luenci.me/en/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://luenci.me/images/L.png><link rel=icon type=image/png sizes=16x16 href=https://luenci.me/images/L.png><link rel=icon type=image/png sizes=32x32 href=https://luenci.me/images/L.png><link rel=apple-touch-icon href=https://luenci.me/L.png><link rel=mask-icon href=https://luenci.me/L.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://luenci.me/en/posts/index.xml><link rel=alternate hreflang=en href=https://luenci.me/en/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://luenci.me/en/posts/"><meta property="og:site_name" content="(〃'▽'〃)"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://luenci.me/en/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://luenci.me/en/ accesskey=h title="Luenci (Alt + H)"><img src=https://luenci.me/images/avatar.jpg alt aria-label=logo height=35>Luenci</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://luenci.me/en/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://luenci.me/en/posts title=📚文章><span class=active>📚文章</span></a></li><li><a href=https://luenci.me/en/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://luenci.me/en/archives title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://luenci.me/en/tags title=🔖标签><span>🔖标签</span></a></li><li><a href=https://luenci.me/en/about title=🙋🏻‍♂️关于><span>🙋🏻‍♂️关于</span></a></li><li><a href=https://luenci.me/en/links title=🤝友链><span>🤝友链</span></a></li><li><a href=https://luenci.me/en/index.xml title=📬RSS><span>📬RSS</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://luenci.me/en/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>golang中的nil</h2></header><div class=entry-content><p>深入理解golang中的nil nil is (a) zero 什么是零值（zero value） 1 2 3 4 5 6 7 8 9 10 11 12 // go中的零值 bool -> false numbers -> 0 string -> "" pointers -> nil // point to nothing...</p></div><footer class=entry-footer>2 min&nbsp;·&nbsp;574 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to golang中的nil" href=https://luenci.me/en/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3golang%E4%B8%AD%E7%9A%84nil/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>云计算和云原生概念浅析</h2></header><div class=entry-content><p>云计算定义 一种能够跨网络、按需提供基础架构、服务、平台和应用的交付方式，正在快速取代原本通过硬布线连接进行资源共享的方式。 – redhat
云计算解决的问题主要是物理资源上云，通过虚拟化技术来将底层资源池化，达到弹性、可控等目的。然而大多数传统应用并不是面向云环境来构建的，这里面包含了大量开发需求（开发框架、类库、后段服务等），就导致了云端的强大能力没有被完全发挥出来。因此，摒弃传统的应用技术架构，基于云的特点重新构建云原生应用，成为企业上云的下一个阶段。 特点 云计算是指在云中运行工作负载，而云是一种能够抽象、汇集和共享整个网络中的可扩展资源的 IT 环境。云计算和云本身都不属于技术的范畴。
云计算是指在云中运行工作负载的功能。 而云是一种环境，是运行应用的地方。 技术则是指用于构建和使用云的软件和硬件 云计算为云原生提供了物理基础，做个不太精确的比喻:“云计算是电脑硬件，云原生是应用”.
云原生 公有云，私有云和混和云 根据服务模式对云计算的分类包括：基础设施作为服务（iaas），平台作为服务（paas），软件作为服务（saas）。 根据云计算的资源归属对象，它可以分为公共云和私有云两大类。
公共云（公共云）是一种向公众提供计算资源的服务。一般通过互联网使用，成本低，公共云的核心属性是共享资源服务。公共云的优点是低成本和良好的可扩展性。缺点是用户对云资源、数据安全、网络性能和匹配等问题缺乏控制。 私有云是为拥有基础设施并控制如何在其上部署应用程序的单个客户而构建的。用户可以在企业数据中心防火墙或安全托管站点中部署私有云。私有云的核心属性是专有资源。 混合云不是一个独立的概念。它是一种混合云服务模式，通过标准化手段或专有技术将公共和私人云结合起来。简单地说，混合云是一种云服务模式，既有公共云，也有私人云。 ...</p></div><footer class=entry-footer>9 min&nbsp;·&nbsp;4212 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to 云计算和云原生概念浅析" href=https://luenci.me/en/posts/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%92%8C%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Golang指针详解</h2></header><div class=entry-content><p>Golang指针 原文来自:https://www.cnblogs.com/-wenli/p/12682477.html
*类型:普通指针类型，用于传递对象地址，不能进行指针运算。 unsafe.Pointer:通用指针类型，用于转换不同类型的指针，不能进行指针运算，不能读取内存存储的值（必须转换到某一类型的普通指针）。 uintptr:用于指针运算，GC 不把 uintptr 当指针，uintptr 无法持有对象。uintptr 类型的目标会被回收。 unsafe.Pointer 是桥梁，可以让任意类型的指针实现相互转换，也可以将任意类型的指针转换为 uintptr 进行指针运算。 unsafe.Pointer 不能参与指针运算，比如你要在某个指针地址上加上一个偏移量，Pointer是不能做这个运算的，那么谁可以呢?
就是uintptr类型了，只要将Pointer类型转换成uintptr类型，做完加减法后，转换成Pointer，通过*操作，取值，修改值，随意。 小结 unsafe.Pointer 可以让你的变量在不同的普通指针类型转来转去，也就是表示为任意可寻址的指针类型。而 uintptr 常用于与 unsafe.Pointer 打配合，用于做指针运算。
unsafe.Pointer unsafe 是关注 Go 程序操作类型安全的包。
unsafe.Pointer 可以让你无视 Go 的类型系统，完成任何类型与内建的 uintptr 类型之间的转化。
unsafe.Pointer称为通用指针，官方文档对该类型有四个重要描述：
（1）任何类型的指针都可以被转化为Pointer
（2）Pointer可以被转化为任何类型的指针
（3）uintptr可以被转化为Pointer
（4）Pointer可以被转化为uintptr
unsafe.Pointer是特别定义的一种指针类型（译注：类似C语言中的void类型的指针），在golang中是用于各种指针相互转换的桥梁，它可以包含任意类型变量的地址。 当然，我们不可以直接通过*p来获取unsafe.Pointer指针指向的真实变量的值，因为我们并不知道变量的具体类型。 和普通指针一样，unsafe.Pointer指针也是可以比较的，并且支持和nil常量比较判断是否为空指针。
uintptr uintptr是一个整数类型。
1 2 3 // uintptr is an integer type that is large enough to hold the bit pattern of // any pointer. type uintptr uintptr 即使uintptr变量仍然有效，由uintptr变量表示的地址处的数据也可能被GC回收，这个需要注意！
unsafe包 unsafe包只有两个类型，三个函数，但是功能很强大。
1 2 3 4 5 type ArbitraryType int type Pointer *ArbitraryType func Sizeof(x ArbitraryType) uintptr func Offsetof(x ArbitraryType) uintptr func Alignof(x ArbitraryType) uintptr ArbitraryType是int的一个别名，在Go中对ArbitraryType赋予特殊的意义。代表一个任意Go表达式类型。 Pointer是int指针类型的一个别名，在Go中可以把Pointer类型，理解成任何指针的父类型。 三个函数的参数均是ArbitraryType类型，就是接受任何类型的变量。
unsafe.Sizeof 接受任意类型的值(表达式)，返回其占用的字节数,这和c语言里面不同，c语言里面sizeof函数的参数是类型，而这里是一个表达式，比如一个变量。 unsafe.Offsetof：返回结构体中元素所在内存的偏移量。 Alignof 返回变量对齐字节数量Offsetof返回变量指定属性的偏移量，这个函数虽然接收的是任何类型的变量，但是有一个前提，就是变量要是一个struct类型，且还不能直接将这个struct类型的变量当作参数，只能将这个struct类型变量的属性当作参数。 ...</p></div><footer class=entry-footer>8 min&nbsp;·&nbsp;3728 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Golang指针详解" href=https://luenci.me/en/posts/go-%E6%99%AE%E9%80%9A%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8Bunsafe.pointeruintptr%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>golang的组合和嵌套（面向接口编程）</h2></header><div class=entry-content><p>官方关于golang的继承和重载的FAQ 原文部分来自：https://segmentfault.com/a/1190000022429780
关于类型继承 面向对象的编程，至少在最著名的语言中，涉及对类型之间关系的过多讨论，这些关系通常可以自动派生。Go 采取了不同的方法。
与其要求程序员提前声明两种类型是相关的，在 Go 中，类型会自动满足任何指定其方法子集的接口。除了减少簿记之外，这种方法还有真正的优势。类型可以同时满足多个接口，没有传统多重继承的复杂性。接口可以是非常轻量级的——具有一个甚至零个方法的接口可以表达一个有用的概念。如果出现新想法或用于测试，可以事后添加接口——无需注释原始类型。因为类型和接口之间没有明确的关系，所以没有要管理或讨论的类型层次结构。
可以使用这些想法来构建类似于类型安全的 Unix 管道的东西。例如，了解如何fmt.Fprintf 为任何输出启用格式化打印，而不仅仅是文件，或者bufio包如何与 文件 I/O 完全分离，或者image包如何生成压缩图像文件。所有这些想法都源于io.Writer表示单个方法 ( Write)的单个接口( )。而这只是皮毛。Go 的接口对程序的结构有着深远的影响。
这需要一些时间来适应，但这种隐式的类型依赖是 Go 最高效的事情之一。
​ –faq: https://golang.org/doc/faq#inheritance
关于重载的定义 如果不需要进行类型匹配，则方法分派会得到简化。使用其他语言的经验告诉我们，拥有多种名称相同但签名不同的方法有时很有用，但在实践中也可能会令人困惑和脆弱。仅按名称匹配并要求类型的一致性是 Go 类型系统中一个主要的简化决定。
关于运算符重载，它似乎更方便而不是绝对要求。同样，没有它，事情会更简单。
​ – faq:https://golang.org/doc/faq#overloading
从一个案例引入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 type ShapeInterface interface { Area() float64 GetName() string PrintArea() } type Shape struct { name string } func (s *Shape) GetName() string { return s.name } func (s *Shape) Area() float64 { return 0.0 } func (s *Shape) PrintArea() { fmt.Printf("%s : Area %v\r\n", s.GetName(), s.Area()) } // Rectangle 矩形求面积 type Rectangle struct { Shape w, h float64 } func (r *Rectangle) Area() float64 { return r.w * r.h } // Circle 圆形 : 重新定义 Area 和PrintArea 方法 type Circle struct { Shape r float64 } func (c *Circle) Area() float64 { return c.r * c.r * math.Pi } func (c *Circle) PrintArea() { fmt.Printf("%s : Area %v\r\n", c.GetName(), c.Area()) } func main() { s := Shape{name: "Shape"} c := Circle{Shape: Shape{name: "Circle"}, r: 10} r := Rectangle{Shape: Shape{name: "Rectangle"}, w: 5, h: 4} listshape := []ShapeInterface{&amp;s, &amp;c, &amp;r} for _, si := range listshape { si.PrintArea() //!! 猜猜哪个Area()方法会被调用 !! } } out: Shape : Area 0 Circle : Area 314.1592653589793 Rectangle : Area 0 // 为啥这里没有调用 5 * 4 原因分析：Rectangle通过组合Shape获得的PrintArea()方法并没有去调用Rectangle实现的Area()方法，而是去调用了Shape的Area()方法。Circle是因为自己重写了PrintArea()所以在方法里调用到了自身的Area()。
...</p></div><footer class=entry-footer>5 min&nbsp;·&nbsp;2140 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to golang的组合和嵌套（面向接口编程）" href=https://luenci.me/en/posts/golang%E7%9A%84%E7%BB%84%E5%90%88%E5%92%8C%E5%B5%8C%E5%A5%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Context 正确使用姿势（推荐）</h2></header><div class=entry-content><p>Context 正确使用姿势 原文参考：https://juejin.cn/post/6844903929340231694
Context 是 immutable（不可变的）
context.Context API 基本上是两类操作：
3个函数用于限定什么时候你的子节点退出； 1个函数用于设置请求范畴的变量 1 2 3 4 5 6 7 8 type Context interface { // 啥时候退出 Deadline() (deadline time.Time, ok bool) Done() &lt;-chan struct{} Err() error // 设置变量 Value(key interface{}) interface{} } 如何创建 Context？ 在 RPC 开始的时候，使用 context.Background() 有些人把在 main() 里记录一个 context.Background()，然后把这个放到服务器的某个变量里，然后请求来了后从这个变量里继承 context。这么做是不对的。直接每个请求，源自自己的 context.Background() 即可。 如果你没有 context，却需要调用一个 context 的函数的话，用 context.TODO() 如果某步操作需要自己的超时设置的话，给它一个独立的 sub-context（如前面的例子） Context 放哪？ 把 Context 想象为一条河流流过你的程序 理想情况下，Context 存在于调用栈（Call Stack） 中 不要把 Context 存储到一个 struct 里 除非你使用的是像 http.Request 中的 request 结构体的方式 request 结构体应该以 Request 结束为生命终止 当 RPC 请求处理结束后，应该去掉对 Context 变量的引用（Unreference） Request 结束，Context 就应该结束。 Context 包的注意事项 要养成关闭 Context 的习惯 特别是 超时的 Contexts 如果一个 context 被 GC 而不是 cancel 了，那一般是你做错了 1 2 ctx, cancel := context.WithTimeout(parentCtx, time.Second * 2) defer cancel()、 使用 Timeout 会导致内部使用 time.AfterFunc，从而会导致 context 在计时器到时之前都不会被垃圾回收。 在建立之后，立即 defer cancel() 是一个好习惯。 ...</p></div><footer class=entry-footer>7 min&nbsp;·&nbsp;3432 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Context 正确使用姿势（推荐）" href=https://luenci.me/en/posts/context%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>聊聊 Wire 依赖注入</h2></header><div class=entry-content><p>Wire 等依赖注入工具旨在简化初始化代码的管理
💡 依赖注入 是一种标准技术，用于生成灵活且松散耦合的代码，通过显式地为组件提供它们工作所需的所有依赖项。
Wire 介绍 参考文章：Golang依赖注入框架wire使用详解_魂影魔宅-CSDN博客_golang wire
Wire 有两个基本概念：提供者(provider)和注入器(Injector)。
官方的定义：
provider: a function that can produce a value. These functions are ordinary Go code.
injector: a function that calls providers in dependency order.
With Wire, you write the injector’s signature, then Wire generates the function’s body.
提供者(provider)：一个可以产生值的函数（通常是构造函数)。这些函数都是普通的 Go 代码 注入器(Injector)：一个按依赖顺序调用提供者的函数。 使用 Wire，您编写注入器(Injector)的签名，然后 Wire 生成函数的主体。
...</p></div><footer class=entry-footer>5 min&nbsp;·&nbsp;2456 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to 聊聊 Wire 依赖注入" href=https://luenci.me/en/posts/%E8%81%8A%E8%81%8Awire%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>defer的妙用之跟踪函数调用链</h2></header><div class=entry-content><p>defer的妙用之跟踪函数调用链 本文参考：Tony Bai 老师的极客时间 《Tony Bai · Go语言第一课》 课程
使用 defer 可以跟踪函数的 执行过程
defer 会预计算参数(表达式进行求值): 详情见 https://luenci.me/2021/08/28/defer&amp;goroutine%E8%BF%AD%E4%BB%A3/#more
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // trace.go package main func Trace(name string) func() { println("enter:", name) return func() { println("exit:", name) } } func foo() { defer Trace("foo")() bar() } func bar() { defer Trace("bar")() } func main() { defer Trace("main")() foo() } out: enter: main enter: foo enter: bar exit: bar exit: foo exit: main 程序的函数调用的全过程一目了然地展现在了我们面前：程序按 main -> foo -> bar的函数调用次序执行，代码在函数的入口与出口处分别输出了跟踪日志。
Go 会对 defer 后面的表达式Trace("foo")()进行求值。由于这个表达式包含一个函数调用Trace("foo")，所以这个函数会被执行。 程序存在的问题
调用 Trace 时需手动显式传入要跟踪的函数名； 如果是并发应用，不同 Goroutine 中函数链跟踪混在一起无法分辨； 输出的跟踪结果缺少层次感，调用关系不易识别； 对要跟踪的函数，需手动调用 Trace 函数 接下来我们一步一步的解决这些问题，来完善我们的函数调用链。
...</p></div><footer class=entry-footer>6 min&nbsp;·&nbsp;2516 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to defer的妙用之跟踪函数调用链" href=https://luenci.me/en/posts/%E8%B7%9F%E8%B8%AA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E9%93%BE/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Golang 并发模型 & Goroutine 详解</h2></header><div class=entry-content><p>Golang 并发模型 & Goroutine 详解 💡 并发不是并行，并发关乎结构，并行关乎执行
操作系统的基本调度与执行单元是进程(process)
操作系统的最小调度单位是线程-线程可作为执行单元可被独立调度到处理器上运行
**CSP( Communicationing Sequential Processes，通信顺序进程)**并发模型 Tony Hoare 的 CSP 模型旨在简化并发程序的编写，让并发程序的编写与编写顺序程序一样简单。Tony Hoare 认为输入输出应该是基本的编程原语，数据处理逻辑(也就是 CSP中的 P)只需调用输入原语获取数据，顺序地处理数据，并将结果数据通过输出原语输出就可以了。因此，在 Tony Hoare 眼中，一个符合 CSP 模型的并发程序应该是一组通过输入输出原语连接起来的 P 的集合。
从这个角度来看，CSP理论不仅是一个并发参考模型，也是一种并发程序的程序组织方法。它的组合思想与 Go 的设计哲学不谋而合。
Tony Hoare 的 CSP 理论中的 P，也就是“Process(进程)”，是一个抽象概念，它代表任何顺序处理逻辑的封装，它获取输入数据(或从其他 P 的输出获取)，并生产出可以被其他 P 消费的输出数据。这里我们可以简单看下 CSP 通信模型的示意图:
注意了，这里的 P 并不一定与操作系统的进程或线程划等号。在 Go 中，与“Process”对 应的是 goroutine。
为了实现 CSP 并发模型中的输入和输出原语，Go 还引入了 goroutine(P)之间的通信原语channel。goroutine 可以从 channel 获取输入数据， 再将处理后得到的结果数据通过 channel 输出。通过 channel 将 goroutine(P)组合连 接在一起，让设计和编写大型并发系统变得更加简单和清晰，我们再也不用为那些传统共 享内存并发模型中的问题而伤脑筋了。
Goroutine 的优势 资源占用小，每个 goroutine 的初始栈大小仅为 2k; 由 Go 运行时而不是操作系统调度，goroutine 上下文切换在用户层完成，开销更小; 在语言层面而不是通过标准库提供。goroutine 由go关键字创建，一退出就会被回收或 销毁，开发体验更佳 语言内置 channel 作为 goroutine 间通信原语，为并发设计提供了强大支撑。 Goroutine 调度器 一个 Go 程序对于操作系统来说只是一个用户层程序，操作系统眼中只有线程，它甚至不知道有一种叫 Goroutine 的事物存在。所以，Goroutine 的调度全要靠 Go 自己完成。那么，实现 Go 程序内 Goroutine 之间“公平”竞争“CPU”资源的任务，就落到了Go 运行时(runtime)头上了。要知道在一个 Go 程序中，除了用户层代码，剩下的就是Go 运行时了。
于是，Goroutine 的调度问题就演变为，Go 运行时如何将程序内的众多 Goroutine，按照一定算法调度到“CPU”资源上运行的问题了。
💡 可是，在操作系统层面，线程竞争的“CPU”资源是真实的物理 CPU，但在 Go 程序层 面，各个 Goroutine 要竞争的“CPU”资源又是什么呢?
Go 程序是用户层程序，它本身就是整体运行在一个或多个操作系统线程上的。所以这个答案就出来了: Goroutine 们要竞争的“CPU”资源就是操作系统线程。这样，Goroutine调度器的任务也就明确了: 将 Goroutine 按照一定算法放到不同的操作系统线程中去执行。 ...</p></div><footer class=entry-footer>6 min&nbsp;·&nbsp;2823 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Golang 并发模型 & Goroutine 详解" href=https://luenci.me/en/posts/golang%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%92%8Cgoroutine-%E8%AF%A6%E8%A7%A3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>关于登录认证这件事</h2></header><div class=entry-content><p>聊聊登录认证这件事 这里介绍的是减少登录页面的编写的方法，比如一个公司中有A，B, C 三个系统，对于用户来说希望是我只需要登录（认证）一次就可以访问A，B，C三个系统，而不是进到A系统在A中登录（认证）一次，进到B系统又要在B中登录（认证）一次，进到C系统还要在C中登录（认证）一次，这样一方面会有重复的编码（A，B，C系统的登录页面逻辑），另一方面对用户来说也是非常不友好。
请区别于对系统中的资源的权限校验
关于LDAP 轻量级目录访问协议 (LDAP) 是一种使应用程序可以快速查询用户信息的协议。
“什么是目录服务？” 目录服务是一个特殊的数据库，用来保存描述性的、基于属性的详细信息，支持过滤功能。 是动态的，灵活的，易扩展的。 如：人员组织管理，电话簿，地址簿。
LDAP介绍 LDAP（Light Directory Access Portocol），它是基于 X.500 标准的轻量级目录访问协议。 目录是一个为查询、浏览和搜索而优化的数据库，它成树状结构组织数据，类似文件目录一样。 目录数据库和关系数据库不同，它有优异的读性能，但写性能差，并且没有事务处理、回滚等复杂功能，不适于存储修改频繁的数据。所以目录天生是用来查询的，就好象它的名字一样。 LDAP目录服务是由目录数据库和一套访问协议组成的系统。
LDAP 登录流程 ...</p></div><footer class=entry-footer>6 min&nbsp;·&nbsp;2889 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to 关于登录认证这件事" href=https://luenci.me/en/posts/%E8%81%8A%E8%81%8A%E7%99%BB%E5%BD%95%E8%AE%A4%E7%9C%9F%E8%BF%99%E4%BB%B6%E4%BA%8B/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>UNIX 系统体系结构</h2></header><div class=entry-content><p>Unix 体系结构 内核：从严格意义来说，可将操作系统（内核）定义为一种软件，它控制计算机硬件资源，提供程序运行环境。 shell: 是一个命令行解释器，它读取用户输入，然后执行命令。 函数 系统调用通常提供一种最小的接口，而库函数通常提供比较复杂的功能。
系统调用：内核的接口。各种版本的Unix实现都提供良好定义、数量有限、直接进入内核的入口点，这些入口点称为系统调用 公用库函数：封装一些功能，库函数可能会包含很多的系统调用 登录 /etc/passwd口令文件中保存这用户的登录相关信息。 由七个以冒号分隔的字段组成：登录名、加密口令、数字用户ID、数字组ID、注释字段、起始目录（/home/sar）、shell程序（/bin/ksh）。 1 2 登录名 加密口令 数字用户ID 数字组ID 注释字段 起始目录 shell程序 root x 0 0 root /root /bin/bash ...</p></div><footer class=entry-footer>5 min&nbsp;·&nbsp;2170 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to UNIX 系统体系结构" href=https://luenci.me/en/posts/unix%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>UNIX 环境高级编程 - 文件和目录</h2></header><div class=entry-content><p>Unix高级编程之文件和目录 文件类型 普通文件（regular file） 这是最常用的文件类型，这种文件包含了某种形式的数据。例如文本文件、二进...</p></div><footer class=entry-footer>1 min&nbsp;·&nbsp;492 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to UNIX 环境高级编程 - 文件和目录" href=https://luenci.me/en/posts/unix%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Runtime:Golang 处理系统调用阻塞方式</h2></header><div class=entry-content><p>Runtime：Golang 处理系统调用阻塞方式 当一个Goroutine由于执行 系统调用 而阻塞时，会将M从GPM中分离出去，然后P再找一个G和M重新执行，避免浪费CPU资源。
前言 什么是 runtime ​ runtime 描述了程序运行时候执行的软件/指令， 在每种语言有着不同的实现。可大可小，在 C 中，runtime 是库代码， 等同于 C runtime library，一系列 C 程序运行所需的函数，在Java中，runtime 还提供了 Java 程序运行所需的虚拟机等。
​ 总而言之，runtime 是一个通用抽象的术语，指的是计算机程序运行的时候所需要的一切代码库，框架，平台等。
Go中的 runtime 在 Go 中， 有一个 runtime 库，其实现了垃圾回收，并发控制， 栈管理以及其他一些 Go 语言的关键特性。 runtime 库是每个 Go 程序的一部分，也就是说编译 Go 代码为机器代码时也会将其也编译进来。所以 Go 官方将其定位偏向类似于 C 语言中的库。Go 中的 runtime 不像 Java runtime （JRE， java runtime envirement ) 一样，jre 还会提供虚拟机， Java 程序要在 JRE 下 才能运行。
所以在 Go 语言中， runtime 只是提供支持语言特性的库的名称，也就是 Go 程序执行时候使用的库。
P的状态切换 ​ 从上图我们可以看出 P 执行系统调用时会执行 entersyscall() 函数（另还有一个类似的阻塞函数 entersyscallblock() ，注意两者的区别）。当系统调用执行完毕切换回去会执行 exitsyscall() 函数，下面我们看一下这两个函数的实现。
...</p></div><footer class=entry-footer>7 min&nbsp;·&nbsp;3310 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Runtime:Golang 处理系统调用阻塞方式" href=https://luenci.me/en/posts/runtimegolang-%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%98%BB%E5%A1%9E%E6%96%B9%E5%BC%8F/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>聊聊分布式事务</h2></header><div class=entry-content><p>聊聊分布式事务 前言 ​ 随着业务的快速发展、业务复杂度越来越高，传统单体应用逐渐暴露出了一些问题，例如开发效率低、可维护性差、架构扩展性差、部署不灵活、健壮性差等等。
​ 微服务架构是一个分布式的系统，按业务进行划分为独立的服务单元，解决单体系统的不足，同时也满足越来越复杂的业务需求。每个微服务仅关注于完成一件任务并很好地完成该任务。
微服务架构的特点 微服务架构的优势非常明显，在近些年迅猛发展。
将复杂的业务拆分成多个小的业务，能够达到更好的业务复用，有利于人员组织分工 服务独立部署，独立扩容，每个服务的修改和部署对其他服务没有影响 每个服务可以根据业务场景选取合适的编程语言和数据库 微服务有以上的优势，但是微服务也带来不少的新问题，例如：
服务数量众多，其测试、部署、监控等都变的更加困难。 单体应用拆分为分布式系统后，进程间的通讯机制和故障处理措施变的更加复杂 系统微服务化后，原先是一个服务内部的本地数据库事务，被拆到了多个服务，需要在分布式环境下保证事务的一致性 上述的各项问题中，1、2都可以通过近几年涌现的各项微服务技术解决，例如Kubernetes提供了服务发现、服务治理等。
因此分布式事务已经成为微服务落地最大的阻碍，也是最具挑战性的一个技术难题。
CAP 理论 一个分布式系统最多只能同时满足 一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。
分布式事务方案 分布式事务模式常见的有XA、TCC、SAGA、可靠消息。
...</p></div><footer class=entry-footer>4 min&nbsp;·&nbsp;1975 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to 聊聊分布式事务" href=https://luenci.me/en/posts/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Golang并发编程最佳实践</h2></header><div class=entry-content><p>Golang 并发编程最佳实践 Goroutine 定义 ​ Goroutines 是与其他函数或方法同时运行的函数或方法。Goroutines 可以被认为是轻量级线程。与线程相比，创建 Goroutine 的成本很小。因此，Go 应用程序通常会同时运行数千个 Goroutine。
Goroutines 相对于线程的优势 与线程相比，Goroutines 非常便宜。它们的堆栈大小只有几 kb，堆栈可以根据应用程序的需要增长和缩小，而在线程的情况下，堆栈大小必须指定并固定。 Goroutine 被多路复用到更少数量的 OS 线程。一个包含数千个 Goroutine 的程序中可能只有一个线程。如果该线程中的任何 Goroutine 阻塞等待用户输入，则创建另一个 OS 线程并将剩余的 Goroutine 移动到新的 OS 线程。所有这些都由运行时处理，我们作为程序员从这些复杂的细节中抽象出来，并获得了一个干净的 API 来处理并发性。 Goroutines 使用通道进行通信。通道通过设计防止在使用 Goroutine 访问共享内存时发生竞争条件。通道可以被认为是 Goroutine 进行通信的管道。 ...</p></div><footer class=entry-footer>8 min&nbsp;·&nbsp;3655 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Golang并发编程最佳实践" href=https://luenci.me/en/posts/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Service Mesh 介绍</h2></header><div class=entry-content><p>Service Mesh 介绍 Service Mesh 是微服务时代的 TCP/IP 协议
​ 一种控制应用程序的不同部分如何相互共享数据的方法。与其他用于管理此通信的系统不同，服务网格是内置于应用中的专用基础结构层。这个可见的基础结构层可以记录应用的不同部分的交互程度（或交互程度），因此随着应用的增长，优化通信和避免停机变得更加容易。 – redhat
​ Buoyant的CEO William Morgan，也就是Service Mesh这个词的发明人，对Service Mesh的定义：
​ 服务网格是一个基础设施层，用于处理服务间通信。云原生应用有着复杂的服务拓扑，服务网格保证请求在这些拓扑中可靠地穿梭。在实际应用当中，服务网格通常是由一系列轻量级的网络代理组成的，它们与应用程序部署在一起，但对应用程序透明。
演化进程 时代0 开发人员想象中，不同服务间通信的方式，抽象表示如下：
时代1：原始通信时代 ​ 然而现实远比想象的复杂，在实际情况中，通信需要底层能够传输字节码和电子信号的物理层来完成，在TCP协议出现之前，服务需要自己处理网络通信所面临的丢包、乱序、重试等一系列流控问题，因此服务实现中，除了业务逻辑外，还夹杂着对网络传输问题的处理逻辑。
...</p></div><footer class=entry-footer>5 min&nbsp;·&nbsp;2198 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Service Mesh 介绍" href=https://luenci.me/en/posts/servicemesh%E6%B5%85%E6%9E%90/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://luenci.me/en/posts/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://luenci.me/en/posts/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><script src=https://sdk.jinrishici.com/v2/browser/jinrishici.js></script><script type=text/javascript>jinrishici.load(function(e){var t=document.querySelector(".poem_sentence"),n=document.querySelector(".poem_info");t.innerHTML=e.data.content,n.innerHTML="—— "+e.data.origin.author})</script><span><a id=running-time></a><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container><link rel=stylesheet href=//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css>👁️‍🗨️访客人数: <span id=busuanzi_value_site_uv></span>|
🌐访问量: <span id=busuanzi_value_site_pv></span></span></span><br><span>&copy; 2024 <a href=https://luenci.me/en/>Luenci</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a> 📖
<text class=poem_sentence></text><text class=poem_info></text></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})});const RunningTimerInterval=1e3,StartTime=new Date("10/11/2018 00:00:00");function prefixZero(e){return e<10&&(e="0"+e),e}function updateTime(){const r=new Date;let e=r.getTime()-StartTime.getTime();const t=24*60*60*1e3,n=Math.floor(e/t);e-=n*t;const s=60*60*1e3,o=Math.floor(e/s);e-=o*s;const i=60*1e3,a=Math.floor(e/i);e-=a*i;const c=Math.floor(e/1e3),l=document.getElementById("running-time");l.innerText="🕚: "+n+"天"+prefixZero(o)+"小时"+prefixZero(a)+"分"+prefixZero(c)+"秒"}document.addEventListener("DOMContentLoaded",()=>{let e=setInterval(updateTime,RunningTimerInterval)})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>