<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.129.0"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Luenci</title>
<meta name="keywords" content="luenci, blog, 技术, 学习, 笔记, 分享">
<meta name="description" content="">
<meta name="author" content="Luenci">
<link rel="canonical" href="http://localhost:1313/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.54405a410796490bc874ab6181fac9b675753cc2b91375d8f882566459eca428.css" integrity="sha256-VEBaQQeWSQvIdKthgfrJtnV1PMK5E3XY&#43;IJWZFnspCg=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Luenci (Alt + H)">Luenci</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Home">
                    <span class="active">Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/index.xml" title="RSS Feed">
                    <span>RSS Feed</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">MySQL数据库引擎和数据类型
    </h2>
  </header>
  <div class="entry-content">
    <p>数据库引擎介绍 前言 1、存储引擎其实就是对于数据库文件的一种存取机制，如何实现存储数据，如何为存储的数据建立索引以及如何更新，查询数据等技术实现的方法。 2、MySQL中的数据用各种不同的技术存储在文件（或内存）中，这些技术中的每一种技术都使用不同的存储机制，索引技巧，锁定水平并且最终提供广泛的不同功能和能力。在MySQL中将这些不同的技术及配套的相关功能称为存储引擎。 3、根据需求可以在表中设置不同的存储引擎。 查看mysql中的引擎 MySQL中常用的几种存储引擎 1．MyISAM存储引擎 存放的位置
MySQL如果使用MyISAM存储引擎，数据库文件类型就包括.frm、.MYD、.MYI，默认存放位置是C:\Documentsand Settings\All Users\Application Data\MySQL\MySQL Server 5.1\data 存放的方式
MyISAM 这种存储引擎不支持事务，不支持行级锁，只支持并发插入的表锁，主要用于高负载的select。 索引的方式
MyISAM也是使用B&#43;tree索引但是和Innodb的在具体实现上有些不同。 该引擎基于ISAM数据库引擎，除了提供ISAM里所没有的索引和字段管理等大量功能，MyISAM还使用一种表格锁定的机制来优化多个并发的读写操作，但是需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间，否则碎片也会随之增加，最终影响数据访问性能。MyISAM还有一些有用的扩展，例如用来修复数据库文件的MyISAMChk工具和用来恢复浪费空间的 MyISAMPack工具。MyISAM强调了快速读取操作，主要用于高负载的select，这可能也是MySQL深受Web开发的主要原因：在Web开发中进行的大量数据操作都是读取操作，所以大多数虚拟主机提供商和Internet平台提供商（Internet Presence Provider, IPP）只允许使用MyISAM格式。
MyISAM类型的表支持三种不同的存储结构：静态型、动态型、压缩型。
静态型：指定义的表列的大小是固定（即不含有：xblob、xtext、varchar等长度可变的数据类型），这样MySQL就会自动使用静态MyISAM格式。使用静态格式的表的性能比较高，因为在维护和访问以预定格式存储数据时需要的开销很低；但这种高性能是以空间为代价换来的，因为在定义的时候是固定的，所以不管列中的值有多大，都会以最大值为准，占据了整个空间。
动态型：如果列（即使只有一列）定义为动态的（xblob, xtext, varchar等数据类型），这时MyISAM就自动使用动态型，虽然动态型的表占用了比静态型表较少的空间，但带来了性能的降低，因为如果某个字段的内容发生改变则其位置很可能需要移动，这样就会导致碎片的产生，随着数据变化的增多，碎片也随之增加，数据访问性能会随之降低。 对于因碎片增加而降低数据访问性这个问题，有两种解决办法：
a、尽可能使用静态数据类型； b、经常使用optimize table table_name语句整理表的碎片，恢复由于表数据的更新和删除导致的空间丢失。如果存储引擎不支持 optimize table table_name则可以转储并 重新加载数据，这样也可以减少碎片； 压缩型：如果在数据库中创建在整个生命周期内只读的表，则应该使用MyISAM的压缩型表来减少空间的占用。
优缺点：MyISAM的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。
2．innoDB存储引擎 存储位置
MySQL如果使用InnoDB存储引擎，数据库文件类型就包括.frm、ibdata1、.ibd，存放位置有两个，.frm文件默认存放位置是C:\Documents and Settings\All Users\ApplicationData\MySQL\MySQL Server 5.1\data，ibdata1、.ibd文件默认存放位置是MySQL安装目录下的data文件夹。 innodb存储引擎的mysql表提供了事务，回滚以及系统崩溃修复能力和多版本迸发控制的事务的安全。
innodb支持自增长列（auto_increment）,自增长列的值不能为空，如果在使用的时候为空的话怎会进行自动存现有的值开始增值，如果有但是比现在的还大，则就保存这个值。
innodb存储引擎支持外键（foreign key） ,外键所在的表称为子表而所依赖的表称为父表。
innodb存储引擎最重要的是支持事务，以及事务相关联功能。
innodb存储引擎支持mvcc的行级锁。
innodb存储引擎索引使用的是B&#43;Tree
优缺点：InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。
...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to MySQL数据库引擎和数据类型" href="http://localhost:1313/articles/1/01/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">MySQL索引和事务
    </h2>
  </header>
  <div class="entry-content">
    <p>索引 索引特点：创建与维护索引会消耗很多时间与磁盘空间，但查询速度大大提高！
在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。
索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。
例如，对于students表：
id class_id name gender score 1 1 小明 M 90 2 1 小红 F 95 3 1 小军 M 88 如果要经常根据score列进行查询，就可以对score列创建索引：
ALTER TABLE students ADD INDEX idx_score (score); 使用ADD INDEX idx_score (score)就创建了一个名称为idx_score，使用列score的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：
ALTER TABLE students ADD INDEX idx_name_score (name, score); 索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如gender列，大约一半的记录值是M，另一半是F，因此，对该列创建索引就没有意义。
可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。
对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。
MySQL索引的类型 1. 普通索引 这是最基本的索引，它没有任何限制，比如上文中为title字段创建的索引就是一个普通索引，MyIASM中默认的BTREE类型的索引，也是我们大多数情况下用到的索引。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 01 –直接创建索引 02 CREATE INDEX index_name ON table(column(length)) 03 –修改表结构的方式添加索引 04 ALTER TABLE table_name ADD INDEX index_name ON (column(length)) 05 –创建表的时候同时创建索引 06 CREATE TABLE `table` ( 07 `id` int(11) NOT NULL AUTO_INCREMENT , 08 `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL , 09 `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL , 10 `time` int(10) NULL DEFAULT NULL , 11 PRIMARY KEY (`id`), 12 INDEX index_name (title(length)) 13 ) 14 –删除索引 15 DROP INDEX index_name ON table ...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to MySQL索引和事务" href="http://localhost:1313/articles/1/01/mysql%E7%B4%A2%E5%BC%95%E5%92%8C%E4%BA%8B%E5%8A%A1/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Pandas函数
    </h2>
  </header>
  <div class="entry-content">
    <p>【python】Pandas中DataFrame基本函数整理 构造函数 DataFrame([data, index, columns, dtype, copy]) #构造数据框1 属性和数据 DataFrame.axes #index: 行标签；columns: 列标签 DataFrame.as_matrix([columns]) #转换为矩阵 DataFrame.dtypes #返回数据的类型 DataFrame.ftypes #返回每一列的 数据类型float64:dense DataFrame.get_dtype_counts() #返回数据框数据类型的个数 DataFrame.get_ftype_counts() #返回数据框数据类型float64:dense的个数 DataFrame.select_dtypes([include, include]) #根据数据类型选取子数据框 DataFrame.values #Numpy的展示方式 DataFrame.axes #返回横纵坐标的标签名 DataFrame.ndim #返回数据框的纬度 DataFrame.size...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to Pandas函数" href="http://localhost:1313/articles/1/01/pandas%E5%87%BD%E6%95%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Python 中的上下文管理器
    </h2>
  </header>
  <div class="entry-content">
    <p> with 这个关键字，对于每一学习Python的人，都不会陌生。 操作文本对象的时候，我们用 with open ，这就是一个上下文管理的例子。
1 2 with open(&#39;test.txt&#39;) as f: print f.readlines() 上下文管理器概念 基本语法
1 2 with EXPR as VAR: BLOCK 几个概念
1 2 3 1. 上下文表达式：with open(&#39;test.txt&#39;) as f: 2. 上下文管理器：open(&#39;test.txt&#39;)	3. f不是上下文管理器，应该是资源对象。 ...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to Python 中的上下文管理器" href="http://localhost:1313/articles/1/01/python-%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">python之百度接口语音识别
    </h2>
  </header>
  <div class="entry-content">
    <p>python编程之百度接口语音识别 首先在百度AI开放平台上创建语音识别应用，创建完毕应用后，得到系统分配给用户的AppID， API Key， secret Key，均为字符串，用于标识用户，为访问做签名验证。 得到验证后，开始编程 1.记录自己声音 2.将记录下来的音频文件上传至云端 3.解析返回后的结果 ...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to python之百度接口语音识别" href="http://localhost:1313/articles/1/01/python%E4%B9%8B%E7%99%BE%E5%BA%A6%E6%8E%A5%E5%8F%A3%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">python函数补充
    </h2>
  </header>
  <div class="entry-content">
    <p>递归函数 递归特性
1.必须有一个明确的结束条件 2.每次进入更深一层递归时，问题规模相比上次递归都应有所减少 3.递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出） 代码演练
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def send(student): if len(student) == 0: return &#39;All student revice messges&#39; one = student.pop() if one == &#39;luenci&#39;: print(&#39;luenci get&#39;) send(student) elif one == &#39;jack&#39;: print(&#39;jack get&#39;) send(student) else: print(&#39;xiaoming get&#39;) send(student) if __name__ == &#34;__main__&#34;: student_list = [&#39;luenci&#39;, &#39;jack&#39;, &#39;xiaoming&#39;] send(student_list) 函数作用域 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def foo(): name = &#39;luenci&#39; def bar(): name = &#39;xiaoming&#39; def tt(): print(name) return tt return bar print(foo) print(foo()) print(foo()()) # bar=foo() # tt=bar() # print(tt) # tt() foo()()() out&gt;&gt; &lt;function foo at 0x0000020655A92E18&gt; &lt;function foo.&lt;locals&gt;.bar at 0x00000206577809D8&gt; &lt;function foo.&lt;locals&gt;.bar.&lt;locals&gt;.tt at 0x0000020657780A60&gt; xiaoming 函数式编程 匿名函数 函数声明：lambda 参数:表达式返回值 1 2 3 4 5 6 7 8 9 10 11 def test(x): return x&#43;1 print(test(10)) fun = lambda x:x&#43;1 print(fun(10)) out: 11 11 ...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to python函数补充" href="http://localhost:1313/articles/1/01/python%E5%87%BD%E6%95%B0%E8%A1%A5%E5%85%85/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Python后端架构演进（转载）
    </h2>
  </header>
  <div class="entry-content">
    <p>Python后端架构演进 本文转自python社区：https://www.pythontab.com/html/2018/pythonweb_0725/1329.html 架构 做了3年的后端开发, 经历一款SaaS产品从0到10(还没有到100, 哈哈哈)的过程, 3年间后端的架构逐步演变, 在微服务的实践过程中遇到的问题也越来越多, 在这里总结下. 产品是一款服务于人力资源的SaaS在线服务, 面向HR有Web...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to Python后端架构演进（转载）" href="http://localhost:1313/articles/1/01/python%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E8%BD%AC%E8%BD%BD/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">python多线程，并发和锁
    </h2>
  </header>
  <div class="entry-content">
    <p>多任务 同一个时间有多个任务在执行 python程序默认是单任务 线程 线程概念 线程，可简单理解为是程序执行的一条分支，也是程序执行流的最小单元。 线程是被系统独立调度和分底的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程为其它线程共享进程所拥有的全部资源。 主线程 当一个程序后动时，就有一个进程被操作系统（OS）创建，与此同时一个线程也立刻运行，该线程通常叫做程序的主线程，简而言之；程序后动就会创建一个主线程。
Copy主线程的重要性有两方面：
1）是产生其他子线程的线程；
2）通常它必须最后完成执行比如执行各种关闭动作·
...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to python多线程，并发和锁" href="http://localhost:1313/articles/1/01/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%92%8C%E9%94%81/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">python的值传递和引用传递
    </h2>
  </header>
  <div class="entry-content">
    <p>函数的传参 函数参数传递机制问题在本质上是调用函数（过程）和被调用函数（过程）在调用发生时进行通信的方法问题。基本的参数传递机制有两种：值传递和引用传递。
值传递（pass-by-value）过程中，被调函数的形式参数作为被调函数的局部变量处理，即在堆栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。 引用传递(pass-by-reference)过程中，被调函数的形式参数虽然也作为局部变量在堆栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过堆栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 In [1]: from ctypes import * In [2]: import os.path In [3]: import sys \# 传入不可变类型 In [4]: def test(x): ...: print(&#34;test before&#34;) ...: print(id(c)) ...: c&#43;=2 ...: print(&#34;test add&#34;) ...: print(id(c)) ...: return c In [5]: a = 2 In [6]: id(2) Out[6]: 11496672 In [7]: n = test(a) test before 11496672 test add 11496736 \# 传入可变类型 In [17]: def test2(x): ...: print(&#34;test before&#34;) ...: print(id(x)) ...: x[0] = 45 ...: print(&#34;test after&#34;) ...: print(id(x)) ...: return x ...: In [18]: e = [0,1,2,3] In [19]: id(e) Out[19]: 140323019352896 In [20]: g = test2(e) test before 140323019352896 test after 140323019352896 结论：python不允许程序员选择采用传值还是传引用。Python参数传递采用的肯定是“传对象引用”的方式。这种方式相当于传值和传引用的一种综合。
如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。 如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象－－相当于通过“传值’来传递对象。 ...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to python的值传递和引用传递" href="http://localhost:1313/articles/1/01/python%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">python的协程
    </h2>
  </header>
  <div class="entry-content">
    <p>可迭代对象 可遍历对象就是可迭代对象 列表、元组、字典、字符串都是可迭代对象 100和自定义myclass 默认都是不可以迷代的 myclass 对象所属的类MyClass如果包含了__iter__（）方法，此时 myclass就是一个可送代对象 可送代对象的本质：对象所属的类中包含了__iter__（）方法 检测一个对象是否可以送代，用isinstance（）函数检测。 迭代器 我们发现选代器最核心的功能就是可以通过next0函...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to python的协程" href="http://localhost:1313/articles/1/01/python%E7%9A%84%E5%8D%8F%E7%A8%8B/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/page/10/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:1313/page/12/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:1313/">Luenci</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
