<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[c语言笔记（1）]]></title>
    <url>%2F2019%2F10%2F13%2FC%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%202%2F</url>
    <content type="text"><![CDATA[c语言笔记（2）先举三反一，再举一反三，学习就应该是这样，先模仿，再改进，最后实现自己的创意！ –小甲鱼论坛递归调用函数本身设置递归结束条件12345678910111213141516171819202122232425262728293031323334353637383940//// Created by Luenci on 2019/10/11.//#include &lt;stdio.h&gt;void fun(void);long fact(int num);void fun(void)&#123; static int count = 10; printf("Hi\n"); if (count--)&#123; fun(); &#125;&#125;long fact(int num)&#123; long result; if(num &gt; 0)&#123; result = num * fact(num-1); &#125; else&#123; result = 1; &#125; return result;&#125;int main(void)&#123;// fun(); int num; long re; printf("请输入您要求阶乘的数："); scanf("%d", &amp;num); re = fact(num); printf("%d", re); return 0;&#125;汉罗塔123456789101112131415161718192021222324#include&lt;stdio.h&gt;void hanoi(int n, char x, char y, char z);void hanoi(int n, char x, char y, char z)&#123; if(n==1)&#123; printf("%c --&gt; %c \n", x,z); &#125; else&#123; // 将前n-1个圆盘借助z移动到y hanoi(n-1, x, z, y); printf("%c --&gt; %c \n", x,z); // 将前n-1个圆盘借助x移动到z hanoi(n-1, y, x, z); &#125;&#125;int main(void)&#123; int n; printf("请输入您的层数："); scanf("%d", &amp;n); hanoi(n, 'X', 'Y', 'Z'); return 0;&#125;快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//// Created by Luenci on 2019/10/11.//#include &lt;stdio.h&gt;void quick_sort(int array[], int left, int right);void quick_sort(int array[], int left, int right) &#123; int i = left, j = right; int temp; // 交换的中间变量 int pivot; // 基准点 pivot = array[(left + right) / 2]; while (i &lt;= j) &#123; // 从右往左找到大于等于基准点的元素 while (array[i] &lt; pivot) &#123; i++; &#125; // 从右到左找到小于等于基准点的元素 while (array[j] &gt; pivot) &#123; j--; &#125; // 如果 i &lt;= j,则互换 if (i &lt;= j) &#123; temp = array[i]; array[i] = array[j]; array[j] = temp; i++; j++; &#125; &#125; if (left &lt; j) &#123; quick_sort(array, left, j); &#125; if (i &lt; right) &#123; quick_sort(array, i, right); &#125;&#125;int main(void)&#123; int array[] = &#123;73, 108, 111, 101, 78, 109, 66, 48, 88, 135&#125;; int i, length; // 计算数组的长度 length = sizeof(array) / sizeof(array[0]); quick_sort(array, 0, length-1); printf("排序后的结果是："); for (i = 0; i &lt; length; i++)&#123; printf("%d ,", array[i]); &#125; putchar('\n'); return 0;&#125;动态内存管理malloc申请动态内存空间free释放动态内存空间calloc申请并初始化一系列内存空间realloc重新分配内训空间malloc函数函数原型void *malloc（size_t size）malloc函数向系统申请分配size个字节的内存空间，并返回一个指向这块空间的地址。如果函数调用成功，返回一个指向申请的内存空间的指针，由于返回类型是void 指针（void * ）， 所以它是可以被转换成任何类型的数据；如果函数调用失败，返回值是NULL。另外，如果size的参数设置为0，返回值也可能是NULL，但这并不意味着函数调用失败。free函数函数原型void free（void *ptr）free函数释放ptr参数指向的内存空间。该内存空间必须是有malloc，calloc或realloc函数申请的。否则，该函数将导致未定义行为。如果ptr参数是NULL，则不执行任何操作。注意：该函数并不会修改ptr参数的值，所以调用后仍然指向原来的地方（变为非法空间）。123456789101112131415161718192021222324252627//// Created by Luenci on 2019/10/12.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int *ptr; ptr = (int *)malloc(sizeof(int)); if(ptr == NULL)&#123; printf("分配内存失败"); exit(1); &#125; printf("请输入一个整数："); scanf("%d", ptr); printf("您输入的整数是:%d\n", *ptr); free(ptr); printf("您输入的整数是:%d\n", *ptr); return 0;&#125;内存泄漏隐式内存泄漏用完内存块没有及时使用free函数释放丢失内存块的地址初始化内存空间mem开头的函数被编入字符串标准库，函数的声明包含在string.h这个头文件中：memset – 使用一个常量字节填充空间memcpy – 拷贝内存空间memmove – 拷贝内存空间memcmp – 比较内存空间memchr – 在内存空间中搜索一个字符123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by Luenci on 2019/10/12.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define N 10int main(void)&#123; int *ptr = NULL; int i; ptr = (int *)malloc(N * sizeof(int)); if(ptr == NULL)&#123; exit(1); &#125; memset(ptr, 0, N * sizeof(int)); for (i= 0; i &lt; N; i++) &#123; printf("%d ", ptr[i]); &#125;// putchar("\n"); putchar('\n'); free(ptr); return 0;&#125;/*1、含义不同。用单引号引起的一个字符实际上代表一个整数，整数值对应于该字符在编译器采用的字符集中的序列值。而一般我们的编译器采用的都是ASCII字符集。因此's'的含义其实和十进制数115的含义是一致的。而用双引号引起的字符串，代表的是一个指向无名数组起始字符的指针。2、大小不同。用单引号引起的一个字符大小就是一个字节。而用双引号引起的字符串大小是字符的总大小+1，因为用双引号引起的字符串会在字符串末尾添加一个二进制为0的字符'\0'。*/calloc函数函数原型void *calloc(size_t nmemb, sizet_t size);calloc函数在内存中动态地申请nmemb个长度为size的连续内存空间（即申请的总空间尺寸为nmemb * size），这些内存空间全部被初始化为 0.calloc函数与malloc函数的一个重要区别是：calloc函数在申请完内存后，自动初始化该内存空间为零malloc函数不进行初始化操作，里面数据是随机的12345678// 两者等价// calloc() 分配内存空间并初始化int *ptr = （int *）calloc（8， sizeof（int））；//malloc()分配内存空间并用memset（）初始化int *ptr = (int *)malloc(8 * sizeof(int))；memset(prt, 0, 8 * sizeof(int));realloc函数如果ptr参数为NULL，那么调用该函数就相当于调用malloc（size）如果size参数为0，并且ptr参数不为NULL，那么调用该函数就相当于调用free（ptr）除非ptr参数为NULL，否则ptr的值必须由先前调用malloc，calloc或realloc函数返回。1234567891011121314151617181920212223242526272829303132//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int i, num; int count = 0; int *ptr = NULL;// 注意这里必须初始化为NULL do &#123; printf("请输入一个整数：（输入-1表示结束）"); scanf("%d", &amp;num); count++; ptr = (int *)realloc(ptr, count * sizeof(int)); if(ptr == NULL)&#123; exit(1); &#125; ptr[count-1] = num; &#125;while(num != -1); printf("输入的整数分别是："); for (int i = 0; i &lt;count ; i++) &#123; printf("%d ", ptr[i]); &#125; free(ptr); return 0;&#125;c语言的内存布局代码段代码段（Text segment）通常是指用来存放在程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读。在代码段中，也有可能包含一些只读的常熟变量，例如字符串常量等。BSS段BSS段（BSS segment/Uninitialized data segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BBS是英文Block Started Symbol的简称，这个区段中的数据在程序运行前将被自动初始化为数字0。堆堆是用于存放进程中被动态分配的内存段，它的大小并不固定，可动态扩展或缩小。当进程调用malloc等函数分配内存时，新分配的内存就被动态调价到对上；当利用free等函数释放内存时，被释放的内存从堆中被剔除。栈栈是函数执行的内存区域，通常和堆共享同一片区域。堆和栈的区别申请方式堆是由程序员手动申请栈时系统自动分配释放方式堆是由程序员手动释放栈由系统自动释放生存周期堆的生存周期由动态申请到程序员主动释放位置，不同函数之间均可自由访问。栈的生存周期由函数调用开始到函数返回时结束，函数之间的局部变量不能互相访问。高级宏定义本质就是替换内联函数在程序函数调用时，直接展开，而不是去查找调用。内联函数嵌入调用者代码中的操作是一种优化操作，因此只有进行优化编译时才会执行代码嵌入处理。若编译过程中没有使用优化选项‘-o’，那么内联函数的代码就不会真正地嵌入到函数调用者代码中，而是只作为普通函数调用来处理。内联函数虽然节省了函数调用的时间消耗，但由于每一个函数出现的地方都要进行替换，因此增加了代码的编译时间。另外，并不是所有的函数都能变成内联函数现在的编译器也很智能，就算你不写inline，它也会自动将一些函数优化成内联函数不带参数的宏定义为了和普通的变量进行区分，宏的名字通常我们约定是由大写字母组成宏定义只是简单地进行替换，并且由于预处理是在编译之前进行，而编译工作的任务之一就是语法检查，所以编译器不会对宏定义进行语法检查宏定义不是说明或语句，在末尾不必加分号宏定义的作用是从定义的位置开始到整个程序的结束可以用 #undef 来终止宏定义的作用域宏定义允许嵌套12345678910111213141516171819//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define PI 3.14int main()&#123; int r; float s; printf("请输入圆的半径："); scanf("%d", &amp;r);// #undef PI 终止宏定义 s = PI * r * r; printf("圆的面积是：%.2f\n", s);&#125;123456789101112131415//// Created by Luenci on 2019/10/13.//// 宏定义的嵌套#include &lt;stdio.h&gt;#define R 6371#define PI 3.14#define V PI * R * R * R * 4 / 3int main()&#123; printf("地球的体积是：%.2f\n", V);&#125;带参数的宏定义12345678910111213141516//// Created by Luenci on 2019/10/13.////带参数的宏定义#include &lt;stdio.h&gt;#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))int main()&#123; int x,y; printf("请输入两个数："); scanf("%d%d", &amp;x, &amp;y); printf("%d是最大的那个数！\n", MAX(x, y));&#125;‘#’ 和 ‘##’‘#’ 和 ‘##’是两个预处理运算符在带参数的宏定义中， #运算符后面应该跟着一个参数，预处理器会把这个参数转换为一个字符串。1234567891011121314//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define STR(s) # sint main(void)&#123; printf(STR(Hlloc %s num = %d), STR(Luenci), 520); return 0;&#125;out :Hlloc Luenci num = 520‘##’运算符被称为记号连接运算符，我们可以使用’##’运算符连接两个参数。123456789101112131415161718192021222324252627 //// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define TOGETHER(x,y) x ## yint main(void)&#123; printf("%d\n", TOGETHER(2,50)); return 0;&#125;//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define TOGETHER(x,y) x ## yint main(void)&#123; printf("%d\n", TOGETHER(2,50)); return 0;&#125;out:250可变参数之前学习了如何让函数支持可变参数，带参数的宏定义是使用可变参数的：1#define SHOWLIST（...） printf（#__VA_ARGS__）其中…表示可变参数，1#__VA_ARGS__在预处理中被实际的参数集所替代。123456789101112#include &lt;stdio.h&gt;#define SHOWLIST(...) printf(#__VA_ARGS__)int main(void)&#123; SHOWLIST(Luenci,5 20, 3.14 \n); return 0;&#125;out:Luenci,5 20, 3.1412345678910111213#include &lt;stdio.h&gt;#define SHOWLIST(format, ...) printf(#format, ##__VA_ARGS__)int main(void)&#123; SHOWLIST(num = %d\n,520); SHOWLIST(hello Luenci\n); return 0;&#125;out:num = 520hello Luenci]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F10%2F13%2FC%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[c语言笔记（1）ps:先举三反一，再举一反三，学习就应该是这样，先模仿，再改进，最后实现自己的创意！ –小甲鱼论坛C语言中各种数据类型所占用的存储空间的大小int—32位 四个字节float —32位 四个字节char—8位 一个字节double—-64位 8个字节bool—-16位 2个字节long—-32位 四个字节整数类型下表列出了关于标准整数类型的存储大小和值范围的细节：类型存储大小值范围char1 字节-128 到 127 或 0 到 255unsigned char1 字节0 到 255signed char1 字节-128 到 127int2 或 4 字节-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647unsigned int2 或 4 字节0 到 65,535 或 0 到 4,294,967,295short2 字节-32,768 到 32,767unsigned short2 字节0 到 65,535long4 字节-2,147,483,648 到 2,147,483,647unsigned long4 字节0 到 4,294,967,295浮点类型下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：类型存储大小值范围精度float4 字节1.2E-38 到 3.4E+386 位小数double8 字节2.3E-308 到 1.7E+30815 位小数long double16 字节3.4E-4932 到 1.1E+493219 位小数void 类型void 类型指定没有可用的值。它通常用于以下三种情况下：序号类型与描述1函数返回为空 C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);2函数参数为空 C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);3指针指向 void 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。？###C语言运算符优先级优先级运算符名称或含义使用形式结合方向说明1[]数组下标数组名[常量表达式]左到右()圆括号（表达式）/函数名(形参表).成员选择（对象）对象.成员名-&gt;成员选择（指针）对象指针-&gt;成员名2-负号运算符-表达式右到左单目运算符(类型)强制类型转换(数据类型)表达式++自增运算符++变量名/变量名++单目运算符–自减运算符–变量名/变量名–单目运算符*取值运算符*指针变量单目运算符&amp;取地址运算符&amp;变量名单目运算符!逻辑非运算符!表达式单目运算符~按位取反运算符~表达式单目运算符sizeof长度运算符sizeof(表达式)3/除表达式/表达式左到右双目运算符*乘表达式*表达式双目运算符%余数（取模）整型表达式/整型表达式双目运算符4+加表达式+表达式左到右双目运算符-减表达式-表达式双目运算符5&lt;&lt;左移变量&lt;&lt;表达式左到右双目运算符&gt;&gt;右移变量&gt;&gt;表达式双目运算符6&gt;大于表达式&gt;表达式左到右双目运算符&gt;=大于等于表达式&gt;=表达式双目运算符&lt;小于表达式&lt;表达式双目运算符&lt;=小于等于表达式&lt;=表达式双目运算符7==等于表达式==表达式左到右双目运算符!=不等于表达式!= 表达式双目运算符8&amp;按位与表达式&amp;表达式左到右双目运算符9^按位异或表达式^表达式左到右双目运算符10|按位或表达式|表达式左到右双目运算符11&amp;&amp;逻辑与表达式&amp;&amp;表达式左到右双目运算符12||逻辑或表达式||表达式左到右双目运算符13?:条件运算符表达式1? 表达式2: 表达式3右到左三目运算符14=赋值运算符变量=表达式右到左/=除后赋值变量/=表达式*=乘后赋值变量*=表达式%=取模后赋值变量%=表达式+=加后赋值变量+=表达式-=减后赋值变量-=表达式&lt;&lt;=左移后赋值变量&lt;&lt;=表达式&gt;&gt;=右移后赋值变量&gt;&gt;=表达式&amp;=按位与后赋值变量&amp;=表达式^=按位异或后赋值变量^=表达式|=按位或后赋值变量|=表达式15,逗号运算符表达式,表达式,…左到右从左向右顺序运算注：同一优先级的运算符，运算次序由结合方向所决定。break和continue语句区别break语句结束当前循环continue语句跳过本次循环二维下标直接索引和指针间接索引的相互转化1234*（array + i） = array[i]*(*(array + i) + j) = array[i][j]*(*(*(array + i) + j) + K) = array[i][j][k] ...二维数组和数组指针的关系12345678910111213141516171819202122//// Created by Luenci on 2019/10/5.//#include &lt;stdio.h&gt;int main()&#123; int array[2][3] = &#123;&#123;0, 1, 2&#125;, &#123;4, 5, 6&#125;&#125;; int (*p)[3] = array; printf("**(p+1): %d\n", **(p+1)); printf("**(array+1): %d\n", **(array+1)); printf("array[1][0]: %d\n", array[1][0]); printf("*(*(p+1)+2): %d\n", *(*(p+1)+2)); printf("*(*(array+1)+2): %d\n", *(*(array+1)+2)); printf("array[1][2]: %d\n", array[1][2]); return 0;&#125;void指针和NULL指针Void指针void指针我们把它称之为通用指针，就是可以指向任意类型的数据。也就是说，任何类型的指针都可以赋值给void指针。123456789101112131415161718192021//// Created by Luenci on 2019/10/5.//#include &lt;stdio.h&gt;int main()&#123; int num = 1024; int *pi = &amp;num; char *ps = "Luenci"; void *pv; pv = pi; printf("pi:%p, pv:%p\n", pi,pv); printf("*pv:%d\n", *(int *)pv); pv = (char *)ps; printf("ps:%p, pv:%p\n", ps, pv); printf("*pv:%s\n", (char *)pv); return 0;&#125;NULL指针当你还不清楚要将指针初始值为什么地址时，请先将它初始化为NULL；在对指针进行解引用时，先检查该指针是否为NULL。这种策略可以为今后编写大型程序 节省大量的 调试时间。1#define NULL ((void *)0)1234567891011121314//// Created by Luenci on 2019/10/5.//#include &lt;stdio.h&gt;int null_pointer()&#123; int *p1; int *p2 = NULL; printf("%d\n", *p1); printf("%d\n", *p2); return 0;&#125;指向指针的指针123456789101112131415161718192021int main()&#123; int num = 520; int *p = &amp;num; int **pp = &amp;p; printf("num: %d\n", num); printf("*p: %d\n", *p); printf("**PP: %d\n", **pp); printf("&amp;p: %p, pp:%p\n", &amp;p, pp); printf("&amp;num:%p, p:%p, *pp:%p\n", &amp;num,p,*pp); return 0;&#125; out: num: 520 *p: 520 **PP: 520 &amp;p: 0061FF14, pp:0061FF14 &amp;num:0061FF18, p:0061FF18, *pp:0061FF18指针数组和指向指针的指针123456789101112131415161718192021222324252627282930313233343536373839int pointer_array()&#123; char *cBooks[] = &#123; &quot;&lt;c程序设计语言&gt;&quot;, &quot;&lt;c专家编程&gt;&quot;, &quot;&lt;c和指针&gt;&quot;, &quot;&lt;c prime plus&gt;&quot;, &quot;&lt;C study&gt;&quot; &#125;; char **byLuenci; char **byGood[4]; byLuenci = &amp;cBooks[4]; byGood[0] = &amp;cBooks[0]; byGood[1] = &amp;cBooks[1]; byGood[2] = &amp;cBooks[2]; byGood[3] = &amp;cBooks[3]; printf(&quot;Luenci拥有的书: %s\n&quot;, *byLuenci); printf(&quot;Luenci喜欢的图书有：\n&quot;); int i; for (int i = 0; i &lt; 4; ++i) &#123; printf(&quot;%s\n&quot;,*byGood[i]); &#125; return 0;&#125;out: Luenci拥有的书: &lt;C study&gt;Luenci喜欢的图书有：&lt;c程序设计语言&gt;&lt;c专家编程&gt;&lt;c和指针&gt;&lt;c prime plus&gt;常量定义1234567891011520，‘a’, 3.14#define price 520#define A 'a'#define PI 3.14 // 使用const关键字修饰 const int price = 520;const char A = 'a';const float pi = 3.14;指向常量的指针指针可以修改为指向不同的常量指针可以修改为指向不同的变量可以通过解引用来读取指针指向的数据不可以通过解引用修改指针指向的数据123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int num =520; const int cnum = 880; const int *pc = &amp;cnum; printf("cnum:%d, &amp;cum:%p \n", cnum, &amp;cnum); printf("*pc:%d, pc:%p\n", *pc, pc); pc = &amp;num; printf("num:%d, &amp;num:%p \n", num, &amp;num); printf("*pc:%d, pc:%p\n", *pc, pc); return 0;&#125;函数结构1234类型名 函数名（参数列表）&#123; 函数体&#125;函数的声明所谓的声明（Declaration），就是告诉编译器我要是用这个函数，你现在没有找到它的定义不要紧，请不要报错，稍后我将会把它补上。函数的参数和返回值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;void print_c();int sum(int n);int max(int x, int y);int max(int x, int y)&#123; // a？b:c 当a的值为真时，返回b的值；否则返回c的值 return x &gt; y ? x:y;&#125;int sum(int n)&#123; int result = 0; do &#123; result += n; &#125;while (n-- &gt; 0); return result;&#125;void print_c()&#123; printf(" ###### \n"); printf("## ##\n"); printf("## \n"); printf("## \n"); printf("## ##\n"); printf(" ###### \n");&#125;int main()&#123; print_c(); int n,x,y;// printf("请输入n的值："); printf("请输入x,y的值：");// scanf("%d", &amp;n); scanf("%d%d", &amp;x, &amp;y);// printf("1+2+3+...+(n-1)+n的结果是：%d\n",sum(n)); printf("x,y中最大值的值为：%d\n", max(x,y)); return 0;&#125;形参和实参用于数据传输，形参就相当与一个占位符，只在函数内部有效。传值和传址1234567891011121314151617181920212223242526//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;void swap(int *x, int *y);void swap(int *x, int *y)&#123; int *temp; printf("In swap 互换前：x %d, y %d\n", *x,*y); temp = *x; *x = *y; *y = temp; printf("In swap 互换后：x %d, y %d\n", *x,*y);&#125;int main()&#123; int x = 3, y = 5; printf("In main 互换前：x %d, y %d\n", x,y); swap(&amp;x,&amp;y); printf("In main 互换后：x %d, y %d\n", x,y); return 0;&#125;传数组实际上传过去的是数组的地址123456789101112131415void get_array(int b[10])&#123; printf("sizeof b: %d\n", sizeof(b));&#125;int main()&#123; int a[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; printf("sizeof a:%d\n", sizeof(a)); get_array(a); out:sizeof a:40sizeof b: 4可变参数引入 头文件#include&lt;stdarg.h&gt;123456789101112131415161718192021222324252627282930313233343536373839//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;int sum(int n, ...);int sum(int n, ...)&#123; int i; int sum = 0; va_list vap; va_start(vap, n); for(i = 0; i &lt; n; i++)&#123; sum += va_arg(vap, int); &#125; va_end(vap); return sum;&#125;int main()&#123; int result,result2,result3; result = sum(3,1,2,-3); printf("result:%d\n", result); result2 = sum(4,2,2,4,2); printf("result2:%d\n", result2); result3 = sum(4,2,8,4,-2); printf("result3:%d\n", result3); return 0;&#125;指针函数使用指针变量作为函数的返回值，就是指针函数123456789101112131415161718192021222324252627282930313233343536373839//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;char *getchartchar();char *getchart(char c)&#123; switch (c) &#123; case &apos;A&apos;: return &quot;Apple&quot;; case &apos;B&apos;: return &quot;Banana&quot;; case &apos;C&apos;: return &quot;Cat&quot;; case &apos;D&apos;: return &quot;Dog&quot;; default: return &quot;None&quot;; &#125;&#125;int main()&#123; char input; printf(&quot;请输入一个字母：&quot;); scanf(&quot;%c&quot;, &amp;input); printf(&quot;%s\n&quot;, getchart(input)); return 0;&#125;in:Aout:ApplePS:不要返回局部变量的指针函数指针指针函数 - - &gt; int *p();函数指针 - - &gt; int (*p)();函数指针作为参数12345678910111213141516171819202122232425262728//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;int add(int, int);int sub(int, int);int clac(int (*fp)(int, int), int, int);int add(int num1, int num2)&#123; return num1 + num2;&#125;int sub(int num1, int num2)&#123; return num1 - num2;&#125;int clac(int (*fp)(int, int), int num1, int num2)&#123; return (*fp)(num1, num2);&#125;int main()&#123; printf("3 + 5 = %d\n", clac(add, 3,5)); printf("3 - 5 = %d\n", clac(sub, 3,5)); return 0;&#125;函数指针作为返回值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//// Created by Luenci on 2019/10/10.//#include &lt;stdio.h&gt;int add(int, int);int sub(int, int);int calc(int (*)(int, int), int, int);int (*slect(char))(int,int);int add(int num1, int num2)&#123; return num1 + num2;&#125;int sub(int num1, int num2)&#123; return num1 - num2;&#125;int calc(int (*fp)(int, int),int num1, int num2)&#123; return (*fp)(num1, num2);&#125;int (*slect(char op))(int, int)&#123; switch(op)&#123; case '+': return add; case '-': return sub; &#125;&#125;int main()&#123; int num1, num2; char op; int (*fp)(int, int); printf("请输入一个式子 (如 1+3) :"); scanf("%d%c%d", &amp;num1, &amp;op, &amp;num2); fp = slect(op); printf("%d %c %d = %d\n", num1, op, num2, calc(fp, num1, num2)); return 0;&#125;局部变量和全局变量局部变量不同函数的变量无法相互访问全局变量如果不对全局变量进行初始化，那么它会自动初始化为0.如果函数在内部存在一个与全局变量同名的局部变量，编译器不会报错，而是在函数中屏蔽全局变量。exsten关键字告诉编译器我等下会定义变量，不要报错不要大量的使用全局变量使用全局变量会使你的程序占用更多的内存，因为全局变量从定义时候开始，知道程序退出才释放。污染命名空间提高了程序耦合性作用域和链接属性当变量被定义在不同的位置时，它的作用域的范围是不一样的，这个作用范围就是我们所说的作用域C语言编译器可以确认四种不同类型的作用域：代码块的作用域文件作用域原型作用域函数作用域代码块作用域（Block scope）在代码块中定义的变量，具有代码块作用域。作用范围是从变量定义的位置开始，到标志代码块结束的大括号（}）处。文件作用域（file scope）任何在代码块之外声明的标识符都具有文件作用域，作用域的范围是从他们的声明位置开始，到文件的结尾处都是可以访问的。原型作用域（prototype scope）原型作用域只适用于那些在函数原型中声明的参数名。函数作用域（function scope）函数作用域只适合于goto语句的标签，作用将goto语句得标签限制在同一个函数内部，以防止出现重名的标签。定义和声明当一个变量被定义的时候，编译器为变量申请内存空间并填充值当一个变量被声明的时候，编译器就知道该变量被定义在其他地方声明是通知编译器该变量名及相关的类型已经存在，不需要再为此申请内存空间。局部变量即是定义又是声明定义只能来一次，否则就叫做重复定义某个同名的变量；而声明可以由你很多次。链接属性external（外部的）多个文件中声明的同名标识符表示一个实体internal（内部的）单个文件中声明的同名标识符表示同一个实体none（无）声明的同名标识符被当做独立的不同实体只有具备文件作用域的标识符才能拥有external或internal的链接属性，其他作用域的标识符都是none属性。默认情况下，具备文件的作用域的标识符拥有external属性。也就是说该标识符允许跨文件访问。对于external属性的标识符，无论在不同文件中声明多少次，表示的都是一个实体。使用static关键字可以使得原先拥有的external属性的标识符变为internal属性。这里有两点需要注意：使用static关键字修改链接属性，只对具有文件作用域的标识符生效（对于拥有其他作用域的标志符是另一种功能）链接属性只能修改一次，也就是说一旦将标识符的链接属性改为internal，就无法变回external。生存期和存储类型C语言变量拥有两种生存周期静态存储器自动存储器具有文件作用域的变量属于静态存储器，函数也属于静态存储器。属于静态存储器的变量在程序执行期间将一直占据存储空间，直到程序关闭才释放具有代码块作用域的变量一般情况下属于自动存储器。属于自动存储期的变量在代码块结束时将自动释放。存储类型存储类型其实是指存储变量值的内存类型，C语言提供了五种类型。autoregisterstaticexterntypedef递归调用函数本身设置递归结束条件12345678910111213141516171819202122232425262728293031323334353637383940//// Created by Luenci on 2019/10/11.//#include &lt;stdio.h&gt;void fun(void);long fact(int num);void fun(void)&#123; static int count = 10; printf("Hi\n"); if (count--)&#123; fun(); &#125;&#125;long fact(int num)&#123; long result; if(num &gt; 0)&#123; result = num * fact(num-1); &#125; else&#123; result = 1; &#125; return result;&#125;int main(void)&#123;// fun(); int num; long re; printf("请输入您要求阶乘的数："); scanf("%d", &amp;num); re = fact(num); printf("%d", re); return 0;&#125;汉罗塔123456789101112131415161718192021222324#include&lt;stdio.h&gt;void hanoi(int n, char x, char y, char z);void hanoi(int n, char x, char y, char z)&#123; if(n==1)&#123; printf("%c --&gt; %c \n", x,z); &#125; else&#123; // 将前n-1个圆盘借助z移动到y hanoi(n-1, x, z, y); printf("%c --&gt; %c \n", x,z); // 将前n-1个圆盘借助x移动到z hanoi(n-1, y, x, z); &#125;&#125;int main(void)&#123; int n; printf("请输入您的层数："); scanf("%d", &amp;n); hanoi(n, 'X', 'Y', 'Z'); return 0;&#125;快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//// Created by Luenci on 2019/10/11.//#include &lt;stdio.h&gt;void quick_sort(int array[], int left, int right);void quick_sort(int array[], int left, int right) &#123; int i = left, j = right; int temp; // 交换的中间变量 int pivot; // 基准点 pivot = array[(left + right) / 2]; while (i &lt;= j) &#123; // 从右往左找到大于等于基准点的元素 while (array[i] &lt; pivot) &#123; i++; &#125; // 从右到左找到小于等于基准点的元素 while (array[j] &gt; pivot) &#123; j--; &#125; // 如果 i &lt;= j,则互换 if (i &lt;= j) &#123; temp = array[i]; array[i] = array[j]; array[j] = temp; i++; j++; &#125; &#125; if (left &lt; j) &#123; quick_sort(array, left, j); &#125; if (i &lt; right) &#123; quick_sort(array, i, right); &#125;&#125;int main(void)&#123; int array[] = &#123;73, 108, 111, 101, 78, 109, 66, 48, 88, 135&#125;; int i, length; // 计算数组的长度 length = sizeof(array) / sizeof(array[0]); quick_sort(array, 0, length-1); printf("排序后的结果是："); for (i = 0; i &lt; length; i++)&#123; printf("%d ,", array[i]); &#125; putchar('\n'); return 0;&#125;动态内存管理malloc申请动态内存空间free释放动态内存空间calloc申请并初始化一系列内存空间realloc重新分配内训空间malloc函数函数原型void *malloc（size_t size）malloc函数向系统申请分配size个字节的内存空间，并返回一个指向这块空间的地址。如果函数调用成功，返回一个指向申请的内存空间的指针，由于返回类型是void 指针（void * ）， 所以它是可以被转换成任何类型的数据；如果函数调用失败，返回值是NULL。另外，如果size的参数设置为0，返回值也可能是NULL，但这并不意味着函数调用失败。free函数函数原型void free（void *ptr）free函数释放ptr参数指向的内存空间。该内存空间必须是有malloc，calloc或realloc函数申请的。否则，该函数将导致未定义行为。如果ptr参数是NULL，则不执行任何操作。注意：该函数并不会修改ptr参数的值，所以调用后仍然指向原来的地方（变为非法空间）。123456789101112131415161718192021222324252627//// Created by Luenci on 2019/10/12.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int *ptr; ptr = (int *)malloc(sizeof(int)); if(ptr == NULL)&#123; printf("分配内存失败"); exit(1); &#125; printf("请输入一个整数："); scanf("%d", ptr); printf("您输入的整数是:%d\n", *ptr); free(ptr); printf("您输入的整数是:%d\n", *ptr); return 0;&#125;内存泄漏隐式内存泄漏用完内存块没有及时使用free函数释放丢失内存块的地址初始化内存空间mem开头的函数被编入字符串标准库，函数的声明包含在string.h这个头文件中：memset – 使用一个常量字节填充空间memcpy – 拷贝内存空间memmove – 拷贝内存空间memcmp – 比较内存空间memchr – 在内存空间中搜索一个字符123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by Luenci on 2019/10/12.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define N 10int main(void)&#123; int *ptr = NULL; int i; ptr = (int *)malloc(N * sizeof(int)); if(ptr == NULL)&#123; exit(1); &#125; memset(ptr, 0, N * sizeof(int)); for (i= 0; i &lt; N; i++) &#123; printf("%d ", ptr[i]); &#125;// putchar("\n"); putchar('\n'); free(ptr); return 0;&#125;/*1、含义不同。用单引号引起的一个字符实际上代表一个整数，整数值对应于该字符在编译器采用的字符集中的序列值。而一般我们的编译器采用的都是ASCII字符集。因此's'的含义其实和十进制数115的含义是一致的。而用双引号引起的字符串，代表的是一个指向无名数组起始字符的指针。2、大小不同。用单引号引起的一个字符大小就是一个字节。而用双引号引起的字符串大小是字符的总大小+1，因为用双引号引起的字符串会在字符串末尾添加一个二进制为0的字符'\0'。*/calloc函数函数原型void *calloc(size_t nmemb, sizet_t size);calloc函数在内存中动态地申请nmemb个长度为size的连续内存空间（即申请的总空间尺寸为nmemb * size），这些内存空间全部被初始化为 0.calloc函数与malloc函数的一个重要区别是：calloc函数在申请完内存后，自动初始化该内存空间为零malloc函数不进行初始化操作，里面数据是随机的12345678// 两者等价// calloc() 分配内存空间并初始化int *ptr = （int *）calloc（8， sizeof（int））；//malloc()分配内存空间并用memset（）初始化int *ptr = (int *)malloc(8 * sizeof(int))；memset(prt, 0, 8 * sizeof(int));realloc函数如果ptr参数为NULL，那么调用该函数就相当于调用malloc（size）如果size参数为0，并且ptr参数不为NULL，那么调用该函数就相当于调用free（ptr）除非ptr参数为NULL，否则ptr的值必须由先前调用malloc，calloc或realloc函数返回。1234567891011121314151617181920212223242526272829303132//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int i, num; int count = 0; int *ptr = NULL;// 注意这里必须初始化为NULL do &#123; printf("请输入一个整数：（输入-1表示结束）"); scanf("%d", &amp;num); count++; ptr = (int *)realloc(ptr, count * sizeof(int)); if(ptr == NULL)&#123; exit(1); &#125; ptr[count-1] = num; &#125;while(num != -1); printf("输入的整数分别是："); for (int i = 0; i &lt;count ; i++) &#123; printf("%d ", ptr[i]); &#125; free(ptr); return 0;&#125;c语言的内存布局代码段代码段（Text segment）通常是指用来存放在程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读。在代码段中，也有可能包含一些只读的常熟变量，例如字符串常量等。BSS段BSS段（BSS segment/Uninitialized data segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BBS是英文Block Started Symbol的简称，这个区段中的数据在程序运行前将被自动初始化为数字0。堆堆是用于存放进程中被动态分配的内存段，它的大小并不固定，可动态扩展或缩小。当进程调用malloc等函数分配内存时，新分配的内存就被动态调价到对上；当利用free等函数释放内存时，被释放的内存从堆中被剔除。栈栈是函数执行的内存区域，通常和堆共享同一片区域。堆和栈的区别申请方式堆是由程序员手动申请栈时系统自动分配释放方式堆是由程序员手动释放栈由系统自动释放生存周期堆的生存周期由动态申请到程序员主动释放位置，不同函数之间均可自由访问。栈的生存周期由函数调用开始到函数返回时结束，函数之间的局部变量不能互相访问。高级宏定义本质就是替换内联函数在程序函数调用时，直接展开，而不是去查找调用。内联函数嵌入调用者代码中的操作是一种优化操作，因此只有进行优化编译时才会执行代码嵌入处理。若编译过程中没有使用优化选项‘-o’，那么内联函数的代码就不会真正地嵌入到函数调用者代码中，而是只作为普通函数调用来处理。内联函数虽然节省了函数调用的时间消耗，但由于每一个函数出现的地方都要进行替换，因此增加了代码的编译时间。另外，并不是所有的函数都能变成内联函数现在的编译器也很智能，就算你不写inline，它也会自动将一些函数优化成内联函数不带参数的宏定义为了和普通的变量进行区分，宏的名字通常我们约定是由大写字母组成宏定义只是简单地进行替换，并且由于预处理是在编译之前进行，而编译工作的任务之一就是语法检查，所以编译器不会对宏定义进行语法检查宏定义不是说明或语句，在末尾不必加分号宏定义的作用是从定义的位置开始到整个程序的结束可以用 #undef 来终止宏定义的作用域宏定义允许嵌套12345678910111213141516171819//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define PI 3.14int main()&#123; int r; float s; printf("请输入圆的半径："); scanf("%d", &amp;r);// #undef PI 终止宏定义 s = PI * r * r; printf("圆的面积是：%.2f\n", s);&#125;123456789101112131415//// Created by Luenci on 2019/10/13.//// 宏定义的嵌套#include &lt;stdio.h&gt;#define R 6371#define PI 3.14#define V PI * R * R * R * 4 / 3int main()&#123; printf("地球的体积是：%.2f\n", V);&#125;带参数的宏定义12345678910111213141516//// Created by Luenci on 2019/10/13.////带参数的宏定义#include &lt;stdio.h&gt;#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))int main()&#123; int x,y; printf("请输入两个数："); scanf("%d%d", &amp;x, &amp;y); printf("%d是最大的那个数！\n", MAX(x, y));&#125;‘#’ 和 ‘##’‘#’ 和 ‘##’是两个预处理运算符在带参数的宏定义中， #运算符后面应该跟着一个参数，预处理器会把这个参数转换为一个字符串。1234567891011121314//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define STR(s) # sint main(void)&#123; printf(STR(Hlloc %s num = %d), STR(Luenci), 520); return 0;&#125;out :Hlloc Luenci num = 520‘##’运算符被称为记号连接运算符，我们可以使用’##’运算符连接两个参数。123456789101112131415161718192021222324252627 //// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define TOGETHER(x,y) x ## yint main(void)&#123; printf("%d\n", TOGETHER(2,50)); return 0;&#125;//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define TOGETHER(x,y) x ## yint main(void)&#123; printf("%d\n", TOGETHER(2,50)); return 0;&#125;out:250可变参数之前学习了如何让函数支持可变参数，带参数的宏定义是使用可变参数的：1#define SHOWLIST（...） printf（#__VA_ARGS__）其中…表示可变参数，1#__VA_ARGS__在预处理中被实际的参数集所替代。123456789101112#include &lt;stdio.h&gt;#define SHOWLIST(...) printf(#__VA_ARGS__)int main(void)&#123; SHOWLIST(Luenci,5 20, 3.14 \n); return 0;&#125;out:Luenci,5 20, 3.1412345678910111213#include &lt;stdio.h&gt;#define SHOWLIST(format, ...) printf(#format, ##__VA_ARGS__)int main(void)&#123; SHOWLIST(num = %d\n,520); SHOWLIST(hello Luenci\n); return 0;&#125;out:num = 520hello Luenci]]></content>
  </entry>
  <entry>
    <title><![CDATA[Django之编写URL]]></title>
    <url>%2F2019%2F10%2F07%2Fdjango%E4%B9%8Burl%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[编写URL编写规则​ 为了使其规范性，在每个新创建的App中设置独立的静态资源和模板文件夹并添加一个空白的.py文件，命为urls.py。如下是创建app中的文件结构：1234567891011121314frist/ migrations/ # 数据库前后是否有变化，生成出迁移文件 static/ # 创建App后存放App中的静态资源文件，自己手动添加 templates/ # 创建App后存放App中的模板文件，自己手动添加 __init__.py admin.py apps.py models.py tests.py urls.py # 创建App后由系统总路由映射到App的路由文件，自己手动添加 view.py系统总路由和app的路由分发配置12345678# 根目录的urls.pyfrom django.contrib import adminfrom django.urls import path,adminurlpatterns = [ path('admin/', admin.site.urls), path('',include('frist.urls')) # 引入app中的urls.py]代码详解:from django.contrib import admin:导入Admin功能模块.from django.urls import path,admin:导入URL编写模块.urlpatterns:整个项目的URL集合,每个元素代表一条URL信息.path(&#39;admin/&#39;, admin.site.urls):设定Admin的URL.&#39;admin/&#39;代表127.0.0.1/admin地址信息,admin后面的斜杠是路径分隔符;admin.site.urls是URL的处理函数,也称为视图函数.path(&#39;&#39;,include(&#39;frist.urls&#39;)):URL为空,代表网站的域名,即127.0.0.1,通常是网站的首页;include将该URL分发给app的urls.py处理.1234567# app下的urls.pyfrom django.urls import pathfrom . import viewsurlpatterns = [ path('',views.index) # 调用和url匹配的视图函数]当根目录的URL分发给app中的URL处理后,下一步就是根据所匹配的URL进行视图的调用.在Views中编写相应的视图函数。如下：12345# index的views.pyfrom django.http import HttpResponse# creat you views here.def index(request): return HttpResponse("hello world")视图函数的参数必须设置为request，该参数代表当前用户的请求对象，该对象包含用户名，请求内容和请求方式等信息，执行完成后必须使用return将处理结果返回。带变量的URL​ 在日常开发中，有时候一个URL可以代表多个不同的页面，如编写带有日期的URL，若根据前面的编写方式，按一年计算，则需要开发者编写365个不同的URL才能实现。这种做法是不可取的，因此，Django在编写URL时，可以对URL设置变量值，使URL具有多样性。​ URL的变量类型有字符类型，整型，slug和uuid，常用的是字符类型和整型。说明如下：字符类型：匹配任何非空字符串，但不含斜杠。如果没有指定类型，默认使用该类型。整形：匹配0和正整数slug：可理解为注释，后缀或附属等概念，常作为URL的解释性字符。可匹配任何ASCII字符以及连接符和下画线，能使URL更加清晰易懂。比如网页的标题是“13岁的孩子”，其URL地址可以设置为“13-sui-de-hai-zi“。uuid：匹配一个uuid格式的对象。为了防止冲突，规定必须使用破折号并且所有字母必须小写，例如0201203-3213-31e-321c34d435（未待完续）]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django简介]]></title>
    <url>%2F2019%2F10%2F07%2Fdjango%E9%85%8D%E7%BD%AE%E5%88%9D%E5%90%AF%2F</url>
    <content type="text"><![CDATA[Django简介背景2003诞生 它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的MVT（框架）Models 模型 数据库Views 视图 放和拿Template 模板 前端From 表单 django 会根据你后台数据库字段及表单层的设计对应的给你创建HTML关于表单的代码Django优点对象关系映射（Object Relational Mapping ORM）：通过定义映射类来构建数据模型，将模型与关系型数据库连接起来，使用ORM框架内置的数据库接口可实现复杂的数据操作。（简单来说就是把数据库的语句换成了python可识别的语言）URL设计：开发者可以设计任意的URL（网站地址）， 而且支持使用正则表达式设计。模板系统：提供可扩展的模板语言，模板之间具有可继承性。表单处理：可以生成各种表单模型，而且表单具有有效性检验功能。Cache系统：完善的缓存系统，可支持多种缓存方式用户管理系统：提供用户认证，权限设置和用户组功能，功能扩展性强。国际化：内置国际化系统，方便开发出多语言的网站。admin管理系统：内置admin管理系统，系统的扩展性强。Django项目目录1234567891011121314用django-admin startproject demo 创建一个demo项目文件结构如下：demo/ # 最外层 这个是整个项目的容器文件夹，可以随意改名字 demo/ # 内层的demo 是这个项目中关于配置文件的一个管理文件夹，这个不允许改名字 __init__.py #初始化文件，代表这个文件夹是一个包，一个模块，demo文件夹就是一个模块了 settings.py # 这个是整个项目的配置文件，配置中间，配置邮件等 urls.py # django项目的总路由配置文件。网站的地址信息 wsgi.py # 全称为Python Web Server Gateway Interface，即为python服务器网关接口， 是python应用与Web服务器之间的接口，用于Django项目在服务器上的部署和上线，一 般不需要修改 manage.py # 命令行工具，允许以多种方式与项目交互。 可输入 python manage.py help 查看 该工具的具体用法Django的创建的App目录使用命令创建app： python manage.py startapp frist创建了App必须把App名称添加到INSTALL_APPS里面。1234567891011121314frist/ migrations/ # 数据库前后是否有变化，生成出迁移文件 static/ # 创建App后存放App中的静态资源文件，自己手动添加 templates/ # 创建App后存放App中的模板文件，自己手动添加 __init__.py admin.py apps.py models.py tests.py urls.py # 创建App后由系统总路由映射到App的路由文件，自己手动添加 view.pyDjango（settings）配置全览123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122"""Django settings for mysite project.Generated by 'django-admin startproject' using Django 2.1.2.For more information on this file, seehttps://docs.djangoproject.com/en/2.1/topics/settings/For the full list of settings and their values, seehttps://docs.djangoproject.com/en/2.1/ref/settings/"""import os# 项目路径# Build paths inside the project like this: os.path.join(BASE_DIR, ...)BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))# Quick-start development settings - unsuitable for production# See https://docs.djangoproject.com/en/2.1/howto/deployment/checklist/# 密匙配置# SECURITY WARNING: keep the secret key used in production secret!SECRET_KEY = '#g$qgqkee8csvp67l$(8ugkx%+i_9k%mbykw-%9zpbnyn!bb!='# 调试模式# SECURITY WARNING: don't run with debug turned on in production!DEBUG = True# 域名访问权限ALLOWED_HOSTS = ['*']# App列表# Application definitionINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'myblog', 'article',]MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]ROOT_URLCONF = 'mysite.urls'TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [BASE_DIR, 'templates'], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', # 自定义模版全局变量(默认变量) 'article.views.global_settings', ], &#125;, &#125;,]WSGI_APPLICATION = 'mysite.wsgi.application'# Database# https://docs.djangoproject.com/en/2.1/ref/settings/#databasesDATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125;# Password validation# https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validatorsAUTH_PASSWORD_VALIDATORS = [ &#123; 'NAME':'django.contrib.auth.password_validation.UserAttributeSimilarityValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator', &#125;,]# Internationalization# https://docs.djangoproject.com/en/2.1/topics/i18n/LANGUAGE_CODE = 'zh-Hans'TIME_ZONE = 'Asia/Shanghai'USE_I18N = TrueUSE_L10N = TrueUSE_TZ = True# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/2.1/howto/static-files/STATIC_URL = '/static/'STATIC_ROOT = os.path.join(BASE_DIR, "static/")项目路径 BASE_DIR：主要通过os模块读取当前项目在系统的具体路径，该代码在创建项目时自动生成，一般情况无需修改密匙配置SECRET_KEY：是一个随机值，在项目创建的时候自动生成，一般情况下无需修改。主要用于重要的数据 加密处理，提高系统的安全性，避免遭到攻击者的恶意破坏。密匙主要用于用户密码，CSRF机制和会话Session等数据加密。12345* 用户密码：Django内置一套用户管理系统，该系统具有用户认证和存储用户信息等功能，在创建用户的时候，将用户的密码通过密匙进行加密处理，保证用户的安全性。* CSRF机制：该机制主要用于表单提交，防止窃取网站的用户信息来制造恶意请求* 会话Session：Session的信息存放在Cookies，以一串随机的字符串表示，用于标识当前访问网站的用户身份，记录相关用户信息。调试模式DEBUG：该值为布尔类型。如果在开发调试阶段应设置为True，在开发调试过程中会自动检测代码是否 发生更改，根据检测结果执行是否刷新重启系统。如果项目部署上线，将其改为False，否则会泄露系统的相关信息。域名访问权限ALLOWED_HOSTS:设置可访问的域名，默认值为空。当DEBUG为True并且ALLOWED_HOSTS为空时，项目只允许以localhost或127.0.0.1在浏览器上访问启动。当DEBUG为False时，ALLOWED_HOSTS为必填项，否则程序无法启动，如果想允许所有域名访问，可设置ALLOW_HOSTS=[‘*’]。App列表INSTALLED_APPS：告诉Django有哪些App。在创建项目时已有admin，auth，和session等配置等信息，这些都是Django内置的应用功能，各个功能说明如下。123456* admin:内置的后台管理系统。* auth：内置的用户认证系统。* contenttypes：记录项目中所有的model元数据（Django的ORM框架）。* session：Session会话功能，用于标识当前访问网站的 用户身份，记录相关用户信息。* message：消息提示功能。* staticfiles：查找静态资源路径。静态资源（static）123456789101112# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/2.1/howto/static-files/STATIC_URL = '/static/' STATIC_ROOT = os.path.join(BASE_DIR, "static/")# 设置根目录的静态资源文件夹staticSTATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'),# 设置App的静态资源文件夹 os.path.join(BASE_DIR, '/static')， ]​​ CSS也称层叠样式表（Cascading Style Sheets），是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。​ JavaScript是一种直译式脚本语言，也是一种动态类型，弱类型，基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。STATIC_URL是必须配置的属性而且属性值不能为空。如果没有配置STATICFILES_DIRS，则STATIC_URL只能识别App里的static静态资源文件夹。STATICFILES_DIRS是可选配置属性，属性值为列表或元组格式，每个列表（元组）元素代表一个静态资源文件夹，这些文件夹可行命名。在浏览器上访问项目的静态资源时，无论项目的静态资源文件夹是如何命名的，在浏览器上，静态资源的上级目录必须为static，而static而STATIC_URL的属性值,因为STATIC_URL也是静态资源的起始URL。​ 除此之外，静态资源配置还有STATIC_ROOT，其作用是方便在服务器上部署项目，实现服务器和项目之间的映射。STATIC_URL和STATICFILES_DIRS区别STATIC_URL是必须配置的属性而且属性的值不能为空。如果没有配置STATICFILES_DIRS,则STATIC_URL只能识别App里面的static静态资源文件夹。STATICFILES_DIRS是可选配置属性，属性值为列表或元组格式，每个列表（元组）元素代表一个静态资源文件夹，这些文件夹可自行命名。在浏览器上访问项目的静态资源时，无论项目的静态资源文件夹是如何命名的，在浏览器上，静态资源的上级目录必须为static，而static是STATIC_URL的属性值，因为STATIC_URL也是静态资源的起始URL。模板路径（template）在web开发中，模板是一种较为特殊的HTML文档。这个HTML文档嵌入了一些能够让Python识别的变量和指令，然后程序解析这些变量和指令，生成完整的HTML网页并返回给用户浏览。模板是Django里面的MTV框架模式的T部分，配置模板路径是Django在解析模板时，如何找到模板所在的位置。创建项目时，Django以有初始的模板配置信息。如下：123456789101112131415161718TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [BASE_DIR, 'templates'], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', # 自定义模版全局变量(默认变量) 'article.views.global_settings', ], &#125;, &#125;,]模板信息是以列表格式呈现的，每个元素具有不同的含义，说明如下：BACKEND：定义模板引擎，用于识别模板里面的变量和指令。内置的模板引擎有DjangoTemplate和jinjia2.Jinjia2，每个模板引擎都有自己的变量和指令语法。DIRS：设置模板所在的路径，告诉Django在那个地方查找模板的位置，默认为空列表APP_DIRS:是否在App里面查找模板文件OPTIONS：用于填充在RequestContext中上下文调用函数，一般情况下不做任何修改。数据库设置（Databases）在settings文件下 有一个DATABASES属性123456789101112131415DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', # 数据库引擎 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), # 本地sqllite3数据库位置 'USER': # 用户名 'PASSWORD': # 数据库密码 'HOST': # 数据库主机地址 &#125; &#125;# 默认的django使用sqllite3作为数据库 # django提供四种 ENGINE 数据库引擎 # django.db.backends.mysql # django.db.backends.oracle # django.db.backends.splite3# 如果你使用的是 PostgreSQL 或者Mysql的话，已经是先创建了数据库，但是默认的SQLlite不需要sqlite3 轻量级数据库（数据存放在文件里面）在Django连接MYSQL数据库时候如果提示django.db.utils.OperationalError的错误信息，这是因为MYSQL8.0版本的密码加密方式发生了变化，8.0版本的用户密码采用的是cha2加密方法。解决方法，把SQL语句将8.0版本加密方法改回原来的加密方式。123# newpassword 是我们设置的用户密码ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'newpassword';FLUSH PRIVILEGES;中间件（Middlewere）中间件（Middleware）是处理Django的request和response对象的钩子。当用户在网站中进行单击某个按钮等操作时，这个动作是用户向网站发送请求（request）；而网页会根据用户的操作返回相关的网页内容，这个过程称为响应处理（response）。从请求到响应的过程中，当Django接收到用户的请求时，Django首先经过中间件处理请求消息，执行相关的处理，然后将处理结果返回给用户，中间件的执行流程如图：如上图，中间件的作用主要是处理用户的请求信息。开发者也可以根据自己的开发需求自定义中间件，只要将自定义的中间件添加到配置属性MIDDLEWARE中即可激活。一般情况下，Django默认的中间件配置均可满足大部分的开发需求。1234567'django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware','django.middleware.csrf.CsrfViewMiddleware','django.contrib.auth.middleware.AuthenticationMiddleware','django.contrib.messages.middleware.MessageMiddleware','django.middleware.clickjacking.XFrameOptionsMiddleware',配置属性MIDDLEWARE的数据格式为列表类型，每个中间件的设置顺序是固定的，如果随意变更中间件很容易导致程序异常，每个中间件的说明如下：SecurityMiddleware：内置的安全机制，保护用户与网站的通信安全。SessionMiddleware：会话Session。LocaleModdleware：支持中文语言。CommonMiddleware：处理请求信息，规范化请求内容。CsrViewMiddleware：开启CSRF防护功能。AuthenticationMiddleware：开启内置的用户认证系统。MessageMiddleware：开启内置的信息提示功能。XFrameOptionsMiddleware：防止恶意程序点击劫持。修改时区及语言LANGUAGE_CODE = ‘en-us’ #语言TIME_ZONE = ‘UTC’ #时区12LANGUAGE_CODE = 'zh-Hans'TIME_ZONE = 'Asia/Shanghai'开启测试服务器用来展示你创建出来的空项目/home/Publc_Class/5-17-django框架/python3 manage.py runserver 0.0.0.0:9090开启了一个测试服务器runserver 可以让你在浏览器看到效果，但是这个是测试服务器，压力不过百创建默认数据库因为django自带的admin界面，首先需要数据库来支持我们来先创建出一个数据库1234makemigrations 数据库前后是否有变化，生成出迁移文件migrate 根据迁移文件 来对应的执行SQL语句 python3 manage.py makemigrationspython3 manage.py migrate如果数据库创建完成，那么目录结构下和manage.py同级的就会有一个db.splite3文件有了这个数据库，就可以创建超级用户来管理admin界面啦！为admin界面创建超级用户数据库有了，要创建超级用户python3 manage.py createsuperuser12345Username (leave blank to use 'root'): rootEmail address: 2573799357@qq.com Password: Password (again): Superuser created successfully.]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高德无人机科技研发岗（测试工程师）面试总结]]></title>
    <url>%2F2019%2F09%2F30%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[高德无人机科技研发岗（测试工程师）面试总结技术面1.在51job上面投递的简历，本科院校“双非”，有一些项目经验。2.面试的时候是技术工程师来一面。问了我关于C++问题（本人主攻Python），有点把我问住了，questionC11标准里，关于智能指针有什么新特性？回答链接：https://www.jianshu.com/p/4f58ebc43b824.我介绍了我的项目经验和实践能力。3.因为可能急需招人，面试官看了我的项目经验等，还是给了我机会。面人资问我期望薪资多少？我说4k然后又问我最低能接受的薪资是多少？我说3.3K现在才明白这是个坑，真正谈的时候是按照你的最低接受薪资来谈的，千万不要说的很低很低。不然后面你就算再谈，也加不了多少钱。这个是我面试受益的第一点。还有就是，不要觉得自己的工作廉价，不敢往高的价格谈（我之前以为自己面试问题都没回答对，而且对C++不熟）不敢向高的要，后来觉得面试首先自己要看得起自己。不管怎么样，薪资不能太低。总结​ 这次短暂的面试让我受益了很多，从应届生小白里面跳出来。希望自己接受这个教训，不要急于求成。面试也应该诚实，懂就懂，不懂就不懂，最忌讳不懂装懂（自己心里要有数）。选择岗位应该长远考虑，不应该只看重面前的小利益。各方面应该考虑全面，多和家里的长辈等有经验的人沟通。]]></content>
      <categories>
        <category>面试经历</category>
      </categories>
      <tags>
        <tag>面试总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 语言中 void* 详解及应用]]></title>
    <url>%2F2019%2F09%2F30%2FC%20%E8%AF%AD%E8%A8%80%E4%B8%AD%20void%20%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[C 语言中 void* 详解及应用void 在英文中作为名词的解释为 “空虚、空间、空隙”，而在 C 语言中，void 被翻译为“无类型”，相应的void * 为“无类型指针”。void 似乎只有”注释”和限制程序的作用，当然，这里的”注释”不是为我们人提供注释，而是为编译器提供一种所谓的注释。void 的作用1.对函数返回的限定，这种情况我们比较常见。2.对函数参数的限定，这种情况也是比较常见的。一般我们常见的就是这两种情况：当函数不需要返回值值时，必须使用void限定，这就是我们所说的第一种情况。例如：void func（int a,char *b）。当函数不允许接受参数时，必须使用void限定，这就是我们所说的第二种情况。例如：int func(void)。void 指针的使用规则\1. void 指针可以指向任意类型的数据，就是说可以用任意类型的指针对 void 指针对 void 指针赋值。例如：123int *a；void *p；p=a；如果要将 void 指针 p 赋给其他类型的指针，则需要强制类型转换，就本例而言：a=（int *）p。在内存的分配中我们可以见到 void 指针使用：内存分配函数 malloc 函数返回的指针就是 void * 型，用户在使用这个指针的时候，要进行强制类型转换，也就是显式说明该指针指向的内存中是存放的什么类型的数据 (int *)malloc(1024) 表示强制规定 malloc 返回的 void* 指针指向的内存中存放的是一个个的 int 型数据。\2. 在 ANSI C 标准中，不允许对 void 指针进行一些算术运算如 p++ 或 p+=1 等，因为既然 void 是无类型，那么每次算术运算我们就不知道该操作几个字节，例如 char 型操作 sizeof(char) 字节，而 int 则要操作 sizeof(int) 字节。而在 GNU 中则允许，因为在默认情况下，GNU 认为 void * 和 char * 一样，既然是确定的，当然可以进行一些算术操作，在这里sizeof(*p)==sizeof(char)。void 几乎只有”注释”和限制程序的作用，因为从来没有人会定义一个 void 变量，让我们试着来定义：1void a;这行语句编译时会出错，提示“illegal use of type ‘void’”。即使 void a 的编译不会出错，它也没有任何实际意义。众所周知，如果指针 p1 和 p2 的类型相同，那么我们可以直接在 p1 和 p2 间互相赋值；如果 p1 和 p2 指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的指针类型转换为左边指针的类型。123456float *p1;int *p2;p1 = p2;//其中p1 = p2语句会编译出错，//提示“&apos;=&apos; : cannot convert from &apos;int *&apos; to &apos;float *&apos;”，必须改为：p1 = (float *)p2;而 void * 则不同，任何类型的指针都可以直接赋值给它，无需进行强制类型转换。123void *p1;int *p2;p1 = p2;但这并不意味着，void * 也可以无需强制类型转换地赋给其它类型的指针。因为”无类型”可以包容”有类型”，而”有类型”则不能包容”无类型”。小心使用 void 指针类型:按照 ANSI(American National Standards Institute) 标准，不能对 void 指针进行算法操作，即下列操作都是不合法的：1234567void * pvoid;pvoid++; //ANSI：错误pvoid += 1; //ANSI：错误//ANSI标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指向数据类型大小的。//例如：int *pint;pint++; //ANSI：正确pint++ 的结果是使其增大 sizeof(int)。但是 GNU 则不这么认定，它指定 void * 的算法操作与 char * 一致。因此下列语句在 GNU 编译器中皆正确：12pvoid++; //GNU：正确pvoid += 1; //GNU：正确pvoid++ 的执行结果是其增大了 1。在实际的程序设计中，为迎合 ANSI 标准，并提高程序的可移植性，我们可以这样编写实现同样功能的代码：123void * pvoid;((char *)pvoid)++; //ANSI：错误；GNU：正确(char *)pvoid += 1; //ANSI：错误；GNU：正确GNU 和 ANSI 还有一些区别，总体而言，GNU 较 ANSI 更”开放”，提供了对更多语法的支持。但是我们在真实设计时，还是应该尽可能地迎合 ANSI 标准。 如果函数的参数可以是任意类型指针，那么应声明其参数为void *。注：void 指针可以任意类型的数据，可以在程序中给我们带来一些好处，函数中形为指针类型时，我们可以将其定义为 void 指针，这样函数就可以接受任意类型的指针。如：典型的如内存操作函数 memcpy 和 memset 的函数原型分别为：12void * memcpy(void *dest, const void *src, size_t len);void * memset ( void * buffer, int c, size_t num );这样，任何类型的指针都可以传入 memcpy 和 memset 中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型（参见 C 语言实现泛型编程）。如果 memcpy 和 memset 的参数类型不是 void *，而是 char *，那才叫真的奇怪了！这样的 memcpy 和 memset 明显不是一个”纯粹的，脱离低级趣味的”函数！void 的出现只是为了一种抽象的需要，如果你正确地理解了面向对象中”抽象基类”的概念，也很容易理解 void 数据类型。正如不能给抽象基类定义一个实例，我们也不能定义一个 void（让我们类比的称 void 为”抽象数据类型”）变量。原文地址：https://www.cnblogs.com/wuyudong/p/c-void-point.html]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>Void* 知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机系统组成及工作原理简介]]></title>
    <url>%2F2019%2F09%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[计算机系统组成及工作原理简介硬件系统中央控制器 CPU运算器 ALU又称算数逻辑部件，是计算机用来进行数据运算的部件算数运算加、减、乘、除四则运算逻辑运算与、或、非、异或等逻辑操作，以及移位、比较和传送等操作，亦称算术逻辑部件（ALU）控制器 Controller通过地址访问存储器，逐条取出选中单元的指令，分析指令，根据指令产生相应的控制信号，用于其他各个部件，控制其他部件完成指令要求的操作。存储器 Memory：计算机中具有记忆能力的部件，用来存放程序或数据内存储器内存，又称主存，是CPU能根据地址线直接寻址的存储空间，是计算机内部存放数据的硬件设备，是程序和数据存储的基本要素。外存储器外存，又称辅存，作为一种辅助存储设备，主要用来存放一些暂时不用而又需长期保存的程序或数据。输入设备 Input Device用来输入程序和数据的部件：常用的输入设备有键盘，鼠标，传声器（麦克风），扫描仪，手写板，数码相机，摄像头等。输出设备 Output Device显示输出结果的部件 显示器，音响，打印机，绘图仪。软件系统系统软件管理，监控，维护计算机正常工作和供用户操作使用的计算机软件。应用软件在某种具体应用，供最终用户使用的软件。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas函数]]></title>
    <url>%2F2019%2F08%2F25%2Fpandas%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[【python】Pandas中DataFrame基本函数整理构造函数DataFrame([data, index, columns, dtype, copy]) #构造数据框1属性和数据DataFrame.axes #index: 行标签；columns: 列标签DataFrame.as_matrix([columns]) #转换为矩阵DataFrame.dtypes #返回数据的类型DataFrame.ftypes #返回每一列的 数据类型float64:denseDataFrame.get_dtype_counts() #返回数据框数据类型的个数DataFrame.get_ftype_counts() #返回数据框数据类型float64:dense的个数DataFrame.select_dtypes([include, include]) #根据数据类型选取子数据框DataFrame.values #Numpy的展示方式DataFrame.axes #返回横纵坐标的标签名DataFrame.ndim #返回数据框的纬度DataFrame.size #返回数据框元素的个数DataFrame.shape #返回数据框的形状DataFrame.memory_usage() #每一列的存储12345678910111213类型转换1234DataFrame.astype(dtype[, copy, errors]) #转换数据类型DataFrame.copy([deep]) #deep深度复制数据DataFrame.isnull() #以布尔的方式返回空值DataFrame.notnull() #以布尔的方式返回非空值1234索引和迭代123456789101112131415161718DataFrame.head([n]) #返回前n行数据DataFrame.at #快速标签常量访问器DataFrame.iat #快速整型常量访问器DataFrame.loc #标签定位，使用名称DataFrame.iloc #整型定位，使用数字DataFrame.insert(loc, column, value) #在特殊地点loc[数字]插入column[列名]某列数据DataFrame.iter() #Iterate over infor axisDataFrame.iteritems() #返回列名和序列的迭代器DataFrame.iterrows() #返回索引和序列的迭代器DataFrame.itertuples([index, name]) #Iterate over DataFrame rows as namedtuples, with index value as first element of the tuple.DataFrame.lookup(row_labels, col_labels) #Label-based “fancy indexing” function for DataFrame.DataFrame.pop(item) #返回删除的项目DataFrame.tail([n]) #返回最后n行DataFrame.xs(key[, axis, level, drop_level]) #Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.DataFrame.isin(values) #是否包含数据框中的元素DataFrame.where(cond[, other, inplace, …]) #条件筛选DataFrame.mask(cond[, other, inplace, …]) #Return an object of same shape as self and whose corresponding entries are from self where cond is False and otherwise are from other.DataFrame.query(expr[, inplace]) #Query the columns of a frame with a boolean expression.123456789101112131415161718二元运算123456789101112131415161718192021222324DataFrame.add(other[,axis,fill_value]) #加法，元素指向DataFrame.sub(other[,axis,fill_value]) #减法，元素指向DataFrame.mul(other[, axis,fill_value]) #乘法，元素指向DataFrame.div(other[, axis,fill_value]) #小数除法，元素指向DataFrame.truediv(other[, axis, level, …]) #真除法，元素指向DataFrame.floordiv(other[, axis, level, …]) #向下取整除法，元素指向DataFrame.mod(other[, axis,fill_value]) #模运算，元素指向DataFrame.pow(other[, axis,fill_value]) #幂运算，元素指向DataFrame.radd(other[, axis,fill_value]) #右侧加法，元素指向DataFrame.rsub(other[, axis,fill_value]) #右侧减法，元素指向DataFrame.rmul(other[, axis,fill_value]) #右侧乘法，元素指向DataFrame.rdiv(other[, axis,fill_value]) #右侧小数除法，元素指向DataFrame.rtruediv(other[, axis, …]) #右侧真除法，元素指向DataFrame.rfloordiv(other[, axis, …]) #右侧向下取整除法，元素指向DataFrame.rmod(other[, axis,fill_value]) #右侧模运算，元素指向DataFrame.rpow(other[, axis,fill_value]) #右侧幂运算，元素指向DataFrame.lt(other[, axis, level]) #类似Array.ltDataFrame.gt(other[, axis, level]) #类似Array.gtDataFrame.le(other[, axis, level]) #类似Array.leDataFrame.ge(other[, axis, level]) #类似Array.geDataFrame.ne(other[, axis, level]) #类似Array.neDataFrame.eq(other[, axis, level]) #类似Array.eqDataFrame.combine(other,func[,fill_value, …]) #Add two DataFrame objects and do not propagate NaN values, so if for aDataFrame.combine_first(other) #Combine two DataFrame objects and default to non-null values in frame calling the method.123456789101112131415161718192021222324函数应用&amp;分组&amp;窗口12345678DataFrame.apply(func[, axis, broadcast, …]) #应用函数DataFrame.applymap(func) #Apply a function to a DataFrame that is intended to operate elementwise, i.e.DataFrame.aggregate(func[, axis]) #Aggregate using callable, string, dict, or list of string/callablesDataFrame.transform(func, *args, **kwargs) #Call function producing a like-indexed NDFrameDataFrame.groupby([by, axis, level, …]) #分组DataFrame.rolling(window[, min_periods, …]) #滚动窗口DataFrame.expanding([min_periods, freq, …]) #拓展窗口DataFrame.ewm([com, span, halflife, …]) #指数权重窗口12345678描述统计学12345678910111213141516171819202122232425262728293031323334DataFrame.abs() #返回绝对值DataFrame.all([axis, bool_only, skipna]) #Return whether all elements are True over requested axisDataFrame.any([axis, bool_only, skipna]) #Return whether any element is True over requested axisDataFrame.clip([lower, upper, axis]) #Trim values at input threshold(s).DataFrame.clip_lower(threshold[, axis]) #Return copy of the input with values below given value(s) truncated.DataFrame.clip_upper(threshold[, axis]) #Return copy of input with values above given value(s) truncated.DataFrame.corr([method, min_periods]) #返回本数据框成对列的相关性系数DataFrame.corrwith(other[, axis, drop]) #返回不同数据框的相关性DataFrame.count([axis, level, numeric_only]) #返回非空元素的个数DataFrame.cov([min_periods]) #计算协方差DataFrame.cummax([axis, skipna]) #Return cumulative max over requested axis.DataFrame.cummin([axis, skipna]) #Return cumulative minimum over requested axis.DataFrame.cumprod([axis, skipna]) #返回累积DataFrame.cumsum([axis, skipna]) #返回累和DataFrame.describe([percentiles,include, …]) #整体描述数据框DataFrame.diff([periods, axis]) #1st discrete difference of objectDataFrame.eval(expr[, inplace]) #Evaluate an expression in the context of the calling DataFrame instance.DataFrame.kurt([axis, skipna, level, …]) #返回无偏峰度Fisher’s (kurtosis of normal == 0.0).DataFrame.mad([axis, skipna, level]) #返回偏差DataFrame.max([axis, skipna, level, …]) #返回最大值DataFrame.mean([axis, skipna, level, …]) #返回均值DataFrame.median([axis, skipna, level, …]) #返回中位数DataFrame.min([axis, skipna, level, …]) #返回最小值DataFrame.mode([axis, numeric_only]) #返回众数DataFrame.pct_change([periods, fill_method]) #返回百分比变化DataFrame.prod([axis, skipna, level, …]) #返回连乘积DataFrame.quantile([q, axis, numeric_only]) #返回分位数DataFrame.rank([axis, method, numeric_only]) #返回数字的排序DataFrame.round([decimals]) #Round a DataFrame to a variable number of decimal places.DataFrame.sem([axis, skipna, level, ddof]) #返回无偏标准误DataFrame.skew([axis, skipna, level, …]) #返回无偏偏度DataFrame.sum([axis, skipna, level, …]) #求和DataFrame.std([axis, skipna, level, ddof]) #返回标准误差DataFrame.var([axis, skipna, level, ddof]) #返回无偏误差 12345678910111213141516171819202122232425262728293031323334从新索引&amp;选取&amp;标签操作12345678910111213141516171819202122232425DataFrame.add_prefix(prefix) #添加前缀DataFrame.add_suffix(suffix) #添加后缀DataFrame.align(other[, join, axis, level]) #Align two object on their axes with theDataFrame.drop(labels[, axis, level, …]) #返回删除的列DataFrame.drop_duplicates([subset, keep, …]) #Return DataFrame with duplicate rows removed, optionally onlyDataFrame.duplicated([subset, keep]) #Return boolean Series denoting duplicate rows, optionally onlyDataFrame.equals(other) #两个数据框是否相同DataFrame.filter([items, like, regex, axis]) #过滤特定的子数据框DataFrame.first(offset) #Convenience method for subsetting initial periods of time series data based on a date offset.DataFrame.head([n]) #返回前n行DataFrame.idxmax([axis, skipna]) #Return index of first occurrence of maximum over requested axis.DataFrame.idxmin([axis, skipna]) #Return index of first occurrence of minimum over requested axis.DataFrame.last(offset) #Convenience method for subsetting final periods of time series data based on a date offset.DataFrame.reindex([index, columns]) #Conform DataFrame to new index with optional filling logic, placing NA/NaN in locations having no value in the previous index.DataFrame.reindex_axis(labels[, axis, …]) #Conform input object to new index with optional filling logic, placing NA/NaN in locations having no value in the previous index.DataFrame.reindex_like(other[, method, …]) #Return an object with matching indices to myself.DataFrame.rename([index, columns]) #Alter axes input function or functions.DataFrame.rename_axis(mapper[, axis, copy]) #Alter index and / or columns using input function or functions.DataFrame.reset_index([level, drop, …]) #For DataFrame with multi-level index, return new DataFrame with labeling information in the columns under the index names, defaulting to ‘level_0’, ‘level_1’, etc.DataFrame.sample([n, frac, replace, …]) #返回随机抽样DataFrame.select(crit[, axis]) #Return data corresponding to axis labels matching criteriaDataFrame.set_index(keys[, drop, append ]) #Set the DataFrame index (row labels) using one or more existing columns.DataFrame.tail([n]) #返回最后几行DataFrame.take(indices[, axis, convert]) #Analogous to ndarray.takeDataFrame.truncate([before, after, axis ]) #Truncates a sorted NDFrame before and/or after some particular index value.12345678910111213141516171819202122232425处理缺失值123DataFrame.dropna([axis, how, thresh, …]) #Return object with labels on given axis omitted where alternately anyDataFrame.fillna([value, method, axis, …]) #填充空值DataFrame.replace([to_replace, value, …]) #Replace values given in ‘to_replace’ with ‘value’.123从新定型&amp;排序&amp;转变形态1234567891011121314DataFrame.pivot([index, columns, values]) #Reshape data (produce a “pivot” table) based on column values.DataFrame.reorder_levels(order[, axis]) #Rearrange index levels using input order.DataFrame.sort_values(by[, axis, ascending]) #Sort by the values along either axisDataFrame.sort_index([axis, level, …]) #Sort object by labels (along an axis)DataFrame.nlargest(n, columns[, keep]) #Get the rows of a DataFrame sorted by the n largest values of columns.DataFrame.nsmallest(n, columns[, keep]) #Get the rows of a DataFrame sorted by the n smallest values of columns.DataFrame.swaplevel([i, j, axis]) #Swap levels i and j in a MultiIndex on a particular axisDataFrame.stack([level, dropna]) #Pivot a level of the (possibly hierarchical) column labels, returning a DataFrame (or Series in the case of an object with a single level of column labels) having a hierarchical index with a new inner-most level of row labels.DataFrame.unstack([level, fill_value]) #Pivot a level of the (necessarily hierarchical) index labels, returning a DataFrame having a new level of column labels whose inner-most level consists of the pivoted index labels.DataFrame.melt([id_vars, value_vars, …]) #“Unpivots” a DataFrame from wide format to long format, optionallyDataFrame.T #Transpose index and columnsDataFrame.to_panel() #Transform long (stacked) format (DataFrame) into wide (3D, Panel) format.DataFrame.to_xarray() #Return an xarray object from the pandas object.DataFrame.transpose(*args, **kwargs) #Transpose index and columns1234567891011121314Combining&amp; joining&amp;merging12345DataFrame.append(other[, ignore_index, …]) #追加数据DataFrame.assign(**kwargs) #Assign new columns to a DataFrame, returning a new object (a copy) with all the original columns in addition to the new ones.DataFrame.join(other[, on, how, lsuffix, …]) #Join columns with other DataFrame either on index or on a key column.DataFrame.merge(right[, how, on, left_on, …]) #Merge DataFrame objects by performing a database-style join operation by columns or indexes.DataFrame.update(other[, join, overwrite, …]) #Modify DataFrame in place using non-NA values from passed DataFrame.12345时间序列12345678910DataFrame.asfreq(freq[, method, how, …]) #将时间序列转换为特定的频次DataFrame.asof(where[, subset]) #The last row without any NaN is taken (or the last row withoutDataFrame.shift([periods, freq, axis]) #Shift index by desired number of periods with an optional time freqDataFrame.first_valid_index() #Return label for first non-NA/null valueDataFrame.last_valid_index() #Return label for last non-NA/null valueDataFrame.resample(rule[, how, axis, …]) #Convenience method for frequency conversion and resampling of time series.DataFrame.to_period([freq, axis, copy]) #Convert DataFrame from DatetimeIndex to PeriodIndex with desiredDataFrame.to_timestamp([freq, how, axis]) #Cast to DatetimeIndex of timestamps, at beginning of periodDataFrame.tz_convert(tz[, axis, level, copy]) #Convert tz-aware axis to target time zone.DataFrame.tz_localize(tz[, axis, level, …]) #Localize tz-naive TimeSeries to target time zone.12345678910作图1234567891011121314DataFrame.plot([x, y, kind, ax, ….]) #DataFrame plotting accessor and methodDataFrame.plot.area([x, y]) #面积图Area plotDataFrame.plot.bar([x, y]) #垂直条形图Vertical bar plotDataFrame.plot.barh([x, y]) #水平条形图Horizontal bar plotDataFrame.plot.box([by]) #箱图BoxplotDataFrame.plot.density(**kwds) #核密度Kernel Density Estimate plotDataFrame.plot.hexbin(x, y[, C, …]) #Hexbin plotDataFrame.plot.hist([by, bins]) #直方图HistogramDataFrame.plot.kde(**kwds) #核密度Kernel Density Estimate plotDataFrame.plot.line([x, y]) #线图Line plotDataFrame.plot.pie([y]) #饼图Pie chartDataFrame.plot.scatter(x, y[, s, c]) #散点图Scatter plotDataFrame.boxplot([column, by, ax, …]) #Make a box plot from DataFrame column optionally grouped by some columns orDataFrame.hist(data[, column, by, grid, …]) #Draw histogram of the DataFrame’s series using matplotlib / pylab.1234567891011121314转换为其他格式123456789101112131415161718192021DataFrame.from_csv(path[, header, sep, …]) #Read CSV file (DEPRECATED, please use pandas.read_csv() instead).DataFrame.from_dict(data[, orient, dtype]) #Construct DataFrame from dict of array-like or dictsDataFrame.from_items(items[,columns,orient]) #Convert (key, value) pairs to DataFrame.DataFrame.from_records(data[, index, …]) #Convert structured or record ndarray to DataFrameDataFrame.info([verbose, buf, max_cols, …]) #Concise summary of a DataFrame.DataFrame.to_pickle(path[, compression, …]) #Pickle (serialize) object to input file path.DataFrame.to_csv([path_or_buf, sep, na_rep]) #Write DataFrame to a comma-separated values (csv) fileDataFrame.to_hdf(path_or_buf, key, **kwargs) #Write the contained data to an HDF5 file using HDFStore.DataFrame.to_sql(name, con[, flavor, …]) #Write records stored in a DataFrame to a SQL database.DataFrame.to_dict([orient, into]) #Convert DataFrame to dictionary.DataFrame.to_excel(excel_writer[, …]) #Write DataFrame to an excel sheetDataFrame.to_json([path_or_buf, orient, …]) #Convert the object to a JSON string.DataFrame.to_html([buf, columns, col_space]) #Render a DataFrame as an HTML table.DataFrame.to_feather(fname) #write out the binary feather-format for DataFramesDataFrame.to_latex([buf, columns, …]) #Render an object to a tabular environment table.DataFrame.to_stata(fname[, convert_dates, …]) #A class for writing Stata binary dta files from array-like objectsDataFrame.to_msgpack([path_or_buf, encoding]) #msgpack (serialize) object to input file pathDataFrame.to_sparse([fill_value, kind]) #Convert to SparseDataFrameDataFrame.to_dense() #Return dense representation of NDFrame (as opposed to sparse)DataFrame.to_string([buf, columns, …]) #Render a DataFrame to a console-friendly tabular output.DataFrame.to_clipboard([excel, sep]) #Attempt to write text representation of object to the system cli]]></content>
      <categories>
        <category>python数据挖掘</category>
      </categories>
      <tags>
        <tag>pandas函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[妹子图爬虫（爬取妹子图图片）]]></title>
    <url>%2F2019%2F07%2F22%2Fpython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[python实现妹子图爬虫（爬取妹子网图片）一个简单的小爬虫实现爬取妹子图网站上的图片。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#coding=utf-8import requestsfrom bs4 import BeautifulSoupimport osall_url = 'http://www.mzitu.com'#http请求头Hostreferer = &#123; 'User-Agent':'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)', 'Referer':'http://www.mzitu.com' &#125;Picreferer = &#123; 'User-Agent':'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)', 'Referer':'http://i.meizitu.net'&#125;#此请求头破解盗链start_html = requests.get(all_url,headers = Hostreferer)#保存地址path = "D:\\mzitu\\"#找寻最大页数soup = BeautifulSoup(start_html.text,"html.parser")page = soup.find_all('a',class_='page-numbers')max_page = page[-2].textsame_url = 'http://www.mzitu.com/all/'for n in range(1,int(max_page)+1): ul = same_url+str(n) start_html = requests.get(ul, headers = Hostreferer) soup = BeautifulSoup(start_html.text,"html.parser") all_a = soup.find('div',class_='all').find_all('a',target='_blank') for a in all_a: title = a.get_text() #提取文本 if(title != ''): print("准备扒取："+title) #win不能创建带？的目录 if(os.path.exists(path+title.strip().replace('?',''))): #print('目录已存在') flag=1 else: os.makedirs(path+title.strip().replace('?','').replace(':', '')) flag=0 os.chdir(path + title.strip().replace('?','').replace(':', '')) href = a['href'] html = requests.get(href,headers = Hostreferer) mess = BeautifulSoup(html.text,"html.parser") pic_max = mess.find_all('span') try: pic_max = pic_max[9].text #最大页数 if(flag == 1 and len(os.listdir(path+title.strip().replace('?',''))) &gt;= int(pic_max)): print('已经保存完毕，跳过') continue for num in range(1, int(pic_max)+1): pic = href+'/'+str(num) html = requests.get(pic,headers = Hostreferer) mess = BeautifulSoup(html.text,"html.parser") pic_url = mess.find('img',alt = title) print(pic_url['src']) #exit(0) html = requests.get(pic_url['src'],headers = Picreferer) file_name = pic_url['src'].split(r'/')[-1] f = open(file_name,'wb') f.write(html.content) f.close() except Exception: pass print('完成 ') print('第',n,'页完成')原文参考：https://blog.csdn.net/baidu_35085676/article/details/68958267]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>爬虫实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据之Hadoop]]></title>
    <url>%2F2019%2F07%2F14%2Fhadoop%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Hadoop介绍组成部分Hadoop主要由3部分组成：Mapreduce编程模型HDFS分布式文件存储YARN配置信息管理员密码：admin123DNS1=202.103.24.68DNS2=202.103.44.150export HADOOP_HOME=/usr/local/hadoop-2.6.4export PATH=$HADOOP_HOME/bin$PATH:/usr/java/jdk1.8.0_201-amd64/binHadoop HDFS 简介概念：namenode：负责记录 数据块 的分布情况– 数据元数据信息datanode:负责实际存储 数据块block：是Hadoop最小存储数据单位 默认 128Msecondarynamenode: 辅助namenode完成fsimage管理或者优化HDFS简单命令hadoop version //查看版本hadoop fs //文件系统客户端hadoop jar //运行jar包hadoop classpath //查看类路径hadoop checknative //检查本地库并压缩hadoop distcp // 远程递归拷贝文件hadoop credential //认证hadoop trace //跟踪$ hdfs dfs -mkdir-p /user/ubuntu/ //在hdfs上建立文件夹$ hdfs dfs -puthdfs.cmd /user/ubuntu/ //将本地文件上传到HDFS$ hdfs dfs -get/user/ubuntu/hadoop.cmd a.cmd //将文件从HDFS取回本地$ hdfs dfs -rm -r -f /user/ubuntu/ //删除$ hdfs dfs -ls -R/ //递归展示HDFS文件系统一、hadoop所在目录cd usr/local/hadoop1二、启动hadoopbash ./starth.sh% 运行start-dfs.sh% 运行start-yarn.sh123启动dfs，浏览器查看：172.16.31.17:500701启动脚本，浏览器查看：172.16.31.17:80881停止脚本：bash ./stoph.sh1三、常用命令1.显示hadoop目录结构hdfs dfs -ls -R /12.在hadoop指定目录内创建新目录hdfs dfs -mkdir /winnie13.将本地文件夹存储至hadoophdfs dfs -put [本地目录] [hadoop目录]14.将本地文件存储至hadoophdfs dfs -put [本地地址] [hadoop目录]15.查看指定目录下内容hdfs dfs -ls [文件目录]16.打开某个已存在文件hdfs dfs -cat [file_path]17.在hadoop指定目录下新建一个空文件hdfs dfs -touchz /winnie/test03.txt18.将hadoop上某个文件重命名hdfs dfs -mv /winnie/test03.txt /winnie/test.txt19.将hadoop上某个文件down至本地已有目录下hdfs dfs -get [文件目录] [本地目录]110.将hadoop指定目录下所有内容保存为一个文件，同时down至本地hdfs dfs -getmerge /winnie/hadoop-file /home/spark/hadoop-file/test.txt111.删除hadoop上指定文件hdfs dfs -rm [文件地址]112.删除hadoop上指定文件夹（包含子目录等）hdfs dfs -rm -r [目录地址]hdfs dfs -rmr [目录地址]1213.将正在运行的hadoop作业kill掉hadoop job -kill [job-id]114.查看帮助hdfs dfs -help1四、安全模式1.退出安全模式NameNode在启动时会自动进入安全模式，安全模式是NameNode的一种状态，在这个阶段，文件系统不允许有任何修改。系统显示Name node in safe mode，说明系统正处于安全模式，这时只需要等待几十秒即可，也可通过下面的命令退出安全模式：/usr/local/hadoop$bin/hadoop dfsadmin -safemode leave12.进入安全模式在必要情况下，可以通过以下命令吧HDFS置于安全模式：/usr/local/hadoop$bin/hadoop dfsadmin -safemode enter1五、补充1.对hdfs操作的命令格式是hdfs dfs1.1 -ls 表示对hdfs下一级目录的查看1.2 -lsr 表示对hdfs目录的递归查看1.3 -mkdir 创建目录1.4 -put 从Linux上传文件到hdfs1.5 -get 从hdfs下载文件到linux1.6 -text 查看文件内容1.7 -rm 表示删除文件1.7 -rmr 表示递归删除文件2.hdfs在对数据存储进行block划分时，如果文件大小超过block，那么按照block大小进行划分；不如block size的，划分为一个块，是实际数据大小。3.hadoop常用命令：hdfs dfs 查看Hadoop HDFS支持的所有命令hdfs dfs –ls 列出目录及文件信息hdfs dfs –lsr 循环列出目录、子目录及文件信息hdfs dfs –tail /user/sunlightcs/test.txt 查看最后1KB的内容hdfs dfs –copyFromLocal test.txt /user/sunlightcs/test.txt 从本地文件系统复制文件到HDFS文件系统，等同于put命令hdfs dfs –copyToLocal /user/sunlightcs/test.txt test.txt 从HDFS文件系统复制文件到本地文件系统，等同于get命令hdfs dfs –chgrp [-R] /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录所属群组，选项-R递归执行，跟linux命令一样hdfs dfs –chown [-R] /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录拥有者，选项-R递归执行hdfs dfs –chmod [-R] MODE /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录权限，MODE可以为相应权限的3位数或+/-{rwx}，选项-R递归执行hdfs dfs –count [-q] PATH 查看PATH目录下，子目录数、文件数、文件大小、文件名/目录名hdfs dfs –cp SRC [SRC …] DST 将文件从SRC复制到DST，如果指定了多个SRC，则DST必须为一个目录hdfs dfs –du PATH 显示该目录中每个文件或目录的大小hdfs dfs –dus PATH 类似于du，PATH为目录时，会显示该目录的总大小hdfs dfs –expunge 清空回收站，文件被删除时，它首先会移到临时目录.Trash/中，当超过延迟时间之后，文件才会被永久删除hdfs dfs –getmerge SRC [SRC …] LOCALDST [addnl] 获取由SRC指定的所有文件，将它们合并为单个文件，并写入本地文件系统中的LOCALDST，选项addnl将在每个文件的末尾处加上一个换行符hdfs dfs –test –[ezd] PATH 对PATH进行如下类型的检查：-e PATH是否存在，如果PATH存在，返回0，否则返回1；-z 文件是否为空，如果长度为0，返回0，否则返回1； -d 是否为目录，如果PATH为目录，返回0，否则返回1hdfs dfs –text PATH 显示文件的内容，当文件为文本文件时，等同于cat；文件为压缩格式（gzip以及hadoop的二进制序列文件格式）时，会先解压缩hdfs dfs –help ls 查看某个[ls]命令的帮助文档Mapreduce解释mapper的角色:hadoop将用户提交的mapper可执行程序或脚本作为一个单独的进程加载起来，这个进程我们称之为mapper进程，hadoop不断地将文件片段转换为行，传递到我们的mapper进程中，mapper进程通过标准输入的方式一行一行地获取这些数据，然后设法将其转换为键值对，再通过标准输出的形式将这些键值对按照一对儿一行的方式输出出去。虽然在我们的mapper函数中，我们自己能分得清key/value(比方说有可能在我们的代码中使用的是string key,int value)，但是当我们采用标准输出之后，key value是打印到一行作为结果输出的(比如sys.stdout.write(“%s\t%s\n”%(birthyear,gender)))，因此我们为了保证hadoop能从中鉴别出我们的键值对，键值对中一定要以分隔符’\t’即Tab(也可自定义分隔符)字符分隔，这样才能保证hadoop正确地为我们进行partitoner、shuffle等等过程。reducer的角色:hadoop将用户提交的reducer可执行程序或脚本同样作为一个单独的进程加载起来，这个进程我们称之为reducer进程，hadoop不断地将键值对(按键排序)按照一对儿一行的方式传递到reducer进程中，reducer进程同样通过标准输入的方式按行获取这些键值对儿，进行自定义计算后将结果通过标准输出的形式输出出去。在reducer这个过程中需要注意的是：传递进reducer的键值对是按照键排过序的，这点是由MR框架的sort过程保证的，因此如果读到一个键与前一个键不同，我们就可以知道当前key对应的pairs已经结束了，接下来将是新的key对应的pairs。]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop介绍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据科学之统计学习]]></title>
    <url>%2F2019%2F07%2F14%2F%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[统计学中心倾向均值（常用的额）中位数分位数：它表示少于数据中特定百分比的一个值众数离散度极差方差统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数概率论中方差用来度量随机变量)和其数学期望（即均值）之间的偏离程度计算公式$$s^2 = \frac{\sum_{}(x-u)^2}{N}$$标准差中文环境中又常称均方差，是离均差平方的算术平均数的平方根，用σ表示。标准差是方差的算术平方根计算公式$$σ = \sqrt\frac{\sum_{}(x-u)^2}{N}$$相关性协方差协方差（Covariance）在概率论和统计学中用于衡量两个变量的总体误差。而方差是协方差的一种特殊情况，即当两个变量是相同的情况。计算公式概率论不独立和独立如果事件E和事件F独立意味着两个事同时发生的概率等于它们分别发生的概率的乘积。$$P（E, F） = P(E)*P(F)$$条件概率如果事件E与事件F独立，那么定义：$$P（E, F） = P(E)*P(F)$$如果两者不一定独立（并且概率都不为0），那么概率公式为：（已知F发生，在此条件下E发生的概率）$$P（E|F） = P（E, F）/P（F）$$]]></content>
      <categories>
        <category>统计学和概率论</category>
      </categories>
      <tags>
        <tag>数学知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之百度接口语音识别]]></title>
    <url>%2F2019%2F07%2F12%2F%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[python编程之百度接口语音识别首先在百度AI开放平台上创建语音识别应用，创建完毕应用后，得到系统分配给用户的AppID， API Key， secret Key，均为字符串，用于标识用户，为访问做签名验证。得到验证后，开始编程1.记录自己声音2.将记录下来的音频文件上传至云端3.解析返回后的结果python实现相关包 pyaudio，baidu-aip123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from aip import AipSpeechimport wavefrom pyaudio import PyAudio, paInt16def save_wave_file(filename, data): '''save the date to the wavfile''' wf = wave.open(filename, 'wb') wf.setnchannels(channels) wf.setsampwidth(sampwidth) wf.setframerate(framerate) wf.writeframes(b"".join(data)) wf.close()def my_record(): pa = PyAudio() stream = pa.open(format=paInt16, channels=1, rate=framerate, input=True, frames_per_buffer=NUM_SAMPLES) my_buf = [] count = 0 print('录音开始') while count &lt; TIME*10: # 控制录音时间 string_audio_data = stream.read(NUM_SAMPLES) my_buf.append(string_audio_data) count += 1 print('录音结束') save_wave_file('01.pcm', my_buf) stream.close()if __name__ == "__main__": framerate = 16000 NUM_SAMPLES = 2000 channels = 1 sampwidth = 2 TIME = 2 my_record() """ 我的 APPID AK SK """ APP_ID = '16795182 ' API_KEY = '8io5s7uv8pjYPUrQp1i8PcIg' SECRET_KEY = 'gK2MljvbcF3SKS4p0C2ieq1SCBNY48BD' client = AipSpeech(APP_ID, API_KEY, SECRET_KEY) # 读取文件 def get_file_content(filePath): with open(filePath, 'rb') as fp: return fp.read() # 识别本地文件 result = client.asr(get_file_content('01.pcm'), 'pcm', 16000, &#123; 'dev_pid': 1536, &#125;) # print(type(result)) print("语音识别结果：", result['result'])]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>语音识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据科学之数据可视化]]></title>
    <url>%2F2019%2F07%2F11%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数据可视化概述可视化的目的，是对数据进行可视化处理，以更明确地，有效的传递信息。数据可视化意义数据可视化是为了从数据中寻找三个方面的信息。模式。指数据中的规律。关系。指数据间的相关性。数据间的比较数据的构成数据的分布或联系异常。指有问题的数据。数据可视化的作用记录信息。用图形的方式描述各种具体或抽象的事物。分析推理。有效的提升了信息认知的效率，从而有助于人们更快地分析和推理出有效信息。信息传播和协同。数据可视化的分类科学可视化信息可视化可视分析学数据可视化基础数据类型根据数据模型，可将数据分为浮点数，整数，字符等根据概念模型类别型数据，有序型数据，区间型数据和比值型数据类别型数据：用于区分物体有序型数据：用来表示对象间的顺序关系区间型数据：用于得到对象间的定量关系。用于比较数值间的比列关系，可以精确地定义比例数据预处理数据的预处理的目的是提升数据质量数据质量包含以下六方面有效性：数据与实际情况对应时，是否违背约束条件准确性：数据能否精确的反映现实。完整性：采集数据集是否包含了数据源中 的所有数据点：且样本的属性都是完整的。一致性：整个数据集中的数据的衡量标准要一致时效性：数据适合当下时间区间内的分析任务可行性：数据源中的数据是使用者可依赖的。数据预处理步骤如下数据清理：指修正数据中的错误，识别脏数据，更正不一致数据的过程。数据集成：指把来自不同数据的同类数据进行合并，减少数据冲突，降低数据冗余程度等。数据归约：指在保证数据挖掘结果准确性的前提下，最大限度地精简数据量，得到简化的数据集。数据转换：指对数据进行规范化处理数据组织与管理大数据存储利用的是分布式存储与访问计数，它具有高效，容错性强等特点。分布式文件系统分布式文件系统是指文件在物理上可能被分散存储在不同地点的节点上，各节点通过计算机网络进行通信和数据传输，但仍然是一个完整的文件。常用的分布式系统有HDFS（hadoop分布式文件系统），GFS（Google分布式文件系统）等。文档存储文档存储支持对结构化数据的访问，一般以键值对的方式进行存储。文档存储类型也支持数组和列值键列式存储列式存储是指以流的方式在列中存储所有的数据键式存储以Key-Value存储，简称KV存储图形数据库图形数据库是NOSQL数据库的一种，是一种非关系型的数据库，它应用图形理论存储实体间的关系信息。关系型数据库关系模型是最传统的数据存储模型，数据按行存储在有架构界定的表中。用户可使用基于关系代数演算的结构化查询语言提供相应的语法查找符合条件的记录。内存数据库内存数据库就是将数据放在内存中直接操作的数据库。特点速度快，能处理实时型业务数据仓库数据仓库是一种特殊的数据库，一般用于存储海量数据，并直接支持后续的分析和决策操作。数据分析与数据挖掘数据分析统计分析是指对数据进行统计描述和统计推断的过程探索性数据分析是对调查，观测所得到的一些初步的杂乱无章的数据，在尽量少的先验假设下进行处理，通过作图，制表等形式和方程拟合，计算某些特征量等手段，探索数据的结构和规律的一种数据分析方法。验证性数据分析是指在已经有事先假设的关系模型等情况下，通过数据分析来验证已提出的假设在线分析和处理是一种交互式探索大规模多维数据集的方法。数据挖掘数据挖掘一般是指从大量的数据中通过算法搜索隐藏于其中的信息的过程。常见的数据挖掘分析方法有分类与预测，聚类分析，关联性分析和异常分析等。分类与预测聚类分析关联分析异常分析数据挖掘的步骤确定业务对象数据准备数据挖掘结果分析知识的同化]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>数据可视化概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站概念]]></title>
    <url>%2F2019%2F07%2F06%2Fserven%2F</url>
    <content type="text"><![CDATA[网站的组成目前多数网站由域名，空间服务器，DNS域名解析，网站程序和数据库等组成空间服务器（以下三种类型）虚拟主机：指在网络服务器上划分一定的磁盘空间供用户放置站点和应用组件等，提供必要的站点功能，数据存放和传输功能。所谓虚拟主机，也叫“网站空间”，就是把一台运行在互联网上的服务器划分成多个”虚拟“的服务器独立服务器：指性能更强大，整体硬件完全独立的服务器，其cpu都在8核以上。VPS（虚拟专用服务器）：将一个服务器分区成多个虚拟独立专享服务器的技术。网站的程序:是建设与修改网站所使用的编程语言。网站的分类资讯门户类网站企业品牌网站交易类网站B2C（Business To Consumer）网站：商家——消费者，主要是购物网站，用于商家和消费者之间的买卖，如传统的百货商店和购物广场。B2B（Business To Business）网站：商家——商家，主要是商务网站，用于商家之间的买卖，如传统的原材料市场和大型批发市场C2C（Consumer To Consumer）网站：消费者——消费者，主要以拍卖网站为主，用于个人的物品的买卖，如传统的旧货市场，跳骚市场，废品收购站等。办公及政府机构网站企业办公事物类网站政府办公类事物网站互动游戏网站功能性网站这类网站的主要特征是将一个具有广泛需求的共能扩展开来，开发一套强大的功能体系，将功能的实现推向极致。如：百度，goolge网站开发的常用术语域名：用于标识一个或多个ip地址DNS：域名系统，用于跟踪计算机的域名及其在互联网上的相应的IP地址]]></content>
      <categories>
        <category>网站知识</category>
      </categories>
      <tags>
        <tag>网站的基本概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法时间复杂度和五大经典排序算法]]></title>
    <url>%2F2019%2F06%2F29%2Fsix%2F</url>
    <content type="text"><![CDATA[渐进时间度表O记法所代表的是渐进上界限，Ω记法代表的是渐进下界Θ代表的集合是上述符号的交集，Θ(g) = O(g)常见的渐进运行时间实例时间复杂度相关名称相关实例及说明Θ（1）常数级哈希表的查询和修改Θ（lg n）对数级二分搜索，其对数基数并不重要Θ（n）线性级列表的遍历Θ(nlgn)线性对数级任意值序列的最优化排序，其复杂度等同于Θ(lg n!)Θ(n^2)平方级拿n个对象进行互相比对Θ(n^3)立方级Floyd-Warshall算法O(n^k)多项式级基于n的k层嵌套循环（k为整数），且必须满足K &gt; 0Ω(K^n)指数级每n项产生一个子集（其中k = 2），且必须满足K &gt; 1Θ(n!)阶乘级对n个值执行全排列操作冒泡排序冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 冒泡排序算法的运作如下： 1、比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。 2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 3、针对所有的元素重复以上的步骤，除了最后一个。 4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 ‘’’冒泡排序的时间复杂度为O(n^2)。1234567891011121314151617181920212223def store(x): '''冒泡排序算法实现''' f=0 while f &lt; len(x): i=0 j=1 while j &lt; len(x): if x[i] &lt;= x[j]: i = i + 1 j = j + 1 elif x[i] &gt; x[j]: var1 = x[i] var2 = x[j] x[j] = var1 x[i] = var2 i = i + 1 j = j + 1 f = f + 1 return xif __name__ == "__main__": test = [2,4,6,5,9,7,12,15,13,19,20,1,3] print(store(test))归并排序归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表， 即把待排序序列分为若干个子序列，每个子序列是有序的。 然后再把有序子序列合并为整体有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。123456789101112131415161718192021222324252627282930313233def merge_extend(x): '''归并排序算法''' # 拆分列表 if len(x) &lt;= 1: # 向下取整数 return x mid = len(x)//2 left = merge_extend(x[:mid]) right = merge_extend(x[mid:]) print(left,right) return merge_add(left, right)def merge_add(a, b): '''和并列表''' result = [] i = 0 j = 0 while i &lt; len(a) and j &lt; len(b): if a[i] &lt; b[j]: result.append(a[i]) i += 1 else: result.append(b[j]) j += 1 #print("a",a[i:]) #print("b",b[j:]) result.extend(a[i:]) result.extend(b[j:]) return resultif __name__ == "__main__": test=[11,0,5,7,3,6,8,1,2] print(merge_extend(test))插入排序插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列， 对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。简单插入排序的时间复杂度也是O(n^2)123456789101112def insert_sort(x): # 取列表的第一个元素为单独的一个，已经排好序的列表 for i in range(1, len(x)): # 要排序的的牌 for j in range(0, i): if x[i] &lt; x[j]: x[i], x[j] = x[j], x[i] return xif __name__=="__main__": test = [2,3,5,7,9,1,20,0,4,12,19,11,8,1] print(insert_sort(test))选择排序选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置， 然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。 选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上， 因此对n个元素的表进行排序总共进行至多n-1次交换。 在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。选择排序的时间复杂度为O(n^2)1234567891011def select_sort(x): '''选择排序''' new = [] while x: new.append(min(x)) x.remove(min(x)) return newif __name__=="__main__": test = [2,3,5,7,9,1,20,0,4,12,19,11,8,1] print(select_sort(test))快速排序1.先从待排序的数组中找出一个数作为基准数（取第一个数即可）， 2.然后将原来的数组划分成两部分：小于基准数的左子数组和大于等于基准数的右子数组。 3.然后对这两个子数组再递归重复上述过程，直到两个子数组的所有数都分别有序。 4.最后返回“左子数组” + “基准数” + “右子数组”，即是最终排序好的数组。快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)1234567891011121314151617def quick_sort(x): '''快速排序''' if len(x) &lt;= 1: return x base = x[0] left = [] right = [] for var in x: if var &gt; base: right.append(var) elif var &lt; base: left.append(var) return quick_sort(left) + [base] + quick_sort(right)if __name__ == "__main__": # 存在重复值被覆盖 test = [2,6,7,8,12,56,36,89,45,3]]]></content>
      <categories>
        <category>算法</category>
        <category>五大经典排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git文章更新测试]]></title>
    <url>%2F2019%2F06%2F28%2Ffive%2F</url>
    <content type="text"><![CDATA[这是一个测试文件test]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>测试文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的正则表达式]]></title>
    <url>%2F2019%2F06%2F26%2Ffour%2F</url>
    <content type="text"><![CDATA[匹配小数1[0-9]&#123;1,&#125;[.][0-9]*匹配整数1[0-9]中文的匹配1[\u4e00-\u9fa5]特殊符号和字符：123456789101112131415161718192021[A-Z0-9a-z]: A,1,a[abc]*: aaa,abc,acc,匹配前面的正则0次或多次a？: a,匹配前面的出现正则0次或一次.： 匹配任意字符\n\t1,2.3,4,5.a,c.*: acb,aaa,weaijdiajdw,desd.*?: 非贪婪匹配\d: 匹配任何数字 [0-9]*:002121,5498464\s: 匹配任意空白符 \n\t\v\r\f\w: 匹配任何数字，字母，字符 [A-Za-z0-9][u4e00-u9fa5] ：匹配中文a|b a,b1|2 1,2&#123;int&#125;:指明正则出现的次数+：匹配前面出现的正则一次或多次?：0次或一次*：0次或多次^:匹配开头$:匹配结尾^$:空[^A-Z]: 除了A-Z都匹配匹配双字节字符(包括汉字在内)：1[^\x00-\xff]匹配空白行的正则表达式：1\n\s*\r匹配HTML标记的正则表达式：1&lt;(\s*?)[^&gt;]*&gt;.*?|&lt;.*?&gt;匹配首尾空白字符的正则表达式：1^\s*|\s*$匹配Email地址的正则表达式：1\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*匹配网址URL的正则表达式：1[a-zA-z]+://[^\s]*匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：1^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$匹配国内电话号码：1\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;匹配腾讯QQ号：1[1-9][0-9]&#123;4,&#125;匹配中国邮政编码：12[1-9]\d&#123;5&#125;(?!\d)评注：中国邮政编码为6位数字匹配身份证：12\d&#123;15&#125;|\d&#123;18&#125;评注：中国的身份证为15位或18位匹配ip地址：12\d+\.\d+\.\d+\.\d+评注：提取ip地址时有用匹配特定数字：1234567891011^[1-9]\d*$ //匹配正整数^-[1-9]\d*$ //匹配负整数^-?[1-9]\d*$ //匹配整数^[1-9]\d*|0$ //匹配非负整数（正整数 + 0）^-[1-9]\d*|0$ //匹配非正整数（负整数 + 0）^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ //匹配正浮点数^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ //匹配负浮点数^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ //匹配浮点数^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ //匹配非负浮点数（正浮点数 + 0）^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$ //匹配非正浮点数（负浮点数 + 0）评注：处理大量数据时有用，具体应用时注意修正匹配特定字符串：12345^[A-Za-z]+$ //匹配由26个英文字母组成的字符串^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串^[a-z]+$ //匹配由26个英文字母的小写组成的字符串^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串^\w+$ //匹配由数字、26个英文字母或者下划线组成的字符串]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解释器介绍]]></title>
    <url>%2F2019%2F06%2F26%2Fthree%2F</url>
    <content type="text"><![CDATA[CPython当我们从Python官方网站下载并安装好Python 3.x后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。IPythonIPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。CPython用&gt;&gt;&gt;作为提示符，而IPython用In [序号]:作为提示符。JpythonJython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。PyPyPyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术（just-in-time compiler 即时编译器，通俗解释就是边编译边执行），对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。、IronPythonIronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。]]></content>
      <categories>
        <category>Python</category>
        <category>编译器介绍</category>
      </categories>
      <tags>
        <tag>python编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2019%2F06%2F23%2Ftow%2F</url>
    <content type="text"><![CDATA[Linux管理文件和目录的命令命令功能命令功能pwd显示当前目录ls查看目录下的内容cd改变所在目录cat显示文件的内容grep在文件中查找某字符cp复制文件touch创建文件mv移动文件rm删除文件rmdir删除目录pwd命令该命令的英文解释为print working directory(打印工作目录)。输入pwd命令，Linux会输出当前目录。cd命令cd命令用来改变所在目录。1234cd / 转到根目录中 cd ~ 转到/home/user用户目录下 cd /usr 转到根目录下的usr目录中-------------绝对路径 cd test 转到当前目录下的test子目录中-------相对路径ls命令​ ls命令用来查看目录的内容。选项含义-a列举目录中的全部文件，包括隐藏文件-l列举目录中的细节，包括权限、所有者、组群、大小、创建日期、文件是否是链接等-f列举的文件显示文件类型-r逆向，从后向前地列举目录中内容-R递归，该选项递归地列举当前目录下所有子目录内的内容-s大小，按文件大小排序-h以人类可读的方式显示文件的大小，如用K、M、G作单位ls -l examples.doc列举文件examples.doc的所有信息cat命令123cat命令可以用来合并文件，也可以用来在屏幕上显示整个文件的内容。cat snow.txt 该命令显示文件snow.txt的内容，ctrl+D退出cat。grep命令12345grep命令的最大功能是在一堆文件中查找一个特定的字符串。 grep money test.txt 以上命令在test.txt中查找money这个字符串，grep查找是区分大小写的touch命令​123touch命令用来创建新文件，他可以创建一个空白的文件，可以在其中添加文本和数据。 touch newfile 该命令创建一个名为newfile的空白文件。cp命令​ cp命令用来拷贝文件，要复制文件，输入命令：12cp &lt;source filename&gt; &lt;target filename&gt;cp t.txt Document/t 该命令将把文件t.txt复制到Document目录下，并命名为t。选项含义-i互动：如果文件将覆盖目标中的文件，他会提示确认-r递归：这个选项会复制整个目录树、子目录以及其他-v详细：显示文件的复制进度mv命令​ mv命令用来移动文件。选项说明-i互动：如果选择的文件会覆盖目标中的文件，他会提示确认-f强制：它会超越互动模式，不提示地移动文件，属于很危险的选项-v详细：显示文件的移动进度​ mv t.txt Document 把文件t.txt 移动到目录Document中。rm命令​ rm命令用来删除文件。选项说明-i互动：提示确认删除-f强制：代替互动模式，不提示确认删除-v详细：显示文件的删除进度-r递归：将删除某个目录以及其中所有的文件和子目录​ rm t.txt 该命令删除文件t.txtrmdir命令​ rmdir命令用来删除目录。mkdir 命令1234567#单个文件夹创建mkdir 文件夹名称#例如：mkdir wenjianjia#多个文件夹创建mkdirs 文件夹1/文件夹2......\#例如：mkdirs wenjianjia1/wenjianjia2chmod命令详解作用：改变一个或多个文件的存取模式(mode)格式：chmod [options] mode files只能文件属主或特权用户才能使用该功能来改变文件存取模式。mode：可以是数字形式或以who opcode permission形式表示。who是可选的，默认是a(所有用户)。只能选择一个opcode(操作码)。可指定多个mode，以逗号分开。综上，包含options、who、opcode、permission等选项，下面分别进行介绍options：标识含义-c，–changes只输出被改变文件的信息-f，–silent，–quiet当chmod不能改变文件模式时，不通知文件的用户–help输出帮助信息。-R，–recursive可递归遍历子目录，把修改应到目录下所有文件和子目录–reference=filename参照filename的权限来设置权限-v，–verbose无论修改是否成功，输出每个文件的信息–version输出版本信息who标识含义u用户g组o其它a所有用户(默认)opcode标识含义+增加权限-删除权限=重新分配权限permission标识含义r读w写x执行s设置用户(或组)的ID号t设置粘着位(sticky bit)，防止文件或目录被非属主删除作为选择，我们多数用三位八进制数字的形式来表示权限，第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限。如6(4+2)代表有读写权，7(4+2+1)有读、写和执行的权限。还可设置第四位，它位于三位权限序列的前面，第四位数字取值是4，2，1，代表意思如下：4，执行时设置用户ID，用于授权给基于文件属主的进程，而不是给创建此进程的用户。2，执行时设置用户组ID，用于授权给基于文件所在组的进程，而不是基于创建此进程的用户。1，设置粘着位。实例：12345678$ chmod u+x file 给file的属主增加执行权限$ chmod 751 file 给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限$ chmod u=rwx,g=rx,o=x file 上例的另一种形式$ chmod =r file 为所有用户分配读权限$ chmod 444 file 同上例$ chmod a-wx,a+r file 同上例$ chmod -R u+r directory 递归地给directory目录下所有文件和子目录的属主分配读的权限$ chmod 4755 设置用ID，给属主分配读、写和执行权限，给组和其他用户分配读、执行的权限。linux下链接ln –s 源文件 目标文件]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
</search>
