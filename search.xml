<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[京东全网爬虫]]></title>
    <url>%2F2019%2F11%2F22%2F%E4%BA%AC%E4%B8%9C%E5%85%A8%E7%BD%91%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[完整代码见： https://github.com/Lucareful/JingDongSpider写在前面：折腾了很久的用python做爬虫项目到现在也该告一段落了，看视频学，遇到bug自己查找，代码思路不对重新写，环境不对自己配置….一路上跌跌撞撞，过程很艰苦，所幸结果为好。代码就像一面明镜，照见我自身的不足。继续加油需求抓取首页的分类信息大分类的url中分类的url小分类的url抓取商品信息商品名称价格评论信息店铺促销选项图片开发环境和技术技术选择：由于全网爬虫，抓取页面非常多，为了提高抓的速度，选择使用scrapy框架+scrapy_redis分布式组件由于京东全网的数据量达到了亿级，存储又是结构化数据，数据库，选择使用MongoDB；京东全网爬虫的实现步骤采取广度优先策略，我们把类别和商品信息的抓取分开来做优点，提高程序的稳定性总体设计实现步骤创建爬虫项目根据需求，定义数据数据模型实现分类起虫保存分类信息实现商品爬虫保存商品信息实现随机User-Agent和代理IP下载器中间件，解决IP反爬。创建爬虫项目scrapy startproject jingDong定义数据模型（要抓取的数据）类别数据模型类用于存储类别信息（Category）-字段：b.category_name：大类别名称。b_category_url：大类别URL。m_category_name：中分类名称。m_category_url：中分类URL。s_category_name：小分类名称s_category_url：小分类URL商品数据模型商品数据模型类：用于存储商品信息（Product）字段：oproduct_category：商品类别product_sku_id：商品IDproduct_name：商品名称product_img_url：商品图片URLproduct_book_info：图书信息，作者，出版社product_option：商品选项product_shop：商品店铺product_comments：商品评论数量product_ad：商品促销product_price：商品价格商品的分类爬虫创建爬虫进入项目目录：cd mall_spider创建爬虫：scrapy genslider category_spider jd.com指定起始URL修改起始URL: https://dc.3.cn/category/get实现保存分类的pipeline类open_spider 方法中，链接MongoDB数据库，获取要操作的集合process_item 方法中，向MongoDB中插入类别数据close_spider 方法中，关闭MongoDB的链接实现商品爬虫步骤分析，确定数据所在的URL代码实现（核心）商品爬虫实现分布式分析，确定数据所在的URL解析列表页，提取商品sku_id，实现翻页，确定翻页的URL获取商品的基本信息，通过手机抓包（APP），确定URLPC详情页面，确定商品的促销信息的URLPC详情页面，确定评论信息的URLPC详情页面，确定商品价格信息的URL代码实现1.重写start_requests方法，根据分类信息构建列表页的请求2.解析列表页，提取商品的skuid，构建商品基本的信息请求；实现列表翻页1.确定商品基本的信息请求1.URL:https://cdnware.m.jd.com/c1/skuDetail/apple/7.3.0/32962088964.json2.请求方法：GET3.参数/数据：32962088964商品的skuid2.解析列表页，提取商品的skuid3.构建商品基本的信息请求4.实现列表翻页解析促销信息，构建商品评价信息的请求1.解析促销信息1.produft_ad：商品促销2.构建商品评价信息的请求1.准备评价信息的请求解析商品评价信息，构建价格信息的请求解析商品评价信息1.product_comments：商品评论数量2.评价数量，好评数量，差拜数量，好评率2.构建价格信息的请求准备价格请求：1.URL:https://p.3.cn/prices/mgets?skulds=J_69334292.2.请求方法：GET3.参数：skulds=J_6933429，j后跟这个商品的sku_id解析价格信息1.product_price：商品价格2.把商品数据交给引擎商品爬虫实现分布式修改爬虫类修改继承关系指定redis_key把重写start_requests改为重写make_request from data I在settings文件中配置scrapy_redis直接拷贝scrapy_redis配置信息，到settings.py中.写一个程序用于把MongoDB中分类信息，放入到爬虫redis_key指定的列表中保存商品数据实现存储商品Pipeline类在open_spider方法，建立MongoDB数据库连接，获取要操作的集合在process_item方法，把数据插入到MongoDB中在close_spider方法，关闭数据库连接在settings.py中开启这个管道实现下载器中间件实现随机User-Agent的中间件在settings.py中开启上面的下载器中间件]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>scrapy框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的进阶学习]]></title>
    <url>%2F2019%2F11%2F19%2FPython%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[import导入模块路径问题存在的问题：当我们把模块文件放到工程文件夹的外部的文件，发现无法正常引入模块原因：外部的文件夹的路径，没有放到环境变量中。查看环境变量1.导入sys模块2.sys.path查看环境变量返回值是列表把自己写的模块的路径加入到环境变量中1234# 将模块路径追加到末尾 sys.path.append(r"模块的路径")# 将模块路径追加到开头sys.path.insert(0,r"模块的路径")12345678910111213141516171819# import module# # module -- 模块名# # name 模块 modele 中的变量# print(module.name)import sys# 查看python解释器搜索的环境变量# 将模块路径追加到末尾# sys.path.append(r"C:\Users\Luenci\Desktop")# 将模块路径追加到开头有sys.path.insert(0, r"C:\Users\Luenci\Desktop")for i in sys.path: print(i) import appprint(app.name)import导入模块import会防止重复导入在同一个程序中多次import同一个模块，只会执行一次重新导入模块为什么需要重新导入模块?模块被导入后，import module不能重新导入模块，重新导入需用reload重新加载模块代码创建模块对象准备一个模块 reload_test 并定义一个函数 test 代码如下：12def demo(): print(&quot;---------- 111 -----------&quot;)1234567891011121314151617181920# 在 ipython 的交互模式下In [5]: import reload_testIn [6]: reload_test.demo()---------- 111 -----------In [7]: reload_test.demo()---------- 111 -----------# 重新加载之后，改变的内容就可以显示In [14]: from imp import reloadIn [15]: reload(reload_test)Out[15]: &lt;module 'reload_test' from 'D:\\pythonStudy\\import笔记\\reload_test.py'&gt;In [16]: reload_test.demo()---------- 222 -----------from XX import XX的私有化问题123456789# modele.py内容name = "Luenci"# 类中定义私有属性# self._name = XXX# 私有化处理# 如果模块中的变量不希望以 from .. import .. 导入_age = 121234567891011# import module## print(module.name)# 私有化有效from module import *# 私有化无效from module import _ageprint(_age)import 和from..…import的区别import XXX此种方式是直接引用from XXX import xxx此种方式是把XXX的内容复制一份到程序中，若修改不应用到原来的模块可变参数的拆包12345678910111213141516171819202122232425262728def func1(*args, **kwargs): print("---- func1 ----") print("args:", args) print("kwargs:", kwargs)def func2(*args, **kwargs): print("args:", args) print("kwargs:", kwargs) # 调用func1 # 此处没有进行拆包，导致参数传递不过去不符合要求 # func1(args, kwargs) # 此处进行了拆包，阐述传递正确 func1(*args, **kwargs)if __name__ == '__main__': func2(10, 20, 30, a=10, b=20)out: args: (10, 20, 30) kwargs: &#123;'a': 10, 'b': 20&#125; ---- func1 ---- args: (10, 20, 30) kwargs: &#123;'a': 10, 'b': 20&#125;单继承的supersuper（）使用的时候，传递参数的时候，self不用传递super（）调用顺序，按照__mro__顺序来完成Grandson.mro是一个元组当在类中使用super在__mro__列表中找到当前类的下一个元素，调用该元素的方法。1234567891011121314151617181920212223242526272829303132333435363738class Parent(object): def __init__(self, name): self.name = name print('parent的init结束被调用')class Son1(Parent): def __init__(self, name, age): self.age = age super().__init__(name) print('Son1的init结束被调用')class Grandson(Son1): def __init__(self, name, age, gender): self.gender = "男" # 单继承不能提供全部参数 super().__init__(name, age) print('Grandson的init结束被调用')gs=Grandson('grandson', 12, "男")print(Grandson.__mro__)print('姓名:', gs.name)print('年龄:', gs.age)print('性别:', gs.gender)out: parent的init结束被调用 Son1的init结束被调用 Grandson的init结束被调用 (&lt;class '__main__.Grandson'&gt;, &lt;class '__main__.Son1'&gt;, &lt;class '__main__.Parent'&gt;, &lt;class 'object'&gt;) 姓名: grandson 年龄: 12 性别: 男多继承和MRO顺序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 定义父类class Parent(object): def __init__(self, name): self.name = name print('parent的init结束被调用')# 定义子类--》继承父类的 name属性class Son1(Parent): def __init__(self, name, age): # 定义age属性 self.age = age Parent.__init__(self, name) print('Son1的init结束被调用')# 定义子类--》继承父类的 name属性class Son2(Parent): def __init__(self, name, gender): # 定义 gender 属性 self.gender = gender Parent.__init__(self, name) print('Son2的init结束被调用')class Grandson(Son1, Son2): def __init__(self, name, age, gender): # 调用父类的初始化方法 Son1.__init__(self, name, age) Son2.__init__(self, name, gender) print('Grandson的init结束被调用')gs = Grandson('grandson', 12, "男")print(Grandson.__mro__)print('姓名:', gs.name)print('年龄:', gs.age)print('性别:', gs.gender)out: parent的init结束被调用 Son1的init结束被调用 parent的init结束被调用 Son2的init结束被调用 Grandson的init结束被调用 (&lt;class '__main__.Grandson'&gt;, &lt;class '__main__.Son1'&gt;, &lt;class '__main__.Son2'&gt;, &lt;class '__main__.Parent'&gt;, &lt;class 'object'&gt;) 姓名: grandson 年龄: 12 性别: 男使用super()调用父类MRO顺序通过上述代码，我们发现由于多继承情况，parent类被的属性被构造了两次，如果在更加复杂的结构下可能更加严重。为了解决这个问题，Python官方采用了一个算法将复杂结构上所有的类全部都映射到一个线性顺序上，而根据这个顺序就能够保证所有的类都会被构造一次这个顺序就是MRO顺序。MRO查看类名.mro()类名.__mro__1234567891011121314151617181920212223242526272829303132333435363738394041424344# 定义父类class Parent(object): def __init__(self, name, *args, **kwargs): self.name = name print('parent的init结束被调用')# 定义子类--》继承父类的 name属性class Son1(Parent): def __init__(self, name, age, *args, **kwargs): # 定义age属性 self.age = age super().__init__(name, *args, **kwargs) print('Son1的init结束被调用')# 定义子类--》继承父类的 name属性class Son2(Parent): def __init__(self, name, gender, *args, **kwargs): # 定义 gender 属性 self.gender = gender super().__init__(name, *args, **kwargs) print('Son2的init结束被调用')class Grandson(Son1, Son2): def __init__(self, name, age, gender): # 调用父类的初始化方法 super().__init__(name, age, gender) # Son1.__init__(self, name, age) # Son2.__init__(self, name, gender) print('Grandson的init结束被调用')gs = Grandson('grandson', 12, "男")print(Grandson.__mro__)out: parent的init结束被调用 Son2的init结束被调用 Son1的init结束被调用 Grandson的init结束被调用 (&lt;class '__main__.Grandson'&gt;, &lt;class '__main__.Son1'&gt;, &lt;class '__main__.Son2'&gt;, &lt;class '__main__.Parent'&gt;, &lt;class 'object'&gt;)注意当在类中使用super（）在 mro列表中找到当前类的下一个元素，调用该元素的方法多继承中，不建议使用类名直接调用父类的方法@property装饰方法定义时，在实例方法的基础上添加@property 装饰器；并且仅有一个self参数调用时，无需括号方法：foo_obj.func()property属性：foo_obj.prop12345678910111213141516171819class Foo(object): # 初始化方法 def __init__(self, num): self.num = num # 获取值得方法 @property def prop(self): return self.numfoo = Foo(100)# print(foo.prop())# @property 像使用属性一样获取值print(foo.prop)out: 100property的其它功能1234567891011121314151617181920212223242526272829303132333435363738class Goods(object): def __init__(self): # 初始化原价 self.org_price = 1000 # 初始化折扣 self.discount = 0.7 # 获取价格的方法 @property def price(self): return self.org_price * self.discount # 设置价格的方法 @price.setter def price(self, val): if val &gt; 0: self.org_price = val # 删除价格的方法 @price.deleter def price(self): print("执行了 deleter 方法")# 创建对象goods = Goods()print(goods.price)goods.price = 500print(goods.price)del goods.priceout: 700.0 350.0 执行了 deleter 方法property的另一种使用方法1BAR = property（get_price, set_price, del_price, &quot;BAR是一个property对象&quot;）#property（第一个参数，第二个参数，第三个参数，第四个参数）#第一个参数，当我们foo.BAR自动调用第一个参数的方法#第二个参教，当我们foo.BAR=100，自动调用第二个参数的方法#第三个参数，当我们del foo.BAR，自动调用第三个参数的方法#第四个参数，当我们Foo.BAR.doc，自动获取第四个参数的内容魔法属性和方法魔术属性__doc__ 描述类的信息和类方法的信息获取类名 类名.__doc__获取对象 对象.方法名.__doc____model__ 获取所属的模块（对象名.__module__）直接运行该文件 获取main__class__ 获取对象所属的类 对象名.__class____dict__ 获取对象或类的信息通过__dict__获取对象信息，对象.__dict__ 返回字典通过__dict__获取类信息 类名.__dict__返回值是一个字典魔术方法__init__初始化方法 类名（）自动调用__del__删除对象的时候， 会调用__del__方法__call__() 使用对象名()会调用该方法__str__() 打印对象的会调用print(obj) __str__方法一定要return，而且必须return字符串内容用字典的书写格式操作对象的方法__getitem__ 对象[‘XX’]__setitem__ 对象[‘XX’] = xx__delitem__ del 对象[‘xx’]1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Goods(object): """这是一个商品的类""" # 类属性 sell = True def __init__(self): self.price = 100 self.category = "吃的" def set_price(self): """设置价格方法""" pass def __call__(self, *args, **kwargs): print("__call__ 方法被调用") def __str__(self): return "我是一个对象" def __getitem__(self, item): print("key:", item) def __setitem__(self, key, value): print("key:%s, value:%s" % (key, value)) def __delitem__(self, key): print("要删除key：", key) def __del__(self): print("__del__ 正在执行")goods = Goods()# 对象名（） 会去调用对象的 __call__() 方法goods()# print 打印对象的时候，默认输出 &lt;__main__.Goods object at 0x000002356857E080&gt;print(goods)# 通过dict获取对象信息，对象.__dict__ 返回字典print(goods.__dict__)# 通过dict 获取类信息 类名.__dict__返回值是一个字典print(Goods.__dict__)# dict1=&#123;&#125;# dictI['a']=10# goods['a']调用 __getitem__ 方法goods['a']# goods['a']=10用 __setitem__ key，valuegoods['a'] = 10# del goods['a'] 调用 __delitem__ keydel goods['a']out： &#123;'price': 100, 'category': '吃的'&#125; &#123;'__module__': '__main__', '__doc__': '这是一个商品的类', 'sell': True, '__init__': &lt;function Goods.__init__ at 0x00000238CE0F5598&gt;, 'set_price': &lt;function Goods.set_price at 0x00000238CE0F5620&gt;, '__call__': &lt;function Goods.__call__ at 0x00000238CE0F56A8&gt;, '__str__': &lt;function Goods.__str__ at 0x00000238CE0F5730&gt;, '__getitem__': &lt;function Goods.__getitem__ at 0x00000238CE0F57B8&gt;, '__setitem__': &lt;function Goods.__setitem__ at 0x00000238CE0F5840&gt;, '__delitem__': &lt;function Goods.__delitem__ at 0x00000238CE0F58C8&gt;, '__del__': &lt;function Goods.__del__ at 0x00000238CE0F5950&gt;, '__dict__': &lt;attribute '__dict__' of 'Goods' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Goods' objects&gt;&#125; key: a key:a, value:10 要删除key： a __del__ 正在执行]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>进阶知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解释器的GIL锁]]></title>
    <url>%2F2019%2F11%2F17%2FGIL%E9%94%81%2F</url>
    <content type="text"><![CDATA[GlL锁定义Gll锁：Global Interpreter Lock，又称：全局解释器锁任何Python线程执行前，必须先获得GlL锁，然后，每执行100条字节码，解释器就自动释放GL锁，让别的线程有机会执行。这个GlL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。GlL不是Python特性GlL是Pythn解释器（Cpython）时引入的概念，在JPython、PyPy中没有GlL。GIL并不是Python的语言缺陷。是解释器层级的锁，跟Python语言特性无关言外之意，就是全局解释器就是为了锁定整个解释器内部的全局资源，每个线程想要运行首先获取GlL，而GlL本身又是一把互斥锁，造成所有线程只能一个一个one-by-one-并发-交替的执行。GlL存在的原因早期计算机都是单核设计CPython在执行多线程的时候并不是线程安全的，所以为了程序的稳定性，加一把全局解释锁，能够确保任何时候都只有一个Python线程执行GlL产生的背景在CPython解释内部运行多个线程的时候，每个线程都需要解释器内部申请相应的全局资源，由于C语言本身比较底层造成CPython在管理所有全局资源的时候并不能应对所有线程同时的资源请求，因此为了防止资源竞争而发生错误，对所有线程申请全局资源增加了限制-全局解释器锁。GlL锁什么时候释放？在当前线程执行超时后会自动释放在当前线程执行阻塞操作时会自动释放当前执行完成时Guido对GIL锁的看法：https://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235关于GIL面试题描述Python GL的概意，以及它对python多线程的影响？编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否可比单线程性能有提升，并解释原因。Python语言和GlL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机（解释器），难以移除GlL。GlIL：全局解释器锁。每个线程在执行的过程都需要先获取GlL，保证同一时刻只有一个线程可以执行代码。线程释放GL锁的情况：在IO操作等可能会引起阻塞的system call之前，可以暂时释放GIL，但在执行完毕后，必须重新获取GlLPython 3.x使用计时器（执行时间达到阔值后，当前线程释放GlL）或Python 2.x，tickets计数达到100Python使用多进程是可以利用多核的CPU资源的。多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁严重问题：既然CPython解释存在GL是否意味每个线程在全局变量就不用加Lock互斥锁了呢？这是一个严重错误的想法，为什么用户操作全局数据还需要加Lock，因为GlL的释放时机我们无法控制-操作非常可能并没有完成，而不像Lock那样我们用完才释放（操作完整）举例线程1取出全局变量g_number==0一直加到20000，但是还没有来得及将20000写入g_number中，就超时了自动释放GIL 而线程2取出g_number==19999加到39999由于超时自动释放GlL此时线程2获取到GIL继续着未完成的事业将20000写入g_number….这就是之前的多线程案例没有加互斥锁的情况晨终结果是140w东右的盾因GIL锁解决方案解决方案一（不推荐）：我们换一个解释器执行程序就行了（jython：用JAVA写的python解释器）解决方案二（推荐）使用多进程替换多线程multiprocessing是一个多进程模块，开多个进程，每个进程都带一个GlL，就相当于多线程来用了。解决方案三（推荐）使用python语言的特性：胶水.我们让子线程部分用c来写，就ok。（实质上也相当于那部分代码绕过了cython解释器）第一步，编写C语言文件：测试代码，C语言写的死循环，文件名为test2.c：123456void Loop()&#123; while(1) &#123; ; &#125;&#125;然后我们把将其编译成.so文件（share object）需要执行如下命令(Linux下)：1gcc test.c -shared -o libtets.so-shared：将其编译成so文件-o：表示output，用来输出的文件名库文件是以lib开头编译过后，在当前的文件夹下就会生成一个.so文件第二步，编写python文件04-04_GIL锁解决方案.py：12345678import ctypes import threading#加载动态库my_lib=ctypes，cdll.LoadLibrary（"./libtest2.so"）#创建子线程t=threading.Thread（target=my_lib.Loop）t.start（）#主线程while True：pass第三步，执行pvthon文件就可避开Cpython解释器的GIL锁总结GIL锁称为：“全局解释器锁“，是CPytrton解释器中的锁机制，也是历史遗留问题要提升多线程执行效率，解决方案：更换解释器改为进程替换多线程子线程使用C语言实现（绕过GL锁）必须要知道的是：CPU密集型不太适合多线程I/O密集型适合多线程（Gil锁会释放）]]></content>
      <categories>
        <category>Python编程</category>
      </categories>
      <tags>
        <tag>GIL锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的闭包和装饰器]]></title>
    <url>%2F2019%2F11%2F17%2F%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[闭包引入函数名是一个特殊的变量，保存了函教的地址和自定义一个变量可以获取函数地址自定义变量调用函数 “函数名（）”12345678910111213141516171819def work(): print("我是一个测试函数")ret = workprint(ret)print("地址：%X" % id(ret))print("地址：%X" % id(work))ret()work()out: &lt;function work at 0x00000161E3091E18&gt; 地址：161E3091E18 地址：161E3091E18 我是一个测试函数 我是一个测试函数当我们定义函数test1后，函数名test1保存的是函数在内存的首地址函数名就是一个特殊的变量，函数名（）调用函数，执行函数体test1()和ret()都会调用函数，并执行函数体和变量名一样的，函数名数名只是函数代码空间的引用，当函数名赋值给一个对象的时候就是引用传递。闭包概念在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包维基百科中关于闭包的概念：在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。闭包构成条件必须有一个内嵌函数（函数里定义的函数）–这对应函数之间的嵌套内嵌函数必须引用一个定义在闭合范围内（外部函数里）的变量–内部函数引用外部变量外部函数必须返回内嵌函数–必须返回那个内部函数123456789101112131415161718192021def function_out(num): print("1.function_out num = ", num) def function_in(num_in): print("2.---------- function_in -----------------num", num) print("3.---------- function_in -----------------num_in", num_in) return function_in# function_out(10)# 调用function_out获取内层函数的地址，保存到retret = function_out(100)# 调用内层函数ret(88)out: 1.function_out num = 100 2.---------- function_in -----------------num 100 3.---------- function_in -----------------num_in 88通俗理解：存在函数的嵌套关系内层函数引用了外层函数的临时变量外层函数返回内层函数的引用闭包中的变量123456789101112131415161718192021def function_out(num): def function_in(): # 如果在内层定义了和外层变量同名的变量，但是要使用外层变量 # nonlocal 不使用内层函数的，而是使用外层的变量 nonlocal num print("function_in num", num) # 内部自定义的变量 num = 88 return function_in# 调用外部函数ret = function_out(99)ret()out: function_in num 99装饰器入门装饰器作用：在不改变函数的代码前提下，给函数添加新的功能装饰器的使用：存在闭包需要装饰的函数写代码要道循开放封闭原则，虽然在这个原则是用的面向对象开发，但是也适用于函数式编程，简单来说它规定已经实现的功能代码不允许被修改，但可以被扩展，即：封闭：已实现的勤能代码块开放：对扩展开放12345678910111213141516171819202122def function_out(func): def function_in(): print("开始验证") func() return function_in@function_out# @function_out装饰了 login() 函数# 底层实现# login = function_out(login)def login(): print("开始登陆！")# 通过闭包调用外层函数# login = function_out(login)login()out: 开始验证 开始登陆！通用版装饰器1234567891011121314151617181920212223242526272829def function_out(func): def function_in(*args, **kwargs): print("开始验证") print("function_in user=", args) print("function_in password=", kwargs) return func(*args, **kwargs) return function_in@function_outdef login(*args, **kwargs): print("开始登陆 user=", args) print("开始登陆 password=", kwargs) return 10# 装饰完 login == function_inresult = login(20, a=18)print(result)out: 开始验证 function_in user= (20,) function_in password= &#123;'a': 18&#125; 开始登陆 user= (20,) 开始登陆 password= &#123;'a': 18&#125; 10在原装饰器增加外部变量1234567891011121314151617181920212223242526272829303132333435363738def test(path): print(path) def function_out(func): def function_in(): print("开始验证") func() return function_in # 返回装饰器的引用（装饰器工厂） return function_out@test("login.py")# @test（"login.py"）分解为2步# 1）test（"login.py"）--&gt;function out 引用(地址)# 2）@ 第一步的结果--&gt;@function outdef login(): print("开始登陆")@test("register.py")def register(): print("开始注册")login()register()out: login.py register.py 开始验证 开始登陆 开始验证 开始注册多重装饰器给一个函数进行多次装饰装饰原则：就近原则（靠近待装饰函数的先装饰，随后一层一层装饰）123456789101112131415161718192021222324252627282930313233343536373839404142# &lt;b&gt;helloWord&lt;/b&gt;# 定义一个让文字加粗的装饰器def makeBlod(func): def function_in(): return '&lt;b&gt;' + func() + '&lt;/b&gt;' return function_in# 定义一个让文字倾斜的装饰器def makeItalic(func): def function_in(): return '&lt;i&gt;' + func() + '&lt;/i&gt;' return function_in@makeBloddef demo(): return "helloWord"@makeItalicdef demo2(): return "Luenci"@makeBlod@makeItalicdef demo3(): return "LYnn"print(demo())print(demo2())print(demo3())out: &lt;b&gt;helloWord&lt;/b&gt; &lt;i&gt;Luenci&lt;/i&gt; &lt;b&gt;&lt;i&gt;LYnn&lt;/i&gt;&lt;/b&gt;类装饰器装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象在Python中一般callable对象都是函数，但也有例外。只要某个对象重写了__call__（）方法，那么这个对象就是callable的。类的书写：必须有两个方法1）__init__方法，必须接收装饰器传递的参数func2）__call__方法格式：@类名待装饰的函数对象名()调用对象的__call__（）方法123456789101112131415161718192021222324252627282930# 装饰器类class Demo(object): def __init__(self, func): print("__init__方法") print("-- func --", func) self.func = func def run(self): print("正在奔跑") def __call__(self, *args, **kwargs): print("-- 开始验证 --") # 调用原来login内容 self.func()@Demo# login = demo(login)def login(): print("正在登陆")login()out: __init__方法 -- func -- &lt;function login at 0x0000024E64D857B8&gt; -- 开始验证 -- 正在登陆]]></content>
      <categories>
        <category>Python编程</category>
      </categories>
      <tags>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的协程]]></title>
    <url>%2F2019%2F11%2F16%2F%E5%8D%8F%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[可迭代对象可遍历对象就是可迭代对象列表、元组、字典、字符串都是可迭代对象100和自定义myclass 默认都是不可以迷代的myclass对象所属的类MyClass如果包含了__iter__（）方法，此时myclass就是一个可送代对象可送代对象的本质：对象所属的类中包含了__iter__（）方法检测一个对象是否可以送代，用isinstance（）函数检测。迭代器我们发现选代器最核心的功能就是可以通过next0函数的调用来返回下一个数据值。如果每次返回的数据值不是在一个已有的数据集合中读取的，而是通过程序按照一定的规律计算生成的，那么也就意味着可以不用再依赖一个已有的数据集合，也就是说不用再将所有要迭代的数据都一次性缓存下来供后续依次读取，这样可以节省大量的存储（内存）空间。举个例子，比如，数学中有个著名的斐波拉契数列（Fibonacci），数列中第一个数为0，第二个数为1，其后的每一个数都可由前两个数相加得到：特点记录遍历的位置提供下一个元素的值（配合next（）函数）迭代器生成斐波那契数列12345678910111213141516171819202122232425262728293031323334353637class Fibanacci(object): def __init__(self, num): # 实例化生成列属性 self.num = num self.a = 1 self.b = 1 self.current_index = 0 def __iter__(self): # 返回自己 return self def __next__(self): if self.current_index &lt; self.num: # 生成斐波那契数列 # 定义变量保存a的值 data = self.a self.a, self.b = self.b, self.a + self.b self.current_index += 1 return data else: raise StopIterationif __name__ == '__main__': fib = Fibanacci(8) value = next(fib) for i in fib: print(i)out: 1 2 3 5 8 13 21生成器生成器是一类特殊的迭代器。利用选代器，我们可以在每次迭代获取数据（通过next()方法）时按照特定的规律进行生成。但是我们在实现一个迭代器时，关于当前迭代到的状态需要我们自己记录，进而才能根据当前状态生成下一个数据。为了达到记录当前状态，并配合next()函数进行迭代使用，我们可以采用更简便的语法，即生成器（generator)。创建生成器方法1要创建一个生成器，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成（）12345678910111213141516171819202122232425262728# 列表推导式data_list = [x*2 for x in range(5)]for i in data_list: print(i)# 生成器的创建data_list1 = (x*2 for x in range(5))# 通过next()获取下一个值value = next(data_list1)print("--------&gt;", value)for j in data_list1: print(j) out: 0 2 4 6 8 --------&gt; 0 2 4 6 8函数中使用yield关键字生成生成器1234567891011121314151617181920def test(): return 10def test2(): yield 10if __name__ == '__main__': m = test() print("m:", m) n = test2() print("n", n) value = next(n) print(value) out： m: 10 n &lt;generator object test2 at 0x000002A2C4C6D0F8&gt; 10生成器生成斐波那契数列123456789101112131415161718192021222324252627282930313233def fibnacci(n): # 初始化a, b的值 a = 1 b = 1 # 纪录迭代位置 current_index = 0 print("-----1------") while current_index &lt; n: # 保存a的值 data = a a, b = b, a+b current_index += 1 print("-----2------") yield data print("-----3------")if __name__ == '__main__': fib = fibnacci(6) print(next(fib)) print(next(fib)) print(next(fib)) out: -----1------ -----2------ 1 -----3------ -----2------ 1 -----3------ -----2------ 2yield作用充当return作用保存程序的运行状态并且暂停程序执行当next的时候，可以继续唤醒程序从yield位置继续向下执行生成器中使用return问题生成器客户以使用return关键字，语法上没有问题，但是如果执行到return语句以后，生成器会停止迭代，抛出停止迭代的异常send作用生成器.send(传递给生成器的值)传递1a = fib.send(1)接收1xxx = yield data协程协程，又称微线程，纤程。英文名Coroutine。从技术的角度来说，“协程就是你可以暂停执行的函数”。如果你把它理解成“就像生成器一样”，那么你就想对了。线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作则是程序员。协程存在的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程（单线程），在一个线程中规定某个代码块执行顺序。协程应用场景协程的适用场景：当程序中存在大量不需要CPU的操作时（IO），适用于协程；通俗的理解：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定协程和线程差异不开辟新的线程的基础上，实现多个任务在实现多任务时，线程切换从系统层面远不止保存和恢复CPU上下文这么简单。操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。1234567891011121314151617181920212223242526# ------------------ 携程的原始实现 --------------------import timedef work1(): while True: print("work1正在工作....") yield time.sleep(0.5)def work2(): while True: print("work2正在工作.............") yield time.sleep(0.5)if __name__ == '__main__': t1 =work1() t2 = work2() print(t1) while True: next(t1) next(t2)greenlet库greenlet 可以实现协程Greenlet是python的一个C扩展，来源于Stackless python，旨在提供可自行调度的“微线程’，即协程。generator实现的协程在yield value时只能将value返回给调用者（caller）。而在greenlet中，target.switch（value）可以切换到指定的协程（target），然后yield value。greenlet用switch来表示协程的切换，从一个协程切换到另一个协程需要显式指定。GNI GREENLE T为了更好使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变的更加简单1234567891011121314151617181920212223242526272829import timefrom greenlet import greenlet# work1生成器def work1(): while True: print("work1正在工作....") time.sleep(2) # 切换到第二个任务 g2.switch()# work1生成器def work2(): while True: print("work2正在工作.............") time.sleep(2) # 切换到第一个任务 g1.switch()if __name__ == '__main__': g1 = greenlet(work1) g2 = greenlet(work2) #执行work1 g1.switch()gevent 库自动调度协程，自动识别程序中的耗时操作greenlet已经实现了协程，但是这个还的人工切换python还有一个比greenlet更强大的并且能够自动切换任务的第三方库 gevent其原理是当一个greenlet遇到IO（指的是input/ output 输入输出，比如网络、文件操作等）操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待使用步骤导入模块Iimport gevent指派任务g1= gevent.spawn（函数名，参数1，参数2，…）join（）让主线程等待协程执行完毕后再退出g1.join()打猴子补丁补丁给程序打补丁（猴子补丁）关于猴子补丁为啥叫猴子补丁，据说是这样子的：这个叫法起源于Zope框架，大家在修正Zope的Bug的时候经常在程序后面追加更新部分，这些被称作是“杂牌军补丁（guerilla patch）”，后来guerilla就渐渐的写成了gorlia（塑猩），再后来就写了monkey（猴子）：所以猴子补丁的叫法是这么莫名其妙的得来的。猴子补丁主要有以下几个用处：1.在运行时替换方法、属性等2.在不修改第三方代码的情况下增加原来不支持的功能3.在运行时为内存中的对象增加patch而不是在盏盘的源代码中增加12345678910111213141516171819202122232425262728293031# 打补丁from gevent import monkey# 破解所有monkey.patch_all()import timeimport geventdef work1(): while True: print(&quot;work1正在工作....&quot;) time.sleep(0.5)def work2(): while True: print(&quot;work2正在工作.............&quot;) # gevent.sleep(0.5) time.sleep(0.5)if __name__ == &apos;__main__&apos;: # 指派任务 g1 = gevent.spawn(work1) g2 = gevent.spawn(work2) # 让主线程等待协程执行完毕再运行 g1.join() g2.join()小福利1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# 妹子图爬虫多协程版# coding=utf-8from gevent import monkeymonkey.patch_all()import geventimport requestsfrom bs4 import BeautifulSoupimport osimport reall_url = 'http://www.mzitu.com'# http请求头Hostreferer = &#123; 'User-Agent': 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)', 'Referer': 'http://www.mzitu.com'&#125;Picreferer = &#123; 'User-Agent': 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)', 'Referer': 'http://i.meizitu.net'&#125;# 此请求头破解盗链start_html = requests.get(all_url, headers=Hostreferer)# 保存地址path = "E:\\mzitu\\"# 找寻最大页数soup = BeautifulSoup(start_html.text, "html.parser")page = soup.find_all('a', class_='page-numbers')max_page = page[-2].textsame_url = 'http://www.mzitu.com/all/'def download_img(pic_url): html = requests.get(pic_url, headers=Picreferer) file_name = pic_url.split(r'/')[-1].replace('"', "") print(file_name) f = open(file_name, 'wb') f.write(html.content) f.close()for n in range(1, int(max_page) + 1): ul = same_url + str(n) start_html = requests.get(ul, headers=Hostreferer) soup = BeautifulSoup(start_html.text, "html.parser") all_a = soup.find('div', class_='all').find_all('a', target='_blank') for a in all_a: # 提取文本 title = a.get_text() if title != '': print("准备扒取：" + title) # win不能创建带？的目录 if os.path.exists(path + title.strip().replace('?', '')): # print('目录已存在') flag = 1 else: os.makedirs(path + title.strip().replace('?', '')) flag = 0 os.chdir(path + title.strip().replace('?', '')) href = a['href'] html = requests.get(href, headers=Hostreferer) mess = BeautifulSoup(html.text, "html.parser") pic_max = mess.find_all('span') try: # 最大页数 pic_max = pic_max[9].text if flag == 1 and len(os.listdir(path + title.strip().replace('?', ''))) &gt;= int(pic_max): print('已经保存完毕，跳过') continue except Exception: pass pic_url = [] for num in range(1, int(pic_max) + 1): pic = href + '/' + str(num) html = requests.get(pic, headers=Hostreferer) mess = BeautifulSoup(html.text, "html.parser") pic_url.append(mess.find('img', alt=title)) # print("图片路径：", pic_url['src']) pic_url = re.findall(r"[a-zA-z]+://[^\s]*", str(pic_url)) print(pic_url) # 将列表编程迭代器 a = pic_url.__iter__() # 开启多个协程 Coroutine = [] for i in range(len(pic_url)): Coroutine.append(gevent.spawn(download_img(next(a)))) gevent.joinall(Coroutine) print('完成') print('第', n, '页完成')]]></content>
      <categories>
        <category>Python编程</category>
      </categories>
      <tags>
        <tag>协程知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的进程，线程和协程对比]]></title>
    <url>%2F2019%2F11%2F16%2F%E8%BF%9B%E7%A8%8B%2C%E7%BA%BF%E7%A8%8B%2C%E5%8D%8F%E7%A8%8B%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[概念进程​ 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。线程​ 线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。协程​ 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。三者关系应用场景多进程：密集CPU任务，需要充分使用多核CPU资源（服务器，太量的并行计算）的时候，用多进程。缺陷：多个进程之间通信成本高，切换开销大。多线程：密集I/O任务（网络I/O，磁盘以I/O，数据库I/O）使用多线程合适。缺陷：同一个时间切片只能运行一个线程，不能做到高并行，但是可以做到高并发。协程：当程中存在太量不需要CPU的操作时（IO），适用于协程；多线程请求返回是无序的，那个线程有数据返回就处理那个线程，而协程返回的数据是有序的。缺陷：单线程执行，处理密集CPU和本地磁盘IO的时候，性能较低。处理网络I/O性能还是比较高。]]></content>
      <categories>
        <category>Python编程</category>
      </categories>
      <tags>
        <tag>进程,线程,协程总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python类中的 私有变量 和 私有方法]]></title>
    <url>%2F2019%2F11%2F15%2Fpython%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Python中的类原文转自：https://blog.csdn.net/sxingming/article/details/52875125默认情况下，Python中的成员函数和成员变量都是公开的(public),在python中没有类似public,private等关键词来修饰成员函数和成员变量。在python中定义私有变量只需要在变量名或函数名前加上 __两个下划线，那么这个函数或变量就是私有的了。在内部，python使用一种 name mangling 技术，将 __membername替换成_classname__membername，也就是说，类的内部定义中,所有以双下划线开始的名字都被”翻译”成前面加上单下划线和类名的形式。例如：为了保证不能在class之外访问私有变量，Python会在类的内部自动的把我们定义的__spam私有变量的名字替换成为_classname__spam(注意，classname前面是一个下划线，spam前是两个下划线)，因此，用户在外部访问__spam的时候就会提示找不到相应的变量。python中的私有变量和私有方法仍然是可以访问的访问方法如下：私有变量:实例._类名__变量名私有方法:实例._类名__方法名()其实，Python并没有真正的私有化支持，但可用下划线得到伪私有。尽量避免定义以下划线开头的变量！（1）_xxx “单下划线 “ 开始的成员变量叫做保护变量，意思是只有类实例和子类实例能访问到这些变量，需通过类提供的接口进行访问；不能用’from module import *’导入（2）__xxx 类中的私有变量/方法名 （Python的函数也是对象，所以成员方法称为成员变量也行得通。）,“ 双下划线 “ 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。（3）__xxx__系统定义名字，前后均有一个“双下划线” 代表python里特殊方法专用的标识，如 __init__（）代表类的构造函数。下面我们看几个例子：123456789101112131415161718192021222324252627282930313233class A(object): def __init__(self): #翻译成 self._A__data=[] self.__data=[] def add(self,item): #翻译成 self._A__data.append(item) self.__data.append(item) def printData(self): #翻译成 self._A__data print(self.__data) a=A()a.add('hello')a.add('python')a.printData()#外界不能访问私有变量 AttributeError: 'A' object has no attribute '__data'#print a.__data #通过这种方式，在外面也能够访问“私有”变量；这一点在调试中是比较有用的！print a._A__data out: ['hello', 'python'] ['hello', 'python']12345678910111213141516171819202122232425262728293031323334353637383940# 获取实例的所有属性 print a.__dict__# 获取实例的所有属性和方法 print dir(a) class A(): def __init__(self): #私有变量，翻译成 self._A__name='python' self.__name='python' #私有方法,翻译成 def _A__say(self) def __say(self): #翻译成 self._A__name print(self.__name) a=A()#访问私有属性,报错!AttributeError: A instance has no attribute '__name'#print a.__name#查询出实例a的属性的集合print(a.__dict__)#这样，就可以访问私有变量了print(a._A__name)#调用私有方法，报错。AttributeError: A instance has no attribute '__say'#a.__say()#获取实例的所有属性和方法print(dir(a))#这样，就可以调用私有方法了a._A__say() out: &#123;'_A__name': 'python'&#125; python ['_A__name', '_A__say', '__doc__', '__init__', '__module__'] python从上面看来,python还是非常的灵活，它的oop没有做到真正的不能访问，只是一种约定让大家去遵守，比如大家都用self来代表类里的当前对象，其实，我们也可以用其它的，只是大家习惯了用self 。小漏洞：派生类和基类取相同的名字就可以使用基类的私有变量12345678910111213141516171819202122232425262728class A(): def __init__(self): self.__name='python' #翻译成self._A__name='python' class B(A): def func(self): #翻译成print self._B__name print(self.__name ) instance=B()#报错：AttributeError: B instance has no attribute '_B__name'#instance.func()print(instance.__dict__)print(instance._A__name)out: &#123;'_A__name': 'python'&#125; python1234567891011121314151617181920212223class A(): def __init__(self): #翻译成self._A__name='python' self.__name='python' class A(A): #派生类和基类取相同的名字就可以使用基类的私有变量。 def func(self): #翻译成print self._A__name print(self.__name) instance=A()instance.func()out: python]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>面向对象编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的进程概念]]></title>
    <url>%2F2019%2F11%2F14%2F%E5%A4%9A%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程进程概念进程（Process）是资源分配的最小单位，是线程的容器。程序是固定不变的，而进程会根据运行需要，让操作系统动态分配各种资源的CPU的时间片轮转，在不同的时间段切换执行不同的进程，但是切换进程是比较耗时的；就引来了轻量级进程，也就是所谓的线程，一个进程中包括多个线程（代码流，其实也就是进程中同时跑的多个方法体）程序：例xxx.py这是程序，是一个静态的进程：一个程序运行起来后，代码+用到的资源称之为进程，它是操作系统分配资源的基本单元。进程状态工作中，任务数往往大于cpu的核数，即一定有一些任务正在执行，而另外一些任务在等待cpu进行执行，因此导致了有了不同的状态进程状态就绪态：运行的条件都已经满足，正在等在cpu执行执行态：cpu正在执行其功能等待态：等待某些条件满足，例如一个程序sleep了，此时就处于等待态进程的创建 - multiprocessingmultiprocessing模块就是跨平台版本的多进程模块，提供了一个Process类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情。·创建子进程跟创建线程十分类似，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start0方法后动Process语法结构如下：Process([group [，target[，name，[args[，kwargs]]]）target：如果传递了函数的引用，这个子进程就执行这里（函数）的代码args：给target指定的函数传递的参数，以元组的方式传递kwargs：给target指定的函数传递命名参数name：给进程设定一个名字，可以不设定group：指定进程组，大多数情况下用不到Process创建的实例对象的常用方法：start()：后动子进程实例（创建子进程）is_alive：判断进程子进程是否还在活着join([timeout]）：是否等待子进程执行结束，或等待多少秒oterminate：不管任务是否完成，立即终止子进程Process创建的实例对象的常用属性：name：当前进程的别名，默认为Process-N，N为从1开始递增的整数pid：当前进程的pid（进程号）linux系统可使用kill命令结束进程123456789101112131415161718192021222324252627282930313233343536373839404142import multiprocessingimport osimport timedef work1(): for i in range(10): # 获取进程的父id print("正在运行work1 第&#123;&#125;次..进程id&#123;&#125;，父进程id&#123;&#125;".format(i, os.getpid(), os.getppid())) time.sleep(2)if __name__ == '__main__': # 获取主进程名称 print("主进程名称", multiprocessing.current_process()) # 获取进程的编号 # 1.获取进程id multiprocessing.current_process().pid print("主进程编号", multiprocessing.current_process().pid) # 2. 模块os # print(os.getpid()) process_obj = multiprocessing.Process(target=work1, name="进程一") process_obj.start() print("XXXX") out: 主进程名称 &lt;_MainProcess(MainProcess, started)&gt; 主进程编号 31776 XXXX 正在运行work1 第0次..进程id43088，父进程id31776 正在运行work1 第1次..进程id43088，父进程id31776 正在运行work1 第2次..进程id43088，父进程id31776 正在运行work1 第3次..进程id43088，父进程id31776 正在运行work1 第4次..进程id43088，父进程id31776 正在运行work1 第5次..进程id43088，父进程id31776 正在运行work1 第6次..进程id43088，父进程id31776 正在运行work1 第7次..进程id43088，父进程id31776 正在运行work1 第8次..进程id43088，父进程id31776 正在运行work1 第9次..进程id43088，父进程id31776进程参数，全局变量进程间不能共享全局变量子进程在运行时候，会将主进程的内容复制到自己进程中，修改只限自己进程有效。不影响其他进程和主进程12345678910111213141516171819202122232425262728293031import multiprocessing# 定义全局变量import timeg_num = 10def work1(): global g_num for i in range(10): g_num += 1 print("work1---------", g_num)def work2(): print("work1---------", g_num)if __name__ == '__main__': p1 = multiprocessing.Process(target=work1) p2 = multiprocessing.Process(target=work2) p1.start() p2.start() time.sleep(3) print("---------main-----------", g_num)out: work1--------- 20 work1--------- 10 ---------main----------- 10守护进程p1.daemon=True设置子进程p1守护主进程，当主进程结束的时候，子进程也随之结束p1.terminate（）终止进程执行，并非是守护进程123456789101112131415161718192021222324252627import multiprocessingimport timedef work1(): for i in range(10): print("正在运行work1...&#123;&#125;".format(time.ctime())) time.sleep(0.5)if __name__ == '__main__': process_obj = multiprocessing.Process(target=work1) # 开启守护 # process_obj.daemon = True process_obj.start() print("我睡两秒就结束", time.ctime()) time.sleep(2) # 终止进程 process_obj.terminate() exit()out: 我睡两秒就结束 Thu Nov 14 16:04:29 2019 正在运行work1...Thu Nov 14 16:04:29 2019 正在运行work1...Thu Nov 14 16:04:30 2019 正在运行work1...Thu Nov 14 16:04:30 2019 正在运行work1...Thu Nov 14 16:04:31 2019进程线程对比功能进程，能够完成多任务，比如在一台电脑上能够同时运行多个QQ线程，能够完成多任务，比如一个QQ中的多个聊天窗口使用区别进程是系统进行资源分配和调度的一个独立单位。线程是进程的一介实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.一个程序至少有一个进程，一个进程至少有一个线程.线程的划分尺度小于进程（资源比进程少），使得多线程程序的并发性高。进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率线程不能独立运行，必须依赖于线程对比维度多进程多线程总结数据共享，同步数据共享复杂，需要用IPC；数据是分开因为共享进程数据，数据共享简单因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂各有千秋内存、CPU占用内存多，切换复杂，CPU利用率低占用内存少，切换简单，PU利用率高CPU线程占优创建销毁、切换创建销毁、切换复杂，速度慢创建销毁、切换简单，速度很快线程占优编程，调试编程简单，调试简单编程复杂，调试复杂进程占优可靠性进程间不会互相影响一个线程挂掉将导致整个进程挂掉进程占优分布式适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单应用于多核分布式进程占优进程线程取舍需要频繁创建销毁的先使用线程；（如：Web服务器）线程的切换速度快，所以在需要大量计算，切换频繁时用线程（如图像处理、算法处理）因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。都满足需求的情况下，用你最熟悉、最拿手的方式需要提醒的是：虽然有这么多的选择原则，但实际应用中基本上都是“进程+线程”的结合方式在Python的原始解释器CPython中存在着GlL（Global Interpreter Lock，全局解释器锁），因此在解释执行python代码时，会产生互斥锁来限制线程对共享资源的访问，直到解释器遇到I/O操作或者操作次数达到一定数目时才会释放GlL。造成了即使在多核CPU中，多线程也只是做着分时切换而已消息队列可以使用multiprocessing模块的Queue实现多进程之间的数据传递Queue本身是一个消息列队程序1234567891011121314151617181920212223242526272829303132333435363738import multiprocessing# 创建队列(指定长度)queue = multiprocessing.Queue(5)# 向队列中放值queue.put("Luenci")queue.put(1)queue.put([5, 2])queue.put((9, 8, 7))queue.put(&#123;"a": 6, "b": 8&#125;)# 判断队列是否全满isfull = queue.full()print("队列为全满：", isfull)# 长度为5，放入第6个数据后，队列就进行入了阻塞状态，默认会等待以列先取出值再放入新的值# queue.put(22)# 不等待的放入# queue.put_nowait(11)# 向队列中取值# 当队列为空的时候，再取值的时候，程序会进行阻塞状态，等待队列中有值再取value = queue.get()print(value)# 当队列为空的时候，再取值的时候，程序会直接报错# value = queue.get_nowait()# 队列元素个数num = queue.qsize()print(num)# 判断队列是否为空empty = queue.empty()print("队列为空？：", empty)进程池进程池概述当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务。进程池实现方式同步方式：pool.apply()异步方式pool.apply_async（copy_work）核心方法multiprocessing.Pool常用函数解析：apply（）：–进程池中进程以同步方式执行任务apply_async（func[，args[，kwds]]）：–使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表进程池中的进程通信12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import multiprocessingimport timedef write_queue(queue): for i in range(10): if queue.full(): print("队列已满") break else: queue.put(i) print("成功添加：", i) time.sleep(0.5)def read_queue(queue): while True: if queue.qsize() == 0: print("队列已空") break value = queue.get() print("已经读取", value)if __name__ == '__main__': # 创建进程池 pool = multiprocessing.Pool(3) # 创建进程池中的队列 queue = multiprocessing.Manager().Queue(10) # 同步的方式执行 # pool.apply(write_queue, args=(queue,)) # pool.apply(read_queue, args=(queue,)) # 异步的方式执行 # apply_async（）返回值ApplyResult对象，该对象有一个wait（）的方法 result = pool.apply_async(write_queue, args=(queue,)) result.wait() pool.apply_async(read_queue, args=(queue,)) # 不再接收新的任务 pool.close() pool.join()out: 成功添加： 0 成功添加： 1 成功添加： 2 成功添加： 3 成功添加： 4 成功添加： 5 成功添加： 6 成功添加： 7 成功添加： 8 成功添加： 9 已经读取 0 已经读取 1 已经读取 2 已经读取 3 已经读取 4 已经读取 5 已经读取 6 已经读取 7 已经读取 8 已经读取 9 队列已空]]></content>
      <categories>
        <category>Python编程</category>
      </categories>
      <tags>
        <tag>进程概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python多线程，并发和锁]]></title>
    <url>%2F2019%2F11%2F13%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多任务同一个时间有多个任务在执行python程序默认是单任务线程线程概念线程，可简单理解为是程序执行的一条分支，也是程序执行流的最小单元。线程是被系统独立调度和分底的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程为其它线程共享进程所拥有的全部资源。主线程当一个程序后动时，就有一个进程被操作系统（OS）创建，与此同时一个线程也立刻运行，该线程通常叫做程序的主线程，简而言之；程序后动就会创建一个主线程。Copy主线程的重要性有两方面：1）是产生其他子线程的线程；2）通常它必须最后完成执行比如执行各种关闭动作·子线程可以看做是程序执行的一条分支，当子线程后动后会和主线程一起同时执行主线程会等待所以子线程结束之后再结束123456789101112131415161718192021222324252627282930313233343536import threadingfrom time import *def loop0(): print('start loop0 at:', ctime()) sleep(4) print('loop0 done at:', ctime())def loop1(): print('start loop1 at:', ctime()) print('loop1 done at:', ctime())def main(): print('starting at :', ctime()) # 使用threading.Thread创建对象（子进程对象） # threading.Thread（target=函数名） thread_1 = threading.Thread(target=loop0) thread_2 = threading.Thread(target=loop1) thread_1.start() thread_2.start() print('all done at:', ctime())if __name__ == '__main__': main() out： starting at : Wed Nov 13 14:21:27 2019 start loop0 at: Wed Nov 13 14:21:27 2019 start loop1 at: Wed Nov 13 14:21:27 2019 loop1 done at: Wed Nov 13 14:21:27 2019 all done at: Wed Nov 13 14:21:27 2019 loop0 done at: Wed Nov 13 14:21:31 2019线程数量目标能够如何查看正在活动的线程数量1.查看线程数量threading.enumerate（）获取当前所有活跃的线程对象列表。使用len()对列表求长度可以看到当前活跃的线程的个数12345678910111213141516171819202122232425262728293031323334353637383940import threadingfrom time import *def loop0(): print('&#123;&#125;start loop0 at&#123;&#125;:'.format(threading.current_thread(), ctime())) sleep(4) print('loop0 done at:', ctime())def loop1(): print('&#123;&#125;start loop1 at&#123;&#125;:'.format(threading.current_thread(), ctime())) print('loop1 done at:', ctime())def main(): print('starting at :', ctime()) # 使用threading.Thread创建对象（子进程对象） # threading.Thread（target=函数名） thread_1 = threading.Thread(target=loop0) thread_2 = threading.Thread(target=loop1) thread_1.start() thread_2.start() print('all done at:', ctime())if __name__ == '__main__': main() thread_list = threading.enumerate() print("当前线程数量：%d" % len(thread_list))out: starting at : Wed Nov 13 14:41:20 2019 &lt;Thread(Thread-1, started 9916)&gt;start loop0 atWed Nov 13 14:41:20 2019: &lt;Thread(Thread-2, started 2868)&gt;start loop1 atWed Nov 13 14:41:20 2019: loop1 done at: Wed Nov 13 14:41:20 2019 all done at: Wed Nov 13 14:41:20 2019 当前线程数量：2 loop0 done at: Wed Nov 13 14:41:24 2019线程参数及顺序线程中传递参数有三种方法1.使用元组传递threading.Thread(target=fun_name,args=(参数。。。))thread_1 = threading.Thread(target=loop0, args=(10, 21, 22))2.使用字典传递 threading.Thread(target=fun_name,kwargs={&quot;参数名&quot;: &quot;参数值&quot;....})thread_1 = threading.Thread(target=loop0, kwargs={&quot;a&quot;: 10, &quot;b&quot;: 21, &quot;c&quot;: 22})3.混合使用元组和字典传递 threading.Thread(target=fun_name,args=(10, 21, 22), kwargs={&quot;参数名&quot;: &quot;参数值&quot;....})thread_1 = threading.Thread(target=loop0, args=(10, 21), kwargs={&quot;c&quot;: 22})123456789101112131415161718192021222324252627282930313233343536373839404142434445import threadingfrom time import *def loop0(a, b, c): print("参数：", a, b, c) print("start loop0 at:", ctime()) sleep(4) print("loop0 done at:", ctime())def loop1(): print("start loop1 at:", ctime()) print("loop1 done at:", ctime())def main(): print("starting at :", ctime()) # 线程中传递参数有三种方法 # 1.使用元组传递 threading.Thread(target=fun_name,args=(参数。。。)) # thread_1 = threading.Thread(target=loop0, args=(10, 21, 22)) # 2.使用字典传递 threading.Thread(target=fun_name,kwargs=&#123;"参数名": "参数值"....&#125;) # thread_1 = threading.Thread(target=loop0, kwargs=&#123;"a": 10, "b": 21, "c": 22&#125;) # 3.混合使用元组和字典传递 threading.Thread(target=fun_name,args=(10, 21, 22), kwargs=&#123;"参数名": "参数值"....&#125;) thread_1 = threading.Thread(target=loop0, args=(10, 21), kwargs=&#123;"c": 22&#125;) thread_2 = threading.Thread(target=loop1) thread_1.start() thread_2.start() print("all done at:", ctime())if __name__ == "__main__": main()out: starting at : Wed Nov 13 15:00:00 2019 参数： 10 21 22 start loop0 at: Wed Nov 13 15:00:00 2019 start loop1 at: Wed Nov 13 15:00:00 2019 loop1 done at: Wed Nov 13 15:00:00 2019 all done at: Wed Nov 13 15:00:00 2019 loop0 done at: Wed Nov 13 15:00:04 2019守护线程守护线程：如果在程序中将子线程设置为守护线程，则该子线程会在主线程结束时自动退出，设置方式为threaj.setDaemon（True），要在thread.start0之前设置，默认是false的，也就是主线程结束时，子线程依然在执行。对于python应用我们都知道main方法是入口，它的运行代表着主线程开始工作了，我们都知道Python虚拟机里面有垃圾回收器的存在使得我们放心让main运行，然而这背后是垃圾回收线程作为守护着主线程的守护线程。1234567891011121314151617181920212223242526272829import threadingimport timedef work1(): for i in range(10): print("正在执行work1...", i) time.sleep(0.5)if __name__ == '__main__': # 创建子线程 thread_woek1 = threading.Thread(target=work1) # 将子线程设置为守护线程 thread_woek1.setDaemon(True) thread_woek1.start() # 睡眠 time.sleep(2) print("game over") # 让程序退出，主线程主动结束 exit() out: 正在执行work1... 0 正在执行work1... 1 正在执行work1... 2 正在执行work1... 3 game over并行和并发多任务的原理剖析操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒…….这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。并发：指的是任务数多于cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一超执行而已）真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。并发：任务数量大于CPU的核心数并行：指的是任务数小于等于cpu核数，即任务真的是一起执行的并行：任务数量小于或等于CPU的核心数多线程——共享全局变量当多个线程修改同一个资源的时候，会出现资源竞争，导致计算结果有误调用join方法优先让某个线程先执行缺点：将多线程变成了单线程，影响执行效率12345678910111213141516171819202122232425262728293031323334import threadingimport timeg_num = 0def work1(): # 声明g_num是一个全局变量 global g_num for i in range(10000000): g_num += 1 print("work1-----------------", g_num)def work2(): global g_num for i in range(10000000): g_num += 1 print("work2-----------------", g_num)if __name__ == '__main__': work_1 = threading.Thread(target=work1) work_2 = threading.Thread(target=work2) work_1.start() # 优先让t1线程先执行， t1执行完毕后，t2才能执行 work_1.join() work_2.start() while len(threading.enumerate()) != 1: time.sleep(1) print("main-----------", g_num)同步和异步同步：多任务，多个任务之间执行的时候要求有先后顺序，必须一个先执行完成之后，另一个才能继续执行，只有一个主线。如：你说完，我再说（同一时间只能做一件事情）异步，指的是：多个任务之间执行没有先后顺序，可以同时运行，执行的先后顺序不会有什么影响，存在的多条运行主线。如：发微信（可以不用等对方回复，继续发）、点外卖（点了外卖后，可以继续忙其他的事情，而不是坐等外卖，啥也不做）线程锁互斥锁当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制线程同步能够保证多个线程安全访问竞争源，最简单的同步机制是引入互斥锁。互斥锁为资源引入一个状态：锁定/非锁定某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import threadingimport timeg_num = 0def work1(): # 声明g_num是一个全局变量 global g_num for i in range(10000000): # 上锁 lock1.acquire() g_num += 1 # 释放锁 lock1.release() print("work1-----------------", g_num)def work2(): global g_num for i in range(10000000): # 上锁 lock1.acquire() g_num += 1 # 解锁 lock1.release() print("work2-----------------", g_num)if __name__ == '__main__': print(time.ctime()) # 创建一把互斥锁 lock1 = threading.Lock() work_1 = threading.Thread(target=work1) work_2 = threading.Thread(target=work2) work_1.start() work_2.start() while len(threading.enumerate()) != 1: time.sleep(1) print("main-----------", g_num) print("总时间:", time.ctime())死锁在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。注意：使用完毕及时释放1234567891011121314151617181920212223import threadingdef get_value(index): data_list = [1, 3, 5, 7, 9] lock1.acquire() if index &gt;= len(data_list): print("下标越界", index) # 若不释放就产生死锁 lock1.release() return print(data_list[index]) lock1.release()if __name__ == '__main__': # 创建一把锁 lock1 = threading.Lock() for i in range(10): t1 = threading.Thread(target=get_value, args=(i, )) t1.start()]]></content>
      <categories>
        <category>Python编程</category>
      </categories>
      <tags>
        <tag>线程概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket网络编程实战-斗鱼弹幕获取]]></title>
    <url>%2F2019%2F10%2F31%2F%E6%96%97%E9%B1%BC%E5%BC%B9%E5%B9%95%E6%8A%93%E5%8F%96%2F</url>
    <content type="text"><![CDATA[asyncore模块介绍这个模块为异步socket的服务器客户端通信提供简单的接口。该模块提供了异步socket服务客户端和服务器的基础架构。相比python原生的socket api，asyncore具备有很大的优势，asyncore对原生的socket进行封装，提供非常简洁优秀的接口，利用asyncore覆写相关需要处理的接口方法，就可以完成一个socket的网络编程，从而需要处理复杂的socket网络状况以及多线程处理等等。实现流程客户端 Socket 开发基本使用1.定义类继承自asyncore.dispatcher2.实现类中的回调代码实现构造函数调用父类方法创建 Socket对象连接服务器实现handle_connect回调函数当socket连接服务器成功时回调该函数实现writable回调函数描述是否有数据需要被发送到服务器。返回值为True表示可写，False表示不可写，如果不实现默认返回为True，当返回True时，回调函数handle_write将被触发实现handle_write 回调函数当有数据需要发送时（writable回调函数返回True时），该函数被触发，通常情况下在该函数中编写send方法发送数据实现readable回调函数描述是否有数据从服务端读取。返回True 表示有数据需要读取，False表示没有数据需要被读取，当不实现默认返回为True，当返回True 时，回调函数handle_read将被触发实现handle_read回调函数当有数据需要读取时触发（readable回调函数返回True时），该函数被触发，通常情况下在该函数中编写recv方法接收数据实现handle_error回调函数当程序运行过程发生异常时回调实现handle_close回调函数当连接被关闭时触发3.创建对象并且执行asyncore.loop进入运行循环timeout表示一次循环所需要的时长12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import asyncoreimport sys# 定义类继承自 asyncore.dispatherclass scoket_client(asyncore.dispatcher): # 实现类中的回调代码 def __init__(self, host, port): # 调用父类的方法 asyncore.dispatcher.__init__(self) # 创建 Scoket 服务器 self.create_socket() # 连接地址 address = (host, port) self.connect(address) pass # 实现handle_connect回调函数 def handle_connect(self): print("连接成功") # 实现writable函数 def writable(self): return False # 实现handle_write回调函数 def handle_write(self): # 内部实现对服务器发送数据代码 # 调用 send 方法发送数据，参数是字节数据 self.send("hello world".encode('utf-8')) # self.send("hello world") # 实现readable回调函数 def readable(self): return True # 实现handle_read回调函数 def handle_read(self): # 主动接收数据 result = self.recv(1024) print(result) # 实现handle_error回调函数 def handle_error(self): # 编写处理错误方法 t, e, trace = sys.exc_info() # 实现handle_close回调函数 def handle_close(self): print("连接关闭") self.close()# 创建对象并且执行asyncore.loop 进入循环if __name__ == '__main__': client = scoket_client('127.0.0.1', 9000) # 开始启动运行循环 asyncore.loop(timeout=5)斗鱼弹幕实战文档资料斗鱼弹幕服务器第三方接入协议V1.6.2.pdf 官方提供协议文档弹幕客户端开发流程连接初始化使用TCP连接服务器IP地址：openbarrage.douyutv.com端口：8601客户端向弹幕服务器发送登录请弧，登录弹幕服务器弹幕服务器收到客户端登录请求并完成登录后，返回登录成功消息给客户端客户端收到登录成功消息后发送进入弹幕分组请求给弹幕服务器弹幕服务器接受到客户端弹幕分组请求后将客户端添加到请求指定的弹幕分组中服务过程客户端每隔45秒发送心跳给弹幕服务器，弹幕服务器回复心跳信息给客户端弹幕服务器如有广播信息，则推送给客户端，服务器消息协议断开连接客户端发送登出消息客户端关闭TCP连接数据发送和接收流程数据包讲解消息长度：4 字节小端整数，表示整条消息（包括自身）长度（字节数）消息长度出现两遍，二者相同消息类型：2 字节小端整数，表示消息类型。取值如下：689 客户端发送给弹幕服务器的文本格式数据690 弹幕服务器发送给客户端的文本格式数据。加密字段：暂时未用，默认为 0。保留字段：暂时未用，默认为 0。数据部分：斗鱼独创序列化文本数据，结尾必须为‘\0’。详细序列化、反序列化算法见下节。（所有协议内容均为 UTF-8 编码）数据包的封装对数据包进行对象化封装，对数据的封装方便以后使用，实现对象和二进制数据之间的转换通过参数构建数据包对象实现获取数据包长度的方法实现获取二进制数据的方法实现发送数据包构建发送数据包的容器实现回调函数，判断容器中有数据就发送没有数据不发送实现登录函数构建登录数据包把数据包添加到发送数据包容器中实现接收数据构建接收数据包队列读取回调函数中读取数据读取长度读取内容构建数据包对象把数据包放入接收数据包容器中构建处理数据包线程构建线程实现回调函数处理数据实现外部传入回调函散通过外部指定回调函数实现自定义数据处理添加参数callback构造函数中添加参数外部传入自定义回调函数在处理接收数据包的线程中调用回调函数数据内容序列话与反序列化1 键 key 和值 value 直接采用‘@=’分割2 数组采用‘/’分割3 如果 key 或者 value 中含有字符‘/’，则使用‘@S’转义4 如果 key 或者 value 中含有字符‘@’ ，使用‘@A’转义举例：多个键值对数据：key1@=value1/key2@=value2/key3@=value3/数组数据：value1/value2/value3/不同消息有相同的协议头、序列化方式加入弹幕分组​ 第三方平台建议选择-9999（即海量弹幕模式 )心跳机制作用是让服务器解决假死连接问题，客户端必须每隔45秒发送一次请求，否则就会被主动断开。实现发送心跳函数构建心跳数据包把数据包添加到发送数据包容器队列中构建心跳线程构建心跳线程添加触发机制添加暂停机制]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令集合]]></title>
    <url>%2F2019%2F10%2F28%2Fgit%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git config配置 Git 的相关参数。Git 一共有3个配置文件：仓库级的配置文件：在仓库的 .git/.gitconfig，该配置文件只对所在的仓库有效。全局配置文件：Mac 系统在 ~/.gitconfig，Windows 系统在 C:\Users\&lt;用户名&gt;\.gitconfig。系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 /usr/local/git）的 etc 文件夹中的 gitconfig。123456789101112131415161718192021222324252627282930313233343536373839404142# 查看配置信息# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; -l# 查看当前生效的配置信息$ git config -l# 编辑配置文件# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; -e# 添加配置项# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; --add &lt;name&gt; &lt;value&gt;# 获取配置项$ git config &lt;--local | --global | --system&gt; --get &lt;name&gt;# 删除配置项$ git config &lt;--local | --global | --system&gt; --unset &lt;name&gt;# 配置提交记录中的用户信息$ git config --global user.name &lt;用户名&gt;$ git config --global user.email &lt;邮箱地址&gt;# 更改Git缓存区的大小# 如果提交的内容较大，默认缓存较小，提交会失败# 缓存大小单位：B，例如：524288000（500MB）$ git config --global http.postBuffer &lt;缓存大小&gt;# 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态$ git config --global color.ui true# 配置可以缓存密码，默认缓存时间15分钟$ git config --global credential.helper cache# 配置密码的缓存时间# 缓存时间单位：秒$ git config --global credential.helper 'cache --timeout=&lt;缓存时间&gt;'# 配置长期存储密码$ git config --global credential.helper storegit clone从远程仓库克隆一个版本库到本地。12345678# 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下$ git clone &lt;远程仓库的网址&gt;# 指定本地仓库的目录$ git clone &lt;远程仓库的网址&gt; &lt;本地目录&gt;# -b 指定要克隆的分支，默认是master分支$ git clone &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt;git init初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。12# 初始化本地仓库，在当前目录下生成 .git 文件夹$ git initgit status查看本地仓库的状态。1234567# 查看本地仓库的状态$ git status# 以简短模式查看本地仓库的状态# 会显示两列，第一列是文件的状态，第二列是对应的文件# 文件状态：A 新增，M 修改，D 删除，?? 未添加到Git中$ git status -sgit remote操作远程库。123456789101112131415161718# 列出已经存在的远程仓库$ git remote# 列出远程仓库的详细信息，在别名后面列出URL地址$ git remote -v$ git remote --verbose# 添加远程仓库$ git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的URL地址&gt;# 修改远程仓库的别名$ git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;# 删除指定名称的远程仓库$ git remote remove &lt;远程仓库的别名&gt;# 修改远程仓库的 URL 地址$ git remote set-url &lt;远程仓库的别名&gt; &lt;新的远程仓库URL地址&gt;git branch操作 Git 的分支命令。1234567891011121314151617181920# 列出本地的所有分支，当前所在分支以 "*" 标出$ git branch# 列出本地的所有分支并显示最后一次提交，当前所在分支以 "*" 标出$ git branch -v# 创建新分支，新的分支基于上一次提交建立$ git branch &lt;分支名&gt;# 修改分支名称# 如果不指定原分支名称则为当前所在分支$ git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;# 强制修改分支名称$ git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;# 删除指定的本地分支$ git branch -d &lt;分支名称&gt;# 强制删除指定的本地分支$ git branch -D &lt;分支名称&gt;git checkout检出命令，用于创建、切换分支等。123456789101112# 切换到已存在的指定分支$ git checkout &lt;分支名称&gt;# 创建并切换到指定的分支，保留所有的提交记录# 等同于 "git branch" 和 "git checkout" 两个命令合并$ git checkout -b &lt;分支名称&gt;# 创建并切换到指定的分支，删除所有的提交记录$ git checkout --orphan &lt;分支名称&gt;# 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响$ git checkout &lt;文件路径&gt;git cherry-pick把已经提交的记录合并到当前分支。12# 把已经提交的记录合并到当前分支$ git cherry-pick &lt;commit ID&gt;git add把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交。1234567891011121314# 把指定的文件添加到暂存区中$ git add &lt;文件路径&gt;# 添加所有修改、已删除的文件到暂存区中$ git add -u [&lt;文件路径&gt;]$ git add --update [&lt;文件路径&gt;]# 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录$ git add -A [&lt;文件路径&gt;]$ git add --all [&lt;文件路径&gt;]# 查看所有修改、已删除但没有提交的文件，进入一个子命令系统$ git add -i [&lt;文件路径&gt;]$ git add --interactive [&lt;文件路径&gt;]git commit将暂存区中的文件提交到本地仓库中。123456789101112# 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息$ git commit# 把暂存区中的文件提交到本地仓库中并添加描述信息$ git commit -m "&lt;提交的描述信息&gt;"# 把所有修改、已删除的文件提交到本地仓库中# 不包括未被版本库跟踪的文件，等同于先调用了 "git add -u"$ git commit -a -m "&lt;提交的描述信息&gt;"# 修改上次提交的描述信息$ git commit --amendgit fetch从远程仓库获取最新的版本到本地的 tmp 分支上。12345# 将远程仓库所有分支的最新版本全部取回到本地$ git fetch &lt;远程仓库的别名&gt;# 将远程仓库指定分支的最新版本取回到本地$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;git merge合并分支。12# 把指定的分支合并到当前所在的分支下$ git merge &lt;分支名称&gt;git diff比较版本之间的差异。123456789101112131415161718# 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改$ git diff# 比较暂存区中的文件和上次提交时的差异$ git diff --cached$ git diff --staged# 比较当前文件和上次提交时的差异$ git diff HEAD# 查看从指定的版本之后改动的内容$ git diff &lt;commit ID&gt;# 比较两个分支之间的差异$ git diff &lt;分支名称&gt; &lt;分支名称&gt;# 查看两个分支分开后各自的改动内容$ git diff &lt;分支名称&gt;...&lt;分支名称&gt;git pull从远程仓库获取最新版本并合并到本地。首先会执行 git fetch，然后执行 git merge，把获取的分支的 HEAD 合并到当前分支。12# 从远程仓库获取最新版本。$ git pullgit push把本地仓库的提交推送到远程仓库。123456# 把本地仓库的分支推送到远程仓库的指定分支$ git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;# 删除指定的远程仓库的分支$ git push &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;$ git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt;git log显示提交的记录。12345678# 打印所有的提交记录$ git log# 打印从第一次提交到指定的提交的记录$ git log &lt;commit ID&gt;# 打印指定数量的最新提交的记录$ git log -&lt;指定的数量&gt;git reset还原提交记录。12345678910111213141516# 重置暂存区，但文件不受影响# 相当于将用 "git add" 命令更新到暂存区的内容撤出暂存区，可以指定文件# 没有指定 commit ID 则默认为当前 HEAD$ git reset [&lt;文件路径&gt;]$ git reset --mixed [&lt;文件路径&gt;]# 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改$ git reset &lt;commit ID&gt;$ git reset --mixed &lt;commit ID&gt;# 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改# 相当于调用 "git reset --mixed" 命令后又做了一次 "git add"$ git reset --soft &lt;commit ID&gt;# 将 HEAD 的指向改变，撤销到指定的提交记录，文件也修改了$ git reset --hard &lt;commit ID&gt;git revert生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。12# 生成一个新的提交来撤销某次提交$ git revert &lt;commit ID&gt;git tag操作标签的命令。1234567891011121314151617181920212223# 打印所有的标签$ git tag# 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录$ git tag &lt;标签名称&gt; [&lt;commit ID&gt;]# 添加带有描述信息的附注标签，可以指定之前的提交记录$ git tag -a &lt;标签名称&gt; -m &lt;标签描述信息&gt; [&lt;commit ID&gt;]# 切换到指定的标签$ git checkout &lt;标签名称&gt;# 查看标签的信息$ git show &lt;标签名称&gt;# 删除指定的标签$ git tag -d &lt;标签名称&gt;# 将指定的标签提交到远程仓库$ git push &lt;远程仓库的别名&gt; &lt;标签名称&gt;# 将本地所有的标签全部提交到远程仓库$ git push &lt;远程仓库的别名&gt; –tagsgit mv重命名文件或者文件夹。12# 重命名指定的文件或者文件夹$ git mv &lt;源文件/文件夹&gt; &lt;目标文件/文件夹&gt;git rm删除文件或者文件夹。12345678# 移除跟踪指定的文件，并从本地仓库的文件夹中删除$ git rm &lt;文件路径&gt;# 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除$ git rm -r &lt;文件夹路径&gt;# 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件$ git rm --cachedGit操作场景示例1. 删除掉本地不存在的远程分支多人合作开发时，如果远程的分支被其他开发删除掉，在本地执行 git branch --all 依然会显示该远程分支，可使用下列的命令进行删除：123456# 使用 pull 命令，添加 -p 参数$ git pull -p# 等同于下面的命令$ git fetch -p$ git fetch --prune origin来源：https://www.jianshu.com/p/93318220cdce]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Python语言的IP代理池]]></title>
    <url>%2F2019%2F10%2F27%2FIP%E4%BB%A3%E7%90%86%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[环境：python3.6MongoDBflaskrequests等第三方库完整代码见： https://github.com/Lucareful/IPProxyPool代理池概述什么是代理池代理池就是有代理IP组成的池子，它可以提供多个稳定可用的代理IP为什么要实现代理池我们在做爬虫的时候，最常见的一种反爬虫手段就是：IP反爬；也就是当同一个IP访问这个网站的次数过多，频率过高，就会限制这个IP的访问。就是需要经常换IP；使用IP代理池是其中一个比较常用的方案免费代理都是非常不稳定的，有10%是可用就很不错了一些收费代理稳定性也不好目的：从一堆不稳定的代理IP中，抽取高可用代理IP，给爬虫使用代理池开发环境python3开发语言requests：发送请求，获取页面数据lxml：使用XPATH从页面提取我们想要的书籍pymonge：把提取到代理IP存储到MongoDB数据库中和MongoDB数据库中读取代理IP，给爬虫使用Flask：用于提供WEB服务代理池工作流程1.代理池工作渡程描述：代理IP采集模块-&gt;采集代理IP-&gt;检测代理IP-&gt;如果不可用用，直接过滤掉，如果可用，指定默认分数-&gt;存入数据库中代理IP检测模块-&gt;从数据库中获取所有代理IP-&gt;检测代理IP-&gt;如果代理IP不可用用，就把分数-1，如果分数为0从数据库中删除，否则更新数据库，如果代理IP可用，恢复为默认分值，更新数据库代理API模块-&gt;从数据库中高可用的代理IP给爬虫使用；代理池的模块及其作用五大核心模块爬虫模块从代理IP网站上采集代理IP进行校验（获取代理响应速度，协议类型，匿名类型）把可用代理IP存储到数据库中代理IP的校验模块：获取指定代理的响应速度，支持的协议以及匿名程度原因：网站上所标注的响应速度，协议类型和匿名类型是不准确的这里使用httpbin.org进行检测数据库模块：实现对代理IP的增删改查操作这里使用MongoDB来存储代理IP检测模块：定时的对代理池中代理进行检测，保证代理池中代理的可用性.从数据库读取所有的代理IP对代理IP进行逐一检测，可用开启多个协程，以提高检测速度如果该代理不可用，就让这个代理分数-1，当代理的分数到0了，就删除该代理；如果检测到代理可用就恢复为满分.代理IP服务接口：提供高可用的代理IP给爬虫使用根据协议类型和域名获取随机一个高质量代理IP根据协议类型和域名获取多个高质量代理IP根据代理IP不可用域名，告诉代理池这个代理IP在该域名下不可用，下次获取这个域名的代理IP时候，就不会再获取这个代理IP了，从而保证代理IP高可用性.代理池的其它模块数据模型：domain.py代理IP的数据模型，用于封装代理IP相关信息，比如ip，端口号，响应速度，协议类型，匿名类型，分数等程序启动入口：main.py·代理池提供一个统一的启动入口工具模块：、日志模块：用于记录日志信息http模块：用于获取随机User-Agent的请求头配置文件：settings.py用于默认代理的分数，配置日志格式，文件，启动的爬虫，检验的间隔时间等.代理池的项目结构12345678910111213141516171819202122--IPProxyPoo1 --core --db --__init__.py --mongo_pool.py --proxy_validate --__init__.py --httpbin_validator.py --proxy_spider --__init__.py --base_spider.py --proxy_kpiders.py --run_spiders.py --proxy_test.py --proxy_api.py --domain.py --utils --__init__.py --http.py --log.py --main.py --settings.py定义代理IP的数据模型类定义Proxy类，继承object实现_init_方法，负责初始化，包含如下字段：ip：代理的IP地址port：代理IP的端口号protocol：代理IP支持的协议类型，http是0，https是1，https和http都支持是2nick_type：代理IP的匿名程度，高匿：0，匿名：1，透明：2speed：代理IP的响应速度，单位sarea：代理IP所在地区score：代理IP的评分，用于衡量代理的可用性；默认分值可以通过配置文件进行配置.在进行代理可用性检查的时候，每遇到一次请求失败就减1份，减到0的时候从池中删除.如果检查代理可用，就恢复默认分值disable_domains：不可用域名列表，有些代理IP在某些域名下不可用，但是在其他域名下可用在配置文件：settings.py中定义MAX_SCORE=50，表示代理IP的默认最高分数提供_str方法，返回数据字符串代理池的工具模块日志模块http模块日志模块能够方便的对程序进行调试能够方便记录程序的运行状态能够方便记录错误信息日志的实现目标：实现日志模块，用于记录日志把日志相关配置信息放到配置文件中修改日志代码，使用配置文件中的配置信息Http模块我在从代理IP网站上抓取代理IP和检验代理IP时候，为了不容易不服务器识别为是一个爬虫，我们最好提供随机的User-Agent请求头.目标：获取随机User-Agent的请求头步骤：1.准备User-Agent的列表2.实现一个方法，获取随机User-Agent的请求头代理池的检验模块目标：检查代理IP速度，匿名程度以及支持的协议类型.步骤：检查代理IP速度和匿名程度；代理IP速度：就是从发送请求到获取响应的时间间隔匿名程度检查：对http://httpbin.org/get 或https://httpbin.org/get 发送请求如果响应的origin中有 ，分割的两个IP就是透明代理IP如果响应的headers 中包含Proxy-Connection 说明是匿名代理IP否则就是高匿代理IP。检查代理IP协议类型如果http://httpbin.org/get 发送请求可以成功，说明支持http协议如果https://httpbin.org/get 发送请求可以成功，说明支持https协议代理池的数据库模块作用：用于对proxies集合进行数据库的相关操作目标：实现对数据库增删改查相关操作、步骤：1.在init中，建立数据连接，获取要操作的集合，在del方法中关闭数据库连接2.提供基础的增删改查功能实现插入功能实现修改该功能实现删除代理：根据代理的IP删除代理查询所有代理IP的功能3.提供代理API模块使用的功能实现查询功能：根据条件进行查询，可以指定查询数量，先分数降序，速度升序排，保证优质的代理IP在上面.实现根据协议类型和要访问网站的域名，获取代理IP列表实现根据协议类型和要访问完整的域名，随机获取一个代理IP实现把指定域名添加到指定IP的disable_domain列表中.实现代理池的爬虫模块爬虫模块的需求需求：抓取各个代理IP网站上的免费代理IP进行检测，如果可用存储到数据库中需要抓取代理IP的页面如下：西刺代理：https://www.xicidaili.com/nn/1ip3366代理：http://www.ip3366.net/free/?stype=1&amp;page=1快代理：https://www.kuaidaili.com/free/inha/1/oproxylistplus代理:https://list.proxylistplus.com/Fresh-HTTP-Proxy-List-166ip代理：http://www.66ip.cn/1.html爬虫模块的设计通用爬虫：通过指定URL列表，分组XPATH和组内XPATH，来提取不同网站的代理IP原因代理IP网站的页面结构几乎都是Table，页面结构类似具体爬虫：用于抓取具体代理IP网站通过继承通用爬虫实现具体网站的抓取，一般只需要指定爬取的URL列表，分组的XPATH和组内XPATH就可以了.如果该网站有特殊反爬手段，可以通过重写某些方法实现反爬爬虫运行模块：启动爬虫，抓取代理IP进行检测，如果可用，就存储到数据库中；通过配置文件来控制启动哪些爬虫，增加扩展性；如果将来我们遇到返回json格式的代理网站，单独写一个爬虫配置下就好了.实现通用爬虫目标：实现可以指定不同URL列表，分组的XPATH和详情的XPATH，从不同页面上提取代理的IP端口号和区域的通用爬虫；步骤：1.在base_spider.py文件中，定义一个BaseSpider类，继承object2.提供三个类成员变量：urls：代理IP网址的URL的列表group_xpath：分组XPATH，获取包含代理IP信息标签列表的XPATHdetail_xpath：组内XPATH，获取代理IP详情的信息XPATH，格式为：{“ip’:’xx’，’port’：’xx’，‘area’：’xx’}3.提供初始方法，传入爬虫URL列表，分组XPATH，详情（组内）XPATH4.对外提供一个获取代理IP的方法遍历URL列表，获取URL根据发送请求，获取页面数据解析页面，提取数据，封装为Proxy对象返回Proxy对象列表实现具体爬虫目标：通过继承通用爬虫，实现多个具体爬虫，分别从各个免费代理IP网站上抓取代理IP1.实现西刺代理爬虫：http://www.xicidaili.com/nn/1定义一个类，继承通用爬虫类（BasicSpider）提供urls，group_xpath 和detail_xpath2.实现ip3366代理爬虫：http://www.ip3366.net/free/？stype=1&amp;page=1定义一个类，继承通用爬虫类（BasicSpider）提供urls，group_xpath 和detail_xpath3.实现快代理爬虫：https://www.kuaidaili.com/free/inha/1/定义一个类，继承通用爬虫类（BasicSpider）提供urls，group_xpath和detail_xpath4.实现 proxylistplus代理爬虫：https://list.proxylistplus.com/Fresh-HTTP-Proxy-List-1定义一个类，继承通用爬虫类（BasicSpider）提供urls，group_xpath 和detail_xpath5.实现66ip爬虫：http://www.66ip.cn/1.html定义一个类，继承通用爬虫类（BasicSpider）提供urls，group_xpath和detail_xpath由于66ip网页进行js+cookie反爬，需要重写父类的get_page_from_url 方法PS：实现66ip爬虫：http://www.66ip.cn/1.html核心：通过加密的js，生成需要cookie信息1.从响应页面中，提取：​ 1.执行生成真正js语句​ 2.生成真正js的函数.2.网页中，是通过eval执行真正js，加载页面；而我们要获取真正的js；我们就需要把eval语句，替换为return，把真正js返回.3.使用js2py，获取执行js的环境，使用js执行环境加载这个函数4.使用这个执行环境，执行调用调用，生成真正js，赋值给一个变量5.从真正的js代码中，提取我们需要cookie信息.实现爬虫的运行模块目标：根据配置文件信息，加载爬虫，抓取代理IP，进行校验，如果可用，写入到数据库中思路：在run_spider.py中，创建RunSpider类提供一个运行爬虫的run方法，作为运行爬虫的入口，实现核心的处理逻辑根据配置文件信息，获取爬虫对象列表.遍历爬虫对象列表，获取爬虫对象，遍历爬虫对象的get_proxies方法，获取代理IP检测代理IP（代理IP检测模块）如果可用，写入数据库（数据库模块）处理异常，防止一个爬虫内部出错了，影响其他的爬虫.使用异步来执行每一个爬虫任务，以提高抓取代理IP效率在init 方法中创建协程池对象把处理一个代理爬虫的代码抽到一个方法使用异步执行这个方法调用协程的join方法，让当前线程等待队列任务的完成.使用schedule模块，实现每隔一定的时间，执行一次爬取任务定义一个start的类方法创建当前类的对象，调用run方法使用schedule模块，每隔一定的时间，执行当前对象的run方法实现代理池的检测模块目的：检查代理IP可用性，保证代理池中代理IP基本可用思路1.在proxy_test.py中，创建Proxy Tester类2.提供一个run 方法，用于处理检测代理命核心逻辑从数据库中获取所有代理IP遍历代理IP列表检查代理可用性如果代理不可用，让代理分数-1，如果代理分数等于0就从数据库中删除该代理，否则更新该代理IP如果代理可用，就恢复该代理的分数，更新到数据库中3.为了提高检查的速度，使用异步来执行检测任务在init方法中，创建队列和协程池把要检测的代理IP，放到队列中i.把检查一个代理可用性的代码，抽取到一个方法中；从队列中获取代理IP，进行检查；检查完毕，调度队列的task_done方法ii.通过异步回调，使用死循环不断执行这个方法，iv.开启多个一个异步任务，来处理代理IP的检测；可以通过配置文件指定异步数量调用队列的join方法，让当前线程等待队列任务完成4.使用schedule模块，每隔一定的时间，执行一次检测任务定义类方法start，用于启动检测模块在start方法中i.创建本类对象i.调用run方法i.每间隔一定时间，执行一下，run方法实现代理池的API模块目标：为爬虫提供高可用代理IP的服务接口步骤：实现根据协议类型和域名，提供随机的获取高可用代理IP的服务实现根据协议类型和域名，提供获取多个高可用代理IP的服务实现给指定的IP上追加不可用域名的服务实现在proxy_api.py中，创建ProxyApi类实现初始方法s初始一个Flask的Web服务实现根据协议类型和域名，提供随机的获取高可用代理IP的服务可用通过protocol和domain参数对IP进行过滤protocol：当前请求的协议类型domain：当前请求域名实现根据协议类型和域名，提供获取多个高可用代理IP的服务·可用通过protocol和domain参数对IP进行过滤实现给指定的IP上追加不可用域名的服务如果在获取IP的时候，有指定域名参数，将不在获取该IP从而进一步提高代理IP的可用性.实现run方法，用于启动Flask的WEB服务实现start的类方法，用于通过类名，启动服务实现代理池的程序入口目标：把启动爬虫，启动检测代理IP，启动WEB服务统一到一起思路：开启三个进程，分别用于启动爬虫，检测代理IP，WEB服务步骤：定义一个run方法用于启动动代理池定义一个列表，用于存储要启动的进程创建启动爬虫的进程，添加到列表中创建启动检测的进程，添加到列表中创建启动提供API服务的进程，添加到列表中遍历进程列表，启动所有进程遍历进程列表，让主进程等待子进程的完成在if__name__==&#39;__main__&#39;：中调用run方法]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>爬虫实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言笔记（3）]]></title>
    <url>%2F2019%2F10%2F22%2Fc%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[结构体结构体声明1234567struct Book&#123; 结构体成员1; 结构体成员2; 结构体成员3; ......&#125;;定义结构体类型变量struct 结构体名称 结构体变量名访问结构体变量要访问结构体成员，我们需要引入一个新的运算符——点号(.)运算符。比如book.title就是引用book结构体的title成员，它是一个字符数组。初始结构体的指定成员值其语法和数组指定初始化元素类似，不过结构体指定初始化成员使用点号（.）运算符和成员名123456789101112131415161718192021222324252627282930313233343536//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;struct Book&#123; char title[128]; char author[40]; float price; unsigned int data; char publisher[40];&#125;book;int main(void)&#123;// struct Book book1; printf("请输入书名："); scanf("%s", book.title); printf("请输入作者："); scanf("%s", book.author); printf("请输入售价："); scanf("%f", &amp;book.price); printf("请输入出版日期："); scanf("%d", &amp;book.data); printf("请输入出版社："); scanf("%s", book.publisher); printf("\n====数据录入完毕====\n\n"); printf("书名：%s\n", book.title); printf("作者：%s\n", book.author); printf("售价：%.2f\n", book.price); printf("出版日期：%d\n", book.data); printf("出版社：%s\n", book.publisher); return 0;&#125;结构体嵌套123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;struct Data&#123; int year; int month; int day;&#125;;struct Book&#123; char title[128]; char author[40]; float price; struct Data data; char publisher[40];&#125;book = &#123; // 初始化 "c学习", "Luenci", 48.8, &#123;2019,11,13&#125;, "文华出版社"&#125;;int main(void)&#123; printf("\n====数据录入为====\n\n"); printf("书名：%s\n", book.title); printf("作者：%s\n", book.author); printf("售价：%.2f\n", book.price); printf("出版日期：%d%d%d\n", book.data.year, book.data.month, book.data.day); printf("出版社：%s\n", book.publisher); return 0;&#125;out书名：c学习作者：Luenci售价：48.80出版日期：20191113出版社：文华出版社结构体数组第二种方法是先声明一个结构体类型（如上例子中Book），再用此类型定义一个结构体数组：12345678910111213struct 结构体名称&#123; 结构体成员;&#125;;struct 结构体名称 数组名[长度];// 初始化结构体数组struct Book book[3] = &#123; &#123;"《零基础学c》", "Luenci", 49.5, &#123;2016, 11, 22&#125;, "清华大学出版社"&#125;， &#123;"《零基础学c》", "Luenci", 49.5, &#123;2016, 11, 22&#125;, "清华大学出版社"&#125;， &#123;"《零基础学c》", "Luenci", 49.5, &#123;2016, 11, 22&#125;, "清华大学出版社"&#125;， &#125;；结构体指针12struct Book *ptr；ptr = &amp;book；通过结构体指针访问结构体成员(*结构体指针).成员名结构体指针-&gt;成员名1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;struct Data&#123; int year; int month; int day;&#125;;struct Book&#123; char title[128]; char author[40]; float price; struct Data data; char publisher[40];&#125;book = &#123; // 初始化 "c学习", "Luenci", 48.8, &#123;2019,11,13&#125;, "文华出版社"&#125;;int main(void)&#123; struct Book *ptr; ptr = &amp;book; printf("\n====数据录入为====\n\n"); printf("书名：%s\n", (*ptr).title); printf("作者：%s\n", (*ptr).author); printf("售价：%.2f\n", (*ptr).price); printf("出版日期：%d%d%d\n", (*ptr).data.year, (*ptr).data.month, (*ptr).data.day); printf("出版社：%s\n", (*ptr).publisher); printf("书名：%s\n", ptr-&gt;title); printf("作者：%s\n", ptr-&gt;author); printf("售价：%.2f\n", ptr-&gt;price); printf("出版日期：%d%d%d\n", ptr-&gt;data.year, ptr-&gt;data.month, ptr-&gt;data.day); printf("出版社：%s\n", ptr-&gt;publisher); return 0;&#125;out:====数据录入为====书名：c学习作者：Luenci售价：48.80出版日期：20191113出版社：文华出版社链表单链表12345graph LRhead --&gt; AA[信息域- 指针] --&gt; B[信息域- 指针]B[信息域- 指针] --&gt; c[信息域- 指针]c[信息域- 指针] --&gt; NULL头插法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// ------------ 头插法实现链表的插入 ---------------//// Created by Luenci on 2019/10/14.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Book&#123; char title[128]; char author[40]; struct Book *next;&#125;;void getInput(struct Book *book)&#123; printf("请输入书名："); scanf("%s", book-&gt;title); printf("请输入作者："); scanf("%s", book-&gt;author);&#125;void add_book(struct Book **library)&#123; struct Book *book, *temp; book = (struct Book *)malloc(sizeof(struct Book)); if(book == NULL)&#123; printf("分配内存失败"); exit(1); &#125; getInput(book); if (*library != NULL)&#123; temp = *library; *library = book; book-&gt;next = temp; &#125; else&#123; *library = book; book-&gt;next = NULL; &#125;&#125;void printLibrary(struct Book *library)&#123; struct Book *book; int count = 1; book = library; while(book != NULL)&#123; printf("Book%d: ", count); printf("书名：%s", book-&gt;title); printf("作者:%s", book-&gt;author); book = book-&gt;next; count++; &#125;&#125;void releaseLibrary(struct Book *library)&#123; while(library != NULL)&#123; library = library-&gt;next; free(library); &#125;&#125;int main(void)&#123; struct Book *library = NULL; int ch; while (1)&#123; printf("请问你是否需要录入书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; add_book(&amp;library); &#125; else&#123; break; &#125; &#125; printf("请问你是否需要打印书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; printLibrary(library); &#125; releaseLibrary(library); return 0;&#125;尾插法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//// Created by Luenci on 2019/10/14.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Book&#123; char title[128]; char author[40]; struct Book *next;&#125;;void getInput(struct Book *book)&#123; printf("请输入书名："); scanf("%s", book-&gt;title); printf("请输入作者："); scanf("%s", book-&gt;author);&#125;void add_book2(struct Book **library)&#123; /* ------------ 尾插法 ------------- */ struct Book *book,*temp; book = (struct Book *)malloc(sizeof(struct Book)); if(book == NULL)&#123; printf("分配内存失败"); exit(1); &#125; getInput(book); if (*library != NULL)&#123; temp = *library; // 定位单链表的尾部位置 while (temp-&gt;next != NULL)&#123; temp = temp-&gt;next; &#125; // 插入数据 temp-&gt;next = book; book-&gt;next = NULL; &#125; else&#123; *library = book; book-&gt;next = NULL; &#125;&#125;void printLibrary(struct Book *library)&#123; struct Book *book; int count = 1; book = library; while(book != NULL)&#123; printf("Book%d: ", count); printf("书名：%s", book-&gt;title); printf("作者:%s", book-&gt;author); book = book-&gt;next; count++; &#125;&#125;void releaseLibrary(struct Book **library)&#123; struct Book *temp; while(library != NULL)&#123; temp = *library; *library = (*library)-&gt;next; free(temp); &#125;&#125;int main(void)&#123; struct Book *library = NULL; int ch; while (1)&#123; printf("请问你是否需要录入书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; add_book2(&amp;library); &#125; else&#123; break; &#125; &#125; printf("请问你是否需要打印书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; printLibrary(library); &#125; releaseLibrary(&amp;library); return 0;&#125;尾插法改进123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178//// Created by Luenci on 2019/10/14.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct Book&#123; char title[128]; char author[40]; struct Book *next;&#125;;void getInput(struct Book *book);void add_book(struct Book **library);void getInput(struct Book *book);void add_book2(struct Book **library);void printLibrary(struct Book *library);struct Book *searchBook(struct Book *library, char *target);void releaseLibrary(struct Book **library);void printBook(struct Book *book);void getInput(struct Book *book)&#123; printf("请输入书名："); scanf("%s", book-&gt;title); printf("请输入作者："); scanf("%s", book-&gt;author);&#125;void add_book(struct Book **library)&#123; /* ----------- 头插法 ------------- */ struct Book *book, *temp; book = (struct Book *)malloc(sizeof(struct Book)); if(book == NULL)&#123; printf("分配内存失败"); exit(1); &#125; getInput(book); if (*library != NULL)&#123; temp = *library; *library = book; book-&gt;next = temp; &#125; else&#123; *library = book; book-&gt;next = NULL; &#125;&#125;void add_book2(struct Book **library)&#123; /* ------------ 尾插法 ------------- */ struct Book *book; static struct Book *tail; book = (struct Book *)malloc(sizeof(struct Book)); if(book == NULL)&#123; printf("分配内存失败"); exit(1); &#125; getInput(book); if (*library != NULL)&#123; tail-&gt;next = book; book-&gt;next = NULL; &#125; else&#123; *library = book; book-&gt;next = NULL; &#125; tail = book;&#125;void printLibrary(struct Book *library)&#123; struct Book *book; int count = 1; book = library; while(book != NULL)&#123; printf("Book%d: ", count); printf("书名：%s", book-&gt;title); printf("作者:%s", book-&gt;author); book = book-&gt;next; count++; &#125;&#125;void releaseLibrary(struct Book **library)&#123; struct Book *temp; while(library != NULL)&#123; temp = *library; *library = (*library)-&gt;next; free(temp); &#125;&#125;struct Book *searchBook(struct Book *library, char *target)&#123; struct Book *book; book = library; while (book != NULL)&#123; // C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false if (!strcmp(book-&gt;title, target) || !strcmp(book-&gt;author, target))&#123; break; &#125; book = book-&gt;next; &#125; return book;&#125;void printBook(struct Book *book)&#123; printf("书名: %s\n", book-&gt;title); printf("作者: %s\n", book-&gt;author);&#125;int main(void)&#123; struct Book *library = NULL; struct Book *book; char *input[128]; int ch; while (1)&#123; printf("请问你是否需要录入书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; add_book2(&amp;library); &#125; else&#123; break; &#125; &#125; printf("请问你是否需要打印书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; printLibrary(library); &#125; printf("\n请输入书名或作者："); scanf("%s", input); book = searchBook(library, input); if(book == NULL)&#123; printf("很抱歉没能找到！\n"); &#125; else&#123; do&#123; printf("已找到符合条件的书籍...\n"); printBook(book); &#125; while ((book = searchBook(book-&gt;next, input)) != NULL); &#125; releaseLibrary(&amp;library); return 0;&#125;链表的插入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//// Created by Luenci on 2019/10/16.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Node&#123; int value; struct Node *next;&#125;;void insertNode(struct Node **head, int value);void printNode(struct Node *head);void insertNode(struct Node **head, int value)&#123; struct Node *previous; struct Node *current; struct Node *new; current = *head; previous = NULL; while (current != NULL &amp;&amp; current-&gt;value &lt; value)&#123; previous = current; current = current-&gt;next; &#125; new = (struct Node *)malloc(sizeof(struct Node)); if (new == NULL)&#123; printf("分配内存失败！\n"); exit(1); &#125; new-&gt;value = value; new-&gt;next = current; if (previous == NULL)&#123; *head = new; &#125; else&#123; previous-&gt;next = new; &#125;&#125;void printNode(struct Node *head)&#123; struct Node *current; current = head; while (current != NULL)&#123; printf("%d ", current-&gt;value); current = current-&gt;next; &#125; putchar('\n');&#125;int main()&#123; struct Node *head = NULL; int input; while (1)&#123; printf("请输入一个整数（-1结束）："); scanf("%d", &amp;input); if(input == -1)&#123; break; &#125; insertNode(&amp;head, input); printNode(head); &#125; return 0;&#125;链表的删除123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//// Created by Luenci on 2019/10/16.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Node&#123; int value; struct Node *next;&#125;;void insertNode(struct Node **head, int value);void printNode(struct Node *head);void delectNode(struct Node **head, int value);void insertNode(struct Node **head, int value)&#123; struct Node *previous; struct Node *current; struct Node *new; current = *head; previous = NULL; while (current != NULL &amp;&amp; current-&gt;value &lt; value)&#123; previous = current; current = current-&gt;next; &#125; new = (struct Node *)malloc(sizeof(struct Node)); if (new == NULL)&#123; printf("分配内存失败！\n"); exit(1); &#125; new-&gt;value = value; new-&gt;next = current; if (previous == NULL)&#123; *head = new; &#125; else&#123; previous-&gt;next = new; &#125;&#125;void delectNode(struct Node **head, int value)&#123; struct Node *previous; struct Node *current; current = *head; previous = NULL; while (current != NULL &amp;&amp; current-&gt;value != value)&#123; previous = current; current = current-&gt;next; &#125; if (current == NULL)&#123; printf("找不到匹配的节点"); return; &#125; else&#123; if(previous == NULL)&#123; *head = current-&gt;next; &#125; else&#123; previous-&gt;next = current-&gt;next; &#125; free(current); &#125;&#125;void printNode(struct Node *head)&#123; struct Node *current; current = head; while (current != NULL)&#123; printf("%d ", current-&gt;value); current = current-&gt;next; &#125; putchar('\n');&#125;int main()&#123; struct Node *head = NULL; int input; printf("开始测试插入整数...\n"); while (1)&#123; printf("请输入一个整数（-1结束）："); scanf("%d", &amp;input); if(input == -1)&#123; break; &#125; insertNode(&amp;head, input); printNode(head); &#125; printf("开始测试删除整数...\n"); while (1)&#123; printf("请输入一个整数（-1结束）："); scanf("%d", &amp;input); if(input == -1)&#123; break; &#125; delectNode(&amp;head, input); printNode(head); &#125; return 0;&#125;内存池优点：设计内存池的目标是为了保证服务器长时间高效的运行，通过对申请空间小而申请频繁的对象进行有效管理，减少内存碎片的产生，合理分配管理用户内存，从而减少系统中出现有效空间足够，而无法分配大块连续内存的情况。结论：内存池基本上满足初期设计目标，但是她并不是完美的，有缺陷，比如,不能申请大于256字节的内存空间，无内存越界检查，无内存自动回缩功能等。只是这些对我们的影响还不是那么重要。typedef基础相比起宏定义的直接替换， typedef是对类型的封装。1234567891011121314151617181920//// Created by Luenci on 2019/10/16.//#include&lt;stdio.h&gt;typedef int integer;int main(void)&#123; integer a; int b; a = 1; b = a; printf("a = %u\n", a); printf("b = %d\n", b); printf("size of a = %d\n", sizeof(a)); return 0;&#125;123456789101112131415161718192021222324252627//// Created by Luenci on 2019/10/16.//#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Data&#123; int year; int mouth; int day;&#125; DATA, *PDATA;int main(void)&#123; struct Data *data; data = (PDATA)malloc(sizeof(DATA)); if (data == NULL)&#123; printf("内存分配失败！\n"); exit(1); &#125; data-&gt;year = 2019; data-&gt;mouth = 10; data-&gt;day = 16; printf("%d-%d-%d\n", data-&gt;year, data-&gt;mouth, data-&gt;day);&#125;进阶Typedef在变成中使用typedef目的一般有两个：一个是给变量起一个容易记住且意义明确的别名另一个是简化一些比较复杂的类型声明共用体共用体的所有成员共享同一个内存地址。123456union 共用体名称&#123; 共用成员1； 共用成员2； 共用成员3；&#125;;123456789101112131415161718192021222324252627282930313233343536373839//// Created by Luenci on 2019/10/19.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;union Test&#123; int i; double pi; char str[6];&#125;;int main(void)&#123; union Test test; test.i = 50; test.pi = 1.2; strcpy(test.str, "Luenci"); printf("addr of test.i:%p\n", &amp;test.i); printf("addr of test.pi:%p\n", &amp;test.pi); printf("addr of test.str:%p\n", &amp;test.str); printf("value of test.i:%d\n", test.i); printf("value of test.i:%.2f\n", test.pi); printf("value of test.i:%s\n", test.str); return 0;&#125;out：addr of test.i:0061FF18addr of test.pi:0061FF18addr of test.str:0061FF18value of test.i:1852142924value of test.i:0.00value of test.i:Luenci​枚举类型如果一个变量只有几种可能的值，那么就可以将其定义为枚举（enumeration）类型。12345// 声明enum 枚举类型名称 &#123;枚举值名称, 枚举值名称...&#125;// 定义enum 枚举类型名称 枚举变量1, 枚举变量;​123456789101112131415161718192021222324252627282930313233343536//// Created by Luenci on 2019/10/19.//#include &lt;stdio.h&gt;#include &lt;time.h&gt;int main(void)&#123; enum Week &#123;sun, mon, tue, wed, thu, fri, sat&#125;; enum Week today; struct tm *p; time_t t; time(&amp;t); p = localtime(&amp;t); today = p-&gt;tm_wday; switch (today)&#123; case mon: case tue: case wed: case thu: case fri: printf("学习！！！\n"); break; case sat: case sun: printf("放假！\n"); break; default: printf("Error!\n"); &#125; return 0;&#125;位域使用位域的做法是在结构体定义时，在结构体成员后面使用冒号（：）和数字来表示该成员所占的位数。无名位域位域成员可以没有名称，只要给出数据类型和位宽即可1234567struct Test&#123; unsigned int x:100; unsigned int y:200; unsigned int z:300; unsigned int :424;&#125;;单片机单片机（Microcontrollers）是一种集成电路芯片，是采用超大规模集成电路技术把具有数据处理能力的中央处理器CPU、随机存储器RAM、只读存储器ROM、多种I/0口和中新系统、定时器/计数器等功能（可能还包括显示驱动电路、脉宽调制电路、模拟多路转换器、A/D转换器等电路）集成到一块硅片上构成的一个小而完善的微型计算机条统，在工业控制领域广泛应用。位操作逻辑位运算符按位取反（~）逻辑位运算符中优先级最高的是按位取反运算符，它的运算符是一个~符号，作用是将1变成0，将0变成1：按位与（&amp;）优先级第二高的是按位与运算符，它的运算符是一个&amp;符号（而逻辑与是两个&amp;符号）按位异或（^）优先级排第三的是按位异或运算符，它的运算符是一个个符号，只有当两个操作数对应的二进制位不同时，它的结果才为1，否则为0：按位或（|）逻辑位运算符中优先级最低的是按位或运算符，它的运算符是一个|符号（而逻辑或是两个I符号）和赋值号结合这四个运算符，除了按位取反只有一个操作数之外，其它三个都可以跟赋值号（=）结合到一块，使得代码更加简洁！1234567891011121314151617181920212223242526//// Created by Luenci on 2019/10/19.//#include &lt;stdio.h&gt;int main(void)&#123; int mask = 0xFF; int v1 = 0xABCDEF; int v2 = 0xABCDEF; int v3 = 0xABCDEF; v1 &amp;= mask; v2 |= mask; v3 ^= mask; printf("v1 = 0x%x\n", v1); printf("v2 = 0x%x\n", v2); printf("v3 = 0x%x\n", v3); return 0;&#125;out:v1 = 0xefv2 = 0xabcdffv3 = 0xabcd10移位运算符A = 0011 1100左移位运算符二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。A &lt;&lt; 2 将得到 240，即为 1111 0000右移位运算符二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。A &gt;&gt; 2 将得到 15，即为 0000 1111一些未定义行为左移、右移运算符右边的操作数如果是为负数，或者右边的操作数火于左边操作数支持的最大宽度，那么表达式的结果均是属于“未定义行为”。左边的操作数是有符号还是无符号数其实也对移位运算符有着不同的影响。无等号数肯定没问题，因为这时候变量里边所有的位都用于表示该数值的大小。但如果是有符号数，那就要区别对待了，因为有符号数的左边第一位是符号位，所以如果恰好这个操作数是个负数，那么移动之后是否覆盖符号位的决定权还是落到了编译器上。文件操作文件概念计算机文件（或称文件、电脑档案、档亲），是存储在基种长期储存设备或临时存储设备中的一段数据流，并且归属于计算机文件系统管理之下。所谓“长期储存设备”一般指磁盘、光盘、磁带等。而“短期存储设备”一般指计算机内存。需要注意的是，存储于长期存储设备的文件不一定是长期存储的，有些也可能是程序或条统运行中产生的临时数据，并于程序或系统退出后删除。打开文件您可以使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：1FILE *fopen( const char * filename, const char * mode );在这里，filename 是字符串，用来命名文件，访问模式 mode 的值可以是下列值中的一个：模式描述r打开一个已有的文本文件，允许读取文件。w打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。a打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。r+打开一个文本文件，允许读写文件。w+打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。a+打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：1"rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b"关闭文件为了关闭文件，请使用 fclose( ) 函数。函数的原型如下：1int fclose( FILE *fp );如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量。C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。写入文件下面是把字符写入到流中的最简单的函数：1int fputc( int c, FILE *fp );函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：1int fputs( const char *s, FILE *fp );函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。您也可以使用 int fprintf(FILE *fp,const char *format, …) 函数来写把一个字符串写入到文件中。读写单个字符fgetc函数描述C 库函数 char *fgets(char *str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。声明下面是 fgets() 函数的声明。1char *fgets(char *str, int n, FILE *stream)参数str – 这是指向一个字符数组的指针，该数组存储了要读取的字符串。n – 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。返回值如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。如果发生错误，返回一个空指针。getc函数描述C 库函数 int getc(FILE *stream) 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。声明下面是 getc() 函数的声明。1int getc(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要在上面执行操作的流。返回值该函数以无符号 char 强制转换为 int 的形式返回读取的字符，如果到达文件末尾或发生读错误，则返回 EOF单个字符写入fputc函数描述C 库函数 int fputc(int char, FILE *stream) 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。声明下面是 fputc() 函数的声明。1int fputc(int char, FILE *stream)参数char – 这是要被写入的字符。该字符以其对应的 int 值进行传递。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符的流。返回值如果没有发生错误，则返回被写入的字符。如果发生错误，则返回 EOF，并设置错误标识符。puts函数描述C 库函数 int putc(int char, FILE *stream) 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。声明下面是 putc() 函数的声明。1int putc(int char, FILE *stream)参数char – 这是要被写入的字符。该字符以其对应的 int 值进行传递。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符的流。返回值该函数以无符号 char 强制转换为 int 的形式返回写入的字符，如果发生错误则返回 EOF。区别fgetc（fputc）函数和getc （putc）函数两个的功和描述基本上是一模一样的，它们的区别主要在于实现上：fgetc（fputc）是一个函数；而getc （putc）则是一个宏的实现一般来说宏产生较大的代码，但是避免了函数调用的堆栈操作，所以速度会比较快。由于getc是由宏实现的，对其参数可能有不止一次的调用，所以不能使用带有副作用（side effects）的参数。123456789101112131415161718192021222324252627282930//// Created by Luenci on 2019/10/20.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; FILE *fp1; FILE *fp2; int ch; if ((fp1 = fopen("D:\\c_study\\test.txt", "r")) == NULL)&#123; printf("打开文件失败！\n"); exit(EXIT_FAILURE); &#125; if ((fp2 = fopen("D:\\c_study\\demo2.txt", "w")) == NULL)&#123; printf("打开文件夹失败！\n"); exit(EXIT_FAILURE); &#125; while ((ch = fgetc((fp1))) != EOF)&#123; fputc(ch, fp2); &#125; fclose(fp1); fclose(fp2); return 0;&#125;读写整个字符串fgets函数描述C 库函数 char *fgets(char *str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。声明下面是 fgets() 函数的声明。1char *fgets(char *str, int n, FILE *stream)参数str – 这是指向一个字符数组的指针，该数组存储了要读取的字符串。n – 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。返回值如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。如果发生错误，返回一个空指针。fputs函数描述C 库函数 int fputs(const char *str, FILE *stream) 把字符串写入到指定的流 stream 中，但不包括空字符。声明下面是 fputs() 函数的声明。1int fputs(const char *str, FILE *stream)参数str – 这是一个数组，包含了要写入的以空字符终止的字符序列。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符串的流。返回值该函数返回一个非负值，如果发生错误则返回 EOF。feof()函数描述C 库函数 int feof(FILE *stream) 测试给定流 stream 的文件结束标识符。声明下面是 feof() 函数的声明。1int feof(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。返回值当设置了与流关联的文件结束标识符时，该函数返回一个非零值，否则返回零。123456789101112131415161718192021222324252627282930313233343536//// Created by Luenci on 2019/10/20.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX 1024int main(void)&#123; FILE *fp1; char buff[MAX]; if ((fp1 = fopen("D:\\c_study\\demo3.txt", "w")) == NULL)&#123; printf("打开文件失败！\n"); exit(EXIT_FAILURE); &#125; fputs("Luenci 的文件操作1 。\n", fp1); fputs("Luenci 的文件操作2 。\n", fp1); fclose(fp1); if ((fp1 = fopen("D:\\c_study\\demo3.txt", "r")) == NULL)&#123; printf("打开文件失败！\n"); exit(EXIT_FAILURE); &#125; while (!feof(fp1))&#123; fgets(buff, MAX, fp1); printf("%s", buff); &#125; fclose(fp1); return 0;&#125;格式化读写文件fprintf（）函数描述C 库函数 int fprintf(FILE *stream, const char *format, …) 发送格式化输出到流 stream 中。声明下面是 fprintf() 函数的声明。1int fprintf(FILE *stream, const char *format, ...)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。format – 这是 C 字符串，包含了要被写入到流 stream 中的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是1%[flags][width][.precision][length]specifier，具体讲解如下：specifier（说明符）输出c字符d 或 i有符号十进制整数e使用 e 字符的科学科学记数法（尾数和指数）E使用 E 字符的科学科学记数法（尾数和指数）f十进制浮点数g自动选择 %e 或 %f 中合适的表示法G自动选择 %E 或 %f 中合适的表示法o有符号八进制s字符的字符串u无符号十进制整数x无符号十六进制整数X无符号十六进制整数（大写字母）p指针地址n无输出%字符flags（标识）描述-在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。+强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。(space)如果没有写入任何符号，则在该值前面插入一个空格。#与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。 与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。0在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。width（宽度）描述(number)要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。*宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。.precision（精度）描述.number对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。 对于 g 和 G 说明符：要输出的最大有效位数。 对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 对于 c 类型：没有任何影响。 当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。.*精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。length（长度）描述h参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。l参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。L参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。附加参数 – 根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。返回值如果成功，则返回写入的字符总数，否则返回一个负数。fread()函数描述C 库函数 size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 从给定流 stream 读取数据到 ptr 所指向的数组中。声明下面是 fread() 函数的声明。1size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)参数ptr – 这是指向带有最小尺寸 size*nmemb 字节的内存块的指针。size – 这是要读取的每个元素的大小，以字节为单位。nmemb – 这是元素的个数，每个元素的大小为 size 字节。stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。返回值成功读取的元素总数会以 size_t 对象返回，size_t 对象是一个整型数据类型。如果总数与 nmemb 参数不同，则可能发生了一个错误或者到达了文件末尾。fwrite（）函数描述C 库函数 size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) 把 ptr 所指向的数组中的数据写入到给定流 stream 中。声明下面是 fwrite() 函数的声明。1size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)参数ptr – 这是指向要被写入的元素数组的指针。size – 这是要被写入的每个元素的大小，以字节为单位。nmemb – 这是元素的个数，每个元素的大小为 size 字节。stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。返回值如果成功，该函数返回一个 size_t 对象，表示元素的总数，该对象是一个整型数据类型。如果该数字与 nmemb 参数不同，则会显示一个错误。文件随机读写ftell（）函数描述C 库函数 long int ftell(FILE *stream) 返回给定流 stream 的当前文件位置。声明下面是 ftell() 函数的声明。1long int ftell(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。返回值该函数返回位置标识符的当前值。如果发生错误，则返回 -1L，全局变量 errno 被设置为一个正值。rewind() 函数描述C 库函数 void rewind(FILE *stream) 设置文件位置为给定流 stream 的文件的开头。声明下面是 rewind() 函数的声明。1void rewind(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。fseek() 函数描述C 库函数 int fseek(FILE *stream, long int offset, int whence) 设置流 stream 的文件位置为给定的偏移 offset，参数 offset 意味着从给定的 whence 位置查找的字节数。声明下面是 fseek() 函数的声明。1int fseek(FILE *stream, long int offset, int whence)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。offset – 这是相对 whence 的偏移量，以字节为单位。whence – 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一：常量描述SEEK_SET文件的开头SEEK_CUR文件指针的当前位置SEEK_END文件的末尾返回值如果成功，则该函数返回零，否则返回非零值。可移植性问题想要编写可移植的代码，就需要考虑以下问题：对于以二进制模式打开的文件，fseek函数在某些操作系统可能不支持SEEK_END位置。一对于以文本模式打开的文件，fseek函数的whence参数只能取SEEK_SET才是有意义的，并且传递给offset参数的值要么是0，要么是上一次对同个文件调用fte11函数获得的返回值。标准流和错误处理文件流标准输入（stdin）标准输入（stdout）标准错误输出（stderr）重定向由于标准输出和标准错误输出通常都是直接打印到屏幕上，为了区分宅们，我们可以使用Linux shell的重定向功能：重定向标准输入使用 &lt;重定向标准输出使用 〉重定向标准错误输出使用 2〉错误处理错误指示器 - ferror（）描述C 库函数 int ferror(FILE *stream) 测试给定流 stream 的错误标识符。声明下面是 ferror() 函数的声明。1int ferror(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。返回值如果设置了与流关联的错误标识符，该函数返回一个非零值，否则返回一个零值。使用clearerr函数可以人为地清除文件末尾指示器和错误指示器的状态。ferror函数只能检测是否出错，但无法获取错误原因。不过，大多数系统函数在出现错误的时候会将错误原因记录在errno中。perror函数可以直观地打印出错误原因。描述C 库函数 void perror(const char *str) 把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 str，后跟一个冒号，然后是一个空格。声明下面是 perror() 函数的声明。1void perror(const char *str)参数str – 这是 C 字符串，包含了一个自定义消息，将显示在原本的错误消息之前。返回值该函数不返回任何值strerror（）函数直接返回错误码对应的错误信息。描述C 库函数 char *strerror(int errnum) 从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。strerror 生成的错误字符串取决于开发平台和编译器。声明下面是 strerror() 函数的声明。1char *strerror(int errnum)参数errnum – 错误号，通常是 errno。返回值该函数返回一个指向错误字符串的指针，该错误字符串描述了错误 errnum。12345678910111213141516171819202122232425//// Created by Luenci on 2019/10/20.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;int main(void)&#123; FILE *fp; if(fp = fopen("bucunzai.txt", "r") == NULL)&#123; printf("出错啦，原因就是：%d\n", errno); fprintf(stderr, "出错啦，原因就是：%s", strerror(errno) ); perror("出错啦，原因就是：");// fputs("打开文件失败！\n", stderr); exit(EXIT_FAILURE); &#125; fclose(fp); return 0;&#125;I/O 缓冲区标准I/O提供的三种类型的缓冲模式按块执行按块缓存也称为全缓存，即在填满缓冲区后才进行实际的设备读写操作；按行执行按行缓存是指在接收到换行符（’\n’）之前，数据都是先缓存在缓冲区的；不缓存也就是允许你直接读写设备上的数据。setvbuf()函数描述C 库函数 int setvbuf(FILE *stream, char *buffer, int mode, size_t size) 定义流 stream 应如何缓冲。声明下面是 setvbuf() 函数的声明。1int setvbuf(FILE *stream, char *buffer, int mode, size_t size)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流。buffer – 这是分配给用户的缓冲。如果设置为 NULL，该函数会自动分配一个指定大小的缓冲。mode – 这指定了文件缓冲的模式：模式描述_IOFBF全缓冲：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充。_IOLBF行缓冲：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符。_IONBF无缓冲：不使用缓冲。每个 I/O 操作都被即时写入。buffer 和 size 参数被忽略。size –这是缓冲的大小，以字节为单位。返回值如果成功，则该函数返回 0，否则返回非零值。fflush（）函数描述C 库函数 int fflush(FILE *stream) 刷新流 stream 的输出缓冲区。声明下面是 fflush() 函数的声明。1int fflush(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个缓冲流。返回值如果成功，该函数返回零值。如果发生错误，则返回 EOF，且设置错误标识符（即 feof）]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C结构体打包技艺]]></title>
    <url>%2F2019%2F10%2F19%2FC%E8%AF%AD%E8%A8%80%E6%89%93%E5%8C%85%E6%8A%80%E8%89%BA%2F</url>
    <content type="text"><![CDATA[失传的 C 结构体打包技艺（转）转自： https://fishc.com.cn/forum.php?mod=viewthread&amp;tid=83418&amp;extra=page%3D2%26filter%3Dtypeid%26typeid%3D571作者：Eric S. Raymond原文链接：http://www.catb.org/esr/structure-packing谁应阅读本文如果你在内存容量受限的嵌入式系统中写程序，或者编写操作系统内核代码，就有必要了解这项技术。如果数据集巨大，应用时常逼近内存极限，这项技术会有所帮助。倘若你非常非常关心如何最大限度地减少处理器缓存段（cache-line）未命中情况的发生，这项技术也有所裨益。2013 年底，我大量应用了一项 C 语言优化技术，这项技术是我早在二十余年前就已掌握的，但彼时之后，鲜有使用。通过精心调整结构成体员的顺序，可以在这种情况下大幅减少内存占用。其效果显著——在上述案例中，可以减少 40% 的内存空间。程序应用于更大的软件仓库，也不会因内存耗尽而崩溃。事出有因。计算机科学课程（正确地）引导人们远离微观优化，转而寻求更理想的算法。计算成本一路走低，令压榨内存的必要性变得越来越低。旧日里，黑客们通过在陌生的硬件架构中跌跌撞撞学习 —— 如今已不多见。首先需要了解的是，对于现代处理器，C 编译器在内存中放置基本 C 数据类型的方式受到约束，以令内存的访问速度更快。用行话来说，x86 和 ARM 上的基本 C 类型是“自对齐（self-aligned）”的。关于指针，无论 32 位（4 字节）还是 64 位（8 字节）也都是自对齐的。我提到“现代处理器”，是因为有些老平台强迫 C 程序违反对齐规则（例如，为 int 指针分配一个奇怪的地址并试图使用它），不仅令速度减慢，还会导致非法指令错误。例如 Sun SPARC 芯片就有这种问题。事实上，如果你下定决心，并恰当地在处理器中设置标志位（e18），在 x86 平台上，也能引发这种错误。你还可以通过 pragma 指令（通常为 ）强迫编译器不采用处理器惯用的对齐规则。但请别随意运用这种方式，因为它强制生成开销更大、速度更慢的代码。通常，采用我在下文介绍的方式，可以节省相同或相近的内存。#pragma pack我们来看一个关于变量在内存中分布的简单案例。思考形式如下的一系列变量声明，它们处在一个 C 模块的顶层。然而实际情况（在 x86、ARM 或其他采用自对齐类型的平台上）如下。存储 p 需要自对齐的 4 或 8 字节空间，这取决于机器字的大小。这是指针对齐 —— 极其严格。1234561. char *p; /* 4 or 8 bytes */2. char c; /* 1 byte */3. char pad[3]; /* 3 bytes */4. int x; /* 4 bytes */字符数组 pad[3] 意味着在这个结构体中，有 3 个字节的空间被浪费掉了。老派术语将其称之为“废液（slop）”。1231. char *p;2. char c;3. short x;在这个例子中，实际分布将会是：1231. char *p;2. char c;3. long x;我们将得到：1231. char c;2. char *p;3. int x;假如实际内存分布可以写成下面这样：首先，在此例中，N 将为 0，x 的地址紧随 p 之后，能确保是与指针对齐的，因为指针的对齐要求总比 int 严格。不过更有可能的情况是，c 将被映射为机器字的首字节。于是乎 M 将会用于填充，以使 p 指针对齐——32 位系统中为 3 字节，64 位系统中为 7 字节。倘若你希望这些变量占用的空间更少，那么可以交换 x 与 c 的次序。在讲述这部分内容前，我们先对标量数组做个说明。在具有自对齐类型的平台上，char、short、int、long 和指针数组都没有内部填充，每个成员都与下一个成员自动对齐。通常情况下，结构体实例以其最宽的标量成员为基准进行对齐。编译器之所以如此，是因为此乃确保所有成员自对齐，实现快速访问最简便的方法。假如你对此有疑惑，ANSI C 提供了一个 宏，可用于读取结构体成员位移。123451. struct foo1 &#123;2. char *p;3. char c;4. long x;5. &#125;;假定处在 64 位系统中，任何 struct fool 的实例都采用8字节对齐。不出所料，其内存分布将会像下面这样：12345678910111. struct foo2 &#123;2. char c; /* 1 byte */3. char pad[7]; /* 7 bytes */4. char *p; /* 8 bytes */5. long x; /* 8 bytes */6. &#125;;如果成员是互不关联的变量，c便可能从任意位置起始，pad的大小则不再固定。因为struct foo2的指针需要与其最宽的成员为基准对齐，这变得不再可能。现在 c 需要指针对齐，接下来填充的7个字节被锁定了。结构体尾填充的通用法则是：编译器将会对结构体进行尾填充，直至它的跨步地址。这条法则决定了 sizeof() 的返回值。12345671. struct foo3 &#123;2. char *p; /* 8 bytes */3. char c; /* 1 byte */4. &#125;;5. 6. struct foo3 singleton;7. struct foo3 quad[4];复制代码你以为 的值是 9，但实际是 16。它的跨步地址是 。于是，在 quad 数组中，每个成员都有 7 字节的尾填充，因为下个结构体的首个成员需要在 ８ 字节边界上对齐。内存分布就好像这个结构是这样声明的：12341. struct foo4 &#123;2. short s; /* 2 bytes */3. char c; /* 1 byte */4. &#125;;因为 s 只需要 2 字节对齐，跨步地址仅在 c 的 1 字节之后，整个 struct foo4 也只需要 1 字节的尾填充。形式如下：的返回值将为 4。12345671. struct foo5 &#123;2. short s;3. char c;4. int flip:1;5. int nybble:4;6. int septet:7;7. &#125;;关于位域需要了解的是，它们是由字（或字节）层面的掩码和移位指令实现的。从编译器的角度来看，struct foo5 中的位域就像 ２ 字节、16 位的字符数组，只用到了其中 12 位。为了使结构体的长度是其最宽成员长度 的整数倍，接下来进行了填充。1234567891. struct foo6 &#123;2. char c;3. struct foo5 &#123;4. ​ char *p;5. ​ short x;6. &#125; inner;7. &#125;;内层结构体成员 char *p 强迫外层结构体与内层结构体指针对齐一致。在 64 位系统中，实际的内存分布将类似这样：理解了编译器在结构体中间和尾部插入填充的原因与方式后，我们来看看如何榨出这些废液。此即结构体打包的技艺。消除废液最简单的方式，是按对齐值递减重新对结构体成员排序。即让所有指针对齐成员排在最前面，因为在 64 位系统中它们占用 8 字节；然后是 4 字节的 int；再然后是 2 字节的 short，最后是字符。123451. struct foo7 &#123;2. char c;3. struct foo7 *p;4. short x;5. &#125;;将隐含的废液写明，形式如下：12345671. struct foo8 &#123;2. struct foo8 *p;3. short x;4. char c;5. &#125;;考虑到自对齐，我们看到所有数据域之间都不需填充。因为有较严对齐要求（更长）成员的跨步地址对不太严对齐要求的（更短）成员来说，总是合法的对齐地址。重打包过的结构体只需要尾填充：注意，重新打包不能确保在所有情况下都能节省空间。将这项技术应用于更靠前 struct foo6 的那个例子，我们得到：123456789101. struct foo9 &#123;2. struct foo9_inner &#123;3. char *p; /* 8 bytes */4. int x; /* 4 bytes */5. char pad[4]; /* 4 bytes */6. &#125; inner;7. char c; /* 1 byte */8. char pad[7]; /* 7 bytes */9. &#125;;结果还是 24 字节，因为 c 无法作为内层结构体的尾填充。要想节省空间，你需要得新设计数据结构。棘手的标量案例#define请当心，重打包结构体时，枚举型变量通常是 int，这与编译器相关；但也可能是 short、long、甚至默认为 char。编译器可能会有 预处理指令或命令行选项指定枚举的尺寸。以上两种情况，最好用 来检查存储尺寸。尽管按尺寸重排是最简单的消除废液的方式，却不一定是正确的方式。还有两个问题需要考量：可读性与缓存局部性。笨拙地、机械地重排结构体可能有损可读性。倘若有可能，最好这样重排成员：将语义相关的数据放在一起，形成连贯的组。最理想的情况是，结构体的设计应与程序的设计相通。为保持可读性所做的工作（将相关和同时访问的数据放在临近位置）也会提高缓存段的局部性。这些都是需要明智地重排，并对数据的存取模式了然于心的原因。是的，某些时候，这种做法与前文将相关数据放入与缓存段长度相同块的做法矛盾。多线程的确是个难题。缓存段弹跳和其他多线程优化问题是很高级的话题，值得单独为它们写份指导。这里我所能做的，只是让你了解有这些问题存在。其他打包技术你可能会有一点儿存取时间的损失，但只要将工作集合压缩得足够小，那点损失可以靠避免缓存未命中补偿。这不仅减小了结构体的可见尺寸，还可以消除废液和/或创造额外的机会来进行重新排序。这种良性串连的效果不难被触发。clang 编译器有个 Wpadded 选项，可以生成有关对齐和填充的信息。读者可以下载一段程序源代码 ，验证上文有关标量和结构体尺寸的结论。理解这些规则的第二个层次是，知其何时及如何会被打破。在我学习它们的日子里（1980 年代早期），我们把不理解这些规则的人称为“所有机器都是 VAX 综合症”的牺牲品。记住，世上所有电脑并非都是 PC。]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>扩展知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言笔记（2）]]></title>
    <url>%2F2019%2F10%2F13%2FC%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[先举三反一，再举一反三，学习就应该是这样，先模仿，再改进，最后实现自己的创意！ –小甲鱼论坛递归调用函数本身设置递归结束条件12345678910111213141516171819202122232425262728293031323334353637383940//// Created by Luenci on 2019/10/11.//#include &lt;stdio.h&gt;void fun(void);long fact(int num);void fun(void)&#123; static int count = 10; printf("Hi\n"); if (count--)&#123; fun(); &#125;&#125;long fact(int num)&#123; long result; if(num &gt; 0)&#123; result = num * fact(num-1); &#125; else&#123; result = 1; &#125; return result;&#125;int main(void)&#123;// fun(); int num; long re; printf("请输入您要求阶乘的数："); scanf("%d", &amp;num); re = fact(num); printf("%d", re); return 0;&#125;汉罗塔123456789101112131415161718192021222324#include&lt;stdio.h&gt;void hanoi(int n, char x, char y, char z);void hanoi(int n, char x, char y, char z)&#123; if(n==1)&#123; printf("%c --&gt; %c \n", x,z); &#125; else&#123; // 将前n-1个圆盘借助z移动到y hanoi(n-1, x, z, y); printf("%c --&gt; %c \n", x,z); // 将前n-1个圆盘借助x移动到z hanoi(n-1, y, x, z); &#125;&#125;int main(void)&#123; int n; printf("请输入您的层数："); scanf("%d", &amp;n); hanoi(n, 'X', 'Y', 'Z'); return 0;&#125;快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//// Created by Luenci on 2019/10/11.//#include &lt;stdio.h&gt;void quick_sort(int array[], int left, int right);void quick_sort(int array[], int left, int right) &#123; int i = left, j = right; int temp; // 交换的中间变量 int pivot; // 基准点 pivot = array[(left + right) / 2]; while (i &lt;= j) &#123; // 从右往左找到大于等于基准点的元素 while (array[i] &lt; pivot) &#123; i++; &#125; // 从右到左找到小于等于基准点的元素 while (array[j] &gt; pivot) &#123; j--; &#125; // 如果 i &lt;= j,则互换 if (i &lt;= j) &#123; temp = array[i]; array[i] = array[j]; array[j] = temp; i++; j++; &#125; &#125; if (left &lt; j) &#123; quick_sort(array, left, j); &#125; if (i &lt; right) &#123; quick_sort(array, i, right); &#125;&#125;int main(void)&#123; int array[] = &#123;73, 108, 111, 101, 78, 109, 66, 48, 88, 135&#125;; int i, length; // 计算数组的长度 length = sizeof(array) / sizeof(array[0]); quick_sort(array, 0, length-1); printf("排序后的结果是："); for (i = 0; i &lt; length; i++)&#123; printf("%d ,", array[i]); &#125; putchar('\n'); return 0;&#125;动态内存管理malloc申请动态内存空间free释放动态内存空间calloc申请并初始化一系列内存空间realloc重新分配内训空间malloc函数函数原型void *malloc（size_t size）malloc函数向系统申请分配size个字节的内存空间，并返回一个指向这块空间的地址。如果函数调用成功，返回一个指向申请的内存空间的指针，由于返回类型是void 指针（void * ）， 所以它是可以被转换成任何类型的数据；如果函数调用失败，返回值是NULL。另外，如果size的参数设置为0，返回值也可能是NULL，但这并不意味着函数调用失败。free函数函数原型void free（void *ptr）free函数释放ptr参数指向的内存空间。该内存空间必须是有malloc，calloc或realloc函数申请的。否则，该函数将导致未定义行为。如果ptr参数是NULL，则不执行任何操作。注意：该函数并不会修改ptr参数的值，所以调用后仍然指向原来的地方（变为非法空间）。123456789101112131415161718192021222324252627//// Created by Luenci on 2019/10/12.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int *ptr; ptr = (int *)malloc(sizeof(int)); if(ptr == NULL)&#123; printf("分配内存失败"); exit(1); &#125; printf("请输入一个整数："); scanf("%d", ptr); printf("您输入的整数是:%d\n", *ptr); free(ptr); printf("您输入的整数是:%d\n", *ptr); return 0;&#125;内存泄漏隐式内存泄漏用完内存块没有及时使用free函数释放丢失内存块的地址初始化内存空间mem开头的函数被编入字符串标准库，函数的声明包含在string.h这个头文件中：memset – 使用一个常量字节填充空间memcpy – 拷贝内存空间memmove – 拷贝内存空间memcmp – 比较内存空间memchr – 在内存空间中搜索一个字符123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by Luenci on 2019/10/12.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define N 10int main(void)&#123; int *ptr = NULL; int i; ptr = (int *)malloc(N * sizeof(int)); if(ptr == NULL)&#123; exit(1); &#125; memset(ptr, 0, N * sizeof(int)); for (i= 0; i &lt; N; i++) &#123; printf("%d ", ptr[i]); &#125;// putchar("\n"); putchar('\n'); free(ptr); return 0;&#125;/*1、含义不同。用单引号引起的一个字符实际上代表一个整数，整数值对应于该字符在编译器采用的字符集中的序列值。而一般我们的编译器采用的都是ASCII字符集。因此's'的含义其实和十进制数115的含义是一致的。而用双引号引起的字符串，代表的是一个指向无名数组起始字符的指针。2、大小不同。用单引号引起的一个字符大小就是一个字节。而用双引号引起的字符串大小是字符的总大小+1，因为用双引号引起的字符串会在字符串末尾添加一个二进制为0的字符'\0'。*/calloc函数函数原型void *calloc(size_t nmemb, sizet_t size);calloc函数在内存中动态地申请nmemb个长度为size的连续内存空间（即申请的总空间尺寸为nmemb * size），这些内存空间全部被初始化为 0.calloc函数与malloc函数的一个重要区别是：calloc函数在申请完内存后，自动初始化该内存空间为零malloc函数不进行初始化操作，里面数据是随机的12345678// 两者等价// calloc() 分配内存空间并初始化int *ptr = （int *）calloc（8， sizeof（int））；//malloc()分配内存空间并用memset（）初始化int *ptr = (int *)malloc(8 * sizeof(int))；memset(prt, 0, 8 * sizeof(int));realloc函数如果ptr参数为NULL，那么调用该函数就相当于调用malloc（size）如果size参数为0，并且ptr参数不为NULL，那么调用该函数就相当于调用free（ptr）除非ptr参数为NULL，否则ptr的值必须由先前调用malloc，calloc或realloc函数返回。1234567891011121314151617181920212223242526272829303132//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int i, num; int count = 0; int *ptr = NULL;// 注意这里必须初始化为NULL do &#123; printf("请输入一个整数：（输入-1表示结束）"); scanf("%d", &amp;num); count++; ptr = (int *)realloc(ptr, count * sizeof(int)); if(ptr == NULL)&#123; exit(1); &#125; ptr[count-1] = num; &#125;while(num != -1); printf("输入的整数分别是："); for (int i = 0; i &lt;count ; i++) &#123; printf("%d ", ptr[i]); &#125; free(ptr); return 0;&#125;c语言的内存布局代码段代码段（Text segment）通常是指用来存放在程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读。在代码段中，也有可能包含一些只读的常熟变量，例如字符串常量等。BSS段BSS段（BSS segment/Uninitialized data segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BBS是英文Block Started Symbol的简称，这个区段中的数据在程序运行前将被自动初始化为数字0。堆堆是用于存放进程中被动态分配的内存段，它的大小并不固定，可动态扩展或缩小。当进程调用malloc等函数分配内存时，新分配的内存就被动态调价到对上；当利用free等函数释放内存时，被释放的内存从堆中被剔除。栈栈是函数执行的内存区域，通常和堆共享同一片区域。堆和栈的区别申请方式堆是由程序员手动申请栈时系统自动分配释放方式堆是由程序员手动释放栈由系统自动释放生存周期堆的生存周期由动态申请到程序员主动释放位置，不同函数之间均可自由访问。栈的生存周期由函数调用开始到函数返回时结束，函数之间的局部变量不能互相访问。高级宏定义本质就是替换内联函数在程序函数调用时，直接展开，而不是去查找调用。内联函数嵌入调用者代码中的操作是一种优化操作，因此只有进行优化编译时才会执行代码嵌入处理。若编译过程中没有使用优化选项‘-o’，那么内联函数的代码就不会真正地嵌入到函数调用者代码中，而是只作为普通函数调用来处理。内联函数虽然节省了函数调用的时间消耗，但由于每一个函数出现的地方都要进行替换，因此增加了代码的编译时间。另外，并不是所有的函数都能变成内联函数现在的编译器也很智能，就算你不写inline，它也会自动将一些函数优化成内联函数不带参数的宏定义为了和普通的变量进行区分，宏的名字通常我们约定是由大写字母组成宏定义只是简单地进行替换，并且由于预处理是在编译之前进行，而编译工作的任务之一就是语法检查，所以编译器不会对宏定义进行语法检查宏定义不是说明或语句，在末尾不必加分号宏定义的作用是从定义的位置开始到整个程序的结束可以用 #undef 来终止宏定义的作用域宏定义允许嵌套12345678910111213141516171819//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define PI 3.14int main()&#123; int r; float s; printf("请输入圆的半径："); scanf("%d", &amp;r);// #undef PI 终止宏定义 s = PI * r * r; printf("圆的面积是：%.2f\n", s);&#125;123456789101112131415//// Created by Luenci on 2019/10/13.//// 宏定义的嵌套#include &lt;stdio.h&gt;#define R 6371#define PI 3.14#define V PI * R * R * R * 4 / 3int main()&#123; printf("地球的体积是：%.2f\n", V);&#125;带参数的宏定义12345678910111213141516//// Created by Luenci on 2019/10/13.////带参数的宏定义#include &lt;stdio.h&gt;#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))int main()&#123; int x,y; printf("请输入两个数："); scanf("%d%d", &amp;x, &amp;y); printf("%d是最大的那个数！\n", MAX(x, y));&#125;‘#’ 和 ‘##’‘#’ 和 ‘##’是两个预处理运算符在带参数的宏定义中， #运算符后面应该跟着一个参数，预处理器会把这个参数转换为一个字符串。1234567891011121314//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define STR(s) # sint main(void)&#123; printf(STR(Hlloc %s num = %d), STR(Luenci), 520); return 0;&#125;out :Hlloc Luenci num = 520‘##’运算符被称为记号连接运算符，我们可以使用’##’运算符连接两个参数。123456789101112131415161718192021222324252627 //// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define TOGETHER(x,y) x ## yint main(void)&#123; printf("%d\n", TOGETHER(2,50)); return 0;&#125;//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define TOGETHER(x,y) x ## yint main(void)&#123; printf("%d\n", TOGETHER(2,50)); return 0;&#125;out:250可变参数之前学习了如何让函数支持可变参数，带参数的宏定义是使用可变参数的：1#define SHOWLIST（...） printf（#__VA_ARGS__）其中…表示可变参数，1#__VA_ARGS__在预处理中被实际的参数集所替代。123456789101112#include &lt;stdio.h&gt;#define SHOWLIST(...) printf(#__VA_ARGS__)int main(void)&#123; SHOWLIST(Luenci,5 20, 3.14 \n); return 0;&#125;out:Luenci,5 20, 3.1412345678910111213#include &lt;stdio.h&gt;#define SHOWLIST(format, ...) printf(#format, ##__VA_ARGS__)int main(void)&#123; SHOWLIST(num = %d\n,520); SHOWLIST(hello Luenci\n); return 0;&#125;out:num = 520hello Luenci]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言笔记（1）]]></title>
    <url>%2F2019%2F10%2F13%2FC%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[ps:先举三反一，再举一反三，学习就应该是这样，先模仿，再改进，最后实现自己的创意！ –小甲鱼论坛C语言中各种数据类型所占用的存储空间的大小int—32位 四个字节float —32位 四个字节char—8位 一个字节double—-64位 8个字节bool—-16位 2个字节long—-32位 四个字节整数类型下表列出了关于标准整数类型的存储大小和值范围的细节：类型存储大小值范围char1 字节-128 到 127 或 0 到 255unsigned char1 字节0 到 255signed char1 字节-128 到 127int2 或 4 字节-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647unsigned int2 或 4 字节0 到 65,535 或 0 到 4,294,967,295short2 字节-32,768 到 32,767unsigned short2 字节0 到 65,535long4 字节-2,147,483,648 到 2,147,483,647unsigned long4 字节0 到 4,294,967,295浮点类型下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：类型存储大小值范围精度float4 字节1.2E-38 到 3.4E+386 位小数double8 字节2.3E-308 到 1.7E+30815 位小数long double16 字节3.4E-4932 到 1.1E+493219 位小数void 类型void 类型指定没有可用的值。它通常用于以下三种情况下：序号类型与描述1函数返回为空 C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);2函数参数为空 C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);3指针指向 void 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。C语言运算符优先级优先级运算符名称或含义使用形式结合方向说明1[]数组下标数组名[常量表达式]左到右()圆括号（表达式）/函数名(形参表).成员选择（对象）对象.成员名-&gt;成员选择（指针）对象指针-&gt;成员名2-负号运算符-表达式右到左单目运算符(类型)强制类型转换(数据类型)表达式++自增运算符++变量名/变量名++单目运算符–自减运算符–变量名/变量名–单目运算符*取值运算符*指针变量单目运算符&amp;取地址运算符&amp;变量名单目运算符!逻辑非运算符!表达式单目运算符~按位取反运算符~表达式单目运算符sizeof长度运算符sizeof(表达式)3/除表达式/表达式左到右双目运算符*乘表达式*表达式双目运算符%余数（取模）整型表达式/整型表达式双目运算符4+加表达式+表达式左到右双目运算符-减表达式-表达式双目运算符5&lt;&lt;左移变量&lt;&lt;表达式左到右双目运算符&gt;&gt;右移变量&gt;&gt;表达式双目运算符6&gt;大于表达式&gt;表达式左到右双目运算符&gt;=大于等于表达式&gt;=表达式双目运算符&lt;小于表达式&lt;表达式双目运算符&lt;=小于等于表达式&lt;=表达式双目运算符7==等于表达式==表达式左到右双目运算符!=不等于表达式!= 表达式双目运算符8&amp;按位与表达式&amp;表达式左到右双目运算符9^按位异或表达式^表达式左到右双目运算符10|按位或表达式|表达式左到右双目运算符11&amp;&amp;逻辑与表达式&amp;&amp;表达式左到右双目运算符12||逻辑或表达式||表达式左到右双目运算符13?:条件运算符表达式1? 表达式2: 表达式3右到左三目运算符14=赋值运算符变量=表达式右到左/=除后赋值变量/=表达式*=乘后赋值变量*=表达式%=取模后赋值变量%=表达式+=加后赋值变量+=表达式-=减后赋值变量-=表达式&lt;&lt;=左移后赋值变量&lt;&lt;=表达式&gt;&gt;=右移后赋值变量&gt;&gt;=表达式&amp;=按位与后赋值变量&amp;=表达式^=按位异或后赋值变量^=表达式|=按位或后赋值变量|=表达式15,逗号运算符表达式,表达式,…左到右从左向右顺序运算注：同一优先级的运算符，运算次序由结合方向所决定。break和continue语句区别break语句结束当前循环continue语句跳过本次循环二维下标直接索引和指针间接索引的相互转化1234*（array + i） = array[i]*(*(array + i) + j) = array[i][j]*(*(*(array + i) + j) + K) = array[i][j][k] ...二维数组和数组指针的关系12345678910111213141516171819202122//// Created by Luenci on 2019/10/5.//#include &lt;stdio.h&gt;int main()&#123; int array[2][3] = &#123;&#123;0, 1, 2&#125;, &#123;4, 5, 6&#125;&#125;; int (*p)[3] = array; printf("**(p+1): %d\n", **(p+1)); printf("**(array+1): %d\n", **(array+1)); printf("array[1][0]: %d\n", array[1][0]); printf("*(*(p+1)+2): %d\n", *(*(p+1)+2)); printf("*(*(array+1)+2): %d\n", *(*(array+1)+2)); printf("array[1][2]: %d\n", array[1][2]); return 0;&#125;void指针和NULL指针Void指针void指针我们把它称之为通用指针，就是可以指向任意类型的数据。也就是说，任何类型的指针都可以赋值给void指针。123456789101112131415161718192021//// Created by Luenci on 2019/10/5.//#include &lt;stdio.h&gt;int main()&#123; int num = 1024; int *pi = &amp;num; char *ps = "Luenci"; void *pv; pv = pi; printf("pi:%p, pv:%p\n", pi,pv); printf("*pv:%d\n", *(int *)pv); pv = (char *)ps; printf("ps:%p, pv:%p\n", ps, pv); printf("*pv:%s\n", (char *)pv); return 0;&#125;NULL指针当你还不清楚要将指针初始值为什么地址时，请先将它初始化为NULL；在对指针进行解引用时，先检查该指针是否为NULL。这种策略可以为今后编写大型程序 节省大量的 调试时间。1#define NULL ((void *)0)1234567891011121314//// Created by Luenci on 2019/10/5.//#include &lt;stdio.h&gt;int null_pointer()&#123; int *p1; int *p2 = NULL; printf("%d\n", *p1); printf("%d\n", *p2); return 0;&#125;指向指针的指针123456789101112131415161718192021int main()&#123; int num = 520; int *p = &amp;num; int **pp = &amp;p; printf("num: %d\n", num); printf("*p: %d\n", *p); printf("**PP: %d\n", **pp); printf("&amp;p: %p, pp:%p\n", &amp;p, pp); printf("&amp;num:%p, p:%p, *pp:%p\n", &amp;num,p,*pp); return 0;&#125; out: num: 520 *p: 520 **PP: 520 &amp;p: 0061FF14, pp:0061FF14 &amp;num:0061FF18, p:0061FF18, *pp:0061FF18指针数组和指向指针的指针123456789101112131415161718192021222324252627282930313233343536373839int pointer_array()&#123; char *cBooks[] = &#123; &quot;&lt;c程序设计语言&gt;&quot;, &quot;&lt;c专家编程&gt;&quot;, &quot;&lt;c和指针&gt;&quot;, &quot;&lt;c prime plus&gt;&quot;, &quot;&lt;C study&gt;&quot; &#125;; char **byLuenci; char **byGood[4]; byLuenci = &amp;cBooks[4]; byGood[0] = &amp;cBooks[0]; byGood[1] = &amp;cBooks[1]; byGood[2] = &amp;cBooks[2]; byGood[3] = &amp;cBooks[3]; printf(&quot;Luenci拥有的书: %s\n&quot;, *byLuenci); printf(&quot;Luenci喜欢的图书有：\n&quot;); int i; for (int i = 0; i &lt; 4; ++i) &#123; printf(&quot;%s\n&quot;,*byGood[i]); &#125; return 0;&#125;out: Luenci拥有的书: &lt;C study&gt;Luenci喜欢的图书有：&lt;c程序设计语言&gt;&lt;c专家编程&gt;&lt;c和指针&gt;&lt;c prime plus&gt;常量定义1234567891011520，‘a’, 3.14#define price 520#define A 'a'#define PI 3.14 // 使用const关键字修饰 const int price = 520;const char A = 'a';const float pi = 3.14;指向常量的指针指针可以修改为指向不同的常量指针可以修改为指向不同的变量可以通过解引用来读取指针指向的数据不可以通过解引用修改指针指向的数据123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int num =520; const int cnum = 880; const int *pc = &amp;cnum; printf("cnum:%d, &amp;cum:%p \n", cnum, &amp;cnum); printf("*pc:%d, pc:%p\n", *pc, pc); pc = &amp;num; printf("num:%d, &amp;num:%p \n", num, &amp;num); printf("*pc:%d, pc:%p\n", *pc, pc); return 0;&#125;函数结构1234类型名 函数名（参数列表）&#123; 函数体&#125;函数的声明所谓的声明（Declaration），就是告诉编译器我要是用这个函数，你现在没有找到它的定义不要紧，请不要报错，稍后我将会把它补上。函数的参数和返回值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;void print_c();int sum(int n);int max(int x, int y);int max(int x, int y)&#123; // a？b:c 当a的值为真时，返回b的值；否则返回c的值 return x &gt; y ? x:y;&#125;int sum(int n)&#123; int result = 0; do &#123; result += n; &#125;while (n-- &gt; 0); return result;&#125;void print_c()&#123; printf(" ###### \n"); printf("## ##\n"); printf("## \n"); printf("## \n"); printf("## ##\n"); printf(" ###### \n");&#125;int main()&#123; print_c(); int n,x,y;// printf("请输入n的值："); printf("请输入x,y的值：");// scanf("%d", &amp;n); scanf("%d%d", &amp;x, &amp;y);// printf("1+2+3+...+(n-1)+n的结果是：%d\n",sum(n)); printf("x,y中最大值的值为：%d\n", max(x,y)); return 0;&#125;形参和实参用于数据传输，形参就相当与一个占位符，只在函数内部有效。传值和传址1234567891011121314151617181920212223242526//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;void swap(int *x, int *y);void swap(int *x, int *y)&#123; int *temp; printf("In swap 互换前：x %d, y %d\n", *x,*y); temp = *x; *x = *y; *y = temp; printf("In swap 互换后：x %d, y %d\n", *x,*y);&#125;int main()&#123; int x = 3, y = 5; printf("In main 互换前：x %d, y %d\n", x,y); swap(&amp;x,&amp;y); printf("In main 互换后：x %d, y %d\n", x,y); return 0;&#125;传数组实际上传过去的是数组的地址123456789101112131415void get_array(int b[10])&#123; printf("sizeof b: %d\n", sizeof(b));&#125;int main()&#123; int a[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; printf("sizeof a:%d\n", sizeof(a)); get_array(a); out:sizeof a:40sizeof b: 4可变参数引入 头文件#include&lt;stdarg.h&gt;123456789101112131415161718192021222324252627282930313233343536373839//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;int sum(int n, ...);int sum(int n, ...)&#123; int i; int sum = 0; va_list vap; va_start(vap, n); for(i = 0; i &lt; n; i++)&#123; sum += va_arg(vap, int); &#125; va_end(vap); return sum;&#125;int main()&#123; int result,result2,result3; result = sum(3,1,2,-3); printf("result:%d\n", result); result2 = sum(4,2,2,4,2); printf("result2:%d\n", result2); result3 = sum(4,2,8,4,-2); printf("result3:%d\n", result3); return 0;&#125;指针函数使用指针变量作为函数的返回值，就是指针函数123456789101112131415161718192021222324252627282930313233343536373839//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;char *getchartchar();char *getchart(char c)&#123; switch (c) &#123; case &apos;A&apos;: return &quot;Apple&quot;; case &apos;B&apos;: return &quot;Banana&quot;; case &apos;C&apos;: return &quot;Cat&quot;; case &apos;D&apos;: return &quot;Dog&quot;; default: return &quot;None&quot;; &#125;&#125;int main()&#123; char input; printf(&quot;请输入一个字母：&quot;); scanf(&quot;%c&quot;, &amp;input); printf(&quot;%s\n&quot;, getchart(input)); return 0;&#125;in:Aout:ApplePS:不要返回局部变量的指针函数指针指针函数 - - &gt; int *p();函数指针 - - &gt; int (*p)();函数指针作为参数12345678910111213141516171819202122232425262728//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;int add(int, int);int sub(int, int);int clac(int (*fp)(int, int), int, int);int add(int num1, int num2)&#123; return num1 + num2;&#125;int sub(int num1, int num2)&#123; return num1 - num2;&#125;int clac(int (*fp)(int, int), int num1, int num2)&#123; return (*fp)(num1, num2);&#125;int main()&#123; printf("3 + 5 = %d\n", clac(add, 3,5)); printf("3 - 5 = %d\n", clac(sub, 3,5)); return 0;&#125;函数指针作为返回值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//// Created by Luenci on 2019/10/10.//#include &lt;stdio.h&gt;int add(int, int);int sub(int, int);int calc(int (*)(int, int), int, int);int (*slect(char))(int,int);int add(int num1, int num2)&#123; return num1 + num2;&#125;int sub(int num1, int num2)&#123; return num1 - num2;&#125;int calc(int (*fp)(int, int),int num1, int num2)&#123; return (*fp)(num1, num2);&#125;int (*slect(char op))(int, int)&#123; switch(op)&#123; case '+': return add; case '-': return sub; &#125;&#125;int main()&#123; int num1, num2; char op; int (*fp)(int, int); printf("请输入一个式子 (如 1+3) :"); scanf("%d%c%d", &amp;num1, &amp;op, &amp;num2); fp = slect(op); printf("%d %c %d = %d\n", num1, op, num2, calc(fp, num1, num2)); return 0;&#125;局部变量和全局变量局部变量不同函数的变量无法相互访问全局变量如果不对全局变量进行初始化，那么它会自动初始化为0.如果函数在内部存在一个与全局变量同名的局部变量，编译器不会报错，而是在函数中屏蔽全局变量。exsten关键字告诉编译器我等下会定义变量，不要报错不要大量的使用全局变量使用全局变量会使你的程序占用更多的内存，因为全局变量从定义时候开始，知道程序退出才释放。污染命名空间提高了程序耦合性作用域和链接属性当变量被定义在不同的位置时，它的作用域的范围是不一样的，这个作用范围就是我们所说的作用域C语言编译器可以确认四种不同类型的作用域：代码块的作用域文件作用域原型作用域函数作用域代码块作用域（Block scope）在代码块中定义的变量，具有代码块作用域。作用范围是从变量定义的位置开始，到标志代码块结束的大括号（}）处。文件作用域（file scope）任何在代码块之外声明的标识符都具有文件作用域，作用域的范围是从他们的声明位置开始，到文件的结尾处都是可以访问的。原型作用域（prototype scope）原型作用域只适用于那些在函数原型中声明的参数名。函数作用域（function scope）函数作用域只适合于goto语句的标签，作用将goto语句得标签限制在同一个函数内部，以防止出现重名的标签。定义和声明当一个变量被定义的时候，编译器为变量申请内存空间并填充值当一个变量被声明的时候，编译器就知道该变量被定义在其他地方声明是通知编译器该变量名及相关的类型已经存在，不需要再为此申请内存空间。局部变量即是定义又是声明定义只能来一次，否则就叫做重复定义某个同名的变量；而声明可以由你很多次。链接属性external（外部的）多个文件中声明的同名标识符表示一个实体internal（内部的）单个文件中声明的同名标识符表示同一个实体none（无）声明的同名标识符被当做独立的不同实体只有具备文件作用域的标识符才能拥有external或internal的链接属性，其他作用域的标识符都是none属性。默认情况下，具备文件的作用域的标识符拥有external属性。也就是说该标识符允许跨文件访问。对于external属性的标识符，无论在不同文件中声明多少次，表示的都是一个实体。使用static关键字可以使得原先拥有的external属性的标识符变为internal属性。这里有两点需要注意：使用static关键字修改链接属性，只对具有文件作用域的标识符生效（对于拥有其他作用域的标志符是另一种功能）链接属性只能修改一次，也就是说一旦将标识符的链接属性改为internal，就无法变回external。生存期和存储类型C语言变量拥有两种生存周期静态存储器自动存储器具有文件作用域的变量属于静态存储器，函数也属于静态存储器。属于静态存储器的变量在程序执行期间将一直占据存储空间，直到程序关闭才释放具有代码块作用域的变量一般情况下属于自动存储器。属于自动存储期的变量在代码块结束时将自动释放。存储类型存储类型其实是指存储变量值的内存类型，C语言提供了五种类型。autoregisterstaticexterntypedef]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django之编写URL]]></title>
    <url>%2F2019%2F10%2F07%2Fdjango%E4%B9%8Burl%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[编写URL编写规则​ 为了使其规范性，在每个新创建的App中设置独立的静态资源和模板文件夹并添加一个空白的.py文件，命为urls.py。如下是创建app中的文件结构：1234567891011121314frist/ migrations/ # 数据库前后是否有变化，生成出迁移文件 static/ # 创建App后存放App中的静态资源文件，自己手动添加 templates/ # 创建App后存放App中的模板文件，自己手动添加 __init__.py admin.py apps.py models.py tests.py urls.py # 创建App后由系统总路由映射到App的路由文件，自己手动添加 view.py系统总路由和app的路由分发配置12345678# 根目录的urls.pyfrom django.contrib import adminfrom django.urls import path,adminurlpatterns = [ path('admin/', admin.site.urls), path('',include('frist.urls')) # 引入app中的urls.py]代码详解:from django.contrib import admin:导入Admin功能模块.from django.urls import path,admin:导入URL编写模块.urlpatterns:整个项目的URL集合,每个元素代表一条URL信息.path(&#39;admin/&#39;, admin.site.urls):设定Admin的URL.&#39;admin/&#39;代表127.0.0.1/admin地址信息,admin后面的斜杠是路径分隔符;admin.site.urls是URL的处理函数,也称为视图函数.path(&#39;&#39;,include(&#39;frist.urls&#39;)):URL为空,代表网站的域名,即127.0.0.1,通常是网站的首页;include将该URL分发给app的urls.py处理.1234567# app下的urls.pyfrom django.urls import pathfrom . import viewsurlpatterns = [ path('',views.index) # 调用和url匹配的视图函数]当根目录的URL分发给app中的URL处理后,下一步就是根据所匹配的URL进行视图的调用.在Views中编写相应的视图函数。如下：12345# index的views.pyfrom django.http import HttpResponse# creat you views here.def index(request): return HttpResponse("hello world")视图函数的参数必须设置为request，该参数代表当前用户的请求对象，该对象包含用户名，请求内容和请求方式等信息，执行完成后必须使用return将处理结果返回。带变量的URL​ 在日常开发中，有时候一个URL可以代表多个不同的页面，如编写带有日期的URL，若根据前面的编写方式，按一年计算，则需要开发者编写365个不同的URL才能实现。这种做法是不可取的，因此，Django在编写URL时，可以对URL设置变量值，使URL具有多样性。​ URL的变量类型有字符类型，整型，slug和uuid，常用的是字符类型和整型。说明如下：字符类型：匹配任何非空字符串，但不含斜杠。如果没有指定类型，默认使用该类型。整形：匹配0和正整数slug：可理解为注释，后缀或附属等概念，常作为URL的解释性字符。可匹配任何ASCII字符以及连接符和下画线，能使URL更加清晰易懂。比如网页的标题是“13岁的孩子”，其URL地址可以设置为“13-sui-de-hai-zi“。uuid：匹配一个uuid格式的对象。为了防止冲突，规定必须使用破折号并且所有字母必须小写，例如0201203-3213-31e-321c34d435（未待完续）]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django简介]]></title>
    <url>%2F2019%2F10%2F07%2Fdjango%E9%85%8D%E7%BD%AE%E5%88%9D%E5%90%AF%2F</url>
    <content type="text"><![CDATA[Django简介背景2003诞生 它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的MVT（框架）Models 模型 数据库Views 视图 放和拿Template 模板 前端From 表单 django 会根据你后台数据库字段及表单层的设计对应的给你创建HTML关于表单的代码Django优点对象关系映射（Object Relational Mapping ORM）：通过定义映射类来构建数据模型，将模型与关系型数据库连接起来，使用ORM框架内置的数据库接口可实现复杂的数据操作。（简单来说就是把数据库的语句换成了python可识别的语言）URL设计：开发者可以设计任意的URL（网站地址）， 而且支持使用正则表达式设计。模板系统：提供可扩展的模板语言，模板之间具有可继承性。表单处理：可以生成各种表单模型，而且表单具有有效性检验功能。Cache系统：完善的缓存系统，可支持多种缓存方式用户管理系统：提供用户认证，权限设置和用户组功能，功能扩展性强。国际化：内置国际化系统，方便开发出多语言的网站。admin管理系统：内置admin管理系统，系统的扩展性强。Django项目目录1234567891011121314用django-admin startproject demo 创建一个demo项目文件结构如下：demo/ # 最外层 这个是整个项目的容器文件夹，可以随意改名字 demo/ # 内层的demo 是这个项目中关于配置文件的一个管理文件夹，这个不允许改名字 __init__.py #初始化文件，代表这个文件夹是一个包，一个模块，demo文件夹就是一个模块了 settings.py # 这个是整个项目的配置文件，配置中间，配置邮件等 urls.py # django项目的总路由配置文件。网站的地址信息 wsgi.py # 全称为Python Web Server Gateway Interface，即为python服务器网关接口， 是python应用与Web服务器之间的接口，用于Django项目在服务器上的部署和上线，一 般不需要修改 manage.py # 命令行工具，允许以多种方式与项目交互。 可输入 python manage.py help 查看 该工具的具体用法Django的创建的App目录使用命令创建app： python manage.py startapp frist创建了App必须把App名称添加到INSTALL_APPS里面。1234567891011121314frist/ migrations/ # 数据库前后是否有变化，生成出迁移文件 static/ # 创建App后存放App中的静态资源文件，自己手动添加 templates/ # 创建App后存放App中的模板文件，自己手动添加 __init__.py admin.py apps.py models.py tests.py urls.py # 创建App后由系统总路由映射到App的路由文件，自己手动添加 view.pyDjango（settings）配置全览123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122"""Django settings for mysite project.Generated by 'django-admin startproject' using Django 2.1.2.For more information on this file, seehttps://docs.djangoproject.com/en/2.1/topics/settings/For the full list of settings and their values, seehttps://docs.djangoproject.com/en/2.1/ref/settings/"""import os# 项目路径# Build paths inside the project like this: os.path.join(BASE_DIR, ...)BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))# Quick-start development settings - unsuitable for production# See https://docs.djangoproject.com/en/2.1/howto/deployment/checklist/# 密匙配置# SECURITY WARNING: keep the secret key used in production secret!SECRET_KEY = '#g$qgqkee8csvp67l$(8ugkx%+i_9k%mbykw-%9zpbnyn!bb!='# 调试模式# SECURITY WARNING: don't run with debug turned on in production!DEBUG = True# 域名访问权限ALLOWED_HOSTS = ['*']# App列表# Application definitionINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'myblog', 'article',]MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]ROOT_URLCONF = 'mysite.urls'TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [BASE_DIR, 'templates'], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', # 自定义模版全局变量(默认变量) 'article.views.global_settings', ], &#125;, &#125;,]WSGI_APPLICATION = 'mysite.wsgi.application'# Database# https://docs.djangoproject.com/en/2.1/ref/settings/#databasesDATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125;# Password validation# https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validatorsAUTH_PASSWORD_VALIDATORS = [ &#123; 'NAME':'django.contrib.auth.password_validation.UserAttributeSimilarityValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator', &#125;,]# Internationalization# https://docs.djangoproject.com/en/2.1/topics/i18n/LANGUAGE_CODE = 'zh-Hans'TIME_ZONE = 'Asia/Shanghai'USE_I18N = TrueUSE_L10N = TrueUSE_TZ = True# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/2.1/howto/static-files/STATIC_URL = '/static/'STATIC_ROOT = os.path.join(BASE_DIR, "static/")项目路径 BASE_DIR：主要通过os模块读取当前项目在系统的具体路径，该代码在创建项目时自动生成，一般情况无需修改密匙配置SECRET_KEY：是一个随机值，在项目创建的时候自动生成，一般情况下无需修改。主要用于重要的数据 加密处理，提高系统的安全性，避免遭到攻击者的恶意破坏。密匙主要用于用户密码，CSRF机制和会话Session等数据加密。12345* 用户密码：Django内置一套用户管理系统，该系统具有用户认证和存储用户信息等功能，在创建用户的时候，将用户的密码通过密匙进行加密处理，保证用户的安全性。* CSRF机制：该机制主要用于表单提交，防止窃取网站的用户信息来制造恶意请求* 会话Session：Session的信息存放在Cookies，以一串随机的字符串表示，用于标识当前访问网站的用户身份，记录相关用户信息。调试模式DEBUG：该值为布尔类型。如果在开发调试阶段应设置为True，在开发调试过程中会自动检测代码是否 发生更改，根据检测结果执行是否刷新重启系统。如果项目部署上线，将其改为False，否则会泄露系统的相关信息。域名访问权限ALLOWED_HOSTS:设置可访问的域名，默认值为空。当DEBUG为True并且ALLOWED_HOSTS为空时，项目只允许以localhost或127.0.0.1在浏览器上访问启动。当DEBUG为False时，ALLOWED_HOSTS为必填项，否则程序无法启动，如果想允许所有域名访问，可设置ALLOW_HOSTS=[‘*’]。App列表INSTALLED_APPS：告诉Django有哪些App。在创建项目时已有admin，auth，和session等配置等信息，这些都是Django内置的应用功能，各个功能说明如下。123456* admin:内置的后台管理系统。* auth：内置的用户认证系统。* contenttypes：记录项目中所有的model元数据（Django的ORM框架）。* session：Session会话功能，用于标识当前访问网站的 用户身份，记录相关用户信息。* message：消息提示功能。* staticfiles：查找静态资源路径。静态资源（static）123456789101112# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/2.1/howto/static-files/STATIC_URL = '/static/' STATIC_ROOT = os.path.join(BASE_DIR, "static/")# 设置根目录的静态资源文件夹staticSTATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'),# 设置App的静态资源文件夹 os.path.join(BASE_DIR, '/static')， ]​​ CSS也称层叠样式表（Cascading Style Sheets），是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。​ JavaScript是一种直译式脚本语言，也是一种动态类型，弱类型，基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。STATIC_URL是必须配置的属性而且属性值不能为空。如果没有配置STATICFILES_DIRS，则STATIC_URL只能识别App里的static静态资源文件夹。STATICFILES_DIRS是可选配置属性，属性值为列表或元组格式，每个列表（元组）元素代表一个静态资源文件夹，这些文件夹可行命名。在浏览器上访问项目的静态资源时，无论项目的静态资源文件夹是如何命名的，在浏览器上，静态资源的上级目录必须为static，而static而STATIC_URL的属性值,因为STATIC_URL也是静态资源的起始URL。​ 除此之外，静态资源配置还有STATIC_ROOT，其作用是方便在服务器上部署项目，实现服务器和项目之间的映射。STATIC_URL和STATICFILES_DIRS区别STATIC_URL是必须配置的属性而且属性的值不能为空。如果没有配置STATICFILES_DIRS,则STATIC_URL只能识别App里面的static静态资源文件夹。STATICFILES_DIRS是可选配置属性，属性值为列表或元组格式，每个列表（元组）元素代表一个静态资源文件夹，这些文件夹可自行命名。在浏览器上访问项目的静态资源时，无论项目的静态资源文件夹是如何命名的，在浏览器上，静态资源的上级目录必须为static，而static是STATIC_URL的属性值，因为STATIC_URL也是静态资源的起始URL。模板路径（template）在web开发中，模板是一种较为特殊的HTML文档。这个HTML文档嵌入了一些能够让Python识别的变量和指令，然后程序解析这些变量和指令，生成完整的HTML网页并返回给用户浏览。模板是Django里面的MTV框架模式的T部分，配置模板路径是Django在解析模板时，如何找到模板所在的位置。创建项目时，Django以有初始的模板配置信息。如下：123456789101112131415161718TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [BASE_DIR, 'templates'], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', # 自定义模版全局变量(默认变量) 'article.views.global_settings', ], &#125;, &#125;,]模板信息是以列表格式呈现的，每个元素具有不同的含义，说明如下：BACKEND：定义模板引擎，用于识别模板里面的变量和指令。内置的模板引擎有DjangoTemplate和jinjia2.Jinjia2，每个模板引擎都有自己的变量和指令语法。DIRS：设置模板所在的路径，告诉Django在那个地方查找模板的位置，默认为空列表APP_DIRS:是否在App里面查找模板文件OPTIONS：用于填充在RequestContext中上下文调用函数，一般情况下不做任何修改。数据库设置（Databases）在settings文件下 有一个DATABASES属性123456789101112131415DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', # 数据库引擎 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), # 本地sqllite3数据库位置 'USER': # 用户名 'PASSWORD': # 数据库密码 'HOST': # 数据库主机地址 &#125; &#125;# 默认的django使用sqllite3作为数据库 # django提供四种 ENGINE 数据库引擎 # django.db.backends.mysql # django.db.backends.oracle # django.db.backends.splite3# 如果你使用的是 PostgreSQL 或者Mysql的话，已经是先创建了数据库，但是默认的SQLlite不需要sqlite3 轻量级数据库（数据存放在文件里面）在Django连接MYSQL数据库时候如果提示django.db.utils.OperationalError的错误信息，这是因为MYSQL8.0版本的密码加密方式发生了变化，8.0版本的用户密码采用的是cha2加密方法。解决方法，把SQL语句将8.0版本加密方法改回原来的加密方式。123# newpassword 是我们设置的用户密码ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'newpassword';FLUSH PRIVILEGES;中间件（Middlewere）中间件（Middleware）是处理Django的request和response对象的钩子。当用户在网站中进行单击某个按钮等操作时，这个动作是用户向网站发送请求（request）；而网页会根据用户的操作返回相关的网页内容，这个过程称为响应处理（response）。从请求到响应的过程中，当Django接收到用户的请求时，Django首先经过中间件处理请求消息，执行相关的处理，然后将处理结果返回给用户，中间件的执行流程如图：如上图，中间件的作用主要是处理用户的请求信息。开发者也可以根据自己的开发需求自定义中间件，只要将自定义的中间件添加到配置属性MIDDLEWARE中即可激活。一般情况下，Django默认的中间件配置均可满足大部分的开发需求。1234567'django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware','django.middleware.csrf.CsrfViewMiddleware','django.contrib.auth.middleware.AuthenticationMiddleware','django.contrib.messages.middleware.MessageMiddleware','django.middleware.clickjacking.XFrameOptionsMiddleware',配置属性MIDDLEWARE的数据格式为列表类型，每个中间件的设置顺序是固定的，如果随意变更中间件很容易导致程序异常，每个中间件的说明如下：SecurityMiddleware：内置的安全机制，保护用户与网站的通信安全。SessionMiddleware：会话Session。LocaleModdleware：支持中文语言。CommonMiddleware：处理请求信息，规范化请求内容。CsrViewMiddleware：开启CSRF防护功能。AuthenticationMiddleware：开启内置的用户认证系统。MessageMiddleware：开启内置的信息提示功能。XFrameOptionsMiddleware：防止恶意程序点击劫持。修改时区及语言LANGUAGE_CODE = ‘en-us’ #语言TIME_ZONE = ‘UTC’ #时区12LANGUAGE_CODE = 'zh-Hans'TIME_ZONE = 'Asia/Shanghai'开启测试服务器用来展示你创建出来的空项目/home/Publc_Class/5-17-django框架/python3 manage.py runserver 0.0.0.0:9090开启了一个测试服务器runserver 可以让你在浏览器看到效果，但是这个是测试服务器，压力不过百创建默认数据库因为django自带的admin界面，首先需要数据库来支持我们来先创建出一个数据库1234makemigrations 数据库前后是否有变化，生成出迁移文件migrate 根据迁移文件 来对应的执行SQL语句 python3 manage.py makemigrationspython3 manage.py migrate如果数据库创建完成，那么目录结构下和manage.py同级的就会有一个db.splite3文件有了这个数据库，就可以创建超级用户来管理admin界面啦！为admin界面创建超级用户数据库有了，要创建超级用户python3 manage.py createsuperuser12345Username (leave blank to use 'root'): rootEmail address: 2573799357@qq.com Password: Password (again): Superuser created successfully.]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高德无人机科技研发岗（测试工程师）面试总结]]></title>
    <url>%2F2019%2F09%2F30%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[高德无人机科技研发岗（测试工程师）面试总结技术面1.在51job上面投递的简历，本科院校“双非”，有一些项目经验。2.面试的时候是技术工程师来一面。问了我关于C++问题（本人主攻Python），有点把我问住了，questionC11标准里，关于智能指针有什么新特性？回答链接：https://www.jianshu.com/p/4f58ebc43b824.我介绍了我的项目经验和实践能力。3.因为可能急需招人，面试官看了我的项目经验等，还是给了我机会。面人资问我期望薪资多少？我说4k然后又问我最低能接受的薪资是多少？我说3.3K现在才明白这是个坑，真正谈的时候是按照你的最低接受薪资来谈的，千万不要说的很低很低。不然后面你就算再谈，也加不了多少钱。这个是我面试受益的第一点。还有就是，不要觉得自己的工作廉价，不敢往高的价格谈（我之前以为自己面试问题都没回答对，而且对C++不熟）不敢向高的要，后来觉得面试首先自己要看得起自己。不管怎么样，薪资不能太低。总结​ 这次短暂的面试让我受益了很多，从应届生小白里面跳出来。希望自己接受这个教训，不要急于求成。面试也应该诚实，懂就懂，不懂就不懂，最忌讳不懂装懂（自己心里要有数）。选择岗位应该长远考虑，不应该只看重面前的小利益。各方面应该考虑全面，多和家里的长辈等有经验的人沟通。]]></content>
      <categories>
        <category>面试经历</category>
      </categories>
      <tags>
        <tag>面试总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 语言中 void* 详解及应用]]></title>
    <url>%2F2019%2F09%2F30%2FC%20%E8%AF%AD%E8%A8%80%E4%B8%AD%20void%20%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[C 语言中 void* 详解及应用void 在英文中作为名词的解释为 “空虚、空间、空隙”，而在 C 语言中，void 被翻译为“无类型”，相应的void * 为“无类型指针”。void 似乎只有”注释”和限制程序的作用，当然，这里的”注释”不是为我们人提供注释，而是为编译器提供一种所谓的注释。void 的作用1.对函数返回的限定，这种情况我们比较常见。2.对函数参数的限定，这种情况也是比较常见的。一般我们常见的就是这两种情况：当函数不需要返回值值时，必须使用void限定，这就是我们所说的第一种情况。例如：void func（int a,char *b）。当函数不允许接受参数时，必须使用void限定，这就是我们所说的第二种情况。例如：int func(void)。void 指针的使用规则\1. void 指针可以指向任意类型的数据，就是说可以用任意类型的指针对 void 指针对 void 指针赋值。例如：123int *a；void *p；p=a；如果要将 void 指针 p 赋给其他类型的指针，则需要强制类型转换，就本例而言：a=（int *）p。在内存的分配中我们可以见到 void 指针使用：内存分配函数 malloc 函数返回的指针就是 void * 型，用户在使用这个指针的时候，要进行强制类型转换，也就是显式说明该指针指向的内存中是存放的什么类型的数据 (int *)malloc(1024) 表示强制规定 malloc 返回的 void* 指针指向的内存中存放的是一个个的 int 型数据。\2. 在 ANSI C 标准中，不允许对 void 指针进行一些算术运算如 p++ 或 p+=1 等，因为既然 void 是无类型，那么每次算术运算我们就不知道该操作几个字节，例如 char 型操作 sizeof(char) 字节，而 int 则要操作 sizeof(int) 字节。而在 GNU 中则允许，因为在默认情况下，GNU 认为 void * 和 char * 一样，既然是确定的，当然可以进行一些算术操作，在这里sizeof(*p)==sizeof(char)。void 几乎只有”注释”和限制程序的作用，因为从来没有人会定义一个 void 变量，让我们试着来定义：1void a;这行语句编译时会出错，提示“illegal use of type ‘void’”。即使 void a 的编译不会出错，它也没有任何实际意义。众所周知，如果指针 p1 和 p2 的类型相同，那么我们可以直接在 p1 和 p2 间互相赋值；如果 p1 和 p2 指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的指针类型转换为左边指针的类型。123456float *p1;int *p2;p1 = p2;//其中p1 = p2语句会编译出错，//提示“&apos;=&apos; : cannot convert from &apos;int *&apos; to &apos;float *&apos;”，必须改为：p1 = (float *)p2;而 void * 则不同，任何类型的指针都可以直接赋值给它，无需进行强制类型转换。123void *p1;int *p2;p1 = p2;但这并不意味着，void * 也可以无需强制类型转换地赋给其它类型的指针。因为”无类型”可以包容”有类型”，而”有类型”则不能包容”无类型”。小心使用 void 指针类型:按照 ANSI(American National Standards Institute) 标准，不能对 void 指针进行算法操作，即下列操作都是不合法的：1234567void * pvoid;pvoid++; //ANSI：错误pvoid += 1; //ANSI：错误//ANSI标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指向数据类型大小的。//例如：int *pint;pint++; //ANSI：正确pint++ 的结果是使其增大 sizeof(int)。但是 GNU 则不这么认定，它指定 void * 的算法操作与 char * 一致。因此下列语句在 GNU 编译器中皆正确：12pvoid++; //GNU：正确pvoid += 1; //GNU：正确pvoid++ 的执行结果是其增大了 1。在实际的程序设计中，为迎合 ANSI 标准，并提高程序的可移植性，我们可以这样编写实现同样功能的代码：123void * pvoid;((char *)pvoid)++; //ANSI：错误；GNU：正确(char *)pvoid += 1; //ANSI：错误；GNU：正确GNU 和 ANSI 还有一些区别，总体而言，GNU 较 ANSI 更”开放”，提供了对更多语法的支持。但是我们在真实设计时，还是应该尽可能地迎合 ANSI 标准。 如果函数的参数可以是任意类型指针，那么应声明其参数为void *。注：void 指针可以任意类型的数据，可以在程序中给我们带来一些好处，函数中形为指针类型时，我们可以将其定义为 void 指针，这样函数就可以接受任意类型的指针。如：典型的如内存操作函数 memcpy 和 memset 的函数原型分别为：12void * memcpy(void *dest, const void *src, size_t len);void * memset ( void * buffer, int c, size_t num );这样，任何类型的指针都可以传入 memcpy 和 memset 中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型（参见 C 语言实现泛型编程）。如果 memcpy 和 memset 的参数类型不是 void *，而是 char *，那才叫真的奇怪了！这样的 memcpy 和 memset 明显不是一个”纯粹的，脱离低级趣味的”函数！void 的出现只是为了一种抽象的需要，如果你正确地理解了面向对象中”抽象基类”的概念，也很容易理解 void 数据类型。正如不能给抽象基类定义一个实例，我们也不能定义一个 void（让我们类比的称 void 为”抽象数据类型”）变量。原文地址：https://www.cnblogs.com/wuyudong/p/c-void-point.html]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>Void* 知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机系统组成及工作原理简介]]></title>
    <url>%2F2019%2F09%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[计算机系统组成及工作原理简介硬件系统中央控制器 CPU运算器 ALU又称算数逻辑部件，是计算机用来进行数据运算的部件算数运算加、减、乘、除四则运算逻辑运算与、或、非、异或等逻辑操作，以及移位、比较和传送等操作，亦称算术逻辑部件（ALU）控制器 Controller通过地址访问存储器，逐条取出选中单元的指令，分析指令，根据指令产生相应的控制信号，用于其他各个部件，控制其他部件完成指令要求的操作。存储器 Memory：计算机中具有记忆能力的部件，用来存放程序或数据内存储器内存，又称主存，是CPU能根据地址线直接寻址的存储空间，是计算机内部存放数据的硬件设备，是程序和数据存储的基本要素。外存储器外存，又称辅存，作为一种辅助存储设备，主要用来存放一些暂时不用而又需长期保存的程序或数据。输入设备 Input Device用来输入程序和数据的部件：常用的输入设备有键盘，鼠标，传声器（麦克风），扫描仪，手写板，数码相机，摄像头等。输出设备 Output Device显示输出结果的部件 显示器，音响，打印机，绘图仪。软件系统系统软件管理，监控，维护计算机正常工作和供用户操作使用的计算机软件。应用软件在某种具体应用，供最终用户使用的软件。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas函数]]></title>
    <url>%2F2019%2F08%2F25%2Fpandas%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[【python】Pandas中DataFrame基本函数整理构造函数DataFrame([data, index, columns, dtype, copy]) #构造数据框1属性和数据DataFrame.axes #index: 行标签；columns: 列标签DataFrame.as_matrix([columns]) #转换为矩阵DataFrame.dtypes #返回数据的类型DataFrame.ftypes #返回每一列的 数据类型float64:denseDataFrame.get_dtype_counts() #返回数据框数据类型的个数DataFrame.get_ftype_counts() #返回数据框数据类型float64:dense的个数DataFrame.select_dtypes([include, include]) #根据数据类型选取子数据框DataFrame.values #Numpy的展示方式DataFrame.axes #返回横纵坐标的标签名DataFrame.ndim #返回数据框的纬度DataFrame.size #返回数据框元素的个数DataFrame.shape #返回数据框的形状DataFrame.memory_usage() #每一列的存储12345678910111213类型转换1234DataFrame.astype(dtype[, copy, errors]) #转换数据类型DataFrame.copy([deep]) #deep深度复制数据DataFrame.isnull() #以布尔的方式返回空值DataFrame.notnull() #以布尔的方式返回非空值1234索引和迭代123456789101112131415161718DataFrame.head([n]) #返回前n行数据DataFrame.at #快速标签常量访问器DataFrame.iat #快速整型常量访问器DataFrame.loc #标签定位，使用名称DataFrame.iloc #整型定位，使用数字DataFrame.insert(loc, column, value) #在特殊地点loc[数字]插入column[列名]某列数据DataFrame.iter() #Iterate over infor axisDataFrame.iteritems() #返回列名和序列的迭代器DataFrame.iterrows() #返回索引和序列的迭代器DataFrame.itertuples([index, name]) #Iterate over DataFrame rows as namedtuples, with index value as first element of the tuple.DataFrame.lookup(row_labels, col_labels) #Label-based “fancy indexing” function for DataFrame.DataFrame.pop(item) #返回删除的项目DataFrame.tail([n]) #返回最后n行DataFrame.xs(key[, axis, level, drop_level]) #Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.DataFrame.isin(values) #是否包含数据框中的元素DataFrame.where(cond[, other, inplace, …]) #条件筛选DataFrame.mask(cond[, other, inplace, …]) #Return an object of same shape as self and whose corresponding entries are from self where cond is False and otherwise are from other.DataFrame.query(expr[, inplace]) #Query the columns of a frame with a boolean expression.123456789101112131415161718二元运算123456789101112131415161718192021222324DataFrame.add(other[,axis,fill_value]) #加法，元素指向DataFrame.sub(other[,axis,fill_value]) #减法，元素指向DataFrame.mul(other[, axis,fill_value]) #乘法，元素指向DataFrame.div(other[, axis,fill_value]) #小数除法，元素指向DataFrame.truediv(other[, axis, level, …]) #真除法，元素指向DataFrame.floordiv(other[, axis, level, …]) #向下取整除法，元素指向DataFrame.mod(other[, axis,fill_value]) #模运算，元素指向DataFrame.pow(other[, axis,fill_value]) #幂运算，元素指向DataFrame.radd(other[, axis,fill_value]) #右侧加法，元素指向DataFrame.rsub(other[, axis,fill_value]) #右侧减法，元素指向DataFrame.rmul(other[, axis,fill_value]) #右侧乘法，元素指向DataFrame.rdiv(other[, axis,fill_value]) #右侧小数除法，元素指向DataFrame.rtruediv(other[, axis, …]) #右侧真除法，元素指向DataFrame.rfloordiv(other[, axis, …]) #右侧向下取整除法，元素指向DataFrame.rmod(other[, axis,fill_value]) #右侧模运算，元素指向DataFrame.rpow(other[, axis,fill_value]) #右侧幂运算，元素指向DataFrame.lt(other[, axis, level]) #类似Array.ltDataFrame.gt(other[, axis, level]) #类似Array.gtDataFrame.le(other[, axis, level]) #类似Array.leDataFrame.ge(other[, axis, level]) #类似Array.geDataFrame.ne(other[, axis, level]) #类似Array.neDataFrame.eq(other[, axis, level]) #类似Array.eqDataFrame.combine(other,func[,fill_value, …]) #Add two DataFrame objects and do not propagate NaN values, so if for aDataFrame.combine_first(other) #Combine two DataFrame objects and default to non-null values in frame calling the method.123456789101112131415161718192021222324函数应用&amp;分组&amp;窗口12345678DataFrame.apply(func[, axis, broadcast, …]) #应用函数DataFrame.applymap(func) #Apply a function to a DataFrame that is intended to operate elementwise, i.e.DataFrame.aggregate(func[, axis]) #Aggregate using callable, string, dict, or list of string/callablesDataFrame.transform(func, *args, **kwargs) #Call function producing a like-indexed NDFrameDataFrame.groupby([by, axis, level, …]) #分组DataFrame.rolling(window[, min_periods, …]) #滚动窗口DataFrame.expanding([min_periods, freq, …]) #拓展窗口DataFrame.ewm([com, span, halflife, …]) #指数权重窗口12345678描述统计学12345678910111213141516171819202122232425262728293031323334DataFrame.abs() #返回绝对值DataFrame.all([axis, bool_only, skipna]) #Return whether all elements are True over requested axisDataFrame.any([axis, bool_only, skipna]) #Return whether any element is True over requested axisDataFrame.clip([lower, upper, axis]) #Trim values at input threshold(s).DataFrame.clip_lower(threshold[, axis]) #Return copy of the input with values below given value(s) truncated.DataFrame.clip_upper(threshold[, axis]) #Return copy of input with values above given value(s) truncated.DataFrame.corr([method, min_periods]) #返回本数据框成对列的相关性系数DataFrame.corrwith(other[, axis, drop]) #返回不同数据框的相关性DataFrame.count([axis, level, numeric_only]) #返回非空元素的个数DataFrame.cov([min_periods]) #计算协方差DataFrame.cummax([axis, skipna]) #Return cumulative max over requested axis.DataFrame.cummin([axis, skipna]) #Return cumulative minimum over requested axis.DataFrame.cumprod([axis, skipna]) #返回累积DataFrame.cumsum([axis, skipna]) #返回累和DataFrame.describe([percentiles,include, …]) #整体描述数据框DataFrame.diff([periods, axis]) #1st discrete difference of objectDataFrame.eval(expr[, inplace]) #Evaluate an expression in the context of the calling DataFrame instance.DataFrame.kurt([axis, skipna, level, …]) #返回无偏峰度Fisher’s (kurtosis of normal == 0.0).DataFrame.mad([axis, skipna, level]) #返回偏差DataFrame.max([axis, skipna, level, …]) #返回最大值DataFrame.mean([axis, skipna, level, …]) #返回均值DataFrame.median([axis, skipna, level, …]) #返回中位数DataFrame.min([axis, skipna, level, …]) #返回最小值DataFrame.mode([axis, numeric_only]) #返回众数DataFrame.pct_change([periods, fill_method]) #返回百分比变化DataFrame.prod([axis, skipna, level, …]) #返回连乘积DataFrame.quantile([q, axis, numeric_only]) #返回分位数DataFrame.rank([axis, method, numeric_only]) #返回数字的排序DataFrame.round([decimals]) #Round a DataFrame to a variable number of decimal places.DataFrame.sem([axis, skipna, level, ddof]) #返回无偏标准误DataFrame.skew([axis, skipna, level, …]) #返回无偏偏度DataFrame.sum([axis, skipna, level, …]) #求和DataFrame.std([axis, skipna, level, ddof]) #返回标准误差DataFrame.var([axis, skipna, level, ddof]) #返回无偏误差 12345678910111213141516171819202122232425262728293031323334从新索引&amp;选取&amp;标签操作12345678910111213141516171819202122232425DataFrame.add_prefix(prefix) #添加前缀DataFrame.add_suffix(suffix) #添加后缀DataFrame.align(other[, join, axis, level]) #Align two object on their axes with theDataFrame.drop(labels[, axis, level, …]) #返回删除的列DataFrame.drop_duplicates([subset, keep, …]) #Return DataFrame with duplicate rows removed, optionally onlyDataFrame.duplicated([subset, keep]) #Return boolean Series denoting duplicate rows, optionally onlyDataFrame.equals(other) #两个数据框是否相同DataFrame.filter([items, like, regex, axis]) #过滤特定的子数据框DataFrame.first(offset) #Convenience method for subsetting initial periods of time series data based on a date offset.DataFrame.head([n]) #返回前n行DataFrame.idxmax([axis, skipna]) #Return index of first occurrence of maximum over requested axis.DataFrame.idxmin([axis, skipna]) #Return index of first occurrence of minimum over requested axis.DataFrame.last(offset) #Convenience method for subsetting final periods of time series data based on a date offset.DataFrame.reindex([index, columns]) #Conform DataFrame to new index with optional filling logic, placing NA/NaN in locations having no value in the previous index.DataFrame.reindex_axis(labels[, axis, …]) #Conform input object to new index with optional filling logic, placing NA/NaN in locations having no value in the previous index.DataFrame.reindex_like(other[, method, …]) #Return an object with matching indices to myself.DataFrame.rename([index, columns]) #Alter axes input function or functions.DataFrame.rename_axis(mapper[, axis, copy]) #Alter index and / or columns using input function or functions.DataFrame.reset_index([level, drop, …]) #For DataFrame with multi-level index, return new DataFrame with labeling information in the columns under the index names, defaulting to ‘level_0’, ‘level_1’, etc.DataFrame.sample([n, frac, replace, …]) #返回随机抽样DataFrame.select(crit[, axis]) #Return data corresponding to axis labels matching criteriaDataFrame.set_index(keys[, drop, append ]) #Set the DataFrame index (row labels) using one or more existing columns.DataFrame.tail([n]) #返回最后几行DataFrame.take(indices[, axis, convert]) #Analogous to ndarray.takeDataFrame.truncate([before, after, axis ]) #Truncates a sorted NDFrame before and/or after some particular index value.12345678910111213141516171819202122232425处理缺失值123DataFrame.dropna([axis, how, thresh, …]) #Return object with labels on given axis omitted where alternately anyDataFrame.fillna([value, method, axis, …]) #填充空值DataFrame.replace([to_replace, value, …]) #Replace values given in ‘to_replace’ with ‘value’.123从新定型&amp;排序&amp;转变形态1234567891011121314DataFrame.pivot([index, columns, values]) #Reshape data (produce a “pivot” table) based on column values.DataFrame.reorder_levels(order[, axis]) #Rearrange index levels using input order.DataFrame.sort_values(by[, axis, ascending]) #Sort by the values along either axisDataFrame.sort_index([axis, level, …]) #Sort object by labels (along an axis)DataFrame.nlargest(n, columns[, keep]) #Get the rows of a DataFrame sorted by the n largest values of columns.DataFrame.nsmallest(n, columns[, keep]) #Get the rows of a DataFrame sorted by the n smallest values of columns.DataFrame.swaplevel([i, j, axis]) #Swap levels i and j in a MultiIndex on a particular axisDataFrame.stack([level, dropna]) #Pivot a level of the (possibly hierarchical) column labels, returning a DataFrame (or Series in the case of an object with a single level of column labels) having a hierarchical index with a new inner-most level of row labels.DataFrame.unstack([level, fill_value]) #Pivot a level of the (necessarily hierarchical) index labels, returning a DataFrame having a new level of column labels whose inner-most level consists of the pivoted index labels.DataFrame.melt([id_vars, value_vars, …]) #“Unpivots” a DataFrame from wide format to long format, optionallyDataFrame.T #Transpose index and columnsDataFrame.to_panel() #Transform long (stacked) format (DataFrame) into wide (3D, Panel) format.DataFrame.to_xarray() #Return an xarray object from the pandas object.DataFrame.transpose(*args, **kwargs) #Transpose index and columns1234567891011121314Combining&amp; joining&amp;merging12345DataFrame.append(other[, ignore_index, …]) #追加数据DataFrame.assign(**kwargs) #Assign new columns to a DataFrame, returning a new object (a copy) with all the original columns in addition to the new ones.DataFrame.join(other[, on, how, lsuffix, …]) #Join columns with other DataFrame either on index or on a key column.DataFrame.merge(right[, how, on, left_on, …]) #Merge DataFrame objects by performing a database-style join operation by columns or indexes.DataFrame.update(other[, join, overwrite, …]) #Modify DataFrame in place using non-NA values from passed DataFrame.12345时间序列12345678910DataFrame.asfreq(freq[, method, how, …]) #将时间序列转换为特定的频次DataFrame.asof(where[, subset]) #The last row without any NaN is taken (or the last row withoutDataFrame.shift([periods, freq, axis]) #Shift index by desired number of periods with an optional time freqDataFrame.first_valid_index() #Return label for first non-NA/null valueDataFrame.last_valid_index() #Return label for last non-NA/null valueDataFrame.resample(rule[, how, axis, …]) #Convenience method for frequency conversion and resampling of time series.DataFrame.to_period([freq, axis, copy]) #Convert DataFrame from DatetimeIndex to PeriodIndex with desiredDataFrame.to_timestamp([freq, how, axis]) #Cast to DatetimeIndex of timestamps, at beginning of periodDataFrame.tz_convert(tz[, axis, level, copy]) #Convert tz-aware axis to target time zone.DataFrame.tz_localize(tz[, axis, level, …]) #Localize tz-naive TimeSeries to target time zone.12345678910作图1234567891011121314DataFrame.plot([x, y, kind, ax, ….]) #DataFrame plotting accessor and methodDataFrame.plot.area([x, y]) #面积图Area plotDataFrame.plot.bar([x, y]) #垂直条形图Vertical bar plotDataFrame.plot.barh([x, y]) #水平条形图Horizontal bar plotDataFrame.plot.box([by]) #箱图BoxplotDataFrame.plot.density(**kwds) #核密度Kernel Density Estimate plotDataFrame.plot.hexbin(x, y[, C, …]) #Hexbin plotDataFrame.plot.hist([by, bins]) #直方图HistogramDataFrame.plot.kde(**kwds) #核密度Kernel Density Estimate plotDataFrame.plot.line([x, y]) #线图Line plotDataFrame.plot.pie([y]) #饼图Pie chartDataFrame.plot.scatter(x, y[, s, c]) #散点图Scatter plotDataFrame.boxplot([column, by, ax, …]) #Make a box plot from DataFrame column optionally grouped by some columns orDataFrame.hist(data[, column, by, grid, …]) #Draw histogram of the DataFrame’s series using matplotlib / pylab.1234567891011121314转换为其他格式123456789101112131415161718192021DataFrame.from_csv(path[, header, sep, …]) #Read CSV file (DEPRECATED, please use pandas.read_csv() instead).DataFrame.from_dict(data[, orient, dtype]) #Construct DataFrame from dict of array-like or dictsDataFrame.from_items(items[,columns,orient]) #Convert (key, value) pairs to DataFrame.DataFrame.from_records(data[, index, …]) #Convert structured or record ndarray to DataFrameDataFrame.info([verbose, buf, max_cols, …]) #Concise summary of a DataFrame.DataFrame.to_pickle(path[, compression, …]) #Pickle (serialize) object to input file path.DataFrame.to_csv([path_or_buf, sep, na_rep]) #Write DataFrame to a comma-separated values (csv) fileDataFrame.to_hdf(path_or_buf, key, **kwargs) #Write the contained data to an HDF5 file using HDFStore.DataFrame.to_sql(name, con[, flavor, …]) #Write records stored in a DataFrame to a SQL database.DataFrame.to_dict([orient, into]) #Convert DataFrame to dictionary.DataFrame.to_excel(excel_writer[, …]) #Write DataFrame to an excel sheetDataFrame.to_json([path_or_buf, orient, …]) #Convert the object to a JSON string.DataFrame.to_html([buf, columns, col_space]) #Render a DataFrame as an HTML table.DataFrame.to_feather(fname) #write out the binary feather-format for DataFramesDataFrame.to_latex([buf, columns, …]) #Render an object to a tabular environment table.DataFrame.to_stata(fname[, convert_dates, …]) #A class for writing Stata binary dta files from array-like objectsDataFrame.to_msgpack([path_or_buf, encoding]) #msgpack (serialize) object to input file pathDataFrame.to_sparse([fill_value, kind]) #Convert to SparseDataFrameDataFrame.to_dense() #Return dense representation of NDFrame (as opposed to sparse)DataFrame.to_string([buf, columns, …]) #Render a DataFrame to a console-friendly tabular output.DataFrame.to_clipboard([excel, sep]) #Attempt to write text representation of object to the system cli]]></content>
      <categories>
        <category>python数据挖掘</category>
      </categories>
      <tags>
        <tag>pandas函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[妹子图爬虫（爬取妹子图图片）]]></title>
    <url>%2F2019%2F07%2F22%2Fpython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[python实现妹子图爬虫（爬取妹子网图片）一个简单的小爬虫实现爬取妹子图网站上的图片。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#coding=utf-8import requestsfrom bs4 import BeautifulSoupimport osall_url = 'http://www.mzitu.com'#http请求头Hostreferer = &#123; 'User-Agent':'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)', 'Referer':'http://www.mzitu.com' &#125;Picreferer = &#123; 'User-Agent':'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)', 'Referer':'http://i.meizitu.net'&#125;#此请求头破解盗链start_html = requests.get(all_url,headers = Hostreferer)#保存地址path = "D:\\mzitu\\"#找寻最大页数soup = BeautifulSoup(start_html.text,"html.parser")page = soup.find_all('a',class_='page-numbers')max_page = page[-2].textsame_url = 'http://www.mzitu.com/all/'for n in range(1,int(max_page)+1): ul = same_url+str(n) start_html = requests.get(ul, headers = Hostreferer) soup = BeautifulSoup(start_html.text,"html.parser") all_a = soup.find('div',class_='all').find_all('a',target='_blank') for a in all_a: title = a.get_text() #提取文本 if(title != ''): print("准备扒取："+title) #win不能创建带？的目录 if(os.path.exists(path+title.strip().replace('?',''))): #print('目录已存在') flag=1 else: os.makedirs(path+title.strip().replace('?','').replace(':', '')) flag=0 os.chdir(path + title.strip().replace('?','').replace(':', '')) href = a['href'] html = requests.get(href,headers = Hostreferer) mess = BeautifulSoup(html.text,"html.parser") pic_max = mess.find_all('span') try: pic_max = pic_max[9].text #最大页数 if(flag == 1 and len(os.listdir(path+title.strip().replace('?',''))) &gt;= int(pic_max)): print('已经保存完毕，跳过') continue for num in range(1, int(pic_max)+1): pic = href+'/'+str(num) html = requests.get(pic,headers = Hostreferer) mess = BeautifulSoup(html.text,"html.parser") pic_url = mess.find('img',alt = title) print(pic_url['src']) #exit(0) html = requests.get(pic_url['src'],headers = Picreferer) file_name = pic_url['src'].split(r'/')[-1] f = open(file_name,'wb') f.write(html.content) f.close() except Exception: pass print('完成 ') print('第',n,'页完成')原文参考：https://blog.csdn.net/baidu_35085676/article/details/68958267]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>爬虫实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据之Hadoop]]></title>
    <url>%2F2019%2F07%2F14%2Fhadoop%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Hadoop介绍组成部分Hadoop主要由3部分组成：Mapreduce编程模型HDFS分布式文件存储YARN配置信息管理员密码：admin123DNS1=202.103.24.68DNS2=202.103.44.150export HADOOP_HOME=/usr/local/hadoop-2.6.4export PATH=$HADOOP_HOME/bin$PATH:/usr/java/jdk1.8.0_201-amd64/binHadoop HDFS 简介概念：namenode：负责记录 数据块 的分布情况– 数据元数据信息datanode:负责实际存储 数据块block：是Hadoop最小存储数据单位 默认 128Msecondarynamenode: 辅助namenode完成fsimage管理或者优化HDFS简单命令hadoop version //查看版本hadoop fs //文件系统客户端hadoop jar //运行jar包hadoop classpath //查看类路径hadoop checknative //检查本地库并压缩hadoop distcp // 远程递归拷贝文件hadoop credential //认证hadoop trace //跟踪$ hdfs dfs -mkdir-p /user/ubuntu/ //在hdfs上建立文件夹$ hdfs dfs -puthdfs.cmd /user/ubuntu/ //将本地文件上传到HDFS$ hdfs dfs -get/user/ubuntu/hadoop.cmd a.cmd //将文件从HDFS取回本地$ hdfs dfs -rm -r -f /user/ubuntu/ //删除$ hdfs dfs -ls -R/ //递归展示HDFS文件系统一、hadoop所在目录cd usr/local/hadoop1二、启动hadoopbash ./starth.sh% 运行start-dfs.sh% 运行start-yarn.sh123启动dfs，浏览器查看：172.16.31.17:500701启动脚本，浏览器查看：172.16.31.17:80881停止脚本：bash ./stoph.sh1三、常用命令1.显示hadoop目录结构hdfs dfs -ls -R /12.在hadoop指定目录内创建新目录hdfs dfs -mkdir /winnie13.将本地文件夹存储至hadoophdfs dfs -put [本地目录] [hadoop目录]14.将本地文件存储至hadoophdfs dfs -put [本地地址] [hadoop目录]15.查看指定目录下内容hdfs dfs -ls [文件目录]16.打开某个已存在文件hdfs dfs -cat [file_path]17.在hadoop指定目录下新建一个空文件hdfs dfs -touchz /winnie/test03.txt18.将hadoop上某个文件重命名hdfs dfs -mv /winnie/test03.txt /winnie/test.txt19.将hadoop上某个文件down至本地已有目录下hdfs dfs -get [文件目录] [本地目录]110.将hadoop指定目录下所有内容保存为一个文件，同时down至本地hdfs dfs -getmerge /winnie/hadoop-file /home/spark/hadoop-file/test.txt111.删除hadoop上指定文件hdfs dfs -rm [文件地址]112.删除hadoop上指定文件夹（包含子目录等）hdfs dfs -rm -r [目录地址]hdfs dfs -rmr [目录地址]1213.将正在运行的hadoop作业kill掉hadoop job -kill [job-id]114.查看帮助hdfs dfs -help1四、安全模式1.退出安全模式NameNode在启动时会自动进入安全模式，安全模式是NameNode的一种状态，在这个阶段，文件系统不允许有任何修改。系统显示Name node in safe mode，说明系统正处于安全模式，这时只需要等待几十秒即可，也可通过下面的命令退出安全模式：/usr/local/hadoop$bin/hadoop dfsadmin -safemode leave12.进入安全模式在必要情况下，可以通过以下命令吧HDFS置于安全模式：/usr/local/hadoop$bin/hadoop dfsadmin -safemode enter1五、补充1.对hdfs操作的命令格式是hdfs dfs1.1 -ls 表示对hdfs下一级目录的查看1.2 -lsr 表示对hdfs目录的递归查看1.3 -mkdir 创建目录1.4 -put 从Linux上传文件到hdfs1.5 -get 从hdfs下载文件到linux1.6 -text 查看文件内容1.7 -rm 表示删除文件1.7 -rmr 表示递归删除文件2.hdfs在对数据存储进行block划分时，如果文件大小超过block，那么按照block大小进行划分；不如block size的，划分为一个块，是实际数据大小。3.hadoop常用命令：hdfs dfs 查看Hadoop HDFS支持的所有命令hdfs dfs –ls 列出目录及文件信息hdfs dfs –lsr 循环列出目录、子目录及文件信息hdfs dfs –tail /user/sunlightcs/test.txt 查看最后1KB的内容hdfs dfs –copyFromLocal test.txt /user/sunlightcs/test.txt 从本地文件系统复制文件到HDFS文件系统，等同于put命令hdfs dfs –copyToLocal /user/sunlightcs/test.txt test.txt 从HDFS文件系统复制文件到本地文件系统，等同于get命令hdfs dfs –chgrp [-R] /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录所属群组，选项-R递归执行，跟linux命令一样hdfs dfs –chown [-R] /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录拥有者，选项-R递归执行hdfs dfs –chmod [-R] MODE /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录权限，MODE可以为相应权限的3位数或+/-{rwx}，选项-R递归执行hdfs dfs –count [-q] PATH 查看PATH目录下，子目录数、文件数、文件大小、文件名/目录名hdfs dfs –cp SRC [SRC …] DST 将文件从SRC复制到DST，如果指定了多个SRC，则DST必须为一个目录hdfs dfs –du PATH 显示该目录中每个文件或目录的大小hdfs dfs –dus PATH 类似于du，PATH为目录时，会显示该目录的总大小hdfs dfs –expunge 清空回收站，文件被删除时，它首先会移到临时目录.Trash/中，当超过延迟时间之后，文件才会被永久删除hdfs dfs –getmerge SRC [SRC …] LOCALDST [addnl] 获取由SRC指定的所有文件，将它们合并为单个文件，并写入本地文件系统中的LOCALDST，选项addnl将在每个文件的末尾处加上一个换行符hdfs dfs –test –[ezd] PATH 对PATH进行如下类型的检查：-e PATH是否存在，如果PATH存在，返回0，否则返回1；-z 文件是否为空，如果长度为0，返回0，否则返回1； -d 是否为目录，如果PATH为目录，返回0，否则返回1hdfs dfs –text PATH 显示文件的内容，当文件为文本文件时，等同于cat；文件为压缩格式（gzip以及hadoop的二进制序列文件格式）时，会先解压缩hdfs dfs –help ls 查看某个[ls]命令的帮助文档Mapreduce解释mapper的角色:hadoop将用户提交的mapper可执行程序或脚本作为一个单独的进程加载起来，这个进程我们称之为mapper进程，hadoop不断地将文件片段转换为行，传递到我们的mapper进程中，mapper进程通过标准输入的方式一行一行地获取这些数据，然后设法将其转换为键值对，再通过标准输出的形式将这些键值对按照一对儿一行的方式输出出去。虽然在我们的mapper函数中，我们自己能分得清key/value(比方说有可能在我们的代码中使用的是string key,int value)，但是当我们采用标准输出之后，key value是打印到一行作为结果输出的(比如sys.stdout.write(“%s\t%s\n”%(birthyear,gender)))，因此我们为了保证hadoop能从中鉴别出我们的键值对，键值对中一定要以分隔符’\t’即Tab(也可自定义分隔符)字符分隔，这样才能保证hadoop正确地为我们进行partitoner、shuffle等等过程。reducer的角色:hadoop将用户提交的reducer可执行程序或脚本同样作为一个单独的进程加载起来，这个进程我们称之为reducer进程，hadoop不断地将键值对(按键排序)按照一对儿一行的方式传递到reducer进程中，reducer进程同样通过标准输入的方式按行获取这些键值对儿，进行自定义计算后将结果通过标准输出的形式输出出去。在reducer这个过程中需要注意的是：传递进reducer的键值对是按照键排过序的，这点是由MR框架的sort过程保证的，因此如果读到一个键与前一个键不同，我们就可以知道当前key对应的pairs已经结束了，接下来将是新的key对应的pairs。]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop介绍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据科学之统计学习]]></title>
    <url>%2F2019%2F07%2F14%2F%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[统计学中心倾向均值（常用的额）中位数分位数：它表示少于数据中特定百分比的一个值众数离散度极差方差统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数概率论中方差用来度量随机变量)和其数学期望（即均值）之间的偏离程度计算公式$$s^2 = \frac{\sum_{}(x-u)^2}{N}$$标准差中文环境中又常称均方差，是离均差平方的算术平均数的平方根，用σ表示。标准差是方差的算术平方根计算公式$$σ = \sqrt\frac{\sum_{}(x-u)^2}{N}$$相关性协方差协方差（Covariance）在概率论和统计学中用于衡量两个变量的总体误差。而方差是协方差的一种特殊情况，即当两个变量是相同的情况。计算公式概率论不独立和独立如果事件E和事件F独立意味着两个事同时发生的概率等于它们分别发生的概率的乘积。$$P（E, F） = P(E)*P(F)$$条件概率如果事件E与事件F独立，那么定义：$$P（E, F） = P(E)*P(F)$$如果两者不一定独立（并且概率都不为0），那么概率公式为：（已知F发生，在此条件下E发生的概率）$$P（E|F） = P（E, F）/P（F）$$]]></content>
      <categories>
        <category>统计学和概率论</category>
      </categories>
      <tags>
        <tag>数学知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之百度接口语音识别]]></title>
    <url>%2F2019%2F07%2F12%2F%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[python编程之百度接口语音识别首先在百度AI开放平台上创建语音识别应用，创建完毕应用后，得到系统分配给用户的AppID， API Key， secret Key，均为字符串，用于标识用户，为访问做签名验证。得到验证后，开始编程1.记录自己声音2.将记录下来的音频文件上传至云端3.解析返回后的结果python实现相关包 pyaudio，baidu-aip123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from aip import AipSpeechimport wavefrom pyaudio import PyAudio, paInt16def save_wave_file(filename, data): '''save the date to the wavfile''' wf = wave.open(filename, 'wb') wf.setnchannels(channels) wf.setsampwidth(sampwidth) wf.setframerate(framerate) wf.writeframes(b"".join(data)) wf.close()def my_record(): pa = PyAudio() stream = pa.open(format=paInt16, channels=1, rate=framerate, input=True, frames_per_buffer=NUM_SAMPLES) my_buf = [] count = 0 print('录音开始') while count &lt; TIME*10: # 控制录音时间 string_audio_data = stream.read(NUM_SAMPLES) my_buf.append(string_audio_data) count += 1 print('录音结束') save_wave_file('01.pcm', my_buf) stream.close()if __name__ == "__main__": framerate = 16000 NUM_SAMPLES = 2000 channels = 1 sampwidth = 2 TIME = 2 my_record() """ 我的 APPID AK SK """ APP_ID = '16795182 ' API_KEY = '8io5s7uv8pjYPUrQp1i8PcIg' SECRET_KEY = 'gK2MljvbcF3SKS4p0C2ieq1SCBNY48BD' client = AipSpeech(APP_ID, API_KEY, SECRET_KEY) # 读取文件 def get_file_content(filePath): with open(filePath, 'rb') as fp: return fp.read() # 识别本地文件 result = client.asr(get_file_content('01.pcm'), 'pcm', 16000, &#123; 'dev_pid': 1536, &#125;) # print(type(result)) print("语音识别结果：", result['result'])]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>语音识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据科学之数据可视化]]></title>
    <url>%2F2019%2F07%2F11%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数据可视化概述可视化的目的，是对数据进行可视化处理，以更明确地，有效的传递信息。数据可视化意义数据可视化是为了从数据中寻找三个方面的信息。模式。指数据中的规律。关系。指数据间的相关性。数据间的比较数据的构成数据的分布或联系异常。指有问题的数据。数据可视化的作用记录信息。用图形的方式描述各种具体或抽象的事物。分析推理。有效的提升了信息认知的效率，从而有助于人们更快地分析和推理出有效信息。信息传播和协同。数据可视化的分类科学可视化信息可视化可视分析学数据可视化基础数据类型根据数据模型，可将数据分为浮点数，整数，字符等根据概念模型类别型数据，有序型数据，区间型数据和比值型数据类别型数据：用于区分物体有序型数据：用来表示对象间的顺序关系区间型数据：用于得到对象间的定量关系。用于比较数值间的比列关系，可以精确地定义比例数据预处理数据的预处理的目的是提升数据质量数据质量包含以下六方面有效性：数据与实际情况对应时，是否违背约束条件准确性：数据能否精确的反映现实。完整性：采集数据集是否包含了数据源中 的所有数据点：且样本的属性都是完整的。一致性：整个数据集中的数据的衡量标准要一致时效性：数据适合当下时间区间内的分析任务可行性：数据源中的数据是使用者可依赖的。数据预处理步骤如下数据清理：指修正数据中的错误，识别脏数据，更正不一致数据的过程。数据集成：指把来自不同数据的同类数据进行合并，减少数据冲突，降低数据冗余程度等。数据归约：指在保证数据挖掘结果准确性的前提下，最大限度地精简数据量，得到简化的数据集。数据转换：指对数据进行规范化处理数据组织与管理大数据存储利用的是分布式存储与访问计数，它具有高效，容错性强等特点。分布式文件系统分布式文件系统是指文件在物理上可能被分散存储在不同地点的节点上，各节点通过计算机网络进行通信和数据传输，但仍然是一个完整的文件。常用的分布式系统有HDFS（hadoop分布式文件系统），GFS（Google分布式文件系统）等。文档存储文档存储支持对结构化数据的访问，一般以键值对的方式进行存储。文档存储类型也支持数组和列值键列式存储列式存储是指以流的方式在列中存储所有的数据键式存储以Key-Value存储，简称KV存储图形数据库图形数据库是NOSQL数据库的一种，是一种非关系型的数据库，它应用图形理论存储实体间的关系信息。关系型数据库关系模型是最传统的数据存储模型，数据按行存储在有架构界定的表中。用户可使用基于关系代数演算的结构化查询语言提供相应的语法查找符合条件的记录。内存数据库内存数据库就是将数据放在内存中直接操作的数据库。特点速度快，能处理实时型业务数据仓库数据仓库是一种特殊的数据库，一般用于存储海量数据，并直接支持后续的分析和决策操作。数据分析与数据挖掘数据分析统计分析是指对数据进行统计描述和统计推断的过程探索性数据分析是对调查，观测所得到的一些初步的杂乱无章的数据，在尽量少的先验假设下进行处理，通过作图，制表等形式和方程拟合，计算某些特征量等手段，探索数据的结构和规律的一种数据分析方法。验证性数据分析是指在已经有事先假设的关系模型等情况下，通过数据分析来验证已提出的假设在线分析和处理是一种交互式探索大规模多维数据集的方法。数据挖掘数据挖掘一般是指从大量的数据中通过算法搜索隐藏于其中的信息的过程。常见的数据挖掘分析方法有分类与预测，聚类分析，关联性分析和异常分析等。分类与预测聚类分析关联分析异常分析数据挖掘的步骤确定业务对象数据准备数据挖掘结果分析知识的同化]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>数据可视化概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站概念]]></title>
    <url>%2F2019%2F07%2F06%2Fserven%2F</url>
    <content type="text"><![CDATA[网站的组成目前多数网站由域名，空间服务器，DNS域名解析，网站程序和数据库等组成空间服务器（以下三种类型）虚拟主机：指在网络服务器上划分一定的磁盘空间供用户放置站点和应用组件等，提供必要的站点功能，数据存放和传输功能。所谓虚拟主机，也叫“网站空间”，就是把一台运行在互联网上的服务器划分成多个”虚拟“的服务器独立服务器：指性能更强大，整体硬件完全独立的服务器，其cpu都在8核以上。VPS（虚拟专用服务器）：将一个服务器分区成多个虚拟独立专享服务器的技术。网站的程序:是建设与修改网站所使用的编程语言。网站的分类资讯门户类网站企业品牌网站交易类网站B2C（Business To Consumer）网站：商家——消费者，主要是购物网站，用于商家和消费者之间的买卖，如传统的百货商店和购物广场。B2B（Business To Business）网站：商家——商家，主要是商务网站，用于商家之间的买卖，如传统的原材料市场和大型批发市场C2C（Consumer To Consumer）网站：消费者——消费者，主要以拍卖网站为主，用于个人的物品的买卖，如传统的旧货市场，跳骚市场，废品收购站等。办公及政府机构网站企业办公事物类网站政府办公类事物网站互动游戏网站功能性网站这类网站的主要特征是将一个具有广泛需求的共能扩展开来，开发一套强大的功能体系，将功能的实现推向极致。如：百度，goolge网站开发的常用术语域名：用于标识一个或多个ip地址DNS：域名系统，用于跟踪计算机的域名及其在互联网上的相应的IP地址]]></content>
      <categories>
        <category>网站知识</category>
      </categories>
      <tags>
        <tag>网站的基本概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法时间复杂度和五大经典排序算法]]></title>
    <url>%2F2019%2F06%2F29%2Fsix%2F</url>
    <content type="text"><![CDATA[渐进时间度表O记法所代表的是渐进上界限，Ω记法代表的是渐进下界Θ代表的集合是上述符号的交集，Θ(g) = O(g)常见的渐进运行时间实例时间复杂度相关名称相关实例及说明Θ（1）常数级哈希表的查询和修改Θ（lg n）对数级二分搜索，其对数基数并不重要Θ（n）线性级列表的遍历Θ(nlgn)线性对数级任意值序列的最优化排序，其复杂度等同于Θ(lg n!)Θ(n^2)平方级拿n个对象进行互相比对Θ(n^3)立方级Floyd-Warshall算法O(n^k)多项式级基于n的k层嵌套循环（k为整数），且必须满足K &gt; 0Ω(K^n)指数级每n项产生一个子集（其中k = 2），且必须满足K &gt; 1Θ(n!)阶乘级对n个值执行全排列操作冒泡排序冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 冒泡排序算法的运作如下： 1、比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。 2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 3、针对所有的元素重复以上的步骤，除了最后一个。 4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 ‘’’冒泡排序的时间复杂度为O(n^2)。1234567891011121314151617181920212223def store(x): '''冒泡排序算法实现''' f=0 while f &lt; len(x): i=0 j=1 while j &lt; len(x): if x[i] &lt;= x[j]: i = i + 1 j = j + 1 elif x[i] &gt; x[j]: var1 = x[i] var2 = x[j] x[j] = var1 x[i] = var2 i = i + 1 j = j + 1 f = f + 1 return xif __name__ == "__main__": test = [2,4,6,5,9,7,12,15,13,19,20,1,3] print(store(test))归并排序归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表， 即把待排序序列分为若干个子序列，每个子序列是有序的。 然后再把有序子序列合并为整体有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。123456789101112131415161718192021222324252627282930313233def merge_extend(x): '''归并排序算法''' # 拆分列表 if len(x) &lt;= 1: # 向下取整数 return x mid = len(x)//2 left = merge_extend(x[:mid]) right = merge_extend(x[mid:]) print(left,right) return merge_add(left, right)def merge_add(a, b): '''和并列表''' result = [] i = 0 j = 0 while i &lt; len(a) and j &lt; len(b): if a[i] &lt; b[j]: result.append(a[i]) i += 1 else: result.append(b[j]) j += 1 #print("a",a[i:]) #print("b",b[j:]) result.extend(a[i:]) result.extend(b[j:]) return resultif __name__ == "__main__": test=[11,0,5,7,3,6,8,1,2] print(merge_extend(test))插入排序插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列， 对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。简单插入排序的时间复杂度也是O(n^2)123456789101112def insert_sort(x): # 取列表的第一个元素为单独的一个，已经排好序的列表 for i in range(1, len(x)): # 要排序的的牌 for j in range(0, i): if x[i] &lt; x[j]: x[i], x[j] = x[j], x[i] return xif __name__=="__main__": test = [2,3,5,7,9,1,20,0,4,12,19,11,8,1] print(insert_sort(test))选择排序选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置， 然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。 选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上， 因此对n个元素的表进行排序总共进行至多n-1次交换。 在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。选择排序的时间复杂度为O(n^2)1234567891011def select_sort(x): '''选择排序''' new = [] while x: new.append(min(x)) x.remove(min(x)) return newif __name__=="__main__": test = [2,3,5,7,9,1,20,0,4,12,19,11,8,1] print(select_sort(test))快速排序1.先从待排序的数组中找出一个数作为基准数（取第一个数即可）， 2.然后将原来的数组划分成两部分：小于基准数的左子数组和大于等于基准数的右子数组。 3.然后对这两个子数组再递归重复上述过程，直到两个子数组的所有数都分别有序。 4.最后返回“左子数组” + “基准数” + “右子数组”，即是最终排序好的数组。快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)1234567891011121314151617def quick_sort(x): '''快速排序''' if len(x) &lt;= 1: return x base = x[0] left = [] right = [] for var in x: if var &gt; base: right.append(var) elif var &lt; base: left.append(var) return quick_sort(left) + [base] + quick_sort(right)if __name__ == "__main__": # 存在重复值被覆盖 test = [2,6,7,8,12,56,36,89,45,3]]]></content>
      <categories>
        <category>算法</category>
        <category>五大经典排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git文章更新测试]]></title>
    <url>%2F2019%2F06%2F28%2Ffive%2F</url>
    <content type="text"><![CDATA[这是一个测试文件test]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>测试文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的正则表达式]]></title>
    <url>%2F2019%2F06%2F26%2Ffour%2F</url>
    <content type="text"><![CDATA[匹配小数1[0-9]&#123;1,&#125;[.][0-9]*匹配整数1[0-9]中文的匹配1[\u4e00-\u9fa5]特殊符号和字符：123456789101112131415161718192021[A-Z0-9a-z]: A,1,a[abc]*: aaa,abc,acc,匹配前面的正则0次或多次a？: a,匹配前面的出现正则0次或一次.： 匹配任意字符\n\t1,2.3,4,5.a,c.*: acb,aaa,weaijdiajdw,desd.*?: 非贪婪匹配\d: 匹配任何数字 [0-9]*:002121,5498464\s: 匹配任意空白符 \n\t\v\r\f\w: 匹配任何数字，字母，字符 [A-Za-z0-9][u4e00-u9fa5] ：匹配中文a|b a,b1|2 1,2&#123;int&#125;:指明正则出现的次数+：匹配前面出现的正则一次或多次?：0次或一次*：0次或多次^:匹配开头$:匹配结尾^$:空[^A-Z]: 除了A-Z都匹配匹配双字节字符(包括汉字在内)：1[^\x00-\xff]匹配空白行的正则表达式：1\n\s*\r匹配HTML标记的正则表达式：1&lt;(\s*?)[^&gt;]*&gt;.*?|&lt;.*?&gt;匹配首尾空白字符的正则表达式：1^\s*|\s*$匹配Email地址的正则表达式：1\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*匹配网址URL的正则表达式：1[a-zA-z]+://[^\s]*匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：1^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$匹配国内电话号码：1\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;匹配腾讯QQ号：1[1-9][0-9]&#123;4,&#125;匹配中国邮政编码：12[1-9]\d&#123;5&#125;(?!\d)评注：中国邮政编码为6位数字匹配身份证：12\d&#123;15&#125;|\d&#123;18&#125;评注：中国的身份证为15位或18位匹配ip地址：12\d+\.\d+\.\d+\.\d+评注：提取ip地址时有用匹配特定数字：1234567891011^[1-9]\d*$ //匹配正整数^-[1-9]\d*$ //匹配负整数^-?[1-9]\d*$ //匹配整数^[1-9]\d*|0$ //匹配非负整数（正整数 + 0）^-[1-9]\d*|0$ //匹配非正整数（负整数 + 0）^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ //匹配正浮点数^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ //匹配负浮点数^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ //匹配浮点数^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ //匹配非负浮点数（正浮点数 + 0）^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$ //匹配非正浮点数（负浮点数 + 0）评注：处理大量数据时有用，具体应用时注意修正匹配特定字符串：12345^[A-Za-z]+$ //匹配由26个英文字母组成的字符串^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串^[a-z]+$ //匹配由26个英文字母的小写组成的字符串^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串^\w+$ //匹配由数字、26个英文字母或者下划线组成的字符串]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解释器介绍]]></title>
    <url>%2F2019%2F06%2F26%2Fthree%2F</url>
    <content type="text"><![CDATA[CPython当我们从Python官方网站下载并安装好Python 3.x后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。IPythonIPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。CPython用&gt;&gt;&gt;作为提示符，而IPython用In [序号]:作为提示符。JpythonJython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。PyPyPyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术（just-in-time compiler 即时编译器，通俗解释就是边编译边执行），对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。、IronPythonIronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。]]></content>
      <categories>
        <category>Python</category>
        <category>编译器介绍</category>
      </categories>
      <tags>
        <tag>python编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2019%2F06%2F23%2Ftow%2F</url>
    <content type="text"><![CDATA[Linux管理文件和目录的命令命令功能命令功能pwd显示当前目录ls查看目录下的内容cd改变所在目录cat显示文件的内容grep在文件中查找某字符cp复制文件touch创建文件mv移动文件rm删除文件rmdir删除目录pwd命令该命令的英文解释为print working directory(打印工作目录)。输入pwd命令，Linux会输出当前目录。cd命令cd命令用来改变所在目录。1234cd / 转到根目录中 cd ~ 转到/home/user用户目录下 cd /usr 转到根目录下的usr目录中-------------绝对路径 cd test 转到当前目录下的test子目录中-------相对路径ls命令​ ls命令用来查看目录的内容。选项含义-a列举目录中的全部文件，包括隐藏文件-l列举目录中的细节，包括权限、所有者、组群、大小、创建日期、文件是否是链接等-f列举的文件显示文件类型-r逆向，从后向前地列举目录中内容-R递归，该选项递归地列举当前目录下所有子目录内的内容-s大小，按文件大小排序-h以人类可读的方式显示文件的大小，如用K、M、G作单位ls -l examples.doc列举文件examples.doc的所有信息cat命令123cat命令可以用来合并文件，也可以用来在屏幕上显示整个文件的内容。cat snow.txt 该命令显示文件snow.txt的内容，ctrl+D退出cat。grep命令12345grep命令的最大功能是在一堆文件中查找一个特定的字符串。 grep money test.txt 以上命令在test.txt中查找money这个字符串，grep查找是区分大小写的touch命令​123touch命令用来创建新文件，他可以创建一个空白的文件，可以在其中添加文本和数据。 touch newfile 该命令创建一个名为newfile的空白文件。cp命令​ cp命令用来拷贝文件，要复制文件，输入命令：12cp &lt;source filename&gt; &lt;target filename&gt;cp t.txt Document/t 该命令将把文件t.txt复制到Document目录下，并命名为t。选项含义-i互动：如果文件将覆盖目标中的文件，他会提示确认-r递归：这个选项会复制整个目录树、子目录以及其他-v详细：显示文件的复制进度mv命令​ mv命令用来移动文件。选项说明-i互动：如果选择的文件会覆盖目标中的文件，他会提示确认-f强制：它会超越互动模式，不提示地移动文件，属于很危险的选项-v详细：显示文件的移动进度​ mv t.txt Document 把文件t.txt 移动到目录Document中。rm命令​ rm命令用来删除文件。选项说明-i互动：提示确认删除-f强制：代替互动模式，不提示确认删除-v详细：显示文件的删除进度-r递归：将删除某个目录以及其中所有的文件和子目录​ rm t.txt 该命令删除文件t.txtrmdir命令​ rmdir命令用来删除目录。mkdir 命令1234567#单个文件夹创建mkdir 文件夹名称#例如：mkdir wenjianjia#多个文件夹创建mkdirs 文件夹1/文件夹2......\#例如：mkdirs wenjianjia1/wenjianjia2chmod命令详解作用：改变一个或多个文件的存取模式(mode)格式：chmod [options] mode files只能文件属主或特权用户才能使用该功能来改变文件存取模式。mode：可以是数字形式或以who opcode permission形式表示。who是可选的，默认是a(所有用户)。只能选择一个opcode(操作码)。可指定多个mode，以逗号分开。综上，包含options、who、opcode、permission等选项，下面分别进行介绍options：标识含义-c，–changes只输出被改变文件的信息-f，–silent，–quiet当chmod不能改变文件模式时，不通知文件的用户–help输出帮助信息。-R，–recursive可递归遍历子目录，把修改应到目录下所有文件和子目录–reference=filename参照filename的权限来设置权限-v，–verbose无论修改是否成功，输出每个文件的信息–version输出版本信息who标识含义u用户g组o其它a所有用户(默认)opcode标识含义+增加权限-删除权限=重新分配权限permission标识含义r读w写x执行s设置用户(或组)的ID号t设置粘着位(sticky bit)，防止文件或目录被非属主删除作为选择，我们多数用三位八进制数字的形式来表示权限，第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限。如6(4+2)代表有读写权，7(4+2+1)有读、写和执行的权限。还可设置第四位，它位于三位权限序列的前面，第四位数字取值是4，2，1，代表意思如下：4，执行时设置用户ID，用于授权给基于文件属主的进程，而不是给创建此进程的用户。2，执行时设置用户组ID，用于授权给基于文件所在组的进程，而不是基于创建此进程的用户。1，设置粘着位。实例：12345678$ chmod u+x file 给file的属主增加执行权限$ chmod 751 file 给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限$ chmod u=rwx,g=rx,o=x file 上例的另一种形式$ chmod =r file 为所有用户分配读权限$ chmod 444 file 同上例$ chmod a-wx,a+r file 同上例$ chmod -R u+r directory 递归地给directory目录下所有文件和子目录的属主分配读的权限$ chmod 4755 设置用ID，给属主分配读、写和执行权限，给组和其他用户分配读、执行的权限。linux下链接ln –s 源文件 目标文件]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
</search>
