<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[妹子图爬虫（爬取妹子图图片）]]></title>
    <url>%2F2019%2F07%2F22%2Fpython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[python实现妹子图爬虫（爬取妹子网图片） 一个简单的小爬虫实现爬取妹子图网站上的图片。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#coding=utf-8import requestsfrom bs4 import BeautifulSoupimport osall_url = 'http://www.mzitu.com'#http请求头Hostreferer = &#123; 'User-Agent':'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)', 'Referer':'http://www.mzitu.com' &#125;Picreferer = &#123; 'User-Agent':'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)', 'Referer':'http://i.meizitu.net'&#125;#此请求头破解盗链start_html = requests.get(all_url,headers = Hostreferer)#保存地址path = "D:\\mzitu\\"#找寻最大页数soup = BeautifulSoup(start_html.text,"html.parser")page = soup.find_all('a',class_='page-numbers')max_page = page[-2].textsame_url = 'http://www.mzitu.com/all/'for n in range(1,int(max_page)+1): ul = same_url+str(n) start_html = requests.get(ul, headers = Hostreferer) soup = BeautifulSoup(start_html.text,"html.parser") all_a = soup.find('div',class_='all').find_all('a',target='_blank') for a in all_a: title = a.get_text() #提取文本 if(title != ''): print("准备扒取："+title) #win不能创建带？的目录 if(os.path.exists(path+title.strip().replace('?',''))): #print('目录已存在') flag=1 else: os.makedirs(path+title.strip().replace('?','').replace(':', '')) flag=0 os.chdir(path + title.strip().replace('?','').replace(':', '')) href = a['href'] html = requests.get(href,headers = Hostreferer) mess = BeautifulSoup(html.text,"html.parser") pic_max = mess.find_all('span') try: pic_max = pic_max[9].text #最大页数 if(flag == 1 and len(os.listdir(path+title.strip().replace('?',''))) &gt;= int(pic_max)): print('已经保存完毕，跳过') continue for num in range(1, int(pic_max)+1): pic = href+'/'+str(num) html = requests.get(pic,headers = Hostreferer) mess = BeautifulSoup(html.text,"html.parser") pic_url = mess.find('img',alt = title) print(pic_url['src']) #exit(0) html = requests.get(pic_url['src'],headers = Picreferer) file_name = pic_url['src'].split(r'/')[-1] f = open(file_name,'wb') f.write(html.content) f.close() except Exception: pass print('完成 ') print('第',n,'页完成')原文参考：https://blog.csdn.net/baidu_35085676/article/details/68958267]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>爬虫实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据之Hadoop]]></title>
    <url>%2F2019%2F07%2F14%2Fhadoop%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Hadoop介绍组成部分 Hadoop主要由3部分组成： Mapreduce编程模型 HDFS分布式文件存储 YARN 配置信息管理员密码：admin123 DNS1=202.103.24.68DNS2=202.103.44.150 export HADOOP_HOME=/usr/local/hadoop-2.6.4export PATH=$HADOOP_HOME/bin$PATH:/usr/java/jdk1.8.0_201-amd64/bin Hadoop HDFS 简介概念： namenode：负责记录 数据块 的分布情况– 数据元数据信息datanode:负责实际存储 数据块block：是Hadoop最小存储数据单位 默认 128Msecondarynamenode: 辅助namenode完成fsimage管理或者优化 HDFS简单命令 hadoop version //查看版本 hadoop fs //文件系统客户端 hadoop jar //运行jar包 hadoop classpath //查看类路径 hadoop checknative //检查本地库并压缩 hadoop distcp // 远程递归拷贝文件 hadoop credential //认证 hadoop trace //跟踪 $ hdfs dfs -mkdir-p /user/ubuntu/ //在hdfs上建立文件夹 $ hdfs dfs -puthdfs.cmd /user/ubuntu/ //将本地文件上传到HDFS $ hdfs dfs -get/user/ubuntu/hadoop.cmd a.cmd //将文件从HDFS取回本地 $ hdfs dfs -rm -r -f /user/ubuntu/ //删除 $ hdfs dfs -ls -R/ //递归展示HDFS文件系统 一、hadoop所在目录cd usr/local/hadoop1 二、启动hadoopbash ./starth.sh% 运行start-dfs.sh% 运行start-yarn.sh123 启动dfs，浏览器查看： 172.16.31.17:500701 启动脚本，浏览器查看： 172.16.31.17:80881 停止脚本： bash ./stoph.sh1三、常用命令 1.显示hadoop目录结构 hdfs dfs -ls -R /1 2.在hadoop指定目录内创建新目录 hdfs dfs -mkdir /winnie1 3.将本地文件夹存储至hadoop hdfs dfs -put [本地目录] [hadoop目录]1 4.将本地文件存储至hadoop hdfs dfs -put [本地地址] [hadoop目录]1 5.查看指定目录下内容 hdfs dfs -ls [文件目录]1 6.打开某个已存在文件 hdfs dfs -cat [file_path]1 7.在hadoop指定目录下新建一个空文件 hdfs dfs -touchz /winnie/test03.txt1 8.将hadoop上某个文件重命名 hdfs dfs -mv /winnie/test03.txt /winnie/test.txt1 9.将hadoop上某个文件down至本地已有目录下 hdfs dfs -get [文件目录] [本地目录]1 10.将hadoop指定目录下所有内容保存为一个文件，同时down至本地 hdfs dfs -getmerge /winnie/hadoop-file /home/spark/hadoop-file/test.txt1 11.删除hadoop上指定文件 hdfs dfs -rm [文件地址]1 12.删除hadoop上指定文件夹（包含子目录等） hdfs dfs -rm -r [目录地址]hdfs dfs -rmr [目录地址]12 13.将正在运行的hadoop作业kill掉 hadoop job -kill [job-id]114.查看帮助 hdfs dfs -help1四、安全模式1.退出安全模式 NameNode在启动时会自动进入安全模式，安全模式是NameNode的一种状态，在这个阶段，文件系统不允许有任何修改。 系统显示Name node in safe mode，说明系统正处于安全模式，这时只需要等待几十秒即可，也可通过下面的命令退出安全模式： /usr/local/hadoop$bin/hadoop dfsadmin -safemode leave1 2.进入安全模式 在必要情况下，可以通过以下命令吧HDFS置于安全模式： /usr/local/hadoop$bin/hadoop dfsadmin -safemode enter1 五、补充 1.对hdfs操作的命令格式是hdfs dfs 1.1 -ls 表示对hdfs下一级目录的查看1.2 -lsr 表示对hdfs目录的递归查看1.3 -mkdir 创建目录1.4 -put 从Linux上传文件到hdfs1.5 -get 从hdfs下载文件到linux1.6 -text 查看文件内容1.7 -rm 表示删除文件1.7 -rmr 表示递归删除文件 2.hdfs在对数据存储进行block划分时，如果文件大小超过block，那么按照block大小进行划分；不如block size的，划分为一个块，是实际数据大小。 3.hadoop常用命令： hdfs dfs 查看Hadoop HDFS支持的所有命令hdfs dfs –ls 列出目录及文件信息hdfs dfs –lsr 循环列出目录、子目录及文件信息hdfs dfs –tail /user/sunlightcs/test.txt 查看最后1KB的内容 hdfs dfs –copyFromLocal test.txt /user/sunlightcs/test.txt 从本地文件系统复制文件到HDFS文件系统，等同于put命令hdfs dfs –copyToLocal /user/sunlightcs/test.txt test.txt 从HDFS文件系统复制文件到本地文件系统，等同于get命令 hdfs dfs –chgrp [-R] /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录所属群组，选项-R递归执行，跟linux命令一样hdfs dfs –chown [-R] /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录拥有者，选项-R递归执行hdfs dfs –chmod [-R] MODE /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录权限，MODE可以为相应权限的3位数或+/-{rwx}，选项-R递归执行 hdfs dfs –count [-q] PATH 查看PATH目录下，子目录数、文件数、文件大小、文件名/目录名hdfs dfs –cp SRC [SRC …] DST 将文件从SRC复制到DST，如果指定了多个SRC，则DST必须为一个目录hdfs dfs –du PATH 显示该目录中每个文件或目录的大小hdfs dfs –dus PATH 类似于du，PATH为目录时，会显示该目录的总大小 hdfs dfs –expunge 清空回收站，文件被删除时，它首先会移到临时目录.Trash/中，当超过延迟时间之后，文件才会被永久删除 hdfs dfs –getmerge SRC [SRC …] LOCALDST [addnl] 获取由SRC指定的所有文件，将它们合并为单个文件，并写入本地文件系统中的LOCALDST，选项addnl将在每个文件的末尾处加上一个换行符 hdfs dfs –test –[ezd] PATH 对PATH进行如下类型的检查：-e PATH是否存在，如果PATH存在，返回0，否则返回1；-z 文件是否为空，如果长度为0，返回0，否则返回1； -d 是否为目录，如果PATH为目录，返回0，否则返回1 hdfs dfs –text PATH 显示文件的内容，当文件为文本文件时，等同于cat；文件为压缩格式（gzip以及hadoop的二进制序列文件格式）时，会先解压缩 hdfs dfs –help ls 查看某个[ls]命令的帮助文档 Mapreduce解释 mapper的角色:hadoop将用户提交的mapper可执行程序或脚本作为一个单独的进程加载起来，这个进程我们称之为mapper进程，hadoop不断地将文件片段转换为行，传递到我们的mapper进程中，mapper进程通过标准输入的方式一行一行地获取这些数据，然后设法将其转换为键值对，再通过标准输出的形式将这些键值对按照一对儿一行的方式输出出去。 虽然在我们的mapper函数中，我们自己能分得清key/value(比方说有可能在我们的代码中使用的是string key,int value)，但是当我们采用标准输出之后，key value是打印到一行作为结果输出的(比如sys.stdout.write(“%s\t%s\n”%(birthyear,gender)))，因此我们为了保证hadoop能从中鉴别出我们的键值对，键值对中一定要以分隔符’\t’即Tab(也可自定义分隔符)字符分隔，这样才能保证hadoop正确地为我们进行partitoner、shuffle等等过程。 reducer的角色:hadoop将用户提交的reducer可执行程序或脚本同样作为一个单独的进程加载起来，这个进程我们称之为reducer进程，hadoop不断地将键值对(按键排序)按照一对儿一行的方式传递到reducer进程中，reducer进程同样通过标准输入的方式按行获取这些键值对儿，进行自定义计算后将结果通过标准输出的形式输出出去。 在reducer这个过程中需要注意的是：传递进reducer的键值对是按照键排过序的，这点是由MR框架的sort过程保证的，因此如果读到一个键与前一个键不同，我们就可以知道当前key对应的pairs已经结束了，接下来将是新的key对应的pairs。]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop介绍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据科学之统计学习]]></title>
    <url>%2F2019%2F07%2F14%2F%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[统计学中心倾向 均值（常用的额） 中位数 分位数：它表示少于数据中特定百分比的一个值 众数 离散度 极差 方差 统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数 概率论中方差用来度量随机变量)和其数学期望（即均值）之间的偏离程度 计算公式 $$s^2 = \frac{\sum_{}(x-u)^2}{N}$$ 标准差 中文环境中又常称均方差，是离均差平方的算术平均数的平方根，用σ表示。标准差是方差的算术平方根 计算公式 $$σ = \sqrt\frac{\sum_{}(x-u)^2}{N}$$ 相关性 协方差 协方差（Covariance）在概率论和统计学中用于衡量两个变量的总体误差。而方差是协方差的一种特殊情况，即当两个变量是相同的情况。 计算公式 概率论不独立和独立 如果事件E和事件F独立意味着两个事同时发生的概率等于它们分别发生的概率的乘积。 $$P（E, F） = P(E)*P(F)$$ 条件概率 如果事件E与事件F独立，那么定义： $$P（E, F） = P(E)*P(F)$$ 如果两者不一定独立（并且概率都不为0），那么概率公式为：（已知F发生，在此条件下E发生的概率）$$P（E|F） = P（E, F）/P（F）$$]]></content>
      <categories>
        <category>统计学和概率论</category>
      </categories>
      <tags>
        <tag>数学知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之百度接口语音识别]]></title>
    <url>%2F2019%2F07%2F12%2F%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[python编程之百度接口语音识别 首先在百度AI开放平台上创建语音识别应用，创建完毕应用后，得到系统分配给用户的AppID， API Key， secret Key，均为字符串，用于标识用户，为访问做签名验证。 得到验证后，开始编程 1.记录自己声音 2.将记录下来的音频文件上传至云端 3.解析返回后的结果 python实现 相关包 pyaudio，baidu-aip 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from aip import AipSpeechimport wavefrom pyaudio import PyAudio, paInt16def save_wave_file(filename, data): '''save the date to the wavfile''' wf = wave.open(filename, 'wb') wf.setnchannels(channels) wf.setsampwidth(sampwidth) wf.setframerate(framerate) wf.writeframes(b"".join(data)) wf.close()def my_record(): pa = PyAudio() stream = pa.open(format=paInt16, channels=1, rate=framerate, input=True, frames_per_buffer=NUM_SAMPLES) my_buf = [] count = 0 print('录音开始') while count &lt; TIME*10: # 控制录音时间 string_audio_data = stream.read(NUM_SAMPLES) my_buf.append(string_audio_data) count += 1 print('录音结束') save_wave_file('01.pcm', my_buf) stream.close()if __name__ == "__main__": framerate = 16000 NUM_SAMPLES = 2000 channels = 1 sampwidth = 2 TIME = 2 my_record() """ 我的 APPID AK SK """ APP_ID = '16795182 ' API_KEY = '8io5s7uv8pjYPUrQp1i8PcIg' SECRET_KEY = 'gK2MljvbcF3SKS4p0C2ieq1SCBNY48BD' client = AipSpeech(APP_ID, API_KEY, SECRET_KEY) # 读取文件 def get_file_content(filePath): with open(filePath, 'rb') as fp: return fp.read() # 识别本地文件 result = client.asr(get_file_content('01.pcm'), 'pcm', 16000, &#123; 'dev_pid': 1536, &#125;) # print(type(result)) print("语音识别结果：", result['result'])]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>语音识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据科学之数据可视化]]></title>
    <url>%2F2019%2F07%2F11%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数据可视化概述 可视化的目的，是对数据进行可视化处理，以更明确地，有效的传递信息。 数据可视化意义 数据可视化是为了从数据中寻找三个方面的信息。 模式。指数据中的规律。 关系。指数据间的相关性。 数据间的比较 数据的构成 数据的分布或联系 异常。指有问题的数据。 数据可视化的作用 记录信息。用图形的方式描述各种具体或抽象的事物。 分析推理。有效的提升了信息认知的效率，从而有助于人们更快地分析和推理出有效信息。 信息传播和协同。 数据可视化的分类 科学可视化 信息可视化 可视分析学 数据可视化基础 数据类型 根据数据模型，可将数据分为 浮点数，整数，字符等 根据概念模型 类别型数据，有序型数据，区间型数据和比值型数据 类别型数据：用于区分物体 有序型数据：用来表示对象间的顺序关系 区间型数据：用于得到对象间的定量关系。 用于比较数值间的比列关系，可以精确地定义比例 数据预处理 数据的预处理的目的是提升数据质量 数据质量包含以下六方面 有效性：数据与实际情况对应时，是否违背约束条件 准确性：数据能否精确的反映现实。 完整性：采集数据集是否包含了数据源中 的所有数据点：且样本的属性都是完整的。 一致性：整个数据集中的数据的衡量标准要一致 时效性：数据适合当下时间区间内的分析任务 可行性：数据源中的数据是使用者可依赖的。 数据预处理步骤如下 数据清理：指修正数据中的错误，识别脏数据，更正不一致数据的过程。 数据集成：指把来自不同数据的同类数据进行合并，减少数据冲突，降低数据冗余程度等。 数据归约：指在保证数据挖掘结果准确性的前提下，最大限度地精简数据量，得到简化的数据集。 数据转换：指对数据进行规范化处理 数据组织与管理 大数据存储利用的是分布式存储与访问计数，它具有高效，容错性强等特点。 分布式文件系统 分布式文件系统是指文件在物理上可能被分散存储在不同地点的节点上，各节点通过计算机网络进行通信和数据传输，但仍然是一个完整的文件。常用的分布式系统有HDFS（hadoop分布式文件系统），GFS（Google分布式文件系统）等。 文档存储 文档存储支持对结构化数据的访问，一般以键值对的方式进行存储。 文档存储类型也支持数组和列值键 列式存储 列式存储是指以流的方式在列中存储所有的数据 键式存储 以Key-Value存储，简称KV存储 图形数据库 图形数据库是NOSQL数据库的一种，是一种非关系型的数据库，它应用图形理论存储实体间的关系信息。 关系型数据库 关系模型是最传统的数据存储模型，数据按行存储在有架构界定的表中。用户可使用基于关系代数演算的结构化查询语言提供相应的语法查找符合条件的记录。 内存数据库 内存数据库就是将数据放在内存中直接操作的数据库。特点速度快，能处理实时型业务 数据仓库 数据仓库是一种特殊的数据库，一般用于存储海量数据，并直接支持后续的分析和决策操作。 数据分析与数据挖掘 数据分析 统计分析 是指对数据进行统计描述和统计推断的过程 探索性数据分析 是对调查，观测所得到的一些初步的杂乱无章的数据，在尽量少的先验假设下进行处理，通过作图，制表等形式和方程拟合，计算某些特征量等手段，探索数据的结构和规律的一种数据分析方法。 验证性数据分析 是指在已经有事先假设的关系模型等情况下，通过数据分析来验证已提出的假设 在线分析和处理 是一种交互式探索大规模多维数据集的方法。 数据挖掘 数据挖掘一般是指从大量的数据中通过算法搜索隐藏于其中的信息的过程。 常见的数据挖掘分析方法有分类与预测，聚类分析，关联性分析和异常分析等。 分类与预测 聚类分析 关联分析 异常分析 数据挖掘的步骤 确定业务对象 数据准备 数据挖掘 结果分析 知识的同化]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>数据可视化概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站概念]]></title>
    <url>%2F2019%2F07%2F06%2Fserven%2F</url>
    <content type="text"><![CDATA[网站的组成 目前多数网站由域名，空间服务器，DNS域名解析，网站程序和数据库等组成 空间服务器（以下三种类型） 虚拟主机：指在网络服务器上划分一定的磁盘空间供用户放置站点和应用组件等，提供必要的站点功能，数据存放和传输功能。所谓虚拟主机，也叫“网站空间”，就是把一台运行在互联网上的服务器划分成多个”虚拟“的服务器 独立服务器：指性能更强大，整体硬件完全独立的服务器，其cpu都在8核以上。 VPS（虚拟专用服务器）：将一个服务器分区成多个虚拟独立专享服务器的技术。 网站的程序:是建设与修改网站所使用的编程语言。 网站的分类 资讯门户类网站 企业品牌网站 交易类网站 B2C（Business To Consumer）网站：商家——消费者，主要是购物网站，用于商家和消费者之间的买卖，如传统的百货商店和购物广场。 B2B（Business To Business）网站：商家——商家，主要是商务网站，用于商家之间的买卖，如传统的原材料市场和大型批发市场 C2C（Consumer To Consumer）网站：消费者——消费者，主要以拍卖网站为主，用于个人的物品的买卖，如传统的旧货市场，跳骚市场，废品收购站等。 办公及政府机构网站 企业办公事物类网站 政府办公类事物网站 互动游戏网站 功能性网站 这类网站的主要特征是将一个具有广泛需求的共能扩展开来，开发一套强大的功能体系，将功能的实现推向极致。如：百度，goolge 网站开发的常用术语域名：用于标识一个或多个ip地址 DNS：域名系统，用于跟踪计算机的域名及其在互联网上的相应的IP地址]]></content>
      <categories>
        <category>网站知识</category>
      </categories>
      <tags>
        <tag>网站的基本概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法时间复杂度和五大经典排序算法]]></title>
    <url>%2F2019%2F06%2F29%2Fsix%2F</url>
    <content type="text"><![CDATA[渐进时间度表 O记法所代表的是渐进上界限，Ω记法代表的是渐进下界 Θ代表的集合是上述符号的交集，Θ(g) = O(g) 常见的渐进运行时间实例 时间复杂度 相关名称 相关实例及说明 Θ（1） 常数级 哈希表的查询和修改 Θ（lg n） 对数级 二分搜索，其对数基数并不重要 Θ（n） 线性级 列表的遍历 Θ(nlgn) 线性对数级 任意值序列的最优化排序，其复杂度等同于Θ(lg n!) Θ(n^2) 平方级 拿n个对象进行互相比对 Θ(n^3) 立方级 Floyd-Warshall算法 O(n^k) 多项式级 基于n的k层嵌套循环（k为整数），且必须满足K &gt; 0 Ω(K^n) 指数级 每n项产生一个子集（其中k = 2），且必须满足K &gt; 1 Θ(n!) 阶乘级 对n个值执行全排列操作 冒泡排序 冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 冒泡排序算法的运作如下： 1、比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。 2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 3、针对所有的元素重复以上的步骤，除了最后一个。 4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 ‘’’ 冒泡排序的时间复杂度为O(n^2)。 1234567891011121314151617181920212223def store(x): '''冒泡排序算法实现''' f=0 while f &lt; len(x): i=0 j=1 while j &lt; len(x): if x[i] &lt;= x[j]: i = i + 1 j = j + 1 elif x[i] &gt; x[j]: var1 = x[i] var2 = x[j] x[j] = var1 x[i] = var2 i = i + 1 j = j + 1 f = f + 1 return xif __name__ == "__main__": test = [2,4,6,5,9,7,12,15,13,19,20,1,3] print(store(test)) 归并排序 归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表， 即把待排序序列分为若干个子序列，每个子序列是有序的。 然后再把有序子序列合并为整体有序序列。 空间复杂度为O(n)，时间复杂度为O(nlogn)。 123456789101112131415161718192021222324252627282930313233def merge_extend(x): '''归并排序算法''' # 拆分列表 if len(x) &lt;= 1: # 向下取整数 return x mid = len(x)//2 left = merge_extend(x[:mid]) right = merge_extend(x[mid:]) print(left,right) return merge_add(left, right)def merge_add(a, b): '''和并列表''' result = [] i = 0 j = 0 while i &lt; len(a) and j &lt; len(b): if a[i] &lt; b[j]: result.append(a[i]) i += 1 else: result.append(b[j]) j += 1 #print("a",a[i:]) #print("b",b[j:]) result.extend(a[i:]) result.extend(b[j:]) return resultif __name__ == "__main__": test=[11,0,5,7,3,6,8,1,2] print(merge_extend(test)) 插入排序 插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列， 对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 简单插入排序的时间复杂度也是O(n^2) 123456789101112def insert_sort(x): # 取列表的第一个元素为单独的一个，已经排好序的列表 for i in range(1, len(x)): # 要排序的的牌 for j in range(0, i): if x[i] &lt; x[j]: x[i], x[j] = x[j], x[i] return xif __name__=="__main__": test = [2,3,5,7,9,1,20,0,4,12,19,11,8,1] print(insert_sort(test)) 选择排序 选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置， 然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。 选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上， 因此对n个元素的表进行排序总共进行至多n-1次交换。 在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。 选择排序的时间复杂度为O(n^2) 1234567891011def select_sort(x): '''选择排序''' new = [] while x: new.append(min(x)) x.remove(min(x)) return newif __name__=="__main__": test = [2,3,5,7,9,1,20,0,4,12,19,11,8,1] print(select_sort(test)) 快速排序 1.先从待排序的数组中找出一个数作为基准数（取第一个数即可）， 2.然后将原来的数组划分成两部分：小于基准数的左子数组和大于等于基准数的右子数组。 3.然后对这两个子数组再递归重复上述过程，直到两个子数组的所有数都分别有序。 4.最后返回“左子数组” + “基准数” + “右子数组”，即是最终排序好的数组。 快速排序是不稳定的，其时间平均时间复杂度是O(nlgn) 1234567891011121314151617def quick_sort(x): '''快速排序''' if len(x) &lt;= 1: return x base = x[0] left = [] right = [] for var in x: if var &gt; base: right.append(var) elif var &lt; base: left.append(var) return quick_sort(left) + [base] + quick_sort(right)if __name__ == "__main__": # 存在重复值被覆盖 test = [2,6,7,8,12,56,36,89,45,3]]]></content>
      <categories>
        <category>算法</category>
        <category>五大经典排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git文章更新测试]]></title>
    <url>%2F2019%2F06%2F28%2Ffive%2F</url>
    <content type="text"><![CDATA[这是一个测试文件 test]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>测试文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的正则表达式]]></title>
    <url>%2F2019%2F06%2F26%2Ffour%2F</url>
    <content type="text"><![CDATA[匹配小数1[0-9]&#123;1,&#125;[.][0-9]* 匹配整数1[0-9] 中文的匹配1[\u4e00-\u9fa5] 特殊符号和字符：123456789101112131415161718192021[A-Z0-9a-z]: A,1,a[abc]*: aaa,abc,acc,匹配前面的正则0次或多次a？: a,匹配前面的出现正则0次或一次.： 匹配任意字符\n\t1,2.3,4,5.a,c.*: acb,aaa,weaijdiajdw,desd.*?: 非贪婪匹配\d: 匹配任何数字 [0-9]*:002121,5498464\s: 匹配任意空白符 \n\t\v\r\f\w: 匹配任何数字，字母，字符 [A-Za-z0-9][u4e00-u9fa5] ：匹配中文a|b a,b1|2 1,2&#123;int&#125;:指明正则出现的次数+：匹配前面出现的正则一次或多次?：0次或一次*：0次或多次^:匹配开头$:匹配结尾^$:空[^A-Z]: 除了A-Z都匹配 匹配双字节字符(包括汉字在内)：1[^\x00-\xff] 匹配空白行的正则表达式：1\n\s*\r 匹配HTML标记的正则表达式：1&lt;(\s*?)[^&gt;]*&gt;.*?|&lt;.*?&gt; 匹配首尾空白字符的正则表达式：1^\s*|\s*$ 匹配Email地址的正则表达式：1\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)* 匹配网址URL的正则表达式：1[a-zA-z]+://[^\s]* 匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：1^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 匹配国内电话号码：1\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125; 匹配腾讯QQ号：1[1-9][0-9]&#123;4,&#125; 匹配中国邮政编码：12[1-9]\d&#123;5&#125;(?!\d)评注：中国邮政编码为6位数字 匹配身份证：12\d&#123;15&#125;|\d&#123;18&#125;评注：中国的身份证为15位或18位 匹配ip地址：12\d+\.\d+\.\d+\.\d+评注：提取ip地址时有用 匹配特定数字：1234567891011^[1-9]\d*$ //匹配正整数^-[1-9]\d*$ //匹配负整数^-?[1-9]\d*$ //匹配整数^[1-9]\d*|0$ //匹配非负整数（正整数 + 0）^-[1-9]\d*|0$ //匹配非正整数（负整数 + 0）^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ //匹配正浮点数^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ //匹配负浮点数^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ //匹配浮点数^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ //匹配非负浮点数（正浮点数 + 0）^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$ //匹配非正浮点数（负浮点数 + 0）评注：处理大量数据时有用，具体应用时注意修正 匹配特定字符串：12345^[A-Za-z]+$ //匹配由26个英文字母组成的字符串^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串^[a-z]+$ //匹配由26个英文字母的小写组成的字符串^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串^\w+$ //匹配由数字、26个英文字母或者下划线组成的字符串]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解释器介绍]]></title>
    <url>%2F2019%2F06%2F26%2Fthree%2F</url>
    <content type="text"><![CDATA[CPython 当我们从Python官方网站下载并安装好Python 3.x后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。 IPython IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。 CPython用&gt;&gt;&gt;作为提示符，而IPython用In [序号]:作为提示符。 Jpython Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。 PyPy PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术（just-in-time compiler 即时编译器，通俗解释就是边编译边执行），对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。 绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。、 IronPython IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。]]></content>
      <categories>
        <category>Python</category>
        <category>编译器介绍</category>
      </categories>
      <tags>
        <tag>python编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2019%2F06%2F23%2Ftow%2F</url>
    <content type="text"><![CDATA[Linux管理文件和目录的命令 命令 功能 命令 功能 pwd 显示当前目录 ls 查看目录下的内容 cd 改变所在目录 cat 显示文件的内容 grep 在文件中查找某字符 cp 复制文件 touch 创建文件 mv 移动文件 rm 删除文件 rmdir 删除目录 pwd命令 该命令的英文解释为print working directory(打印工作目录)。输入pwd命令，Linux会输出当前目录。 cd命令 cd命令用来改变所在目录。 1234cd / 转到根目录中 cd ~ 转到/home/user用户目录下 cd /usr 转到根目录下的usr目录中-------------绝对路径 cd test 转到当前目录下的test子目录中-------相对路径 ls命令 ​ ls命令用来查看目录的内容。 选项 含义 -a 列举目录中的全部文件，包括隐藏文件 -l 列举目录中的细节，包括权限、所有者、组群、大小、创建日期、文件是否是链接等 -f 列举的文件显示文件类型 -r 逆向，从后向前地列举目录中内容 -R 递归，该选项递归地列举当前目录下所有子目录内的内容 -s 大小，按文件大小排序 -h 以人类可读的方式显示文件的大小，如用K、M、G作单位 ls -l examples.doc 列举文件examples.doc的所有信息 cat命令123cat命令可以用来合并文件，也可以用来在屏幕上显示整个文件的内容。cat snow.txt 该命令显示文件snow.txt的内容，ctrl+D退出cat。 grep命令12345grep命令的最大功能是在一堆文件中查找一个特定的字符串。 grep money test.txt 以上命令在test.txt中查找money这个字符串，grep查找是区分大小写的 touch命令​123touch命令用来创建新文件，他可以创建一个空白的文件，可以在其中添加文本和数据。 touch newfile 该命令创建一个名为newfile的空白文件。 cp命令​ cp命令用来拷贝文件，要复制文件，输入命令： 12cp &lt;source filename&gt; &lt;target filename&gt;cp t.txt Document/t 该命令将把文件t.txt复制到Document目录下，并命名为t。 选项 含义 -i 互动：如果文件将覆盖目标中的文件，他会提示确认 -r 递归：这个选项会复制整个目录树、子目录以及其他 -v 详细：显示文件的复制进度 mv命令​ mv命令用来移动文件。 选项 说明 -i 互动：如果选择的文件会覆盖目标中的文件，他会提示确认 -f 强制：它会超越互动模式，不提示地移动文件，属于很危险的选项 -v 详细：显示文件的移动进度 ​ mv t.txt Document 把文件t.txt 移动到目录Document中。 rm命令​ rm命令用来删除文件。 选项 说明 -i 互动：提示确认删除 -f 强制：代替互动模式，不提示确认删除 -v 详细：显示文件的删除进度 -r 递归：将删除某个目录以及其中所有的文件和子目录 ​ rm t.txt 该命令删除文件t.txt rmdir命令 ​ rmdir命令用来删除目录。 mkdir 命令 1234567#单个文件夹创建mkdir 文件夹名称#例如：mkdir wenjianjia#多个文件夹创建mkdirs 文件夹1/文件夹2......\#例如：mkdirs wenjianjia1/wenjianjia2 chmod命令详解作用： 改变一个或多个文件的存取模式(mode) 格式： chmod [options] mode files 只能文件属主或特权用户才能使用该功能来改变文件存取模式。 mode：可以是数字形式或以who opcode permission形式表示。who是可选的，默认是a(所有用户)。只能选择一个opcode(操作码)。可指定多个mode，以逗号分开。 综上，包含options、who、opcode、permission等选项，下面分别进行介绍 options： 标识 含义 -c，–changes 只输出被改变文件的信息 -f，–silent，–quiet 当chmod不能改变文件模式时，不通知文件的用户 –help 输出帮助信息。 -R，–recursive 可递归遍历子目录，把修改应到目录下所有文件和子目录 –reference=filename 参照filename的权限来设置权限 -v，–verbose 无论修改是否成功，输出每个文件的信息 –version 输出版本信息 who 标识 含义 u 用户 g 组 o 其它 a 所有用户(默认) opcode 标识 含义 + 增加权限 - 删除权限 = 重新分配权限 permission 标识 含义 r 读 w 写 x 执行 s 设置用户(或组)的ID号 t 设置粘着位(sticky bit)，防止文件或目录被非属主删除 作为选择，我们多数用三位八进制数字的形式来表示权限，第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限。如6(4+2)代表有读写权，7(4+2+1)有读、写和执行的权限。 还可设置第四位，它位于三位权限序列的前面，第四位数字取值是4，2，1，代表意思如下： 4，执行时设置用户ID，用于授权给基于文件属主的进程，而不是给创建此进程的用户。2，执行时设置用户组ID，用于授权给基于文件所在组的进程，而不是基于创建此进程的用户。1，设置粘着位。 实例： 12345678$ chmod u+x file 给file的属主增加执行权限$ chmod 751 file 给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限$ chmod u=rwx,g=rx,o=x file 上例的另一种形式$ chmod =r file 为所有用户分配读权限$ chmod 444 file 同上例$ chmod a-wx,a+r file 同上例$ chmod -R u+r directory 递归地给directory目录下所有文件和子目录的属主分配读的权限$ chmod 4755 设置用ID，给属主分配读、写和执行权限，给组和其他用户分配读、执行的权限。 linux下链接 ln –s 源文件 目标文件]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
</search>
