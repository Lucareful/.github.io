<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[c语言笔记（3）]]></title>
    <url>%2F2019%2F10%2F22%2Fc%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[结构体结构体声明1234567struct Book&#123; 结构体成员1; 结构体成员2; 结构体成员3; ......&#125;;定义结构体类型变量struct 结构体名称 结构体变量名访问结构体变量要访问结构体成员，我们需要引入一个新的运算符——点号(.)运算符。比如book.title就是引用book结构体的title成员，它是一个字符数组。初始结构体的指定成员值其语法和数组指定初始化元素类似，不过结构体指定初始化成员使用点号（.）运算符和成员名123456789101112131415161718192021222324252627282930313233343536//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;struct Book&#123; char title[128]; char author[40]; float price; unsigned int data; char publisher[40];&#125;book;int main(void)&#123;// struct Book book1; printf("请输入书名："); scanf("%s", book.title); printf("请输入作者："); scanf("%s", book.author); printf("请输入售价："); scanf("%f", &amp;book.price); printf("请输入出版日期："); scanf("%d", &amp;book.data); printf("请输入出版社："); scanf("%s", book.publisher); printf("\n====数据录入完毕====\n\n"); printf("书名：%s\n", book.title); printf("作者：%s\n", book.author); printf("售价：%.2f\n", book.price); printf("出版日期：%d\n", book.data); printf("出版社：%s\n", book.publisher); return 0;&#125;结构体嵌套123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;struct Data&#123; int year; int month; int day;&#125;;struct Book&#123; char title[128]; char author[40]; float price; struct Data data; char publisher[40];&#125;book = &#123; // 初始化 "c学习", "Luenci", 48.8, &#123;2019,11,13&#125;, "文华出版社"&#125;;int main(void)&#123; printf("\n====数据录入为====\n\n"); printf("书名：%s\n", book.title); printf("作者：%s\n", book.author); printf("售价：%.2f\n", book.price); printf("出版日期：%d%d%d\n", book.data.year, book.data.month, book.data.day); printf("出版社：%s\n", book.publisher); return 0;&#125;out书名：c学习作者：Luenci售价：48.80出版日期：20191113出版社：文华出版社结构体数组第二种方法是先声明一个结构体类型（如上例子中Book），再用此类型定义一个结构体数组：12345678910111213struct 结构体名称&#123; 结构体成员;&#125;;struct 结构体名称 数组名[长度];// 初始化结构体数组struct Book book[3] = &#123; &#123;"《零基础学c》", "Luenci", 49.5, &#123;2016, 11, 22&#125;, "清华大学出版社"&#125;， &#123;"《零基础学c》", "Luenci", 49.5, &#123;2016, 11, 22&#125;, "清华大学出版社"&#125;， &#123;"《零基础学c》", "Luenci", 49.5, &#123;2016, 11, 22&#125;, "清华大学出版社"&#125;， &#125;；结构体指针12struct Book *ptr；ptr = &amp;book；通过结构体指针访问结构体成员(*结构体指针).成员名结构体指针-&gt;成员名1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;struct Data&#123; int year; int month; int day;&#125;;struct Book&#123; char title[128]; char author[40]; float price; struct Data data; char publisher[40];&#125;book = &#123; // 初始化 "c学习", "Luenci", 48.8, &#123;2019,11,13&#125;, "文华出版社"&#125;;int main(void)&#123; struct Book *ptr; ptr = &amp;book; printf("\n====数据录入为====\n\n"); printf("书名：%s\n", (*ptr).title); printf("作者：%s\n", (*ptr).author); printf("售价：%.2f\n", (*ptr).price); printf("出版日期：%d%d%d\n", (*ptr).data.year, (*ptr).data.month, (*ptr).data.day); printf("出版社：%s\n", (*ptr).publisher); printf("书名：%s\n", ptr-&gt;title); printf("作者：%s\n", ptr-&gt;author); printf("售价：%.2f\n", ptr-&gt;price); printf("出版日期：%d%d%d\n", ptr-&gt;data.year, ptr-&gt;data.month, ptr-&gt;data.day); printf("出版社：%s\n", ptr-&gt;publisher); return 0;&#125;out:====数据录入为====书名：c学习作者：Luenci售价：48.80出版日期：20191113出版社：文华出版社链表单链表12345graph LRhead --&gt; AA[信息域- 指针] --&gt; B[信息域- 指针]B[信息域- 指针] --&gt; c[信息域- 指针]c[信息域- 指针] --&gt; NULL头插法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// ------------ 头插法实现链表的插入 ---------------//// Created by Luenci on 2019/10/14.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Book&#123; char title[128]; char author[40]; struct Book *next;&#125;;void getInput(struct Book *book)&#123; printf("请输入书名："); scanf("%s", book-&gt;title); printf("请输入作者："); scanf("%s", book-&gt;author);&#125;void add_book(struct Book **library)&#123; struct Book *book, *temp; book = (struct Book *)malloc(sizeof(struct Book)); if(book == NULL)&#123; printf("分配内存失败"); exit(1); &#125; getInput(book); if (*library != NULL)&#123; temp = *library; *library = book; book-&gt;next = temp; &#125; else&#123; *library = book; book-&gt;next = NULL; &#125;&#125;void printLibrary(struct Book *library)&#123; struct Book *book; int count = 1; book = library; while(book != NULL)&#123; printf("Book%d: ", count); printf("书名：%s", book-&gt;title); printf("作者:%s", book-&gt;author); book = book-&gt;next; count++; &#125;&#125;void releaseLibrary(struct Book *library)&#123; while(library != NULL)&#123; library = library-&gt;next; free(library); &#125;&#125;int main(void)&#123; struct Book *library = NULL; int ch; while (1)&#123; printf("请问你是否需要录入书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; add_book(&amp;library); &#125; else&#123; break; &#125; &#125; printf("请问你是否需要打印书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; printLibrary(library); &#125; releaseLibrary(library); return 0;&#125;尾插法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//// Created by Luenci on 2019/10/14.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Book&#123; char title[128]; char author[40]; struct Book *next;&#125;;void getInput(struct Book *book)&#123; printf("请输入书名："); scanf("%s", book-&gt;title); printf("请输入作者："); scanf("%s", book-&gt;author);&#125;void add_book2(struct Book **library)&#123; /* ------------ 尾插法 ------------- */ struct Book *book,*temp; book = (struct Book *)malloc(sizeof(struct Book)); if(book == NULL)&#123; printf("分配内存失败"); exit(1); &#125; getInput(book); if (*library != NULL)&#123; temp = *library; // 定位单链表的尾部位置 while (temp-&gt;next != NULL)&#123; temp = temp-&gt;next; &#125; // 插入数据 temp-&gt;next = book; book-&gt;next = NULL; &#125; else&#123; *library = book; book-&gt;next = NULL; &#125;&#125;void printLibrary(struct Book *library)&#123; struct Book *book; int count = 1; book = library; while(book != NULL)&#123; printf("Book%d: ", count); printf("书名：%s", book-&gt;title); printf("作者:%s", book-&gt;author); book = book-&gt;next; count++; &#125;&#125;void releaseLibrary(struct Book **library)&#123; struct Book *temp; while(library != NULL)&#123; temp = *library; *library = (*library)-&gt;next; free(temp); &#125;&#125;int main(void)&#123; struct Book *library = NULL; int ch; while (1)&#123; printf("请问你是否需要录入书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; add_book2(&amp;library); &#125; else&#123; break; &#125; &#125; printf("请问你是否需要打印书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; printLibrary(library); &#125; releaseLibrary(&amp;library); return 0;&#125;尾插法改进123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178//// Created by Luenci on 2019/10/14.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct Book&#123; char title[128]; char author[40]; struct Book *next;&#125;;void getInput(struct Book *book);void add_book(struct Book **library);void getInput(struct Book *book);void add_book2(struct Book **library);void printLibrary(struct Book *library);struct Book *searchBook(struct Book *library, char *target);void releaseLibrary(struct Book **library);void printBook(struct Book *book);void getInput(struct Book *book)&#123; printf("请输入书名："); scanf("%s", book-&gt;title); printf("请输入作者："); scanf("%s", book-&gt;author);&#125;void add_book(struct Book **library)&#123; /* ----------- 头插法 ------------- */ struct Book *book, *temp; book = (struct Book *)malloc(sizeof(struct Book)); if(book == NULL)&#123; printf("分配内存失败"); exit(1); &#125; getInput(book); if (*library != NULL)&#123; temp = *library; *library = book; book-&gt;next = temp; &#125; else&#123; *library = book; book-&gt;next = NULL; &#125;&#125;void add_book2(struct Book **library)&#123; /* ------------ 尾插法 ------------- */ struct Book *book; static struct Book *tail; book = (struct Book *)malloc(sizeof(struct Book)); if(book == NULL)&#123; printf("分配内存失败"); exit(1); &#125; getInput(book); if (*library != NULL)&#123; tail-&gt;next = book; book-&gt;next = NULL; &#125; else&#123; *library = book; book-&gt;next = NULL; &#125; tail = book;&#125;void printLibrary(struct Book *library)&#123; struct Book *book; int count = 1; book = library; while(book != NULL)&#123; printf("Book%d: ", count); printf("书名：%s", book-&gt;title); printf("作者:%s", book-&gt;author); book = book-&gt;next; count++; &#125;&#125;void releaseLibrary(struct Book **library)&#123; struct Book *temp; while(library != NULL)&#123; temp = *library; *library = (*library)-&gt;next; free(temp); &#125;&#125;struct Book *searchBook(struct Book *library, char *target)&#123; struct Book *book; book = library; while (book != NULL)&#123; // C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false if (!strcmp(book-&gt;title, target) || !strcmp(book-&gt;author, target))&#123; break; &#125; book = book-&gt;next; &#125; return book;&#125;void printBook(struct Book *book)&#123; printf("书名: %s\n", book-&gt;title); printf("作者: %s\n", book-&gt;author);&#125;int main(void)&#123; struct Book *library = NULL; struct Book *book; char *input[128]; int ch; while (1)&#123; printf("请问你是否需要录入书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; add_book2(&amp;library); &#125; else&#123; break; &#125; &#125; printf("请问你是否需要打印书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; printLibrary(library); &#125; printf("\n请输入书名或作者："); scanf("%s", input); book = searchBook(library, input); if(book == NULL)&#123; printf("很抱歉没能找到！\n"); &#125; else&#123; do&#123; printf("已找到符合条件的书籍...\n"); printBook(book); &#125; while ((book = searchBook(book-&gt;next, input)) != NULL); &#125; releaseLibrary(&amp;library); return 0;&#125;链表的插入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//// Created by Luenci on 2019/10/16.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Node&#123; int value; struct Node *next;&#125;;void insertNode(struct Node **head, int value);void printNode(struct Node *head);void insertNode(struct Node **head, int value)&#123; struct Node *previous; struct Node *current; struct Node *new; current = *head; previous = NULL; while (current != NULL &amp;&amp; current-&gt;value &lt; value)&#123; previous = current; current = current-&gt;next; &#125; new = (struct Node *)malloc(sizeof(struct Node)); if (new == NULL)&#123; printf("分配内存失败！\n"); exit(1); &#125; new-&gt;value = value; new-&gt;next = current; if (previous == NULL)&#123; *head = new; &#125; else&#123; previous-&gt;next = new; &#125;&#125;void printNode(struct Node *head)&#123; struct Node *current; current = head; while (current != NULL)&#123; printf("%d ", current-&gt;value); current = current-&gt;next; &#125; putchar('\n');&#125;int main()&#123; struct Node *head = NULL; int input; while (1)&#123; printf("请输入一个整数（-1结束）："); scanf("%d", &amp;input); if(input == -1)&#123; break; &#125; insertNode(&amp;head, input); printNode(head); &#125; return 0;&#125;链表的删除123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//// Created by Luenci on 2019/10/16.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Node&#123; int value; struct Node *next;&#125;;void insertNode(struct Node **head, int value);void printNode(struct Node *head);void delectNode(struct Node **head, int value);void insertNode(struct Node **head, int value)&#123; struct Node *previous; struct Node *current; struct Node *new; current = *head; previous = NULL; while (current != NULL &amp;&amp; current-&gt;value &lt; value)&#123; previous = current; current = current-&gt;next; &#125; new = (struct Node *)malloc(sizeof(struct Node)); if (new == NULL)&#123; printf("分配内存失败！\n"); exit(1); &#125; new-&gt;value = value; new-&gt;next = current; if (previous == NULL)&#123; *head = new; &#125; else&#123; previous-&gt;next = new; &#125;&#125;void delectNode(struct Node **head, int value)&#123; struct Node *previous; struct Node *current; current = *head; previous = NULL; while (current != NULL &amp;&amp; current-&gt;value != value)&#123; previous = current; current = current-&gt;next; &#125; if (current == NULL)&#123; printf("找不到匹配的节点"); return; &#125; else&#123; if(previous == NULL)&#123; *head = current-&gt;next; &#125; else&#123; previous-&gt;next = current-&gt;next; &#125; free(current); &#125;&#125;void printNode(struct Node *head)&#123; struct Node *current; current = head; while (current != NULL)&#123; printf("%d ", current-&gt;value); current = current-&gt;next; &#125; putchar('\n');&#125;int main()&#123; struct Node *head = NULL; int input; printf("开始测试插入整数...\n"); while (1)&#123; printf("请输入一个整数（-1结束）："); scanf("%d", &amp;input); if(input == -1)&#123; break; &#125; insertNode(&amp;head, input); printNode(head); &#125; printf("开始测试删除整数...\n"); while (1)&#123; printf("请输入一个整数（-1结束）："); scanf("%d", &amp;input); if(input == -1)&#123; break; &#125; delectNode(&amp;head, input); printNode(head); &#125; return 0;&#125;内存池优点：设计内存池的目标是为了保证服务器长时间高效的运行，通过对申请空间小而申请频繁的对象进行有效管理，减少内存碎片的产生，合理分配管理用户内存，从而减少系统中出现有效空间足够，而无法分配大块连续内存的情况。结论：内存池基本上满足初期设计目标，但是她并不是完美的，有缺陷，比如,不能申请大于256字节的内存空间，无内存越界检查，无内存自动回缩功能等。只是这些对我们的影响还不是那么重要。typedef基础相比起宏定义的直接替换， typedef是对类型的封装。1234567891011121314151617181920//// Created by Luenci on 2019/10/16.//#include&lt;stdio.h&gt;typedef int integer;int main(void)&#123; integer a; int b; a = 1; b = a; printf("a = %u\n", a); printf("b = %d\n", b); printf("size of a = %d\n", sizeof(a)); return 0;&#125;123456789101112131415161718192021222324252627//// Created by Luenci on 2019/10/16.//#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Data&#123; int year; int mouth; int day;&#125; DATA, *PDATA;int main(void)&#123; struct Data *data; data = (PDATA)malloc(sizeof(DATA)); if (data == NULL)&#123; printf("内存分配失败！\n"); exit(1); &#125; data-&gt;year = 2019; data-&gt;mouth = 10; data-&gt;day = 16; printf("%d-%d-%d\n", data-&gt;year, data-&gt;mouth, data-&gt;day);&#125;进阶Typedef在变成中使用typedef目的一般有两个：一个是给变量起一个容易记住且意义明确的别名另一个是简化一些比较复杂的类型声明共用体共用体的所有成员共享同一个内存地址。123456union 共用体名称&#123; 共用成员1； 共用成员2； 共用成员3；&#125;;123456789101112131415161718192021222324252627282930313233343536373839//// Created by Luenci on 2019/10/19.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;union Test&#123; int i; double pi; char str[6];&#125;;int main(void)&#123; union Test test; test.i = 50; test.pi = 1.2; strcpy(test.str, "Luenci"); printf("addr of test.i:%p\n", &amp;test.i); printf("addr of test.pi:%p\n", &amp;test.pi); printf("addr of test.str:%p\n", &amp;test.str); printf("value of test.i:%d\n", test.i); printf("value of test.i:%.2f\n", test.pi); printf("value of test.i:%s\n", test.str); return 0;&#125;out：addr of test.i:0061FF18addr of test.pi:0061FF18addr of test.str:0061FF18value of test.i:1852142924value of test.i:0.00value of test.i:Luenci​枚举类型如果一个变量只有几种可能的值，那么就可以将其定义为枚举（enumeration）类型。12345// 声明enum 枚举类型名称 &#123;枚举值名称, 枚举值名称...&#125;// 定义enum 枚举类型名称 枚举变量1, 枚举变量;​123456789101112131415161718192021222324252627282930313233343536//// Created by Luenci on 2019/10/19.//#include &lt;stdio.h&gt;#include &lt;time.h&gt;int main(void)&#123; enum Week &#123;sun, mon, tue, wed, thu, fri, sat&#125;; enum Week today; struct tm *p; time_t t; time(&amp;t); p = localtime(&amp;t); today = p-&gt;tm_wday; switch (today)&#123; case mon: case tue: case wed: case thu: case fri: printf("学习！！！\n"); break; case sat: case sun: printf("放假！\n"); break; default: printf("Error!\n"); &#125; return 0;&#125;位域使用位域的做法是在结构体定义时，在结构体成员后面使用冒号（：）和数字来表示该成员所占的位数。无名位域位域成员可以没有名称，只要给出数据类型和位宽即可1234567struct Test&#123; unsigned int x:100; unsigned int y:200; unsigned int z:300; unsigned int :424;&#125;;单片机单片机（Microcontrollers）是一种集成电路芯片，是采用超大规模集成电路技术把具有数据处理能力的中央处理器CPU、随机存储器RAM、只读存储器ROM、多种I/0口和中新系统、定时器/计数器等功能（可能还包括显示驱动电路、脉宽调制电路、模拟多路转换器、A/D转换器等电路）集成到一块硅片上构成的一个小而完善的微型计算机条统，在工业控制领域广泛应用。位操作逻辑位运算符按位取反（~）逻辑位运算符中优先级最高的是按位取反运算符，它的运算符是一个~符号，作用是将1变成0，将0变成1：按位与（&amp;）优先级第二高的是按位与运算符，它的运算符是一个&amp;符号（而逻辑与是两个&amp;符号）按位异或（^）优先级排第三的是按位异或运算符，它的运算符是一个个符号，只有当两个操作数对应的二进制位不同时，它的结果才为1，否则为0：按位或（|）逻辑位运算符中优先级最低的是按位或运算符，它的运算符是一个|符号（而逻辑或是两个I符号）和赋值号结合这四个运算符，除了按位取反只有一个操作数之外，其它三个都可以跟赋值号（=）结合到一块，使得代码更加简洁！1234567891011121314151617181920212223242526//// Created by Luenci on 2019/10/19.//#include &lt;stdio.h&gt;int main(void)&#123; int mask = 0xFF; int v1 = 0xABCDEF; int v2 = 0xABCDEF; int v3 = 0xABCDEF; v1 &amp;= mask; v2 |= mask; v3 ^= mask; printf("v1 = 0x%x\n", v1); printf("v2 = 0x%x\n", v2); printf("v3 = 0x%x\n", v3); return 0;&#125;out:v1 = 0xefv2 = 0xabcdffv3 = 0xabcd10移位运算符A = 0011 1100左移位运算符二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。A &lt;&lt; 2 将得到 240，即为 1111 0000右移位运算符二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。A &gt;&gt; 2 将得到 15，即为 0000 1111一些未定义行为左移、右移运算符右边的操作数如果是为负数，或者右边的操作数火于左边操作数支持的最大宽度，那么表达式的结果均是属于“未定义行为”。左边的操作数是有符号还是无符号数其实也对移位运算符有着不同的影响。无等号数肯定没问题，因为这时候变量里边所有的位都用于表示该数值的大小。但如果是有符号数，那就要区别对待了，因为有符号数的左边第一位是符号位，所以如果恰好这个操作数是个负数，那么移动之后是否覆盖符号位的决定权还是落到了编译器上。文件操作文件概念计算机文件（或称文件、电脑档案、档亲），是存储在基种长期储存设备或临时存储设备中的一段数据流，并且归属于计算机文件系统管理之下。所谓“长期储存设备”一般指磁盘、光盘、磁带等。而“短期存储设备”一般指计算机内存。需要注意的是，存储于长期存储设备的文件不一定是长期存储的，有些也可能是程序或条统运行中产生的临时数据，并于程序或系统退出后删除。打开文件您可以使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：1FILE *fopen( const char * filename, const char * mode );在这里，filename 是字符串，用来命名文件，访问模式 mode 的值可以是下列值中的一个：模式描述r打开一个已有的文本文件，允许读取文件。w打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。a打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。r+打开一个文本文件，允许读写文件。w+打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。a+打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：1"rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b"关闭文件为了关闭文件，请使用 fclose( ) 函数。函数的原型如下：1int fclose( FILE *fp );如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量。C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。写入文件下面是把字符写入到流中的最简单的函数：1int fputc( int c, FILE *fp );函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：1int fputs( const char *s, FILE *fp );函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。您也可以使用 int fprintf(FILE *fp,const char *format, …) 函数来写把一个字符串写入到文件中。读写单个字符fgetc函数描述C 库函数 char *fgets(char *str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。声明下面是 fgets() 函数的声明。1char *fgets(char *str, int n, FILE *stream)参数str – 这是指向一个字符数组的指针，该数组存储了要读取的字符串。n – 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。返回值如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。如果发生错误，返回一个空指针。getc函数描述C 库函数 int getc(FILE *stream) 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。声明下面是 getc() 函数的声明。1int getc(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要在上面执行操作的流。返回值该函数以无符号 char 强制转换为 int 的形式返回读取的字符，如果到达文件末尾或发生读错误，则返回 EOF单个字符写入fputc函数描述C 库函数 int fputc(int char, FILE *stream) 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。声明下面是 fputc() 函数的声明。1int fputc(int char, FILE *stream)参数char – 这是要被写入的字符。该字符以其对应的 int 值进行传递。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符的流。返回值如果没有发生错误，则返回被写入的字符。如果发生错误，则返回 EOF，并设置错误标识符。puts函数描述C 库函数 int putc(int char, FILE *stream) 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。声明下面是 putc() 函数的声明。1int putc(int char, FILE *stream)参数char – 这是要被写入的字符。该字符以其对应的 int 值进行传递。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符的流。返回值该函数以无符号 char 强制转换为 int 的形式返回写入的字符，如果发生错误则返回 EOF。区别fgetc（fputc）函数和getc （putc）函数两个的功和描述基本上是一模一样的，它们的区别主要在于实现上：fgetc（fputc）是一个函数；而getc （putc）则是一个宏的实现一般来说宏产生较大的代码，但是避免了函数调用的堆栈操作，所以速度会比较快。由于getc是由宏实现的，对其参数可能有不止一次的调用，所以不能使用带有副作用（side effects）的参数。123456789101112131415161718192021222324252627282930//// Created by Luenci on 2019/10/20.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; FILE *fp1; FILE *fp2; int ch; if ((fp1 = fopen("D:\\c_study\\test.txt", "r")) == NULL)&#123; printf("打开文件失败！\n"); exit(EXIT_FAILURE); &#125; if ((fp2 = fopen("D:\\c_study\\demo2.txt", "w")) == NULL)&#123; printf("打开文件夹失败！\n"); exit(EXIT_FAILURE); &#125; while ((ch = fgetc((fp1))) != EOF)&#123; fputc(ch, fp2); &#125; fclose(fp1); fclose(fp2); return 0;&#125;读写整个字符串fgets函数描述C 库函数 char *fgets(char *str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。声明下面是 fgets() 函数的声明。1char *fgets(char *str, int n, FILE *stream)参数str – 这是指向一个字符数组的指针，该数组存储了要读取的字符串。n – 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。返回值如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。如果发生错误，返回一个空指针。fputs函数描述C 库函数 int fputs(const char *str, FILE *stream) 把字符串写入到指定的流 stream 中，但不包括空字符。声明下面是 fputs() 函数的声明。1int fputs(const char *str, FILE *stream)参数str – 这是一个数组，包含了要写入的以空字符终止的字符序列。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符串的流。返回值该函数返回一个非负值，如果发生错误则返回 EOF。feof()函数描述C 库函数 int feof(FILE *stream) 测试给定流 stream 的文件结束标识符。声明下面是 feof() 函数的声明。1int feof(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。返回值当设置了与流关联的文件结束标识符时，该函数返回一个非零值，否则返回零。123456789101112131415161718192021222324252627282930313233343536//// Created by Luenci on 2019/10/20.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX 1024int main(void)&#123; FILE *fp1; char buff[MAX]; if ((fp1 = fopen("D:\\c_study\\demo3.txt", "w")) == NULL)&#123; printf("打开文件失败！\n"); exit(EXIT_FAILURE); &#125; fputs("Luenci 的文件操作1 。\n", fp1); fputs("Luenci 的文件操作2 。\n", fp1); fclose(fp1); if ((fp1 = fopen("D:\\c_study\\demo3.txt", "r")) == NULL)&#123; printf("打开文件失败！\n"); exit(EXIT_FAILURE); &#125; while (!feof(fp1))&#123; fgets(buff, MAX, fp1); printf("%s", buff); &#125; fclose(fp1); return 0;&#125;格式化读写文件fprintf（）函数描述C 库函数 int fprintf(FILE *stream, const char *format, …) 发送格式化输出到流 stream 中。声明下面是 fprintf() 函数的声明。1int fprintf(FILE *stream, const char *format, ...)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。format – 这是 C 字符串，包含了要被写入到流 stream 中的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是1%[flags][width][.precision][length]specifier，具体讲解如下：specifier（说明符）输出c字符d 或 i有符号十进制整数e使用 e 字符的科学科学记数法（尾数和指数）E使用 E 字符的科学科学记数法（尾数和指数）f十进制浮点数g自动选择 %e 或 %f 中合适的表示法G自动选择 %E 或 %f 中合适的表示法o有符号八进制s字符的字符串u无符号十进制整数x无符号十六进制整数X无符号十六进制整数（大写字母）p指针地址n无输出%字符flags（标识）描述-在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。+强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。(space)如果没有写入任何符号，则在该值前面插入一个空格。#与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。 与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。0在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。width（宽度）描述(number)要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。*宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。.precision（精度）描述.number对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。 对于 g 和 G 说明符：要输出的最大有效位数。 对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 对于 c 类型：没有任何影响。 当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。.*精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。length（长度）描述h参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。l参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。L参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。附加参数 – 根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。返回值如果成功，则返回写入的字符总数，否则返回一个负数。fread()函数描述C 库函数 size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 从给定流 stream 读取数据到 ptr 所指向的数组中。声明下面是 fread() 函数的声明。1size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)参数ptr – 这是指向带有最小尺寸 size*nmemb 字节的内存块的指针。size – 这是要读取的每个元素的大小，以字节为单位。nmemb – 这是元素的个数，每个元素的大小为 size 字节。stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。返回值成功读取的元素总数会以 size_t 对象返回，size_t 对象是一个整型数据类型。如果总数与 nmemb 参数不同，则可能发生了一个错误或者到达了文件末尾。fwrite（）函数描述C 库函数 size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) 把 ptr 所指向的数组中的数据写入到给定流 stream 中。声明下面是 fwrite() 函数的声明。1size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)参数ptr – 这是指向要被写入的元素数组的指针。size – 这是要被写入的每个元素的大小，以字节为单位。nmemb – 这是元素的个数，每个元素的大小为 size 字节。stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。返回值如果成功，该函数返回一个 size_t 对象，表示元素的总数，该对象是一个整型数据类型。如果该数字与 nmemb 参数不同，则会显示一个错误。文件随机读写ftell（）函数描述C 库函数 long int ftell(FILE *stream) 返回给定流 stream 的当前文件位置。声明下面是 ftell() 函数的声明。1long int ftell(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。返回值该函数返回位置标识符的当前值。如果发生错误，则返回 -1L，全局变量 errno 被设置为一个正值。rewind() 函数描述C 库函数 void rewind(FILE *stream) 设置文件位置为给定流 stream 的文件的开头。声明下面是 rewind() 函数的声明。1void rewind(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。fseek() 函数描述C 库函数 int fseek(FILE *stream, long int offset, int whence) 设置流 stream 的文件位置为给定的偏移 offset，参数 offset 意味着从给定的 whence 位置查找的字节数。声明下面是 fseek() 函数的声明。1int fseek(FILE *stream, long int offset, int whence)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。offset – 这是相对 whence 的偏移量，以字节为单位。whence – 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一：常量描述SEEK_SET文件的开头SEEK_CUR文件指针的当前位置SEEK_END文件的末尾返回值如果成功，则该函数返回零，否则返回非零值。可移植性问题想要编写可移植的代码，就需要考虑以下问题：对于以二进制模式打开的文件，fseek函数在某些操作系统可能不支持SEEK_END位置。一对于以文本模式打开的文件，fseek函数的whence参数只能取SEEK_SET才是有意义的，并且传递给offset参数的值要么是0，要么是上一次对同个文件调用fte11函数获得的返回值。标准流和错误处理文件流标准输入（stdin）标准输入（stdout）标准错误输出（stderr）重定向由于标准输出和标准错误输出通常都是直接打印到屏幕上，为了区分宅们，我们可以使用Linux shell的重定向功能：重定向标准输入使用 &lt;重定向标准输出使用 〉重定向标准错误输出使用 2〉错误处理错误指示器 - ferror（）描述C 库函数 int ferror(FILE *stream) 测试给定流 stream 的错误标识符。声明下面是 ferror() 函数的声明。1int ferror(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。返回值如果设置了与流关联的错误标识符，该函数返回一个非零值，否则返回一个零值。使用clearerr函数可以人为地清除文件末尾指示器和错误指示器的状态。ferror函数只能检测是否出错，但无法获取错误原因。不过，大多数系统函数在出现错误的时候会将错误原因记录在errno中。perror函数可以直观地打印出错误原因。描述C 库函数 void perror(const char *str) 把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 str，后跟一个冒号，然后是一个空格。声明下面是 perror() 函数的声明。1void perror(const char *str)参数str – 这是 C 字符串，包含了一个自定义消息，将显示在原本的错误消息之前。返回值该函数不返回任何值strerror（）函数直接返回错误码对应的错误信息。描述C 库函数 char *strerror(int errnum) 从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。strerror 生成的错误字符串取决于开发平台和编译器。声明下面是 strerror() 函数的声明。1char *strerror(int errnum)参数errnum – 错误号，通常是 errno。返回值该函数返回一个指向错误字符串的指针，该错误字符串描述了错误 errnum。12345678910111213141516171819202122232425//// Created by Luenci on 2019/10/20.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;int main(void)&#123; FILE *fp; if(fp = fopen("bucunzai.txt", "r") == NULL)&#123; printf("出错啦，原因就是：%d\n", errno); fprintf(stderr, "出错啦，原因就是：%s", strerror(errno) ); perror("出错啦，原因就是：");// fputs("打开文件失败！\n", stderr); exit(EXIT_FAILURE); &#125; fclose(fp); return 0;&#125;I/O 缓冲区标准I/O提供的三种类型的缓冲模式按块执行按块缓存也称为全缓存，即在填满缓冲区后才进行实际的设备读写操作；按行执行按行缓存是指在接收到换行符（’\n’）之前，数据都是先缓存在缓冲区的；不缓存也就是允许你直接读写设备上的数据。setvbuf()函数描述C 库函数 int setvbuf(FILE *stream, char *buffer, int mode, size_t size) 定义流 stream 应如何缓冲。声明下面是 setvbuf() 函数的声明。1int setvbuf(FILE *stream, char *buffer, int mode, size_t size)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流。buffer – 这是分配给用户的缓冲。如果设置为 NULL，该函数会自动分配一个指定大小的缓冲。mode – 这指定了文件缓冲的模式：模式描述_IOFBF全缓冲：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充。_IOLBF行缓冲：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符。_IONBF无缓冲：不使用缓冲。每个 I/O 操作都被即时写入。buffer 和 size 参数被忽略。size –这是缓冲的大小，以字节为单位。返回值如果成功，则该函数返回 0，否则返回非零值。fflush（）函数描述C 库函数 int fflush(FILE *stream) 刷新流 stream 的输出缓冲区。声明下面是 fflush() 函数的声明。1int fflush(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个缓冲流。返回值如果成功，该函数返回零值。如果发生错误，则返回 EOF，且设置错误标识符（即 feof）]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C结构体打包技艺]]></title>
    <url>%2F2019%2F10%2F19%2FC%E8%AF%AD%E8%A8%80%E6%89%93%E5%8C%85%E6%8A%80%E8%89%BA%2F</url>
    <content type="text"><![CDATA[失传的 C 结构体打包技艺（转）转自： https://fishc.com.cn/forum.php?mod=viewthread&amp;tid=83418&amp;extra=page%3D2%26filter%3Dtypeid%26typeid%3D571作者：Eric S. Raymond原文链接：http://www.catb.org/esr/structure-packing谁应阅读本文如果你在内存容量受限的嵌入式系统中写程序，或者编写操作系统内核代码，就有必要了解这项技术。如果数据集巨大，应用时常逼近内存极限，这项技术会有所帮助。倘若你非常非常关心如何最大限度地减少处理器缓存段（cache-line）未命中情况的发生，这项技术也有所裨益。2013 年底，我大量应用了一项 C 语言优化技术，这项技术是我早在二十余年前就已掌握的，但彼时之后，鲜有使用。通过精心调整结构成体员的顺序，可以在这种情况下大幅减少内存占用。其效果显著——在上述案例中，可以减少 40% 的内存空间。程序应用于更大的软件仓库，也不会因内存耗尽而崩溃。事出有因。计算机科学课程（正确地）引导人们远离微观优化，转而寻求更理想的算法。计算成本一路走低，令压榨内存的必要性变得越来越低。旧日里，黑客们通过在陌生的硬件架构中跌跌撞撞学习 —— 如今已不多见。首先需要了解的是，对于现代处理器，C 编译器在内存中放置基本 C 数据类型的方式受到约束，以令内存的访问速度更快。用行话来说，x86 和 ARM 上的基本 C 类型是“自对齐（self-aligned）”的。关于指针，无论 32 位（4 字节）还是 64 位（8 字节）也都是自对齐的。我提到“现代处理器”，是因为有些老平台强迫 C 程序违反对齐规则（例如，为 int 指针分配一个奇怪的地址并试图使用它），不仅令速度减慢，还会导致非法指令错误。例如 Sun SPARC 芯片就有这种问题。事实上，如果你下定决心，并恰当地在处理器中设置标志位（e18），在 x86 平台上，也能引发这种错误。你还可以通过 pragma 指令（通常为 ）强迫编译器不采用处理器惯用的对齐规则。但请别随意运用这种方式，因为它强制生成开销更大、速度更慢的代码。通常，采用我在下文介绍的方式，可以节省相同或相近的内存。#pragma pack我们来看一个关于变量在内存中分布的简单案例。思考形式如下的一系列变量声明，它们处在一个 C 模块的顶层。然而实际情况（在 x86、ARM 或其他采用自对齐类型的平台上）如下。存储 p 需要自对齐的 4 或 8 字节空间，这取决于机器字的大小。这是指针对齐 —— 极其严格。1234561. char *p; /* 4 or 8 bytes */2. char c; /* 1 byte */3. char pad[3]; /* 3 bytes */4. int x; /* 4 bytes */字符数组 pad[3] 意味着在这个结构体中，有 3 个字节的空间被浪费掉了。老派术语将其称之为“废液（slop）”。1231. char *p;2. char c;3. short x;在这个例子中，实际分布将会是：1231. char *p;2. char c;3. long x;我们将得到：1231. char c;2. char *p;3. int x;假如实际内存分布可以写成下面这样：首先，在此例中，N 将为 0，x 的地址紧随 p 之后，能确保是与指针对齐的，因为指针的对齐要求总比 int 严格。不过更有可能的情况是，c 将被映射为机器字的首字节。于是乎 M 将会用于填充，以使 p 指针对齐——32 位系统中为 3 字节，64 位系统中为 7 字节。倘若你希望这些变量占用的空间更少，那么可以交换 x 与 c 的次序。在讲述这部分内容前，我们先对标量数组做个说明。在具有自对齐类型的平台上，char、short、int、long 和指针数组都没有内部填充，每个成员都与下一个成员自动对齐。通常情况下，结构体实例以其最宽的标量成员为基准进行对齐。编译器之所以如此，是因为此乃确保所有成员自对齐，实现快速访问最简便的方法。假如你对此有疑惑，ANSI C 提供了一个 宏，可用于读取结构体成员位移。123451. struct foo1 &#123;2. char *p;3. char c;4. long x;5. &#125;;假定处在 64 位系统中，任何 struct fool 的实例都采用8字节对齐。不出所料，其内存分布将会像下面这样：12345678910111. struct foo2 &#123;2. char c; /* 1 byte */3. char pad[7]; /* 7 bytes */4. char *p; /* 8 bytes */5. long x; /* 8 bytes */6. &#125;;如果成员是互不关联的变量，c便可能从任意位置起始，pad的大小则不再固定。因为struct foo2的指针需要与其最宽的成员为基准对齐，这变得不再可能。现在 c 需要指针对齐，接下来填充的7个字节被锁定了。结构体尾填充的通用法则是：编译器将会对结构体进行尾填充，直至它的跨步地址。这条法则决定了 sizeof() 的返回值。12345671. struct foo3 &#123;2. char *p; /* 8 bytes */3. char c; /* 1 byte */4. &#125;;5. 6. struct foo3 singleton;7. struct foo3 quad[4];复制代码你以为 的值是 9，但实际是 16。它的跨步地址是 。于是，在 quad 数组中，每个成员都有 7 字节的尾填充，因为下个结构体的首个成员需要在 ８ 字节边界上对齐。内存分布就好像这个结构是这样声明的：12341. struct foo4 &#123;2. short s; /* 2 bytes */3. char c; /* 1 byte */4. &#125;;因为 s 只需要 2 字节对齐，跨步地址仅在 c 的 1 字节之后，整个 struct foo4 也只需要 1 字节的尾填充。形式如下：的返回值将为 4。12345671. struct foo5 &#123;2. short s;3. char c;4. int flip:1;5. int nybble:4;6. int septet:7;7. &#125;;关于位域需要了解的是，它们是由字（或字节）层面的掩码和移位指令实现的。从编译器的角度来看，struct foo5 中的位域就像 ２ 字节、16 位的字符数组，只用到了其中 12 位。为了使结构体的长度是其最宽成员长度 的整数倍，接下来进行了填充。1234567891. struct foo6 &#123;2. char c;3. struct foo5 &#123;4. ​ char *p;5. ​ short x;6. &#125; inner;7. &#125;;内层结构体成员 char *p 强迫外层结构体与内层结构体指针对齐一致。在 64 位系统中，实际的内存分布将类似这样：理解了编译器在结构体中间和尾部插入填充的原因与方式后，我们来看看如何榨出这些废液。此即结构体打包的技艺。消除废液最简单的方式，是按对齐值递减重新对结构体成员排序。即让所有指针对齐成员排在最前面，因为在 64 位系统中它们占用 8 字节；然后是 4 字节的 int；再然后是 2 字节的 short，最后是字符。123451. struct foo7 &#123;2. char c;3. struct foo7 *p;4. short x;5. &#125;;将隐含的废液写明，形式如下：12345671. struct foo8 &#123;2. struct foo8 *p;3. short x;4. char c;5. &#125;;考虑到自对齐，我们看到所有数据域之间都不需填充。因为有较严对齐要求（更长）成员的跨步地址对不太严对齐要求的（更短）成员来说，总是合法的对齐地址。重打包过的结构体只需要尾填充：注意，重新打包不能确保在所有情况下都能节省空间。将这项技术应用于更靠前 struct foo6 的那个例子，我们得到：123456789101. struct foo9 &#123;2. struct foo9_inner &#123;3. char *p; /* 8 bytes */4. int x; /* 4 bytes */5. char pad[4]; /* 4 bytes */6. &#125; inner;7. char c; /* 1 byte */8. char pad[7]; /* 7 bytes */9. &#125;;结果还是 24 字节，因为 c 无法作为内层结构体的尾填充。要想节省空间，你需要得新设计数据结构。棘手的标量案例#define请当心，重打包结构体时，枚举型变量通常是 int，这与编译器相关；但也可能是 short、long、甚至默认为 char。编译器可能会有 预处理指令或命令行选项指定枚举的尺寸。以上两种情况，最好用 来检查存储尺寸。尽管按尺寸重排是最简单的消除废液的方式，却不一定是正确的方式。还有两个问题需要考量：可读性与缓存局部性。笨拙地、机械地重排结构体可能有损可读性。倘若有可能，最好这样重排成员：将语义相关的数据放在一起，形成连贯的组。最理想的情况是，结构体的设计应与程序的设计相通。为保持可读性所做的工作（将相关和同时访问的数据放在临近位置）也会提高缓存段的局部性。这些都是需要明智地重排，并对数据的存取模式了然于心的原因。是的，某些时候，这种做法与前文将相关数据放入与缓存段长度相同块的做法矛盾。多线程的确是个难题。缓存段弹跳和其他多线程优化问题是很高级的话题，值得单独为它们写份指导。这里我所能做的，只是让你了解有这些问题存在。其他打包技术你可能会有一点儿存取时间的损失，但只要将工作集合压缩得足够小，那点损失可以靠避免缓存未命中补偿。这不仅减小了结构体的可见尺寸，还可以消除废液和/或创造额外的机会来进行重新排序。这种良性串连的效果不难被触发。clang 编译器有个 Wpadded 选项，可以生成有关对齐和填充的信息。读者可以下载一段程序源代码 ，验证上文有关标量和结构体尺寸的结论。理解这些规则的第二个层次是，知其何时及如何会被打破。在我学习它们的日子里（1980 年代早期），我们把不理解这些规则的人称为“所有机器都是 VAX 综合症”的牺牲品。记住，世上所有电脑并非都是 PC。]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>扩展知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言笔记（2）]]></title>
    <url>%2F2019%2F10%2F13%2FC%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[先举三反一，再举一反三，学习就应该是这样，先模仿，再改进，最后实现自己的创意！ –小甲鱼论坛递归调用函数本身设置递归结束条件12345678910111213141516171819202122232425262728293031323334353637383940//// Created by Luenci on 2019/10/11.//#include &lt;stdio.h&gt;void fun(void);long fact(int num);void fun(void)&#123; static int count = 10; printf("Hi\n"); if (count--)&#123; fun(); &#125;&#125;long fact(int num)&#123; long result; if(num &gt; 0)&#123; result = num * fact(num-1); &#125; else&#123; result = 1; &#125; return result;&#125;int main(void)&#123;// fun(); int num; long re; printf("请输入您要求阶乘的数："); scanf("%d", &amp;num); re = fact(num); printf("%d", re); return 0;&#125;汉罗塔123456789101112131415161718192021222324#include&lt;stdio.h&gt;void hanoi(int n, char x, char y, char z);void hanoi(int n, char x, char y, char z)&#123; if(n==1)&#123; printf("%c --&gt; %c \n", x,z); &#125; else&#123; // 将前n-1个圆盘借助z移动到y hanoi(n-1, x, z, y); printf("%c --&gt; %c \n", x,z); // 将前n-1个圆盘借助x移动到z hanoi(n-1, y, x, z); &#125;&#125;int main(void)&#123; int n; printf("请输入您的层数："); scanf("%d", &amp;n); hanoi(n, 'X', 'Y', 'Z'); return 0;&#125;快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//// Created by Luenci on 2019/10/11.//#include &lt;stdio.h&gt;void quick_sort(int array[], int left, int right);void quick_sort(int array[], int left, int right) &#123; int i = left, j = right; int temp; // 交换的中间变量 int pivot; // 基准点 pivot = array[(left + right) / 2]; while (i &lt;= j) &#123; // 从右往左找到大于等于基准点的元素 while (array[i] &lt; pivot) &#123; i++; &#125; // 从右到左找到小于等于基准点的元素 while (array[j] &gt; pivot) &#123; j--; &#125; // 如果 i &lt;= j,则互换 if (i &lt;= j) &#123; temp = array[i]; array[i] = array[j]; array[j] = temp; i++; j++; &#125; &#125; if (left &lt; j) &#123; quick_sort(array, left, j); &#125; if (i &lt; right) &#123; quick_sort(array, i, right); &#125;&#125;int main(void)&#123; int array[] = &#123;73, 108, 111, 101, 78, 109, 66, 48, 88, 135&#125;; int i, length; // 计算数组的长度 length = sizeof(array) / sizeof(array[0]); quick_sort(array, 0, length-1); printf("排序后的结果是："); for (i = 0; i &lt; length; i++)&#123; printf("%d ,", array[i]); &#125; putchar('\n'); return 0;&#125;动态内存管理malloc申请动态内存空间free释放动态内存空间calloc申请并初始化一系列内存空间realloc重新分配内训空间malloc函数函数原型void *malloc（size_t size）malloc函数向系统申请分配size个字节的内存空间，并返回一个指向这块空间的地址。如果函数调用成功，返回一个指向申请的内存空间的指针，由于返回类型是void 指针（void * ）， 所以它是可以被转换成任何类型的数据；如果函数调用失败，返回值是NULL。另外，如果size的参数设置为0，返回值也可能是NULL，但这并不意味着函数调用失败。free函数函数原型void free（void *ptr）free函数释放ptr参数指向的内存空间。该内存空间必须是有malloc，calloc或realloc函数申请的。否则，该函数将导致未定义行为。如果ptr参数是NULL，则不执行任何操作。注意：该函数并不会修改ptr参数的值，所以调用后仍然指向原来的地方（变为非法空间）。123456789101112131415161718192021222324252627//// Created by Luenci on 2019/10/12.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int *ptr; ptr = (int *)malloc(sizeof(int)); if(ptr == NULL)&#123; printf("分配内存失败"); exit(1); &#125; printf("请输入一个整数："); scanf("%d", ptr); printf("您输入的整数是:%d\n", *ptr); free(ptr); printf("您输入的整数是:%d\n", *ptr); return 0;&#125;内存泄漏隐式内存泄漏用完内存块没有及时使用free函数释放丢失内存块的地址初始化内存空间mem开头的函数被编入字符串标准库，函数的声明包含在string.h这个头文件中：memset – 使用一个常量字节填充空间memcpy – 拷贝内存空间memmove – 拷贝内存空间memcmp – 比较内存空间memchr – 在内存空间中搜索一个字符123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by Luenci on 2019/10/12.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define N 10int main(void)&#123; int *ptr = NULL; int i; ptr = (int *)malloc(N * sizeof(int)); if(ptr == NULL)&#123; exit(1); &#125; memset(ptr, 0, N * sizeof(int)); for (i= 0; i &lt; N; i++) &#123; printf("%d ", ptr[i]); &#125;// putchar("\n"); putchar('\n'); free(ptr); return 0;&#125;/*1、含义不同。用单引号引起的一个字符实际上代表一个整数，整数值对应于该字符在编译器采用的字符集中的序列值。而一般我们的编译器采用的都是ASCII字符集。因此's'的含义其实和十进制数115的含义是一致的。而用双引号引起的字符串，代表的是一个指向无名数组起始字符的指针。2、大小不同。用单引号引起的一个字符大小就是一个字节。而用双引号引起的字符串大小是字符的总大小+1，因为用双引号引起的字符串会在字符串末尾添加一个二进制为0的字符'\0'。*/calloc函数函数原型void *calloc(size_t nmemb, sizet_t size);calloc函数在内存中动态地申请nmemb个长度为size的连续内存空间（即申请的总空间尺寸为nmemb * size），这些内存空间全部被初始化为 0.calloc函数与malloc函数的一个重要区别是：calloc函数在申请完内存后，自动初始化该内存空间为零malloc函数不进行初始化操作，里面数据是随机的12345678// 两者等价// calloc() 分配内存空间并初始化int *ptr = （int *）calloc（8， sizeof（int））；//malloc()分配内存空间并用memset（）初始化int *ptr = (int *)malloc(8 * sizeof(int))；memset(prt, 0, 8 * sizeof(int));realloc函数如果ptr参数为NULL，那么调用该函数就相当于调用malloc（size）如果size参数为0，并且ptr参数不为NULL，那么调用该函数就相当于调用free（ptr）除非ptr参数为NULL，否则ptr的值必须由先前调用malloc，calloc或realloc函数返回。1234567891011121314151617181920212223242526272829303132//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int i, num; int count = 0; int *ptr = NULL;// 注意这里必须初始化为NULL do &#123; printf("请输入一个整数：（输入-1表示结束）"); scanf("%d", &amp;num); count++; ptr = (int *)realloc(ptr, count * sizeof(int)); if(ptr == NULL)&#123; exit(1); &#125; ptr[count-1] = num; &#125;while(num != -1); printf("输入的整数分别是："); for (int i = 0; i &lt;count ; i++) &#123; printf("%d ", ptr[i]); &#125; free(ptr); return 0;&#125;c语言的内存布局代码段代码段（Text segment）通常是指用来存放在程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读。在代码段中，也有可能包含一些只读的常熟变量，例如字符串常量等。BSS段BSS段（BSS segment/Uninitialized data segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BBS是英文Block Started Symbol的简称，这个区段中的数据在程序运行前将被自动初始化为数字0。堆堆是用于存放进程中被动态分配的内存段，它的大小并不固定，可动态扩展或缩小。当进程调用malloc等函数分配内存时，新分配的内存就被动态调价到对上；当利用free等函数释放内存时，被释放的内存从堆中被剔除。栈栈是函数执行的内存区域，通常和堆共享同一片区域。堆和栈的区别申请方式堆是由程序员手动申请栈时系统自动分配释放方式堆是由程序员手动释放栈由系统自动释放生存周期堆的生存周期由动态申请到程序员主动释放位置，不同函数之间均可自由访问。栈的生存周期由函数调用开始到函数返回时结束，函数之间的局部变量不能互相访问。高级宏定义本质就是替换内联函数在程序函数调用时，直接展开，而不是去查找调用。内联函数嵌入调用者代码中的操作是一种优化操作，因此只有进行优化编译时才会执行代码嵌入处理。若编译过程中没有使用优化选项‘-o’，那么内联函数的代码就不会真正地嵌入到函数调用者代码中，而是只作为普通函数调用来处理。内联函数虽然节省了函数调用的时间消耗，但由于每一个函数出现的地方都要进行替换，因此增加了代码的编译时间。另外，并不是所有的函数都能变成内联函数现在的编译器也很智能，就算你不写inline，它也会自动将一些函数优化成内联函数不带参数的宏定义为了和普通的变量进行区分，宏的名字通常我们约定是由大写字母组成宏定义只是简单地进行替换，并且由于预处理是在编译之前进行，而编译工作的任务之一就是语法检查，所以编译器不会对宏定义进行语法检查宏定义不是说明或语句，在末尾不必加分号宏定义的作用是从定义的位置开始到整个程序的结束可以用 #undef 来终止宏定义的作用域宏定义允许嵌套12345678910111213141516171819//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define PI 3.14int main()&#123; int r; float s; printf("请输入圆的半径："); scanf("%d", &amp;r);// #undef PI 终止宏定义 s = PI * r * r; printf("圆的面积是：%.2f\n", s);&#125;123456789101112131415//// Created by Luenci on 2019/10/13.//// 宏定义的嵌套#include &lt;stdio.h&gt;#define R 6371#define PI 3.14#define V PI * R * R * R * 4 / 3int main()&#123; printf("地球的体积是：%.2f\n", V);&#125;带参数的宏定义12345678910111213141516//// Created by Luenci on 2019/10/13.////带参数的宏定义#include &lt;stdio.h&gt;#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))int main()&#123; int x,y; printf("请输入两个数："); scanf("%d%d", &amp;x, &amp;y); printf("%d是最大的那个数！\n", MAX(x, y));&#125;‘#’ 和 ‘##’‘#’ 和 ‘##’是两个预处理运算符在带参数的宏定义中， #运算符后面应该跟着一个参数，预处理器会把这个参数转换为一个字符串。1234567891011121314//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define STR(s) # sint main(void)&#123; printf(STR(Hlloc %s num = %d), STR(Luenci), 520); return 0;&#125;out :Hlloc Luenci num = 520‘##’运算符被称为记号连接运算符，我们可以使用’##’运算符连接两个参数。123456789101112131415161718192021222324252627 //// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define TOGETHER(x,y) x ## yint main(void)&#123; printf("%d\n", TOGETHER(2,50)); return 0;&#125;//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define TOGETHER(x,y) x ## yint main(void)&#123; printf("%d\n", TOGETHER(2,50)); return 0;&#125;out:250可变参数之前学习了如何让函数支持可变参数，带参数的宏定义是使用可变参数的：1#define SHOWLIST（...） printf（#__VA_ARGS__）其中…表示可变参数，1#__VA_ARGS__在预处理中被实际的参数集所替代。123456789101112#include &lt;stdio.h&gt;#define SHOWLIST(...) printf(#__VA_ARGS__)int main(void)&#123; SHOWLIST(Luenci,5 20, 3.14 \n); return 0;&#125;out:Luenci,5 20, 3.1412345678910111213#include &lt;stdio.h&gt;#define SHOWLIST(format, ...) printf(#format, ##__VA_ARGS__)int main(void)&#123; SHOWLIST(num = %d\n,520); SHOWLIST(hello Luenci\n); return 0;&#125;out:num = 520hello Luenci]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言笔记（1）]]></title>
    <url>%2F2019%2F10%2F13%2FC%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[ps:先举三反一，再举一反三，学习就应该是这样，先模仿，再改进，最后实现自己的创意！ –小甲鱼论坛C语言中各种数据类型所占用的存储空间的大小int—32位 四个字节float —32位 四个字节char—8位 一个字节double—-64位 8个字节bool—-16位 2个字节long—-32位 四个字节整数类型下表列出了关于标准整数类型的存储大小和值范围的细节：类型存储大小值范围char1 字节-128 到 127 或 0 到 255unsigned char1 字节0 到 255signed char1 字节-128 到 127int2 或 4 字节-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647unsigned int2 或 4 字节0 到 65,535 或 0 到 4,294,967,295short2 字节-32,768 到 32,767unsigned short2 字节0 到 65,535long4 字节-2,147,483,648 到 2,147,483,647unsigned long4 字节0 到 4,294,967,295浮点类型下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：类型存储大小值范围精度float4 字节1.2E-38 到 3.4E+386 位小数double8 字节2.3E-308 到 1.7E+30815 位小数long double16 字节3.4E-4932 到 1.1E+493219 位小数void 类型void 类型指定没有可用的值。它通常用于以下三种情况下：序号类型与描述1函数返回为空 C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);2函数参数为空 C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);3指针指向 void 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。C语言运算符优先级优先级运算符名称或含义使用形式结合方向说明1[]数组下标数组名[常量表达式]左到右()圆括号（表达式）/函数名(形参表).成员选择（对象）对象.成员名-&gt;成员选择（指针）对象指针-&gt;成员名2-负号运算符-表达式右到左单目运算符(类型)强制类型转换(数据类型)表达式++自增运算符++变量名/变量名++单目运算符–自减运算符–变量名/变量名–单目运算符*取值运算符*指针变量单目运算符&amp;取地址运算符&amp;变量名单目运算符!逻辑非运算符!表达式单目运算符~按位取反运算符~表达式单目运算符sizeof长度运算符sizeof(表达式)3/除表达式/表达式左到右双目运算符*乘表达式*表达式双目运算符%余数（取模）整型表达式/整型表达式双目运算符4+加表达式+表达式左到右双目运算符-减表达式-表达式双目运算符5&lt;&lt;左移变量&lt;&lt;表达式左到右双目运算符&gt;&gt;右移变量&gt;&gt;表达式双目运算符6&gt;大于表达式&gt;表达式左到右双目运算符&gt;=大于等于表达式&gt;=表达式双目运算符&lt;小于表达式&lt;表达式双目运算符&lt;=小于等于表达式&lt;=表达式双目运算符7==等于表达式==表达式左到右双目运算符!=不等于表达式!= 表达式双目运算符8&amp;按位与表达式&amp;表达式左到右双目运算符9^按位异或表达式^表达式左到右双目运算符10|按位或表达式|表达式左到右双目运算符11&amp;&amp;逻辑与表达式&amp;&amp;表达式左到右双目运算符12||逻辑或表达式||表达式左到右双目运算符13?:条件运算符表达式1? 表达式2: 表达式3右到左三目运算符14=赋值运算符变量=表达式右到左/=除后赋值变量/=表达式*=乘后赋值变量*=表达式%=取模后赋值变量%=表达式+=加后赋值变量+=表达式-=减后赋值变量-=表达式&lt;&lt;=左移后赋值变量&lt;&lt;=表达式&gt;&gt;=右移后赋值变量&gt;&gt;=表达式&amp;=按位与后赋值变量&amp;=表达式^=按位异或后赋值变量^=表达式|=按位或后赋值变量|=表达式15,逗号运算符表达式,表达式,…左到右从左向右顺序运算注：同一优先级的运算符，运算次序由结合方向所决定。break和continue语句区别break语句结束当前循环continue语句跳过本次循环二维下标直接索引和指针间接索引的相互转化1234*（array + i） = array[i]*(*(array + i) + j) = array[i][j]*(*(*(array + i) + j) + K) = array[i][j][k] ...二维数组和数组指针的关系12345678910111213141516171819202122//// Created by Luenci on 2019/10/5.//#include &lt;stdio.h&gt;int main()&#123; int array[2][3] = &#123;&#123;0, 1, 2&#125;, &#123;4, 5, 6&#125;&#125;; int (*p)[3] = array; printf("**(p+1): %d\n", **(p+1)); printf("**(array+1): %d\n", **(array+1)); printf("array[1][0]: %d\n", array[1][0]); printf("*(*(p+1)+2): %d\n", *(*(p+1)+2)); printf("*(*(array+1)+2): %d\n", *(*(array+1)+2)); printf("array[1][2]: %d\n", array[1][2]); return 0;&#125;void指针和NULL指针Void指针void指针我们把它称之为通用指针，就是可以指向任意类型的数据。也就是说，任何类型的指针都可以赋值给void指针。123456789101112131415161718192021//// Created by Luenci on 2019/10/5.//#include &lt;stdio.h&gt;int main()&#123; int num = 1024; int *pi = &amp;num; char *ps = "Luenci"; void *pv; pv = pi; printf("pi:%p, pv:%p\n", pi,pv); printf("*pv:%d\n", *(int *)pv); pv = (char *)ps; printf("ps:%p, pv:%p\n", ps, pv); printf("*pv:%s\n", (char *)pv); return 0;&#125;NULL指针当你还不清楚要将指针初始值为什么地址时，请先将它初始化为NULL；在对指针进行解引用时，先检查该指针是否为NULL。这种策略可以为今后编写大型程序 节省大量的 调试时间。1#define NULL ((void *)0)1234567891011121314//// Created by Luenci on 2019/10/5.//#include &lt;stdio.h&gt;int null_pointer()&#123; int *p1; int *p2 = NULL; printf("%d\n", *p1); printf("%d\n", *p2); return 0;&#125;指向指针的指针123456789101112131415161718192021int main()&#123; int num = 520; int *p = &amp;num; int **pp = &amp;p; printf("num: %d\n", num); printf("*p: %d\n", *p); printf("**PP: %d\n", **pp); printf("&amp;p: %p, pp:%p\n", &amp;p, pp); printf("&amp;num:%p, p:%p, *pp:%p\n", &amp;num,p,*pp); return 0;&#125; out: num: 520 *p: 520 **PP: 520 &amp;p: 0061FF14, pp:0061FF14 &amp;num:0061FF18, p:0061FF18, *pp:0061FF18指针数组和指向指针的指针123456789101112131415161718192021222324252627282930313233343536373839int pointer_array()&#123; char *cBooks[] = &#123; &quot;&lt;c程序设计语言&gt;&quot;, &quot;&lt;c专家编程&gt;&quot;, &quot;&lt;c和指针&gt;&quot;, &quot;&lt;c prime plus&gt;&quot;, &quot;&lt;C study&gt;&quot; &#125;; char **byLuenci; char **byGood[4]; byLuenci = &amp;cBooks[4]; byGood[0] = &amp;cBooks[0]; byGood[1] = &amp;cBooks[1]; byGood[2] = &amp;cBooks[2]; byGood[3] = &amp;cBooks[3]; printf(&quot;Luenci拥有的书: %s\n&quot;, *byLuenci); printf(&quot;Luenci喜欢的图书有：\n&quot;); int i; for (int i = 0; i &lt; 4; ++i) &#123; printf(&quot;%s\n&quot;,*byGood[i]); &#125; return 0;&#125;out: Luenci拥有的书: &lt;C study&gt;Luenci喜欢的图书有：&lt;c程序设计语言&gt;&lt;c专家编程&gt;&lt;c和指针&gt;&lt;c prime plus&gt;常量定义1234567891011520，‘a’, 3.14#define price 520#define A 'a'#define PI 3.14 // 使用const关键字修饰 const int price = 520;const char A = 'a';const float pi = 3.14;指向常量的指针指针可以修改为指向不同的常量指针可以修改为指向不同的变量可以通过解引用来读取指针指向的数据不可以通过解引用修改指针指向的数据123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int num =520; const int cnum = 880; const int *pc = &amp;cnum; printf("cnum:%d, &amp;cum:%p \n", cnum, &amp;cnum); printf("*pc:%d, pc:%p\n", *pc, pc); pc = &amp;num; printf("num:%d, &amp;num:%p \n", num, &amp;num); printf("*pc:%d, pc:%p\n", *pc, pc); return 0;&#125;函数结构1234类型名 函数名（参数列表）&#123; 函数体&#125;函数的声明所谓的声明（Declaration），就是告诉编译器我要是用这个函数，你现在没有找到它的定义不要紧，请不要报错，稍后我将会把它补上。函数的参数和返回值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;void print_c();int sum(int n);int max(int x, int y);int max(int x, int y)&#123; // a？b:c 当a的值为真时，返回b的值；否则返回c的值 return x &gt; y ? x:y;&#125;int sum(int n)&#123; int result = 0; do &#123; result += n; &#125;while (n-- &gt; 0); return result;&#125;void print_c()&#123; printf(" ###### \n"); printf("## ##\n"); printf("## \n"); printf("## \n"); printf("## ##\n"); printf(" ###### \n");&#125;int main()&#123; print_c(); int n,x,y;// printf("请输入n的值："); printf("请输入x,y的值：");// scanf("%d", &amp;n); scanf("%d%d", &amp;x, &amp;y);// printf("1+2+3+...+(n-1)+n的结果是：%d\n",sum(n)); printf("x,y中最大值的值为：%d\n", max(x,y)); return 0;&#125;形参和实参用于数据传输，形参就相当与一个占位符，只在函数内部有效。传值和传址1234567891011121314151617181920212223242526//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;void swap(int *x, int *y);void swap(int *x, int *y)&#123; int *temp; printf("In swap 互换前：x %d, y %d\n", *x,*y); temp = *x; *x = *y; *y = temp; printf("In swap 互换后：x %d, y %d\n", *x,*y);&#125;int main()&#123; int x = 3, y = 5; printf("In main 互换前：x %d, y %d\n", x,y); swap(&amp;x,&amp;y); printf("In main 互换后：x %d, y %d\n", x,y); return 0;&#125;传数组实际上传过去的是数组的地址123456789101112131415void get_array(int b[10])&#123; printf("sizeof b: %d\n", sizeof(b));&#125;int main()&#123; int a[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; printf("sizeof a:%d\n", sizeof(a)); get_array(a); out:sizeof a:40sizeof b: 4可变参数引入 头文件#include&lt;stdarg.h&gt;123456789101112131415161718192021222324252627282930313233343536373839//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;int sum(int n, ...);int sum(int n, ...)&#123; int i; int sum = 0; va_list vap; va_start(vap, n); for(i = 0; i &lt; n; i++)&#123; sum += va_arg(vap, int); &#125; va_end(vap); return sum;&#125;int main()&#123; int result,result2,result3; result = sum(3,1,2,-3); printf("result:%d\n", result); result2 = sum(4,2,2,4,2); printf("result2:%d\n", result2); result3 = sum(4,2,8,4,-2); printf("result3:%d\n", result3); return 0;&#125;指针函数使用指针变量作为函数的返回值，就是指针函数123456789101112131415161718192021222324252627282930313233343536373839//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;char *getchartchar();char *getchart(char c)&#123; switch (c) &#123; case &apos;A&apos;: return &quot;Apple&quot;; case &apos;B&apos;: return &quot;Banana&quot;; case &apos;C&apos;: return &quot;Cat&quot;; case &apos;D&apos;: return &quot;Dog&quot;; default: return &quot;None&quot;; &#125;&#125;int main()&#123; char input; printf(&quot;请输入一个字母：&quot;); scanf(&quot;%c&quot;, &amp;input); printf(&quot;%s\n&quot;, getchart(input)); return 0;&#125;in:Aout:ApplePS:不要返回局部变量的指针函数指针指针函数 - - &gt; int *p();函数指针 - - &gt; int (*p)();函数指针作为参数12345678910111213141516171819202122232425262728//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;int add(int, int);int sub(int, int);int clac(int (*fp)(int, int), int, int);int add(int num1, int num2)&#123; return num1 + num2;&#125;int sub(int num1, int num2)&#123; return num1 - num2;&#125;int clac(int (*fp)(int, int), int num1, int num2)&#123; return (*fp)(num1, num2);&#125;int main()&#123; printf("3 + 5 = %d\n", clac(add, 3,5)); printf("3 - 5 = %d\n", clac(sub, 3,5)); return 0;&#125;函数指针作为返回值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//// Created by Luenci on 2019/10/10.//#include &lt;stdio.h&gt;int add(int, int);int sub(int, int);int calc(int (*)(int, int), int, int);int (*slect(char))(int,int);int add(int num1, int num2)&#123; return num1 + num2;&#125;int sub(int num1, int num2)&#123; return num1 - num2;&#125;int calc(int (*fp)(int, int),int num1, int num2)&#123; return (*fp)(num1, num2);&#125;int (*slect(char op))(int, int)&#123; switch(op)&#123; case '+': return add; case '-': return sub; &#125;&#125;int main()&#123; int num1, num2; char op; int (*fp)(int, int); printf("请输入一个式子 (如 1+3) :"); scanf("%d%c%d", &amp;num1, &amp;op, &amp;num2); fp = slect(op); printf("%d %c %d = %d\n", num1, op, num2, calc(fp, num1, num2)); return 0;&#125;局部变量和全局变量局部变量不同函数的变量无法相互访问全局变量如果不对全局变量进行初始化，那么它会自动初始化为0.如果函数在内部存在一个与全局变量同名的局部变量，编译器不会报错，而是在函数中屏蔽全局变量。exsten关键字告诉编译器我等下会定义变量，不要报错不要大量的使用全局变量使用全局变量会使你的程序占用更多的内存，因为全局变量从定义时候开始，知道程序退出才释放。污染命名空间提高了程序耦合性作用域和链接属性当变量被定义在不同的位置时，它的作用域的范围是不一样的，这个作用范围就是我们所说的作用域C语言编译器可以确认四种不同类型的作用域：代码块的作用域文件作用域原型作用域函数作用域代码块作用域（Block scope）在代码块中定义的变量，具有代码块作用域。作用范围是从变量定义的位置开始，到标志代码块结束的大括号（}）处。文件作用域（file scope）任何在代码块之外声明的标识符都具有文件作用域，作用域的范围是从他们的声明位置开始，到文件的结尾处都是可以访问的。原型作用域（prototype scope）原型作用域只适用于那些在函数原型中声明的参数名。函数作用域（function scope）函数作用域只适合于goto语句的标签，作用将goto语句得标签限制在同一个函数内部，以防止出现重名的标签。定义和声明当一个变量被定义的时候，编译器为变量申请内存空间并填充值当一个变量被声明的时候，编译器就知道该变量被定义在其他地方声明是通知编译器该变量名及相关的类型已经存在，不需要再为此申请内存空间。局部变量即是定义又是声明定义只能来一次，否则就叫做重复定义某个同名的变量；而声明可以由你很多次。链接属性external（外部的）多个文件中声明的同名标识符表示一个实体internal（内部的）单个文件中声明的同名标识符表示同一个实体none（无）声明的同名标识符被当做独立的不同实体只有具备文件作用域的标识符才能拥有external或internal的链接属性，其他作用域的标识符都是none属性。默认情况下，具备文件的作用域的标识符拥有external属性。也就是说该标识符允许跨文件访问。对于external属性的标识符，无论在不同文件中声明多少次，表示的都是一个实体。使用static关键字可以使得原先拥有的external属性的标识符变为internal属性。这里有两点需要注意：使用static关键字修改链接属性，只对具有文件作用域的标识符生效（对于拥有其他作用域的标志符是另一种功能）链接属性只能修改一次，也就是说一旦将标识符的链接属性改为internal，就无法变回external。生存期和存储类型C语言变量拥有两种生存周期静态存储器自动存储器具有文件作用域的变量属于静态存储器，函数也属于静态存储器。属于静态存储器的变量在程序执行期间将一直占据存储空间，直到程序关闭才释放具有代码块作用域的变量一般情况下属于自动存储器。属于自动存储期的变量在代码块结束时将自动释放。存储类型存储类型其实是指存储变量值的内存类型，C语言提供了五种类型。autoregisterstaticexterntypedef]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django之编写URL]]></title>
    <url>%2F2019%2F10%2F07%2Fdjango%E4%B9%8Burl%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[编写URL编写规则​ 为了使其规范性，在每个新创建的App中设置独立的静态资源和模板文件夹并添加一个空白的.py文件，命为urls.py。如下是创建app中的文件结构：1234567891011121314frist/ migrations/ # 数据库前后是否有变化，生成出迁移文件 static/ # 创建App后存放App中的静态资源文件，自己手动添加 templates/ # 创建App后存放App中的模板文件，自己手动添加 __init__.py admin.py apps.py models.py tests.py urls.py # 创建App后由系统总路由映射到App的路由文件，自己手动添加 view.py系统总路由和app的路由分发配置12345678# 根目录的urls.pyfrom django.contrib import adminfrom django.urls import path,adminurlpatterns = [ path('admin/', admin.site.urls), path('',include('frist.urls')) # 引入app中的urls.py]代码详解:from django.contrib import admin:导入Admin功能模块.from django.urls import path,admin:导入URL编写模块.urlpatterns:整个项目的URL集合,每个元素代表一条URL信息.path(&#39;admin/&#39;, admin.site.urls):设定Admin的URL.&#39;admin/&#39;代表127.0.0.1/admin地址信息,admin后面的斜杠是路径分隔符;admin.site.urls是URL的处理函数,也称为视图函数.path(&#39;&#39;,include(&#39;frist.urls&#39;)):URL为空,代表网站的域名,即127.0.0.1,通常是网站的首页;include将该URL分发给app的urls.py处理.1234567# app下的urls.pyfrom django.urls import pathfrom . import viewsurlpatterns = [ path('',views.index) # 调用和url匹配的视图函数]当根目录的URL分发给app中的URL处理后,下一步就是根据所匹配的URL进行视图的调用.在Views中编写相应的视图函数。如下：12345# index的views.pyfrom django.http import HttpResponse# creat you views here.def index(request): return HttpResponse("hello world")视图函数的参数必须设置为request，该参数代表当前用户的请求对象，该对象包含用户名，请求内容和请求方式等信息，执行完成后必须使用return将处理结果返回。带变量的URL​ 在日常开发中，有时候一个URL可以代表多个不同的页面，如编写带有日期的URL，若根据前面的编写方式，按一年计算，则需要开发者编写365个不同的URL才能实现。这种做法是不可取的，因此，Django在编写URL时，可以对URL设置变量值，使URL具有多样性。​ URL的变量类型有字符类型，整型，slug和uuid，常用的是字符类型和整型。说明如下：字符类型：匹配任何非空字符串，但不含斜杠。如果没有指定类型，默认使用该类型。整形：匹配0和正整数slug：可理解为注释，后缀或附属等概念，常作为URL的解释性字符。可匹配任何ASCII字符以及连接符和下画线，能使URL更加清晰易懂。比如网页的标题是“13岁的孩子”，其URL地址可以设置为“13-sui-de-hai-zi“。uuid：匹配一个uuid格式的对象。为了防止冲突，规定必须使用破折号并且所有字母必须小写，例如0201203-3213-31e-321c34d435（未待完续）]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django简介]]></title>
    <url>%2F2019%2F10%2F07%2Fdjango%E9%85%8D%E7%BD%AE%E5%88%9D%E5%90%AF%2F</url>
    <content type="text"><![CDATA[Django简介背景2003诞生 它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的MVT（框架）Models 模型 数据库Views 视图 放和拿Template 模板 前端From 表单 django 会根据你后台数据库字段及表单层的设计对应的给你创建HTML关于表单的代码Django优点对象关系映射（Object Relational Mapping ORM）：通过定义映射类来构建数据模型，将模型与关系型数据库连接起来，使用ORM框架内置的数据库接口可实现复杂的数据操作。（简单来说就是把数据库的语句换成了python可识别的语言）URL设计：开发者可以设计任意的URL（网站地址）， 而且支持使用正则表达式设计。模板系统：提供可扩展的模板语言，模板之间具有可继承性。表单处理：可以生成各种表单模型，而且表单具有有效性检验功能。Cache系统：完善的缓存系统，可支持多种缓存方式用户管理系统：提供用户认证，权限设置和用户组功能，功能扩展性强。国际化：内置国际化系统，方便开发出多语言的网站。admin管理系统：内置admin管理系统，系统的扩展性强。Django项目目录1234567891011121314用django-admin startproject demo 创建一个demo项目文件结构如下：demo/ # 最外层 这个是整个项目的容器文件夹，可以随意改名字 demo/ # 内层的demo 是这个项目中关于配置文件的一个管理文件夹，这个不允许改名字 __init__.py #初始化文件，代表这个文件夹是一个包，一个模块，demo文件夹就是一个模块了 settings.py # 这个是整个项目的配置文件，配置中间，配置邮件等 urls.py # django项目的总路由配置文件。网站的地址信息 wsgi.py # 全称为Python Web Server Gateway Interface，即为python服务器网关接口， 是python应用与Web服务器之间的接口，用于Django项目在服务器上的部署和上线，一 般不需要修改 manage.py # 命令行工具，允许以多种方式与项目交互。 可输入 python manage.py help 查看 该工具的具体用法Django的创建的App目录使用命令创建app： python manage.py startapp frist创建了App必须把App名称添加到INSTALL_APPS里面。1234567891011121314frist/ migrations/ # 数据库前后是否有变化，生成出迁移文件 static/ # 创建App后存放App中的静态资源文件，自己手动添加 templates/ # 创建App后存放App中的模板文件，自己手动添加 __init__.py admin.py apps.py models.py tests.py urls.py # 创建App后由系统总路由映射到App的路由文件，自己手动添加 view.pyDjango（settings）配置全览123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122"""Django settings for mysite project.Generated by 'django-admin startproject' using Django 2.1.2.For more information on this file, seehttps://docs.djangoproject.com/en/2.1/topics/settings/For the full list of settings and their values, seehttps://docs.djangoproject.com/en/2.1/ref/settings/"""import os# 项目路径# Build paths inside the project like this: os.path.join(BASE_DIR, ...)BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))# Quick-start development settings - unsuitable for production# See https://docs.djangoproject.com/en/2.1/howto/deployment/checklist/# 密匙配置# SECURITY WARNING: keep the secret key used in production secret!SECRET_KEY = '#g$qgqkee8csvp67l$(8ugkx%+i_9k%mbykw-%9zpbnyn!bb!='# 调试模式# SECURITY WARNING: don't run with debug turned on in production!DEBUG = True# 域名访问权限ALLOWED_HOSTS = ['*']# App列表# Application definitionINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'myblog', 'article',]MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]ROOT_URLCONF = 'mysite.urls'TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [BASE_DIR, 'templates'], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', # 自定义模版全局变量(默认变量) 'article.views.global_settings', ], &#125;, &#125;,]WSGI_APPLICATION = 'mysite.wsgi.application'# Database# https://docs.djangoproject.com/en/2.1/ref/settings/#databasesDATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125;# Password validation# https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validatorsAUTH_PASSWORD_VALIDATORS = [ &#123; 'NAME':'django.contrib.auth.password_validation.UserAttributeSimilarityValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator', &#125;,]# Internationalization# https://docs.djangoproject.com/en/2.1/topics/i18n/LANGUAGE_CODE = 'zh-Hans'TIME_ZONE = 'Asia/Shanghai'USE_I18N = TrueUSE_L10N = TrueUSE_TZ = True# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/2.1/howto/static-files/STATIC_URL = '/static/'STATIC_ROOT = os.path.join(BASE_DIR, "static/")项目路径 BASE_DIR：主要通过os模块读取当前项目在系统的具体路径，该代码在创建项目时自动生成，一般情况无需修改密匙配置SECRET_KEY：是一个随机值，在项目创建的时候自动生成，一般情况下无需修改。主要用于重要的数据 加密处理，提高系统的安全性，避免遭到攻击者的恶意破坏。密匙主要用于用户密码，CSRF机制和会话Session等数据加密。12345* 用户密码：Django内置一套用户管理系统，该系统具有用户认证和存储用户信息等功能，在创建用户的时候，将用户的密码通过密匙进行加密处理，保证用户的安全性。* CSRF机制：该机制主要用于表单提交，防止窃取网站的用户信息来制造恶意请求* 会话Session：Session的信息存放在Cookies，以一串随机的字符串表示，用于标识当前访问网站的用户身份，记录相关用户信息。调试模式DEBUG：该值为布尔类型。如果在开发调试阶段应设置为True，在开发调试过程中会自动检测代码是否 发生更改，根据检测结果执行是否刷新重启系统。如果项目部署上线，将其改为False，否则会泄露系统的相关信息。域名访问权限ALLOWED_HOSTS:设置可访问的域名，默认值为空。当DEBUG为True并且ALLOWED_HOSTS为空时，项目只允许以localhost或127.0.0.1在浏览器上访问启动。当DEBUG为False时，ALLOWED_HOSTS为必填项，否则程序无法启动，如果想允许所有域名访问，可设置ALLOW_HOSTS=[‘*’]。App列表INSTALLED_APPS：告诉Django有哪些App。在创建项目时已有admin，auth，和session等配置等信息，这些都是Django内置的应用功能，各个功能说明如下。123456* admin:内置的后台管理系统。* auth：内置的用户认证系统。* contenttypes：记录项目中所有的model元数据（Django的ORM框架）。* session：Session会话功能，用于标识当前访问网站的 用户身份，记录相关用户信息。* message：消息提示功能。* staticfiles：查找静态资源路径。静态资源（static）123456789101112# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/2.1/howto/static-files/STATIC_URL = '/static/' STATIC_ROOT = os.path.join(BASE_DIR, "static/")# 设置根目录的静态资源文件夹staticSTATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'),# 设置App的静态资源文件夹 os.path.join(BASE_DIR, '/static')， ]​​ CSS也称层叠样式表（Cascading Style Sheets），是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。​ JavaScript是一种直译式脚本语言，也是一种动态类型，弱类型，基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。STATIC_URL是必须配置的属性而且属性值不能为空。如果没有配置STATICFILES_DIRS，则STATIC_URL只能识别App里的static静态资源文件夹。STATICFILES_DIRS是可选配置属性，属性值为列表或元组格式，每个列表（元组）元素代表一个静态资源文件夹，这些文件夹可行命名。在浏览器上访问项目的静态资源时，无论项目的静态资源文件夹是如何命名的，在浏览器上，静态资源的上级目录必须为static，而static而STATIC_URL的属性值,因为STATIC_URL也是静态资源的起始URL。​ 除此之外，静态资源配置还有STATIC_ROOT，其作用是方便在服务器上部署项目，实现服务器和项目之间的映射。STATIC_URL和STATICFILES_DIRS区别STATIC_URL是必须配置的属性而且属性的值不能为空。如果没有配置STATICFILES_DIRS,则STATIC_URL只能识别App里面的static静态资源文件夹。STATICFILES_DIRS是可选配置属性，属性值为列表或元组格式，每个列表（元组）元素代表一个静态资源文件夹，这些文件夹可自行命名。在浏览器上访问项目的静态资源时，无论项目的静态资源文件夹是如何命名的，在浏览器上，静态资源的上级目录必须为static，而static是STATIC_URL的属性值，因为STATIC_URL也是静态资源的起始URL。模板路径（template）在web开发中，模板是一种较为特殊的HTML文档。这个HTML文档嵌入了一些能够让Python识别的变量和指令，然后程序解析这些变量和指令，生成完整的HTML网页并返回给用户浏览。模板是Django里面的MTV框架模式的T部分，配置模板路径是Django在解析模板时，如何找到模板所在的位置。创建项目时，Django以有初始的模板配置信息。如下：123456789101112131415161718TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [BASE_DIR, 'templates'], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', # 自定义模版全局变量(默认变量) 'article.views.global_settings', ], &#125;, &#125;,]模板信息是以列表格式呈现的，每个元素具有不同的含义，说明如下：BACKEND：定义模板引擎，用于识别模板里面的变量和指令。内置的模板引擎有DjangoTemplate和jinjia2.Jinjia2，每个模板引擎都有自己的变量和指令语法。DIRS：设置模板所在的路径，告诉Django在那个地方查找模板的位置，默认为空列表APP_DIRS:是否在App里面查找模板文件OPTIONS：用于填充在RequestContext中上下文调用函数，一般情况下不做任何修改。数据库设置（Databases）在settings文件下 有一个DATABASES属性123456789101112131415DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', # 数据库引擎 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), # 本地sqllite3数据库位置 'USER': # 用户名 'PASSWORD': # 数据库密码 'HOST': # 数据库主机地址 &#125; &#125;# 默认的django使用sqllite3作为数据库 # django提供四种 ENGINE 数据库引擎 # django.db.backends.mysql # django.db.backends.oracle # django.db.backends.splite3# 如果你使用的是 PostgreSQL 或者Mysql的话，已经是先创建了数据库，但是默认的SQLlite不需要sqlite3 轻量级数据库（数据存放在文件里面）在Django连接MYSQL数据库时候如果提示django.db.utils.OperationalError的错误信息，这是因为MYSQL8.0版本的密码加密方式发生了变化，8.0版本的用户密码采用的是cha2加密方法。解决方法，把SQL语句将8.0版本加密方法改回原来的加密方式。123# newpassword 是我们设置的用户密码ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'newpassword';FLUSH PRIVILEGES;中间件（Middlewere）中间件（Middleware）是处理Django的request和response对象的钩子。当用户在网站中进行单击某个按钮等操作时，这个动作是用户向网站发送请求（request）；而网页会根据用户的操作返回相关的网页内容，这个过程称为响应处理（response）。从请求到响应的过程中，当Django接收到用户的请求时，Django首先经过中间件处理请求消息，执行相关的处理，然后将处理结果返回给用户，中间件的执行流程如图：如上图，中间件的作用主要是处理用户的请求信息。开发者也可以根据自己的开发需求自定义中间件，只要将自定义的中间件添加到配置属性MIDDLEWARE中即可激活。一般情况下，Django默认的中间件配置均可满足大部分的开发需求。1234567'django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware','django.middleware.csrf.CsrfViewMiddleware','django.contrib.auth.middleware.AuthenticationMiddleware','django.contrib.messages.middleware.MessageMiddleware','django.middleware.clickjacking.XFrameOptionsMiddleware',配置属性MIDDLEWARE的数据格式为列表类型，每个中间件的设置顺序是固定的，如果随意变更中间件很容易导致程序异常，每个中间件的说明如下：SecurityMiddleware：内置的安全机制，保护用户与网站的通信安全。SessionMiddleware：会话Session。LocaleModdleware：支持中文语言。CommonMiddleware：处理请求信息，规范化请求内容。CsrViewMiddleware：开启CSRF防护功能。AuthenticationMiddleware：开启内置的用户认证系统。MessageMiddleware：开启内置的信息提示功能。XFrameOptionsMiddleware：防止恶意程序点击劫持。修改时区及语言LANGUAGE_CODE = ‘en-us’ #语言TIME_ZONE = ‘UTC’ #时区12LANGUAGE_CODE = 'zh-Hans'TIME_ZONE = 'Asia/Shanghai'开启测试服务器用来展示你创建出来的空项目/home/Publc_Class/5-17-django框架/python3 manage.py runserver 0.0.0.0:9090开启了一个测试服务器runserver 可以让你在浏览器看到效果，但是这个是测试服务器，压力不过百创建默认数据库因为django自带的admin界面，首先需要数据库来支持我们来先创建出一个数据库1234makemigrations 数据库前后是否有变化，生成出迁移文件migrate 根据迁移文件 来对应的执行SQL语句 python3 manage.py makemigrationspython3 manage.py migrate如果数据库创建完成，那么目录结构下和manage.py同级的就会有一个db.splite3文件有了这个数据库，就可以创建超级用户来管理admin界面啦！为admin界面创建超级用户数据库有了，要创建超级用户python3 manage.py createsuperuser12345Username (leave blank to use 'root'): rootEmail address: 2573799357@qq.com Password: Password (again): Superuser created successfully.]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高德无人机科技研发岗（测试工程师）面试总结]]></title>
    <url>%2F2019%2F09%2F30%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[高德无人机科技研发岗（测试工程师）面试总结技术面1.在51job上面投递的简历，本科院校“双非”，有一些项目经验。2.面试的时候是技术工程师来一面。问了我关于C++问题（本人主攻Python），有点把我问住了，questionC11标准里，关于智能指针有什么新特性？回答链接：https://www.jianshu.com/p/4f58ebc43b824.我介绍了我的项目经验和实践能力。3.因为可能急需招人，面试官看了我的项目经验等，还是给了我机会。面人资问我期望薪资多少？我说4k然后又问我最低能接受的薪资是多少？我说3.3K现在才明白这是个坑，真正谈的时候是按照你的最低接受薪资来谈的，千万不要说的很低很低。不然后面你就算再谈，也加不了多少钱。这个是我面试受益的第一点。还有就是，不要觉得自己的工作廉价，不敢往高的价格谈（我之前以为自己面试问题都没回答对，而且对C++不熟）不敢向高的要，后来觉得面试首先自己要看得起自己。不管怎么样，薪资不能太低。总结​ 这次短暂的面试让我受益了很多，从应届生小白里面跳出来。希望自己接受这个教训，不要急于求成。面试也应该诚实，懂就懂，不懂就不懂，最忌讳不懂装懂（自己心里要有数）。选择岗位应该长远考虑，不应该只看重面前的小利益。各方面应该考虑全面，多和家里的长辈等有经验的人沟通。]]></content>
      <categories>
        <category>面试经历</category>
      </categories>
      <tags>
        <tag>面试总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 语言中 void* 详解及应用]]></title>
    <url>%2F2019%2F09%2F30%2FC%20%E8%AF%AD%E8%A8%80%E4%B8%AD%20void%20%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[C 语言中 void* 详解及应用void 在英文中作为名词的解释为 “空虚、空间、空隙”，而在 C 语言中，void 被翻译为“无类型”，相应的void * 为“无类型指针”。void 似乎只有”注释”和限制程序的作用，当然，这里的”注释”不是为我们人提供注释，而是为编译器提供一种所谓的注释。void 的作用1.对函数返回的限定，这种情况我们比较常见。2.对函数参数的限定，这种情况也是比较常见的。一般我们常见的就是这两种情况：当函数不需要返回值值时，必须使用void限定，这就是我们所说的第一种情况。例如：void func（int a,char *b）。当函数不允许接受参数时，必须使用void限定，这就是我们所说的第二种情况。例如：int func(void)。void 指针的使用规则\1. void 指针可以指向任意类型的数据，就是说可以用任意类型的指针对 void 指针对 void 指针赋值。例如：123int *a；void *p；p=a；如果要将 void 指针 p 赋给其他类型的指针，则需要强制类型转换，就本例而言：a=（int *）p。在内存的分配中我们可以见到 void 指针使用：内存分配函数 malloc 函数返回的指针就是 void * 型，用户在使用这个指针的时候，要进行强制类型转换，也就是显式说明该指针指向的内存中是存放的什么类型的数据 (int *)malloc(1024) 表示强制规定 malloc 返回的 void* 指针指向的内存中存放的是一个个的 int 型数据。\2. 在 ANSI C 标准中，不允许对 void 指针进行一些算术运算如 p++ 或 p+=1 等，因为既然 void 是无类型，那么每次算术运算我们就不知道该操作几个字节，例如 char 型操作 sizeof(char) 字节，而 int 则要操作 sizeof(int) 字节。而在 GNU 中则允许，因为在默认情况下，GNU 认为 void * 和 char * 一样，既然是确定的，当然可以进行一些算术操作，在这里sizeof(*p)==sizeof(char)。void 几乎只有”注释”和限制程序的作用，因为从来没有人会定义一个 void 变量，让我们试着来定义：1void a;这行语句编译时会出错，提示“illegal use of type ‘void’”。即使 void a 的编译不会出错，它也没有任何实际意义。众所周知，如果指针 p1 和 p2 的类型相同，那么我们可以直接在 p1 和 p2 间互相赋值；如果 p1 和 p2 指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的指针类型转换为左边指针的类型。123456float *p1;int *p2;p1 = p2;//其中p1 = p2语句会编译出错，//提示“&apos;=&apos; : cannot convert from &apos;int *&apos; to &apos;float *&apos;”，必须改为：p1 = (float *)p2;而 void * 则不同，任何类型的指针都可以直接赋值给它，无需进行强制类型转换。123void *p1;int *p2;p1 = p2;但这并不意味着，void * 也可以无需强制类型转换地赋给其它类型的指针。因为”无类型”可以包容”有类型”，而”有类型”则不能包容”无类型”。小心使用 void 指针类型:按照 ANSI(American National Standards Institute) 标准，不能对 void 指针进行算法操作，即下列操作都是不合法的：1234567void * pvoid;pvoid++; //ANSI：错误pvoid += 1; //ANSI：错误//ANSI标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指向数据类型大小的。//例如：int *pint;pint++; //ANSI：正确pint++ 的结果是使其增大 sizeof(int)。但是 GNU 则不这么认定，它指定 void * 的算法操作与 char * 一致。因此下列语句在 GNU 编译器中皆正确：12pvoid++; //GNU：正确pvoid += 1; //GNU：正确pvoid++ 的执行结果是其增大了 1。在实际的程序设计中，为迎合 ANSI 标准，并提高程序的可移植性，我们可以这样编写实现同样功能的代码：123void * pvoid;((char *)pvoid)++; //ANSI：错误；GNU：正确(char *)pvoid += 1; //ANSI：错误；GNU：正确GNU 和 ANSI 还有一些区别，总体而言，GNU 较 ANSI 更”开放”，提供了对更多语法的支持。但是我们在真实设计时，还是应该尽可能地迎合 ANSI 标准。 如果函数的参数可以是任意类型指针，那么应声明其参数为void *。注：void 指针可以任意类型的数据，可以在程序中给我们带来一些好处，函数中形为指针类型时，我们可以将其定义为 void 指针，这样函数就可以接受任意类型的指针。如：典型的如内存操作函数 memcpy 和 memset 的函数原型分别为：12void * memcpy(void *dest, const void *src, size_t len);void * memset ( void * buffer, int c, size_t num );这样，任何类型的指针都可以传入 memcpy 和 memset 中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型（参见 C 语言实现泛型编程）。如果 memcpy 和 memset 的参数类型不是 void *，而是 char *，那才叫真的奇怪了！这样的 memcpy 和 memset 明显不是一个”纯粹的，脱离低级趣味的”函数！void 的出现只是为了一种抽象的需要，如果你正确地理解了面向对象中”抽象基类”的概念，也很容易理解 void 数据类型。正如不能给抽象基类定义一个实例，我们也不能定义一个 void（让我们类比的称 void 为”抽象数据类型”）变量。原文地址：https://www.cnblogs.com/wuyudong/p/c-void-point.html]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>Void* 知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机系统组成及工作原理简介]]></title>
    <url>%2F2019%2F09%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[计算机系统组成及工作原理简介硬件系统中央控制器 CPU运算器 ALU又称算数逻辑部件，是计算机用来进行数据运算的部件算数运算加、减、乘、除四则运算逻辑运算与、或、非、异或等逻辑操作，以及移位、比较和传送等操作，亦称算术逻辑部件（ALU）控制器 Controller通过地址访问存储器，逐条取出选中单元的指令，分析指令，根据指令产生相应的控制信号，用于其他各个部件，控制其他部件完成指令要求的操作。存储器 Memory：计算机中具有记忆能力的部件，用来存放程序或数据内存储器内存，又称主存，是CPU能根据地址线直接寻址的存储空间，是计算机内部存放数据的硬件设备，是程序和数据存储的基本要素。外存储器外存，又称辅存，作为一种辅助存储设备，主要用来存放一些暂时不用而又需长期保存的程序或数据。输入设备 Input Device用来输入程序和数据的部件：常用的输入设备有键盘，鼠标，传声器（麦克风），扫描仪，手写板，数码相机，摄像头等。输出设备 Output Device显示输出结果的部件 显示器，音响，打印机，绘图仪。软件系统系统软件管理，监控，维护计算机正常工作和供用户操作使用的计算机软件。应用软件在某种具体应用，供最终用户使用的软件。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas函数]]></title>
    <url>%2F2019%2F08%2F25%2Fpandas%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[【python】Pandas中DataFrame基本函数整理构造函数DataFrame([data, index, columns, dtype, copy]) #构造数据框1属性和数据DataFrame.axes #index: 行标签；columns: 列标签DataFrame.as_matrix([columns]) #转换为矩阵DataFrame.dtypes #返回数据的类型DataFrame.ftypes #返回每一列的 数据类型float64:denseDataFrame.get_dtype_counts() #返回数据框数据类型的个数DataFrame.get_ftype_counts() #返回数据框数据类型float64:dense的个数DataFrame.select_dtypes([include, include]) #根据数据类型选取子数据框DataFrame.values #Numpy的展示方式DataFrame.axes #返回横纵坐标的标签名DataFrame.ndim #返回数据框的纬度DataFrame.size #返回数据框元素的个数DataFrame.shape #返回数据框的形状DataFrame.memory_usage() #每一列的存储12345678910111213类型转换1234DataFrame.astype(dtype[, copy, errors]) #转换数据类型DataFrame.copy([deep]) #deep深度复制数据DataFrame.isnull() #以布尔的方式返回空值DataFrame.notnull() #以布尔的方式返回非空值1234索引和迭代123456789101112131415161718DataFrame.head([n]) #返回前n行数据DataFrame.at #快速标签常量访问器DataFrame.iat #快速整型常量访问器DataFrame.loc #标签定位，使用名称DataFrame.iloc #整型定位，使用数字DataFrame.insert(loc, column, value) #在特殊地点loc[数字]插入column[列名]某列数据DataFrame.iter() #Iterate over infor axisDataFrame.iteritems() #返回列名和序列的迭代器DataFrame.iterrows() #返回索引和序列的迭代器DataFrame.itertuples([index, name]) #Iterate over DataFrame rows as namedtuples, with index value as first element of the tuple.DataFrame.lookup(row_labels, col_labels) #Label-based “fancy indexing” function for DataFrame.DataFrame.pop(item) #返回删除的项目DataFrame.tail([n]) #返回最后n行DataFrame.xs(key[, axis, level, drop_level]) #Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.DataFrame.isin(values) #是否包含数据框中的元素DataFrame.where(cond[, other, inplace, …]) #条件筛选DataFrame.mask(cond[, other, inplace, …]) #Return an object of same shape as self and whose corresponding entries are from self where cond is False and otherwise are from other.DataFrame.query(expr[, inplace]) #Query the columns of a frame with a boolean expression.123456789101112131415161718二元运算123456789101112131415161718192021222324DataFrame.add(other[,axis,fill_value]) #加法，元素指向DataFrame.sub(other[,axis,fill_value]) #减法，元素指向DataFrame.mul(other[, axis,fill_value]) #乘法，元素指向DataFrame.div(other[, axis,fill_value]) #小数除法，元素指向DataFrame.truediv(other[, axis, level, …]) #真除法，元素指向DataFrame.floordiv(other[, axis, level, …]) #向下取整除法，元素指向DataFrame.mod(other[, axis,fill_value]) #模运算，元素指向DataFrame.pow(other[, axis,fill_value]) #幂运算，元素指向DataFrame.radd(other[, axis,fill_value]) #右侧加法，元素指向DataFrame.rsub(other[, axis,fill_value]) #右侧减法，元素指向DataFrame.rmul(other[, axis,fill_value]) #右侧乘法，元素指向DataFrame.rdiv(other[, axis,fill_value]) #右侧小数除法，元素指向DataFrame.rtruediv(other[, axis, …]) #右侧真除法，元素指向DataFrame.rfloordiv(other[, axis, …]) #右侧向下取整除法，元素指向DataFrame.rmod(other[, axis,fill_value]) #右侧模运算，元素指向DataFrame.rpow(other[, axis,fill_value]) #右侧幂运算，元素指向DataFrame.lt(other[, axis, level]) #类似Array.ltDataFrame.gt(other[, axis, level]) #类似Array.gtDataFrame.le(other[, axis, level]) #类似Array.leDataFrame.ge(other[, axis, level]) #类似Array.geDataFrame.ne(other[, axis, level]) #类似Array.neDataFrame.eq(other[, axis, level]) #类似Array.eqDataFrame.combine(other,func[,fill_value, …]) #Add two DataFrame objects and do not propagate NaN values, so if for aDataFrame.combine_first(other) #Combine two DataFrame objects and default to non-null values in frame calling the method.123456789101112131415161718192021222324函数应用&amp;分组&amp;窗口12345678DataFrame.apply(func[, axis, broadcast, …]) #应用函数DataFrame.applymap(func) #Apply a function to a DataFrame that is intended to operate elementwise, i.e.DataFrame.aggregate(func[, axis]) #Aggregate using callable, string, dict, or list of string/callablesDataFrame.transform(func, *args, **kwargs) #Call function producing a like-indexed NDFrameDataFrame.groupby([by, axis, level, …]) #分组DataFrame.rolling(window[, min_periods, …]) #滚动窗口DataFrame.expanding([min_periods, freq, …]) #拓展窗口DataFrame.ewm([com, span, halflife, …]) #指数权重窗口12345678描述统计学12345678910111213141516171819202122232425262728293031323334DataFrame.abs() #返回绝对值DataFrame.all([axis, bool_only, skipna]) #Return whether all elements are True over requested axisDataFrame.any([axis, bool_only, skipna]) #Return whether any element is True over requested axisDataFrame.clip([lower, upper, axis]) #Trim values at input threshold(s).DataFrame.clip_lower(threshold[, axis]) #Return copy of the input with values below given value(s) truncated.DataFrame.clip_upper(threshold[, axis]) #Return copy of input with values above given value(s) truncated.DataFrame.corr([method, min_periods]) #返回本数据框成对列的相关性系数DataFrame.corrwith(other[, axis, drop]) #返回不同数据框的相关性DataFrame.count([axis, level, numeric_only]) #返回非空元素的个数DataFrame.cov([min_periods]) #计算协方差DataFrame.cummax([axis, skipna]) #Return cumulative max over requested axis.DataFrame.cummin([axis, skipna]) #Return cumulative minimum over requested axis.DataFrame.cumprod([axis, skipna]) #返回累积DataFrame.cumsum([axis, skipna]) #返回累和DataFrame.describe([percentiles,include, …]) #整体描述数据框DataFrame.diff([periods, axis]) #1st discrete difference of objectDataFrame.eval(expr[, inplace]) #Evaluate an expression in the context of the calling DataFrame instance.DataFrame.kurt([axis, skipna, level, …]) #返回无偏峰度Fisher’s (kurtosis of normal == 0.0).DataFrame.mad([axis, skipna, level]) #返回偏差DataFrame.max([axis, skipna, level, …]) #返回最大值DataFrame.mean([axis, skipna, level, …]) #返回均值DataFrame.median([axis, skipna, level, …]) #返回中位数DataFrame.min([axis, skipna, level, …]) #返回最小值DataFrame.mode([axis, numeric_only]) #返回众数DataFrame.pct_change([periods, fill_method]) #返回百分比变化DataFrame.prod([axis, skipna, level, …]) #返回连乘积DataFrame.quantile([q, axis, numeric_only]) #返回分位数DataFrame.rank([axis, method, numeric_only]) #返回数字的排序DataFrame.round([decimals]) #Round a DataFrame to a variable number of decimal places.DataFrame.sem([axis, skipna, level, ddof]) #返回无偏标准误DataFrame.skew([axis, skipna, level, …]) #返回无偏偏度DataFrame.sum([axis, skipna, level, …]) #求和DataFrame.std([axis, skipna, level, ddof]) #返回标准误差DataFrame.var([axis, skipna, level, ddof]) #返回无偏误差 12345678910111213141516171819202122232425262728293031323334从新索引&amp;选取&amp;标签操作12345678910111213141516171819202122232425DataFrame.add_prefix(prefix) #添加前缀DataFrame.add_suffix(suffix) #添加后缀DataFrame.align(other[, join, axis, level]) #Align two object on their axes with theDataFrame.drop(labels[, axis, level, …]) #返回删除的列DataFrame.drop_duplicates([subset, keep, …]) #Return DataFrame with duplicate rows removed, optionally onlyDataFrame.duplicated([subset, keep]) #Return boolean Series denoting duplicate rows, optionally onlyDataFrame.equals(other) #两个数据框是否相同DataFrame.filter([items, like, regex, axis]) #过滤特定的子数据框DataFrame.first(offset) #Convenience method for subsetting initial periods of time series data based on a date offset.DataFrame.head([n]) #返回前n行DataFrame.idxmax([axis, skipna]) #Return index of first occurrence of maximum over requested axis.DataFrame.idxmin([axis, skipna]) #Return index of first occurrence of minimum over requested axis.DataFrame.last(offset) #Convenience method for subsetting final periods of time series data based on a date offset.DataFrame.reindex([index, columns]) #Conform DataFrame to new index with optional filling logic, placing NA/NaN in locations having no value in the previous index.DataFrame.reindex_axis(labels[, axis, …]) #Conform input object to new index with optional filling logic, placing NA/NaN in locations having no value in the previous index.DataFrame.reindex_like(other[, method, …]) #Return an object with matching indices to myself.DataFrame.rename([index, columns]) #Alter axes input function or functions.DataFrame.rename_axis(mapper[, axis, copy]) #Alter index and / or columns using input function or functions.DataFrame.reset_index([level, drop, …]) #For DataFrame with multi-level index, return new DataFrame with labeling information in the columns under the index names, defaulting to ‘level_0’, ‘level_1’, etc.DataFrame.sample([n, frac, replace, …]) #返回随机抽样DataFrame.select(crit[, axis]) #Return data corresponding to axis labels matching criteriaDataFrame.set_index(keys[, drop, append ]) #Set the DataFrame index (row labels) using one or more existing columns.DataFrame.tail([n]) #返回最后几行DataFrame.take(indices[, axis, convert]) #Analogous to ndarray.takeDataFrame.truncate([before, after, axis ]) #Truncates a sorted NDFrame before and/or after some particular index value.12345678910111213141516171819202122232425处理缺失值123DataFrame.dropna([axis, how, thresh, …]) #Return object with labels on given axis omitted where alternately anyDataFrame.fillna([value, method, axis, …]) #填充空值DataFrame.replace([to_replace, value, …]) #Replace values given in ‘to_replace’ with ‘value’.123从新定型&amp;排序&amp;转变形态1234567891011121314DataFrame.pivot([index, columns, values]) #Reshape data (produce a “pivot” table) based on column values.DataFrame.reorder_levels(order[, axis]) #Rearrange index levels using input order.DataFrame.sort_values(by[, axis, ascending]) #Sort by the values along either axisDataFrame.sort_index([axis, level, …]) #Sort object by labels (along an axis)DataFrame.nlargest(n, columns[, keep]) #Get the rows of a DataFrame sorted by the n largest values of columns.DataFrame.nsmallest(n, columns[, keep]) #Get the rows of a DataFrame sorted by the n smallest values of columns.DataFrame.swaplevel([i, j, axis]) #Swap levels i and j in a MultiIndex on a particular axisDataFrame.stack([level, dropna]) #Pivot a level of the (possibly hierarchical) column labels, returning a DataFrame (or Series in the case of an object with a single level of column labels) having a hierarchical index with a new inner-most level of row labels.DataFrame.unstack([level, fill_value]) #Pivot a level of the (necessarily hierarchical) index labels, returning a DataFrame having a new level of column labels whose inner-most level consists of the pivoted index labels.DataFrame.melt([id_vars, value_vars, …]) #“Unpivots” a DataFrame from wide format to long format, optionallyDataFrame.T #Transpose index and columnsDataFrame.to_panel() #Transform long (stacked) format (DataFrame) into wide (3D, Panel) format.DataFrame.to_xarray() #Return an xarray object from the pandas object.DataFrame.transpose(*args, **kwargs) #Transpose index and columns1234567891011121314Combining&amp; joining&amp;merging12345DataFrame.append(other[, ignore_index, …]) #追加数据DataFrame.assign(**kwargs) #Assign new columns to a DataFrame, returning a new object (a copy) with all the original columns in addition to the new ones.DataFrame.join(other[, on, how, lsuffix, …]) #Join columns with other DataFrame either on index or on a key column.DataFrame.merge(right[, how, on, left_on, …]) #Merge DataFrame objects by performing a database-style join operation by columns or indexes.DataFrame.update(other[, join, overwrite, …]) #Modify DataFrame in place using non-NA values from passed DataFrame.12345时间序列12345678910DataFrame.asfreq(freq[, method, how, …]) #将时间序列转换为特定的频次DataFrame.asof(where[, subset]) #The last row without any NaN is taken (or the last row withoutDataFrame.shift([periods, freq, axis]) #Shift index by desired number of periods with an optional time freqDataFrame.first_valid_index() #Return label for first non-NA/null valueDataFrame.last_valid_index() #Return label for last non-NA/null valueDataFrame.resample(rule[, how, axis, …]) #Convenience method for frequency conversion and resampling of time series.DataFrame.to_period([freq, axis, copy]) #Convert DataFrame from DatetimeIndex to PeriodIndex with desiredDataFrame.to_timestamp([freq, how, axis]) #Cast to DatetimeIndex of timestamps, at beginning of periodDataFrame.tz_convert(tz[, axis, level, copy]) #Convert tz-aware axis to target time zone.DataFrame.tz_localize(tz[, axis, level, …]) #Localize tz-naive TimeSeries to target time zone.12345678910作图1234567891011121314DataFrame.plot([x, y, kind, ax, ….]) #DataFrame plotting accessor and methodDataFrame.plot.area([x, y]) #面积图Area plotDataFrame.plot.bar([x, y]) #垂直条形图Vertical bar plotDataFrame.plot.barh([x, y]) #水平条形图Horizontal bar plotDataFrame.plot.box([by]) #箱图BoxplotDataFrame.plot.density(**kwds) #核密度Kernel Density Estimate plotDataFrame.plot.hexbin(x, y[, C, …]) #Hexbin plotDataFrame.plot.hist([by, bins]) #直方图HistogramDataFrame.plot.kde(**kwds) #核密度Kernel Density Estimate plotDataFrame.plot.line([x, y]) #线图Line plotDataFrame.plot.pie([y]) #饼图Pie chartDataFrame.plot.scatter(x, y[, s, c]) #散点图Scatter plotDataFrame.boxplot([column, by, ax, …]) #Make a box plot from DataFrame column optionally grouped by some columns orDataFrame.hist(data[, column, by, grid, …]) #Draw histogram of the DataFrame’s series using matplotlib / pylab.1234567891011121314转换为其他格式123456789101112131415161718192021DataFrame.from_csv(path[, header, sep, …]) #Read CSV file (DEPRECATED, please use pandas.read_csv() instead).DataFrame.from_dict(data[, orient, dtype]) #Construct DataFrame from dict of array-like or dictsDataFrame.from_items(items[,columns,orient]) #Convert (key, value) pairs to DataFrame.DataFrame.from_records(data[, index, …]) #Convert structured or record ndarray to DataFrameDataFrame.info([verbose, buf, max_cols, …]) #Concise summary of a DataFrame.DataFrame.to_pickle(path[, compression, …]) #Pickle (serialize) object to input file path.DataFrame.to_csv([path_or_buf, sep, na_rep]) #Write DataFrame to a comma-separated values (csv) fileDataFrame.to_hdf(path_or_buf, key, **kwargs) #Write the contained data to an HDF5 file using HDFStore.DataFrame.to_sql(name, con[, flavor, …]) #Write records stored in a DataFrame to a SQL database.DataFrame.to_dict([orient, into]) #Convert DataFrame to dictionary.DataFrame.to_excel(excel_writer[, …]) #Write DataFrame to an excel sheetDataFrame.to_json([path_or_buf, orient, …]) #Convert the object to a JSON string.DataFrame.to_html([buf, columns, col_space]) #Render a DataFrame as an HTML table.DataFrame.to_feather(fname) #write out the binary feather-format for DataFramesDataFrame.to_latex([buf, columns, …]) #Render an object to a tabular environment table.DataFrame.to_stata(fname[, convert_dates, …]) #A class for writing Stata binary dta files from array-like objectsDataFrame.to_msgpack([path_or_buf, encoding]) #msgpack (serialize) object to input file pathDataFrame.to_sparse([fill_value, kind]) #Convert to SparseDataFrameDataFrame.to_dense() #Return dense representation of NDFrame (as opposed to sparse)DataFrame.to_string([buf, columns, …]) #Render a DataFrame to a console-friendly tabular output.DataFrame.to_clipboard([excel, sep]) #Attempt to write text representation of object to the system cli]]></content>
      <categories>
        <category>python数据挖掘</category>
      </categories>
      <tags>
        <tag>pandas函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[妹子图爬虫（爬取妹子图图片）]]></title>
    <url>%2F2019%2F07%2F22%2Fpython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[python实现妹子图爬虫（爬取妹子网图片）一个简单的小爬虫实现爬取妹子图网站上的图片。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#coding=utf-8import requestsfrom bs4 import BeautifulSoupimport osall_url = 'http://www.mzitu.com'#http请求头Hostreferer = &#123; 'User-Agent':'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)', 'Referer':'http://www.mzitu.com' &#125;Picreferer = &#123; 'User-Agent':'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)', 'Referer':'http://i.meizitu.net'&#125;#此请求头破解盗链start_html = requests.get(all_url,headers = Hostreferer)#保存地址path = "D:\\mzitu\\"#找寻最大页数soup = BeautifulSoup(start_html.text,"html.parser")page = soup.find_all('a',class_='page-numbers')max_page = page[-2].textsame_url = 'http://www.mzitu.com/all/'for n in range(1,int(max_page)+1): ul = same_url+str(n) start_html = requests.get(ul, headers = Hostreferer) soup = BeautifulSoup(start_html.text,"html.parser") all_a = soup.find('div',class_='all').find_all('a',target='_blank') for a in all_a: title = a.get_text() #提取文本 if(title != ''): print("准备扒取："+title) #win不能创建带？的目录 if(os.path.exists(path+title.strip().replace('?',''))): #print('目录已存在') flag=1 else: os.makedirs(path+title.strip().replace('?','').replace(':', '')) flag=0 os.chdir(path + title.strip().replace('?','').replace(':', '')) href = a['href'] html = requests.get(href,headers = Hostreferer) mess = BeautifulSoup(html.text,"html.parser") pic_max = mess.find_all('span') try: pic_max = pic_max[9].text #最大页数 if(flag == 1 and len(os.listdir(path+title.strip().replace('?',''))) &gt;= int(pic_max)): print('已经保存完毕，跳过') continue for num in range(1, int(pic_max)+1): pic = href+'/'+str(num) html = requests.get(pic,headers = Hostreferer) mess = BeautifulSoup(html.text,"html.parser") pic_url = mess.find('img',alt = title) print(pic_url['src']) #exit(0) html = requests.get(pic_url['src'],headers = Picreferer) file_name = pic_url['src'].split(r'/')[-1] f = open(file_name,'wb') f.write(html.content) f.close() except Exception: pass print('完成 ') print('第',n,'页完成')原文参考：https://blog.csdn.net/baidu_35085676/article/details/68958267]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>爬虫实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据之Hadoop]]></title>
    <url>%2F2019%2F07%2F14%2Fhadoop%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Hadoop介绍组成部分Hadoop主要由3部分组成：Mapreduce编程模型HDFS分布式文件存储YARN配置信息管理员密码：admin123DNS1=202.103.24.68DNS2=202.103.44.150export HADOOP_HOME=/usr/local/hadoop-2.6.4export PATH=$HADOOP_HOME/bin$PATH:/usr/java/jdk1.8.0_201-amd64/binHadoop HDFS 简介概念：namenode：负责记录 数据块 的分布情况– 数据元数据信息datanode:负责实际存储 数据块block：是Hadoop最小存储数据单位 默认 128Msecondarynamenode: 辅助namenode完成fsimage管理或者优化HDFS简单命令hadoop version //查看版本hadoop fs //文件系统客户端hadoop jar //运行jar包hadoop classpath //查看类路径hadoop checknative //检查本地库并压缩hadoop distcp // 远程递归拷贝文件hadoop credential //认证hadoop trace //跟踪$ hdfs dfs -mkdir-p /user/ubuntu/ //在hdfs上建立文件夹$ hdfs dfs -puthdfs.cmd /user/ubuntu/ //将本地文件上传到HDFS$ hdfs dfs -get/user/ubuntu/hadoop.cmd a.cmd //将文件从HDFS取回本地$ hdfs dfs -rm -r -f /user/ubuntu/ //删除$ hdfs dfs -ls -R/ //递归展示HDFS文件系统一、hadoop所在目录cd usr/local/hadoop1二、启动hadoopbash ./starth.sh% 运行start-dfs.sh% 运行start-yarn.sh123启动dfs，浏览器查看：172.16.31.17:500701启动脚本，浏览器查看：172.16.31.17:80881停止脚本：bash ./stoph.sh1三、常用命令1.显示hadoop目录结构hdfs dfs -ls -R /12.在hadoop指定目录内创建新目录hdfs dfs -mkdir /winnie13.将本地文件夹存储至hadoophdfs dfs -put [本地目录] [hadoop目录]14.将本地文件存储至hadoophdfs dfs -put [本地地址] [hadoop目录]15.查看指定目录下内容hdfs dfs -ls [文件目录]16.打开某个已存在文件hdfs dfs -cat [file_path]17.在hadoop指定目录下新建一个空文件hdfs dfs -touchz /winnie/test03.txt18.将hadoop上某个文件重命名hdfs dfs -mv /winnie/test03.txt /winnie/test.txt19.将hadoop上某个文件down至本地已有目录下hdfs dfs -get [文件目录] [本地目录]110.将hadoop指定目录下所有内容保存为一个文件，同时down至本地hdfs dfs -getmerge /winnie/hadoop-file /home/spark/hadoop-file/test.txt111.删除hadoop上指定文件hdfs dfs -rm [文件地址]112.删除hadoop上指定文件夹（包含子目录等）hdfs dfs -rm -r [目录地址]hdfs dfs -rmr [目录地址]1213.将正在运行的hadoop作业kill掉hadoop job -kill [job-id]114.查看帮助hdfs dfs -help1四、安全模式1.退出安全模式NameNode在启动时会自动进入安全模式，安全模式是NameNode的一种状态，在这个阶段，文件系统不允许有任何修改。系统显示Name node in safe mode，说明系统正处于安全模式，这时只需要等待几十秒即可，也可通过下面的命令退出安全模式：/usr/local/hadoop$bin/hadoop dfsadmin -safemode leave12.进入安全模式在必要情况下，可以通过以下命令吧HDFS置于安全模式：/usr/local/hadoop$bin/hadoop dfsadmin -safemode enter1五、补充1.对hdfs操作的命令格式是hdfs dfs1.1 -ls 表示对hdfs下一级目录的查看1.2 -lsr 表示对hdfs目录的递归查看1.3 -mkdir 创建目录1.4 -put 从Linux上传文件到hdfs1.5 -get 从hdfs下载文件到linux1.6 -text 查看文件内容1.7 -rm 表示删除文件1.7 -rmr 表示递归删除文件2.hdfs在对数据存储进行block划分时，如果文件大小超过block，那么按照block大小进行划分；不如block size的，划分为一个块，是实际数据大小。3.hadoop常用命令：hdfs dfs 查看Hadoop HDFS支持的所有命令hdfs dfs –ls 列出目录及文件信息hdfs dfs –lsr 循环列出目录、子目录及文件信息hdfs dfs –tail /user/sunlightcs/test.txt 查看最后1KB的内容hdfs dfs –copyFromLocal test.txt /user/sunlightcs/test.txt 从本地文件系统复制文件到HDFS文件系统，等同于put命令hdfs dfs –copyToLocal /user/sunlightcs/test.txt test.txt 从HDFS文件系统复制文件到本地文件系统，等同于get命令hdfs dfs –chgrp [-R] /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录所属群组，选项-R递归执行，跟linux命令一样hdfs dfs –chown [-R] /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录拥有者，选项-R递归执行hdfs dfs –chmod [-R] MODE /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录权限，MODE可以为相应权限的3位数或+/-{rwx}，选项-R递归执行hdfs dfs –count [-q] PATH 查看PATH目录下，子目录数、文件数、文件大小、文件名/目录名hdfs dfs –cp SRC [SRC …] DST 将文件从SRC复制到DST，如果指定了多个SRC，则DST必须为一个目录hdfs dfs –du PATH 显示该目录中每个文件或目录的大小hdfs dfs –dus PATH 类似于du，PATH为目录时，会显示该目录的总大小hdfs dfs –expunge 清空回收站，文件被删除时，它首先会移到临时目录.Trash/中，当超过延迟时间之后，文件才会被永久删除hdfs dfs –getmerge SRC [SRC …] LOCALDST [addnl] 获取由SRC指定的所有文件，将它们合并为单个文件，并写入本地文件系统中的LOCALDST，选项addnl将在每个文件的末尾处加上一个换行符hdfs dfs –test –[ezd] PATH 对PATH进行如下类型的检查：-e PATH是否存在，如果PATH存在，返回0，否则返回1；-z 文件是否为空，如果长度为0，返回0，否则返回1； -d 是否为目录，如果PATH为目录，返回0，否则返回1hdfs dfs –text PATH 显示文件的内容，当文件为文本文件时，等同于cat；文件为压缩格式（gzip以及hadoop的二进制序列文件格式）时，会先解压缩hdfs dfs –help ls 查看某个[ls]命令的帮助文档Mapreduce解释mapper的角色:hadoop将用户提交的mapper可执行程序或脚本作为一个单独的进程加载起来，这个进程我们称之为mapper进程，hadoop不断地将文件片段转换为行，传递到我们的mapper进程中，mapper进程通过标准输入的方式一行一行地获取这些数据，然后设法将其转换为键值对，再通过标准输出的形式将这些键值对按照一对儿一行的方式输出出去。虽然在我们的mapper函数中，我们自己能分得清key/value(比方说有可能在我们的代码中使用的是string key,int value)，但是当我们采用标准输出之后，key value是打印到一行作为结果输出的(比如sys.stdout.write(“%s\t%s\n”%(birthyear,gender)))，因此我们为了保证hadoop能从中鉴别出我们的键值对，键值对中一定要以分隔符’\t’即Tab(也可自定义分隔符)字符分隔，这样才能保证hadoop正确地为我们进行partitoner、shuffle等等过程。reducer的角色:hadoop将用户提交的reducer可执行程序或脚本同样作为一个单独的进程加载起来，这个进程我们称之为reducer进程，hadoop不断地将键值对(按键排序)按照一对儿一行的方式传递到reducer进程中，reducer进程同样通过标准输入的方式按行获取这些键值对儿，进行自定义计算后将结果通过标准输出的形式输出出去。在reducer这个过程中需要注意的是：传递进reducer的键值对是按照键排过序的，这点是由MR框架的sort过程保证的，因此如果读到一个键与前一个键不同，我们就可以知道当前key对应的pairs已经结束了，接下来将是新的key对应的pairs。]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop介绍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据科学之统计学习]]></title>
    <url>%2F2019%2F07%2F14%2F%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[统计学中心倾向均值（常用的额）中位数分位数：它表示少于数据中特定百分比的一个值众数离散度极差方差统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数概率论中方差用来度量随机变量)和其数学期望（即均值）之间的偏离程度计算公式$$s^2 = \frac{\sum_{}(x-u)^2}{N}$$标准差中文环境中又常称均方差，是离均差平方的算术平均数的平方根，用σ表示。标准差是方差的算术平方根计算公式$$σ = \sqrt\frac{\sum_{}(x-u)^2}{N}$$相关性协方差协方差（Covariance）在概率论和统计学中用于衡量两个变量的总体误差。而方差是协方差的一种特殊情况，即当两个变量是相同的情况。计算公式概率论不独立和独立如果事件E和事件F独立意味着两个事同时发生的概率等于它们分别发生的概率的乘积。$$P（E, F） = P(E)*P(F)$$条件概率如果事件E与事件F独立，那么定义：$$P（E, F） = P(E)*P(F)$$如果两者不一定独立（并且概率都不为0），那么概率公式为：（已知F发生，在此条件下E发生的概率）$$P（E|F） = P（E, F）/P（F）$$]]></content>
      <categories>
        <category>统计学和概率论</category>
      </categories>
      <tags>
        <tag>数学知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之百度接口语音识别]]></title>
    <url>%2F2019%2F07%2F12%2F%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[python编程之百度接口语音识别首先在百度AI开放平台上创建语音识别应用，创建完毕应用后，得到系统分配给用户的AppID， API Key， secret Key，均为字符串，用于标识用户，为访问做签名验证。得到验证后，开始编程1.记录自己声音2.将记录下来的音频文件上传至云端3.解析返回后的结果python实现相关包 pyaudio，baidu-aip123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from aip import AipSpeechimport wavefrom pyaudio import PyAudio, paInt16def save_wave_file(filename, data): '''save the date to the wavfile''' wf = wave.open(filename, 'wb') wf.setnchannels(channels) wf.setsampwidth(sampwidth) wf.setframerate(framerate) wf.writeframes(b"".join(data)) wf.close()def my_record(): pa = PyAudio() stream = pa.open(format=paInt16, channels=1, rate=framerate, input=True, frames_per_buffer=NUM_SAMPLES) my_buf = [] count = 0 print('录音开始') while count &lt; TIME*10: # 控制录音时间 string_audio_data = stream.read(NUM_SAMPLES) my_buf.append(string_audio_data) count += 1 print('录音结束') save_wave_file('01.pcm', my_buf) stream.close()if __name__ == "__main__": framerate = 16000 NUM_SAMPLES = 2000 channels = 1 sampwidth = 2 TIME = 2 my_record() """ 我的 APPID AK SK """ APP_ID = '16795182 ' API_KEY = '8io5s7uv8pjYPUrQp1i8PcIg' SECRET_KEY = 'gK2MljvbcF3SKS4p0C2ieq1SCBNY48BD' client = AipSpeech(APP_ID, API_KEY, SECRET_KEY) # 读取文件 def get_file_content(filePath): with open(filePath, 'rb') as fp: return fp.read() # 识别本地文件 result = client.asr(get_file_content('01.pcm'), 'pcm', 16000, &#123; 'dev_pid': 1536, &#125;) # print(type(result)) print("语音识别结果：", result['result'])]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>语音识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据科学之数据可视化]]></title>
    <url>%2F2019%2F07%2F11%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数据可视化概述可视化的目的，是对数据进行可视化处理，以更明确地，有效的传递信息。数据可视化意义数据可视化是为了从数据中寻找三个方面的信息。模式。指数据中的规律。关系。指数据间的相关性。数据间的比较数据的构成数据的分布或联系异常。指有问题的数据。数据可视化的作用记录信息。用图形的方式描述各种具体或抽象的事物。分析推理。有效的提升了信息认知的效率，从而有助于人们更快地分析和推理出有效信息。信息传播和协同。数据可视化的分类科学可视化信息可视化可视分析学数据可视化基础数据类型根据数据模型，可将数据分为浮点数，整数，字符等根据概念模型类别型数据，有序型数据，区间型数据和比值型数据类别型数据：用于区分物体有序型数据：用来表示对象间的顺序关系区间型数据：用于得到对象间的定量关系。用于比较数值间的比列关系，可以精确地定义比例数据预处理数据的预处理的目的是提升数据质量数据质量包含以下六方面有效性：数据与实际情况对应时，是否违背约束条件准确性：数据能否精确的反映现实。完整性：采集数据集是否包含了数据源中 的所有数据点：且样本的属性都是完整的。一致性：整个数据集中的数据的衡量标准要一致时效性：数据适合当下时间区间内的分析任务可行性：数据源中的数据是使用者可依赖的。数据预处理步骤如下数据清理：指修正数据中的错误，识别脏数据，更正不一致数据的过程。数据集成：指把来自不同数据的同类数据进行合并，减少数据冲突，降低数据冗余程度等。数据归约：指在保证数据挖掘结果准确性的前提下，最大限度地精简数据量，得到简化的数据集。数据转换：指对数据进行规范化处理数据组织与管理大数据存储利用的是分布式存储与访问计数，它具有高效，容错性强等特点。分布式文件系统分布式文件系统是指文件在物理上可能被分散存储在不同地点的节点上，各节点通过计算机网络进行通信和数据传输，但仍然是一个完整的文件。常用的分布式系统有HDFS（hadoop分布式文件系统），GFS（Google分布式文件系统）等。文档存储文档存储支持对结构化数据的访问，一般以键值对的方式进行存储。文档存储类型也支持数组和列值键列式存储列式存储是指以流的方式在列中存储所有的数据键式存储以Key-Value存储，简称KV存储图形数据库图形数据库是NOSQL数据库的一种，是一种非关系型的数据库，它应用图形理论存储实体间的关系信息。关系型数据库关系模型是最传统的数据存储模型，数据按行存储在有架构界定的表中。用户可使用基于关系代数演算的结构化查询语言提供相应的语法查找符合条件的记录。内存数据库内存数据库就是将数据放在内存中直接操作的数据库。特点速度快，能处理实时型业务数据仓库数据仓库是一种特殊的数据库，一般用于存储海量数据，并直接支持后续的分析和决策操作。数据分析与数据挖掘数据分析统计分析是指对数据进行统计描述和统计推断的过程探索性数据分析是对调查，观测所得到的一些初步的杂乱无章的数据，在尽量少的先验假设下进行处理，通过作图，制表等形式和方程拟合，计算某些特征量等手段，探索数据的结构和规律的一种数据分析方法。验证性数据分析是指在已经有事先假设的关系模型等情况下，通过数据分析来验证已提出的假设在线分析和处理是一种交互式探索大规模多维数据集的方法。数据挖掘数据挖掘一般是指从大量的数据中通过算法搜索隐藏于其中的信息的过程。常见的数据挖掘分析方法有分类与预测，聚类分析，关联性分析和异常分析等。分类与预测聚类分析关联分析异常分析数据挖掘的步骤确定业务对象数据准备数据挖掘结果分析知识的同化]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>数据可视化概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站概念]]></title>
    <url>%2F2019%2F07%2F06%2Fserven%2F</url>
    <content type="text"><![CDATA[网站的组成目前多数网站由域名，空间服务器，DNS域名解析，网站程序和数据库等组成空间服务器（以下三种类型）虚拟主机：指在网络服务器上划分一定的磁盘空间供用户放置站点和应用组件等，提供必要的站点功能，数据存放和传输功能。所谓虚拟主机，也叫“网站空间”，就是把一台运行在互联网上的服务器划分成多个”虚拟“的服务器独立服务器：指性能更强大，整体硬件完全独立的服务器，其cpu都在8核以上。VPS（虚拟专用服务器）：将一个服务器分区成多个虚拟独立专享服务器的技术。网站的程序:是建设与修改网站所使用的编程语言。网站的分类资讯门户类网站企业品牌网站交易类网站B2C（Business To Consumer）网站：商家——消费者，主要是购物网站，用于商家和消费者之间的买卖，如传统的百货商店和购物广场。B2B（Business To Business）网站：商家——商家，主要是商务网站，用于商家之间的买卖，如传统的原材料市场和大型批发市场C2C（Consumer To Consumer）网站：消费者——消费者，主要以拍卖网站为主，用于个人的物品的买卖，如传统的旧货市场，跳骚市场，废品收购站等。办公及政府机构网站企业办公事物类网站政府办公类事物网站互动游戏网站功能性网站这类网站的主要特征是将一个具有广泛需求的共能扩展开来，开发一套强大的功能体系，将功能的实现推向极致。如：百度，goolge网站开发的常用术语域名：用于标识一个或多个ip地址DNS：域名系统，用于跟踪计算机的域名及其在互联网上的相应的IP地址]]></content>
      <categories>
        <category>网站知识</category>
      </categories>
      <tags>
        <tag>网站的基本概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法时间复杂度和五大经典排序算法]]></title>
    <url>%2F2019%2F06%2F29%2Fsix%2F</url>
    <content type="text"><![CDATA[渐进时间度表O记法所代表的是渐进上界限，Ω记法代表的是渐进下界Θ代表的集合是上述符号的交集，Θ(g) = O(g)常见的渐进运行时间实例时间复杂度相关名称相关实例及说明Θ（1）常数级哈希表的查询和修改Θ（lg n）对数级二分搜索，其对数基数并不重要Θ（n）线性级列表的遍历Θ(nlgn)线性对数级任意值序列的最优化排序，其复杂度等同于Θ(lg n!)Θ(n^2)平方级拿n个对象进行互相比对Θ(n^3)立方级Floyd-Warshall算法O(n^k)多项式级基于n的k层嵌套循环（k为整数），且必须满足K &gt; 0Ω(K^n)指数级每n项产生一个子集（其中k = 2），且必须满足K &gt; 1Θ(n!)阶乘级对n个值执行全排列操作冒泡排序冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 冒泡排序算法的运作如下： 1、比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。 2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 3、针对所有的元素重复以上的步骤，除了最后一个。 4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 ‘’’冒泡排序的时间复杂度为O(n^2)。1234567891011121314151617181920212223def store(x): '''冒泡排序算法实现''' f=0 while f &lt; len(x): i=0 j=1 while j &lt; len(x): if x[i] &lt;= x[j]: i = i + 1 j = j + 1 elif x[i] &gt; x[j]: var1 = x[i] var2 = x[j] x[j] = var1 x[i] = var2 i = i + 1 j = j + 1 f = f + 1 return xif __name__ == "__main__": test = [2,4,6,5,9,7,12,15,13,19,20,1,3] print(store(test))归并排序归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表， 即把待排序序列分为若干个子序列，每个子序列是有序的。 然后再把有序子序列合并为整体有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。123456789101112131415161718192021222324252627282930313233def merge_extend(x): '''归并排序算法''' # 拆分列表 if len(x) &lt;= 1: # 向下取整数 return x mid = len(x)//2 left = merge_extend(x[:mid]) right = merge_extend(x[mid:]) print(left,right) return merge_add(left, right)def merge_add(a, b): '''和并列表''' result = [] i = 0 j = 0 while i &lt; len(a) and j &lt; len(b): if a[i] &lt; b[j]: result.append(a[i]) i += 1 else: result.append(b[j]) j += 1 #print("a",a[i:]) #print("b",b[j:]) result.extend(a[i:]) result.extend(b[j:]) return resultif __name__ == "__main__": test=[11,0,5,7,3,6,8,1,2] print(merge_extend(test))插入排序插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列， 对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。简单插入排序的时间复杂度也是O(n^2)123456789101112def insert_sort(x): # 取列表的第一个元素为单独的一个，已经排好序的列表 for i in range(1, len(x)): # 要排序的的牌 for j in range(0, i): if x[i] &lt; x[j]: x[i], x[j] = x[j], x[i] return xif __name__=="__main__": test = [2,3,5,7,9,1,20,0,4,12,19,11,8,1] print(insert_sort(test))选择排序选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置， 然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。 选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上， 因此对n个元素的表进行排序总共进行至多n-1次交换。 在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。选择排序的时间复杂度为O(n^2)1234567891011def select_sort(x): '''选择排序''' new = [] while x: new.append(min(x)) x.remove(min(x)) return newif __name__=="__main__": test = [2,3,5,7,9,1,20,0,4,12,19,11,8,1] print(select_sort(test))快速排序1.先从待排序的数组中找出一个数作为基准数（取第一个数即可）， 2.然后将原来的数组划分成两部分：小于基准数的左子数组和大于等于基准数的右子数组。 3.然后对这两个子数组再递归重复上述过程，直到两个子数组的所有数都分别有序。 4.最后返回“左子数组” + “基准数” + “右子数组”，即是最终排序好的数组。快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)1234567891011121314151617def quick_sort(x): '''快速排序''' if len(x) &lt;= 1: return x base = x[0] left = [] right = [] for var in x: if var &gt; base: right.append(var) elif var &lt; base: left.append(var) return quick_sort(left) + [base] + quick_sort(right)if __name__ == "__main__": # 存在重复值被覆盖 test = [2,6,7,8,12,56,36,89,45,3]]]></content>
      <categories>
        <category>算法</category>
        <category>五大经典排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git文章更新测试]]></title>
    <url>%2F2019%2F06%2F28%2Ffive%2F</url>
    <content type="text"><![CDATA[这是一个测试文件test]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>测试文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的正则表达式]]></title>
    <url>%2F2019%2F06%2F26%2Ffour%2F</url>
    <content type="text"><![CDATA[匹配小数1[0-9]&#123;1,&#125;[.][0-9]*匹配整数1[0-9]中文的匹配1[\u4e00-\u9fa5]特殊符号和字符：123456789101112131415161718192021[A-Z0-9a-z]: A,1,a[abc]*: aaa,abc,acc,匹配前面的正则0次或多次a？: a,匹配前面的出现正则0次或一次.： 匹配任意字符\n\t1,2.3,4,5.a,c.*: acb,aaa,weaijdiajdw,desd.*?: 非贪婪匹配\d: 匹配任何数字 [0-9]*:002121,5498464\s: 匹配任意空白符 \n\t\v\r\f\w: 匹配任何数字，字母，字符 [A-Za-z0-9][u4e00-u9fa5] ：匹配中文a|b a,b1|2 1,2&#123;int&#125;:指明正则出现的次数+：匹配前面出现的正则一次或多次?：0次或一次*：0次或多次^:匹配开头$:匹配结尾^$:空[^A-Z]: 除了A-Z都匹配匹配双字节字符(包括汉字在内)：1[^\x00-\xff]匹配空白行的正则表达式：1\n\s*\r匹配HTML标记的正则表达式：1&lt;(\s*?)[^&gt;]*&gt;.*?|&lt;.*?&gt;匹配首尾空白字符的正则表达式：1^\s*|\s*$匹配Email地址的正则表达式：1\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*匹配网址URL的正则表达式：1[a-zA-z]+://[^\s]*匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：1^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$匹配国内电话号码：1\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;匹配腾讯QQ号：1[1-9][0-9]&#123;4,&#125;匹配中国邮政编码：12[1-9]\d&#123;5&#125;(?!\d)评注：中国邮政编码为6位数字匹配身份证：12\d&#123;15&#125;|\d&#123;18&#125;评注：中国的身份证为15位或18位匹配ip地址：12\d+\.\d+\.\d+\.\d+评注：提取ip地址时有用匹配特定数字：1234567891011^[1-9]\d*$ //匹配正整数^-[1-9]\d*$ //匹配负整数^-?[1-9]\d*$ //匹配整数^[1-9]\d*|0$ //匹配非负整数（正整数 + 0）^-[1-9]\d*|0$ //匹配非正整数（负整数 + 0）^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ //匹配正浮点数^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ //匹配负浮点数^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ //匹配浮点数^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ //匹配非负浮点数（正浮点数 + 0）^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$ //匹配非正浮点数（负浮点数 + 0）评注：处理大量数据时有用，具体应用时注意修正匹配特定字符串：12345^[A-Za-z]+$ //匹配由26个英文字母组成的字符串^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串^[a-z]+$ //匹配由26个英文字母的小写组成的字符串^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串^\w+$ //匹配由数字、26个英文字母或者下划线组成的字符串]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解释器介绍]]></title>
    <url>%2F2019%2F06%2F26%2Fthree%2F</url>
    <content type="text"><![CDATA[CPython当我们从Python官方网站下载并安装好Python 3.x后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。IPythonIPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。CPython用&gt;&gt;&gt;作为提示符，而IPython用In [序号]:作为提示符。JpythonJython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。PyPyPyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术（just-in-time compiler 即时编译器，通俗解释就是边编译边执行），对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。、IronPythonIronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。]]></content>
      <categories>
        <category>Python</category>
        <category>编译器介绍</category>
      </categories>
      <tags>
        <tag>python编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2019%2F06%2F23%2Ftow%2F</url>
    <content type="text"><![CDATA[Linux管理文件和目录的命令命令功能命令功能pwd显示当前目录ls查看目录下的内容cd改变所在目录cat显示文件的内容grep在文件中查找某字符cp复制文件touch创建文件mv移动文件rm删除文件rmdir删除目录pwd命令该命令的英文解释为print working directory(打印工作目录)。输入pwd命令，Linux会输出当前目录。cd命令cd命令用来改变所在目录。1234cd / 转到根目录中 cd ~ 转到/home/user用户目录下 cd /usr 转到根目录下的usr目录中-------------绝对路径 cd test 转到当前目录下的test子目录中-------相对路径ls命令​ ls命令用来查看目录的内容。选项含义-a列举目录中的全部文件，包括隐藏文件-l列举目录中的细节，包括权限、所有者、组群、大小、创建日期、文件是否是链接等-f列举的文件显示文件类型-r逆向，从后向前地列举目录中内容-R递归，该选项递归地列举当前目录下所有子目录内的内容-s大小，按文件大小排序-h以人类可读的方式显示文件的大小，如用K、M、G作单位ls -l examples.doc列举文件examples.doc的所有信息cat命令123cat命令可以用来合并文件，也可以用来在屏幕上显示整个文件的内容。cat snow.txt 该命令显示文件snow.txt的内容，ctrl+D退出cat。grep命令12345grep命令的最大功能是在一堆文件中查找一个特定的字符串。 grep money test.txt 以上命令在test.txt中查找money这个字符串，grep查找是区分大小写的touch命令​123touch命令用来创建新文件，他可以创建一个空白的文件，可以在其中添加文本和数据。 touch newfile 该命令创建一个名为newfile的空白文件。cp命令​ cp命令用来拷贝文件，要复制文件，输入命令：12cp &lt;source filename&gt; &lt;target filename&gt;cp t.txt Document/t 该命令将把文件t.txt复制到Document目录下，并命名为t。选项含义-i互动：如果文件将覆盖目标中的文件，他会提示确认-r递归：这个选项会复制整个目录树、子目录以及其他-v详细：显示文件的复制进度mv命令​ mv命令用来移动文件。选项说明-i互动：如果选择的文件会覆盖目标中的文件，他会提示确认-f强制：它会超越互动模式，不提示地移动文件，属于很危险的选项-v详细：显示文件的移动进度​ mv t.txt Document 把文件t.txt 移动到目录Document中。rm命令​ rm命令用来删除文件。选项说明-i互动：提示确认删除-f强制：代替互动模式，不提示确认删除-v详细：显示文件的删除进度-r递归：将删除某个目录以及其中所有的文件和子目录​ rm t.txt 该命令删除文件t.txtrmdir命令​ rmdir命令用来删除目录。mkdir 命令1234567#单个文件夹创建mkdir 文件夹名称#例如：mkdir wenjianjia#多个文件夹创建mkdirs 文件夹1/文件夹2......\#例如：mkdirs wenjianjia1/wenjianjia2chmod命令详解作用：改变一个或多个文件的存取模式(mode)格式：chmod [options] mode files只能文件属主或特权用户才能使用该功能来改变文件存取模式。mode：可以是数字形式或以who opcode permission形式表示。who是可选的，默认是a(所有用户)。只能选择一个opcode(操作码)。可指定多个mode，以逗号分开。综上，包含options、who、opcode、permission等选项，下面分别进行介绍options：标识含义-c，–changes只输出被改变文件的信息-f，–silent，–quiet当chmod不能改变文件模式时，不通知文件的用户–help输出帮助信息。-R，–recursive可递归遍历子目录，把修改应到目录下所有文件和子目录–reference=filename参照filename的权限来设置权限-v，–verbose无论修改是否成功，输出每个文件的信息–version输出版本信息who标识含义u用户g组o其它a所有用户(默认)opcode标识含义+增加权限-删除权限=重新分配权限permission标识含义r读w写x执行s设置用户(或组)的ID号t设置粘着位(sticky bit)，防止文件或目录被非属主删除作为选择，我们多数用三位八进制数字的形式来表示权限，第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限。如6(4+2)代表有读写权，7(4+2+1)有读、写和执行的权限。还可设置第四位，它位于三位权限序列的前面，第四位数字取值是4，2，1，代表意思如下：4，执行时设置用户ID，用于授权给基于文件属主的进程，而不是给创建此进程的用户。2，执行时设置用户组ID，用于授权给基于文件所在组的进程，而不是基于创建此进程的用户。1，设置粘着位。实例：12345678$ chmod u+x file 给file的属主增加执行权限$ chmod 751 file 给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限$ chmod u=rwx,g=rx,o=x file 上例的另一种形式$ chmod =r file 为所有用户分配读权限$ chmod 444 file 同上例$ chmod a-wx,a+r file 同上例$ chmod -R u+r directory 递归地给directory目录下所有文件和子目录的属主分配读的权限$ chmod 4755 设置用ID，给属主分配读、写和执行权限，给组和其他用户分配读、执行的权限。linux下链接ln –s 源文件 目标文件]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
</search>
