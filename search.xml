<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写在前面</title>
    <url>/2023/02/06/README/</url>
    <content><![CDATA[<h1>写在前面</h1>
<h2 id="About-ME-1-0">About ME 1.0</h2>
<p>此博客记录了我的一些学习过程和一些项目的源码和学习笔记。有兴趣的朋友可在菜单的<code>分类</code>中找寻自己感兴趣的内容。有些内容可能过于浅显或者有误，欢迎大家指教和斧正。</p>
<p>学无止境，希望大家都能学有所成。</p>
<p>每一种编程语言都是一种艺术，希望大家选择编程语言不要纠结不前，还不如先出发。一直在路上。</p>
<p>2018/12/4</p>
<h2 id="About-ME-2-0">About ME 2.0</h2>
<p>博文断断续续的写了两年多了，这两年我对技术的思考从浅显到底层，从一条线到一个平面。一路走来，收获良多。最初的信念现在还在坚守着：</p>
<p>仰望星空，也脚踏实地。</p>
<p>从一而终，终身学习，以有涯之生，追无涯之知，不亦乐乎！</p>
<p>2021/04/24</p>
]]></content>
      <categories>
        <category>个人随感</category>
      </categories>
  </entry>
  <entry>
    <title>CMDB 介绍</title>
    <url>/2023/02/06/CMDB%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1>CMDB介绍</h1>
<h2 id="CMDB含义">CMDB含义</h2>
<blockquote>
<p>CMDB代表配置管理数据库，通常被称为任何ITSM系统的心脏。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/img/CMDB-Diagram-1030x539-1.png" alt="CMDB 图"></p>
<p>​	简而言之，CMDB是一个存储库，用于存储有关构成IT基础架构的组件的信息。 这些组件通常称为CI（可配置项）。 据ITIL称，CI是为交付IT服务而需要进行管理的任何资产。</p>
<p>通常，CMDB包括CI的列表，它们的属性以及它们之间的关系。</p>
<p>CMDB的<strong>核心功能之一是支持服务管理流程</strong>，主要包括：事件，问题，变更，发布和资产管理。</p>
<span id="more"></span>
<h3 id="CMDB如何工作？">CMDB如何工作？</h3>
<blockquote>
<p>如前所述，CMDB是数据库。 它的独特之处在于它包含配置项的信息和关系，通常以列表的形式表示。</p>
</blockquote>
<ul>
<li>
<p>配置管理系统（CMS）负责管理此类CI所需的技术能力，该管理系统是可以具有多个CMDB的逻辑数据模型。</p>
</li>
<li>
<p>在组织中，通常发现CMDB是 <a href="https://www.motadata.com/zh-CN/itsm-software/">ITSM解决方案</a>，为资产和配置管理提供支持。</p>
</li>
<li>
<p>CMDB提供了查看和使用资产和可配置项目的通用场所。 该信息通常与其他ITSM流程（事件，问题和变更）结合使用，以创建有意义的关系。</p>
</li>
<li>
<p>使用发现和导出工具填充CMDB中的数据。 在Motadata ServiceOps ITSM平台中，我们支持无代理和基于代理的发现以填充CMDB。</p>
</li>
<li>
<p>由于数据量巨大，以行的形式，很少有人直接访问CMDB。 在Motadata ServiceOps ITSM中，用户可以使用报告模块将其CMDB数据有意义地组织到报告中。</p>
</li>
</ul>
<h2 id="CMDB用处">CMDB用处</h2>
<h4 id="CMDB是所有IT资产的参考点">CMDB是所有IT资产的参考点</h4>
<ul>
<li><strong>CMDB是所有硬件和软件资产的中央数据库</strong></li>
</ul>
<h4 id="CMDB允许跟踪IT基础架构中的更改">CMDB允许跟踪IT基础架构中的更改</h4>
<ul>
<li>如前所述，CMDB 通常作为 ITSM 解决方案的一部分存在。 在 Motadata ServiceOps ITSM 中，变更管理与 CMDB 紧密集成，允许使用变更模型跟踪变更。</li>
</ul>
<h4 id="CMDB允许跟踪IT基础架构中的更改-2">CMDB允许跟踪IT基础架构中的更改</h4>
<ul>
<li>如前所述，CMDB 通常作为 ITSM 解决方案的一部分存在。 在 Motadata ServiceOps ITSM 中，变更管理与 CMDB 紧密集成，允许使用变更模型跟踪变更。</li>
</ul>
<h4 id="CMDB有助于知识管理过程">CMDB有助于知识管理过程</h4>
<p>强大的知识管理需要高质量的数据输入。 使用适当的CMDB，可以在知识库中建立大量解决方案，因为：</p>
<ul>
<li>CMDB具有外来资产与事件，问题和变更管理的关系记录，允许对任何问题进行根本原因分析。</li>
<li>它维护对资产所做的所有更改的日志，以使技术人员能够识别不良更改。</li>
<li>CMDB保存资产的属性详细信息，使技术人员可以方便地访问它们。</li>
</ul>
<h4 id="CMDB有助于ITSM流程">CMDB有助于ITSM流程</h4>
<ul>
<li>当针对资产创建故障单时，通常将其与CMDB中的CI记录相关联。 该协会通过问题和变更管理继续发挥着至关重要的作用。</li>
</ul>
<h2 id="CMDB与资产管理">CMDB与资产管理</h2>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/img/CMDB-vs.-Asset-Management-966x1030-1.png" alt="CMDB 与资产管理"></p>
<p>​	谈论CMDB和资产管理引起了很多混乱，因为这两个术语在概念上是相关的。 但是有明显的区别。</p>
<ul>
<li>
<p>当资产在IT环境中处于活动状态时，CMDB专注于用于管理资产的信息。 它涉及识别资产的组成，用途以及与其他资产的关联方式。</p>
</li>
<li>
<p>资产管理是一组过程，例如采购管理，硬件资产管理，软件许可证管理，合同管理等，用于管理从采购到报废的资产的整个生命周期。</p>
</li>
<li>
<p>CMDB与资产管理之间的主要区别在于，CMDB将资产包括为配置项（CI），而在资产管理中，资产是对企业具有潜在财务价值的单个元素。</p>
</li>
<li>
<p>CMDB的目的是对组织中的所有IT资产有一个全面而正确的视图。 这使组织可以在一个地方管理所有资产，而不必分别处理每个资产。 这使CMDB成为建立有效资产管理策略的重要工具。</p>
</li>
</ul>
<h2 id="CMDB管理信息的分类">CMDB管理信息的分类</h2>
<ul>
<li><strong>固定信息</strong> 很多数据都可以通过一些程序，或者是自动化的手段进行自动的录入，几乎是不会变的，但需要有一个比较好的规范，比如像机房或者交换机这样一些信息，自动化工具是抽取不出来的，所以我们采用了一个变通的方法，统一交换机的命名规范，统一采用机房+机柜的命名规范，然后通过脚本抓包的方式把网络结构还原出来。如果主机也是基于这样的规范命名的话，甚至还可以把机柜还原出来。</li>
<li>可变信息
<ul>
<li>人员信息：包括像联系方式的等信息，主要是为监控系统提供相应的数据；</li>
<li>状态信息：包括资源上线状况、下线状况，主要是为自动化上线提供相应的信息；</li>
<li>环境信息：包括生产环境还是测试的环境，主要是为监控系统及自动化系统提供相应的信息；</li>
<li>项目信息：在跟一些业务系统做一对接时，项目信息是非常重要的，比如说业务系统需要知道某一个项目有哪一些IP都需要从这里面取数据，同时也是自动化系统的支撑，有了项目归属，服务器才知道应该去做哪些部署。</li>
</ul>
</li>
</ul>
<h2 id="CMDB的挑战">CMDB的挑战</h2>
<ul>
<li>来自各种来源的数据聚合以填充CMDB可能会非常昂贵。</li>
<li>由于CMDB是组织的一部分，并且组织倾向于发展和变化，因此使CMDB保持最新是一个挑战。</li>
<li>仅仅拥有数据是没有用的。 一个人必须获得意义。 这就是为什么CMDB通常与其他工具（如ITSM或独立的报告工具）结合使用的原因。 拥有多个工具会大大增加成本。 幸运的是，Motadata ServiceOps ITSM具有内置的报告工具，可用于分析CMDB。</li>
</ul>
<h2 id="CMDB的价值">CMDB的价值</h2>
<p>按照CMDB不同层来说：</p>
<ul>
<li>接口层的价值 支撑整个运维平台的建设，尽量做到自动化，中心化的管理。</li>
<li>展示层的价值 通过一个展示就很方便地知道我现在的物理服务器，虚拟机等的比例是多少，亦或者可以知道我们每个机柜的容量是多少，只要数据是准确的，有价值的，基于这些数据，我们就可以做出非常多的组合。</li>
</ul>
<p>按照通用的运维工作的价值维度来说：</p>
<ul>
<li>稳定 信息的维护越少人工干预，就越稳定。</li>
<li>效率 如果按照中心化的思路去做CMDB话，有很多信息就不需要多处变更了，从这个维度来说，也就提高了我们的效率，提高效率的同时也保证整个系统的稳定，因为人工操作难免都会出现一些问题的。</li>
<li>成本 我们可以根据CPU和内存去推算我的这个月这台服务器支出是多少，有了这些数据就可以得到每个月的机房支出，计算资源利用率。那么就可以很方便地进行。</li>
</ul>
<h2 id="涉及的工具">涉及的工具</h2>
<ul>
<li>Ansible</li>
</ul>
<p>​	简单的自动化IT工具。这个工具的目标有这么几项：自动化部署APP；自动化管理配置项；自动化的持续交互；自动化的（AWS）云服务管理。所有的这几个目标从本质上来说都是在一个台或者几台服务器上，执行一系列的命令而已。</p>
<ul>
<li>SALTSTACK</li>
</ul>
<p>​	一种全新的基础设施管理方式，部署轻松，在几分钟内可运行起来，扩展性好，很容易管理上万台服务器，速度够快，服务器之间秒级通讯。</p>
<p>底层采用动态的连接总线，使其可以用于编配，远程执行， 配置管理等等。</p>
<h1>参考链接</h1>
<ul>
<li><a href="https://www.motadata.com/zh-CN/blog/what-is-cmdb/">💬1 - 什么是CMDB？ | 它为什么如此重要？ | 元数据 (motadata.com)</a></li>
<li><a href="https://maxwellyue.gitbooks.io/cmdb/content/devops/cmdb/cmdb-shi-shi-mo.html">CMDB是什么 · DevOps (gitbooks.io)</a></li>
</ul>
]]></content>
      <categories>
        <category>运维开发</category>
      </categories>
      <tags>
        <tag>运维开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 网络模型</title>
    <url>/2023/02/06/linux%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1>linux 网络模型</h1>
<h2 id="概念说明">概念说明</h2>
<p>在进行解释之前，首先要说明几个概念：</p>
<ul>
<li>用户空间和内核空间</li>
<li>进程切换</li>
<li>进程的阻塞</li>
<li>文件描述符</li>
<li>缓存 I/O</li>
</ul>
<h3 id="用户空间与内核空间">用户空间与内核空间</h3>
<p>​	现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</p>
<p>​	针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为<strong>内核空间</strong>。</p>
<p>而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为<strong>用户空间</strong>。</p>
<h3 id="进程切换">进程切换</h3>
<p>​	为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<ol>
<li>保存处理机上下文，包括程序计数器和其他寄存器。</li>
<li>更新PCB信息。</li>
<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li>
<li>选择另一个进程执行，并更新其PCB。</li>
<li>更新内存管理的数据结构。</li>
<li>恢复处理机上下文。</li>
</ol>
<p><strong>总而言之就是很耗资源</strong>，具体的可以参考这篇文章：<a href="http://guojing.me/linux-kernel-architecture/posts/process-switch/">进程切换</a></p>
<h3 id="进程的阻塞">进程的阻塞</h3>
<p>​	正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<strong>当进程进入阻塞状态，是不占用CPU资源的</strong>。</p>
<h3 id="文件描述符fd">文件描述符fd</h3>
<p>​	文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>
<p>​	文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<h3 id="缓存-I-O">缓存 I/O</h3>
<p>​	缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的**页缓存（ page cache ）**中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<p><strong>缓存 I/O 的缺点：</strong><br>
数据在传输过程中需要在应用程序地址空间和内核进行<strong>多次数据拷贝</strong>操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<h3 id="IO拷贝">IO拷贝</h3>
<blockquote>
<p><strong>DMA 负责内核间的 IO 传输，CPU 负责内核和应用间的 IO 传输。</strong></p>
<p>更多详情见：<a href="https://cloud.tencent.com/developer/article/1759493">一文彻底揭秘操作系统之「零拷贝」！ - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
</blockquote>
<h4 id="CPU-COPY">CPU COPY</h4>
<p>​	通过计算机的组成原理我们知道, 内存的读写操作是需要 CPU 的协调数据总线,地址总线和控制总线来完成的因此在&quot;拷贝&quot;发生的时候,往往需要 CPU 暂停现有的处理逻辑,来协助内存的读写，这种我们称为 CPU COPY。CPU COPY 不但占用了 CPU 资源,还占用了总线的带宽。</p>
<h4 id="DMA-COPY">DMA COPY</h4>
<p>​	DMA(DIRECT MEMORY ACCESS) 是现代计算机的重要功能，它有一个重要特点：当需要与外设进行数据交换时, CPU 只需要初始化这个动作便可以继续执行其他指令,剩下的数据传输的动作完全由DMA来完成可以看到 DMA COPY 是可以避免大量的 CPU 中断的</p>
<span id="more"></span>
<h2 id="IO模式">IO模式</h2>
<p>​	刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p>
<ol>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ol>
<p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。</p>
<ul>
<li>阻塞 I/O（blocking IO）</li>
<li>非阻塞 I/O（nonblocking IO）</li>
<li>I/O 多路复用（ IO multiplexing）</li>
<li>信号驱动 I/O（ signal driven IO）</li>
<li>异步 I/O（asynchronous IO）</li>
</ul>
<p>注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</p>
<h3 id="阻塞-I-O（blocking-IO）">阻塞 I/O（blocking IO）</h3>
<p>​	在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：<br>
<img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/img/blocking-io.png" alt="blocking IO"></p>
<p>​	当用户进程调用了<code>recvfrom</code>这个系统调用，<code>kernel</code>就开始了<code>IO</code>的第一个阶段：</p>
<ul>
<li>准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。
<ul>
<li>比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。</li>
</ul>
</li>
</ul>
<p>​	当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>
<h3 id="非阻塞-I-O（nonblocking-IO）">非阻塞 I/O（nonblocking IO）</h3>
<p>​	linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：<br>
<img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/img/non-blocking-io.png" alt="非阻塞 I/O"></p>
<p>​	当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度io讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<blockquote>
<p>所以，nonblocking IO的特点是用户进程需要<strong>不断的主动询问</strong>kernel数据好了没有。</p>
</blockquote>
<h3 id="I-O-多路复用（-IO-multiplexing）">I/O 多路复用（ IO multiplexing）</h3>
<p>​	IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/img/io-multiplexing.png" alt="I/O多路复用"></p>
<p>​	<strong>当用户进程调用了select，那么整个进程会被block</strong>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>​	所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
<p>​	这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>​	所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用<code>multi-threading + blocking IO</code>的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>​	在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<h4 id="I-O-多路复用之select、poll、epoll详解">I/O 多路复用之select、poll、epoll详解</h4>
<p>​	select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。（这里啰嗦下）</p>
<h5 id="select">select</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure>
<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p>
<p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p>
<h5 id="poll">poll</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int poll (struct pollfd *fds, unsigned int nfds, int timeout);</span><br></pre></td></tr></table></figure>
<p>​	不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct pollfd &#123;</span><br><span class="line">    int fd; /* file descriptor */</span><br><span class="line">    short events; /* requested events to watch */</span><br><span class="line">    short revents; /* returned events witnessed */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​	pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>
<p>​	从上面看，select和poll都需要在返回后，<strong>通过遍历文件描述符来获取已经就绪的socket</strong>。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
<p><strong>poll无最大文件描述符数量的限制</strong>。</p>
<p>​	poll和select同样存在一个缺点：包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件	描述符是否就绪，其开销也随着文件描述符数量增加而线性增大。</p>
<ul>
<li>
<p>将用户态传入的数组拷贝到内核空间</p>
</li>
<li>
<p>然后查询每个fd对应设备状态：</p>
</li>
<li>
<ul>
<li>
<p>若设备就绪 在设备等待队列中加入一项继续遍历</p>
</li>
<li>
<ul>
<li>若遍历完所有fd后，都没发现就绪的设备 挂起当前进程，直到设备就绪或主动超时，被唤醒后它又再次遍历fd。这个过程经历多次无意义遍历。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>无最大连接数限制，因其基于链表存储，缺点：</p>
<ul>
<li>大量fd数组被整体复制于用户态和内核地址空间间，而不管是否有意义</li>
<li>若报告了fd后，没有被处理，则下次poll时会再次报告该fd</li>
</ul>
<h5 id="epoll">epoll</h5>
<p>​	epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<h5 id="epoll操作过程">epoll操作过程</h5>
<p>epoll操作过程需要三个接口，分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure>
<p><strong>1. int epoll_create(int size);</strong><br>
创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，<code>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议</code>。<br>
当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<p><strong>2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</strong></p>
<blockquote>
<p>函数是对指定描述符fd执行op操作。</p>
</blockquote>
<ul>
<li>epfd：是epoll_create()的返回值。</li>
<li>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</li>
<li>fd：是需要监听的fd（文件描述符）</li>
<li>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct epoll_event &#123;</span><br><span class="line">  __uint32_t events;  /* Epoll events */</span><br><span class="line">  epoll_data_t data;  /* User data variable */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>events可以是以下几个宏的集合：</p>
<ul>
<li>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</li>
<li>EPOLLOUT：表示对应的文件描述符可以写；</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li>
<li>EPOLLERR：表示对应的文件描述符发生错误；</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断；</li>
<li>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</li>
<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li>
</ul>
<p><strong>3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong></p>
<blockquote>
<p>等待epfd上的io事件，最多返回maxevents个事件。</p>
</blockquote>
<p>​	参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
<h5 id="工作模式">工作模式</h5>
<p>epoll对文件描述符的操作有两种模式：<strong>LT（level trigger）<strong>和</strong>ET（edge trigger）</strong>。LT模式是默认模式，LT模式与ET模式的区别如下：<br>
　　<strong>LT模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>
　　<strong>ET模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<h6 id="1-LT模式">1. LT模式</h6>
<p>​	LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<h6 id="2-ET模式">2. ET模式</h6>
<p>​	ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p>​	ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h5 id="3-总结">3. 总结</h5>
<p>假如有这样一个例子：</p>
<ol>
<li>我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符</li>
<li>这个时候从管道的另一端被写入了2KB的数据</li>
<li>调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作</li>
<li>然后我们读取了1KB的数据</li>
<li>调用epoll_wait(2)……</li>
</ol>
<p><strong>LT模式：</strong></p>
<p>​	如果是LT模式，那么在第5步调用epoll_wait(2)之后，仍然能受到通知。</p>
<p><strong>ET模式：</strong></p>
<p>​	如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait(2)之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。</p>
<p>​	当使用epoll的ET模型来工作时，当产生了一个EPOLLIN事件后，读数据的时候需要考虑的是当recv()返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs)&#123;</span><br><span class="line">  buflen = recv(activeevents[i].data.fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(buflen &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读</span></span><br><span class="line">    <span class="comment">// 在这里就当作是该次事件已处理处.</span></span><br><span class="line">    <span class="keyword">if</span>(errno == EAGAIN)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(buflen == <span class="number">0</span>)&#123;</span><br><span class="line">     <span class="comment">// 这里表示对端的socket已正常关闭.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(buflen == <span class="keyword">sizeof</span>(buf)&#123;</span><br><span class="line">      rs = <span class="number">1</span>;   <span class="comment">// 需要再次读取</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line">      rs = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Linux中的EAGAIN含义</strong></p>
<p>​	Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。<br>
​	从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。</p>
<p>​	例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。<br>
​	又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</p>
<h5 id="代码演示">代码演示</h5>
<p>下面是一段不完整的代码且格式不对，意在表述上面的过程，去掉了一些模板代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IPADDRESS   <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT        8787</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE     1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTENQ     5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDSIZE      1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLLEVENTS 100</span></span><br><span class="line"></span><br><span class="line">listenfd = socket_bind(IPADDRESS,PORT);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EPOLLEVENTS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个描述符</span></span><br><span class="line">epollfd = epoll_create(FDSIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加监听描述符事件</span></span><br><span class="line">add_event(epollfd,listenfd,EPOLLIN);</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环等待</span></span><br><span class="line"><span class="keyword">for</span> ( ; ; )&#123;</span><br><span class="line">    <span class="comment">//该函数返回已经准备好的描述符事件数目</span></span><br><span class="line">    ret = epoll_wait(epollfd,events,EPOLLEVENTS,<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//处理接收到的连接</span></span><br><span class="line">    handle_events(epollfd,events,ret,listenfd,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_events</span><span class="params">(<span class="type">int</span> epollfd,<span class="keyword">struct</span> epoll_event *events,<span class="type">int</span> num,<span class="type">int</span> listenfd,<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i;</span><br><span class="line">     <span class="type">int</span> fd;</span><br><span class="line">     <span class="comment">//进行遍历;这里只要遍历已经准备好的io事件。num并不是当初epoll_create时的FDSIZE。</span></span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; num;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         fd = events[i].data.fd;</span><br><span class="line">        <span class="comment">//根据描述符的类型和事件类型进行处理</span></span><br><span class="line">         <span class="keyword">if</span> ((fd == listenfd) &amp;&amp;(events[i].events &amp; EPOLLIN))</span><br><span class="line">            handle_accpet(epollfd,listenfd);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">            do_read(epollfd,fd,buf);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">            do_write(epollfd,fd,buf);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_event</span><span class="params">(<span class="type">int</span> epollfd,<span class="type">int</span> fd,<span class="type">int</span> state)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理接收到的连接</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_accpet</span><span class="params">(<span class="type">int</span> epollfd,<span class="type">int</span> listenfd)</span>&#123;</span><br><span class="line">     <span class="type">int</span> clifd;     </span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span>     </span><br><span class="line">     <span class="type">socklen_t</span>  cliaddrlen;     </span><br><span class="line">     clifd = accept(listenfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;cliaddrlen);     </span><br><span class="line">     <span class="keyword">if</span> (clifd == <span class="number">-1</span>)         </span><br><span class="line">     perror(<span class="string">&quot;accpet error:&quot;</span>);     </span><br><span class="line">     <span class="keyword">else</span> &#123;         </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;accept a new client: %s:%d\n&quot;</span>,inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port);                       <span class="comment">//添加一个客户描述符和事件         </span></span><br><span class="line">         add_event(epollfd,clifd,EPOLLIN);     </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读处理</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_read</span><span class="params">(<span class="type">int</span> epollfd,<span class="type">int</span> fd,<span class="type">char</span> *buf)</span>&#123;</span><br><span class="line">    <span class="type">int</span> nread;</span><br><span class="line">    nread = read(fd,buf,MAXSIZE);</span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>)     &#123;         </span><br><span class="line">        perror(<span class="string">&quot;read error:&quot;</span>);         </span><br><span class="line">        close(fd); <span class="comment">//记住close fd        </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLIN); <span class="comment">//删除监听 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)     &#123;         </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;client close.\n&quot;</span>);</span><br><span class="line">        close(fd); <span class="comment">//记住close fd       </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLIN); <span class="comment">//删除监听 </span></span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">else</span> &#123;         </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read message is : %s&quot;</span>,buf);        </span><br><span class="line">        <span class="comment">//修改描述符对应的事件，由读改为写         </span></span><br><span class="line">        modify_event(epollfd,fd,EPOLLOUT);     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写处理</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_write</span><span class="params">(<span class="type">int</span> epollfd,<span class="type">int</span> fd,<span class="type">char</span> *buf)</span> &#123;     </span><br><span class="line">    <span class="type">int</span> nwrite;     </span><br><span class="line">    nwrite = write(fd,buf,<span class="built_in">strlen</span>(buf));     </span><br><span class="line">    <span class="keyword">if</span> (nwrite == <span class="number">-1</span>)&#123;         </span><br><span class="line">        perror(<span class="string">&quot;write error:&quot;</span>);        </span><br><span class="line">        close(fd);   <span class="comment">//记住close fd       </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLOUT);  <span class="comment">//删除监听    </span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        modify_event(epollfd,fd,EPOLLIN); </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,MAXSIZE); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除事件</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delete_event</span><span class="params">(<span class="type">int</span> epollfd,<span class="type">int</span> fd,<span class="type">int</span> state)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改事件</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">modify_event</span><span class="params">(<span class="type">int</span> epollfd,<span class="type">int</span> fd,<span class="type">int</span> state)</span>&#123;     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注：另外一端我就省了</span></span><br></pre></td></tr></table></figure>
<h5 id="epoll总结">epoll总结</h5>
<p>​	在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而<strong>epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知</strong>。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)</p>
<p><strong>epoll的优点主要是以下几个方面：</strong></p>
<ol>
<li>
<p>监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以<code>cat /proc/sys/fs/file-max</code>查看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对 于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</p>
</li>
<li>
<p>IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</p>
</li>
</ol>
<p>如果没有大量的idle-connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle-connection，就会发现epoll的效率大大高于select/poll</p>
<h3 id="异步-I-O（asynchronous-IO）">异步 I/O（asynchronous IO）</h3>
<p>Linux下的asynchronous IO其实用得很少。先看一下它的流程：<br>
<img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/img/async-io.png" alt="异步IO"></p>
<p>​	用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<h2 id="总结">总结</h2>
<h3 id="blocking和non-blocking的区别">blocking和non-blocking的区别</h3>
<p>​	调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p>
<h3 id="synchronous-IO和asynchronous-IO的区别">synchronous IO和asynchronous IO的区别</h3>
<p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：</p>
<ul>
<li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</li>
<li>An asynchronous I/O operation does not cause the requesting process to be blocked</li>
</ul>
<p>​	两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p>
<p>​	有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p>
<p>​	而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>
<h3 id="五种-IO-模型的比较">五种 IO 模型的比较</h3>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/img/06fig06.gif" alt="graphics/06fig06.gif"></p>
<p>​	通过上面的图片，可以发现<code>non-blocking IO</code>和<code>asynchronous IO</code>的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<h1>参考链接</h1>
<ul>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/272891398">一文搞懂select、poll和epoll区别 - 知乎 (zhihu.com)</a></p>
</li>
<li>
<p><a href="https://cloud.tencent.com/developer/article/1759493">一文彻底揭秘操作系统之「零拷贝」！ - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
</li>
<li>
<p><a href="https://www.shenyanchao.cn/blog/2018/12/25/epoll/">linux epoll模型 | 申艳超-博客 (shenyanchao.cn)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>UNIX</category>
      </categories>
      <tags>
        <tag>网络模型</tag>
      </tags>
  </entry>
  <entry>
    <title>GitOps 介绍</title>
    <url>/2023/02/06/GitOps%20%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1>GitOps 介绍</h1>
<blockquote>
<p><a href="https://icloudnative.io/posts/what-is-gitops/">https://icloudnative.io/posts/what-is-gitops/</a></p>
</blockquote>
<h2 id="基础设施即代码">基础设施即代码</h2>
<p>在理解 GitOps 之前，我们需要先理解什么是<strong>基础设施即代码</strong>。</p>
<p>基础设施即代码（Infrastructure as Code, <strong>IaC</strong>），顾名思义，表示使用代码（而非手动流程）来定义基础设施，研发人员可以像对待应用软件一样对待基础设施，例如：</p>
<ul>
<li>可以创建包含基础架构规范的声明式配置文件，从而便于编辑和分发配置。</li>
<li>可以确保每次配置的环境都完全相同。</li>
<li>可以进行版本控制，所有的变更都会被记录下来，方便溯源。</li>
<li>可以将基础设施划分为若干个模块化组件，并通过自动化以不同的方式进行组合。</li>
</ul>
<p>当然，广义上的 IaC 不仅仅只关于基础设施，还包含了<strong>网络</strong>、<strong>安全</strong>、<strong>配置</strong>等等，所以广义上的 IaC 又叫 <strong>X as Code</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Lucareful/RepoImg/main/img/2022-07-02-16-10-zwMOq2.jpg" alt="img"></p>
<p>​	比如你想在 AWS 中创建服务器，配置网络，部署 Kubernetes 集群以及各种工作负载，你只需要定义好 Terraform 或 Ansible 的声明式配置，以及 Kubernetes 的配置清单即可，免去一切繁杂的手动操作。</p>
<h2 id="GitOps-是什么">GitOps 是什么</h2>
<p>​	GitOps = IaC + Git + CI/CD，即基于 IaC 的版本化 CI/CD。它的核心是使用 Git 仓库来管理基础设施和应用的配置，并且<strong>以 Git 仓库作为基础设施和应用的单一事实来源</strong>，你从其他地方修改配置（比如手动改线上配置）一概不予通过。</p>
<p><img src="https://raw.githubusercontent.com/Lucareful/RepoImg/main/img/2022-07-02-16-34-pRb1Jc.jpg" alt="img"></p>
<p>​	Git 仓库中的声明式配置描述了目标环境当前所需基础设施的期望状态，借助于 GitOps，如果集群的实际状态与 Git 仓库中定义的期望状态不匹配，Kubernetes reconcilers 会根据期望状态来调整当前的状态，最终使实际状态符合期望状态。</p>
<p>​	另一方面，现代应用的开发更多关注的是迭代速度和规模，拥有成熟 DevOps 文化的组织每天可以将代码部署到生成环境中数百次，DevOps 团队可以通过版本控制、代码审查以及自动测试和部署的 CI/CD 流水线等最佳实践来实现这一目标，这就是 GitOps 干的事情。</p>
<h2 id="GitOps-vs-DevOps">GitOps vs DevOps</h2>
<p>​	从广义上来看，GitOps 与 DevOps 并不冲突，<strong>GitOps 是一种技术手段，而 DevOps 是一种文化</strong>。GitOps 是一种实现持续交付（Continuous Delivery）、持续部署（Continuous Deployment）和基础设施即代码（IaC）的工具和框架，它是支持 DevOps 文化的。</p>
<p>从狭义上来看，GitOps 与 DevOps 有以下几个区别：</p>
<p>​	首先，<strong>GitOps 是以目标为导向的</strong>。它使用 Git 来维护期望状态，并不断调整实际状态，最终与期望状态相匹配。而 <strong>DevOps 更多关注的是最佳实践</strong>，这些实践可以普遍应用于企业的每一个流程。</p>
<p>​	其次，<strong>GitOps 采取声明式的操作方法，而 DevOps 同时接受声明式和命令式的方法</strong>，所以 DevOps 除了适用于容器环境之外，还适用于虚拟机和裸机环境。</p>
<p>​	最后，<strong>GitOps 重新定义了云原生场景下的 CI/CD</strong>，它以 Git 作为中心的不可变状态声明，以加快持续部署速度。</p>
<span id="more"></span>
<h2 id="GitOps-的设计哲学">GitOps 的设计哲学</h2>
<p>想要使用 GitOps 来管理你的基础设施和应用，需要践行以下几个原则：</p>
<h3 id="1-声明式">1. 声明式</h3>
<p>必须通过声明式来描述系统的期望状态。例如 Kubernetes，众多现代云原生工具都是声明式的，Kubernetes 只是其中的一种。</p>
<h3 id="2-版本控制-不可变">2. 版本控制/不可变</h3>
<p>因为所有的状态声明都存储在 Git 仓库中，并且把 Git 仓库作为单一事实来源，那么所有的操作都是从 Git 仓库里驱动的，而且保留了完整的版本历史，方便回滚。有了 Git 优秀的安全保障，也可以使用 SSH 密钥来签署 commits，对代码的作者和出处实施强有力的安全保障。</p>
<h3 id="3-自动应用变更">3. 自动应用变更</h3>
<p>Git 仓库中声明的期望状态发生了任何变更，都可以立即应用到系统中，而且不需要安装配置额外工具（比如 kubectl），也不需要配置 Kubernetes 的认证授权。</p>
<h3 id="4-持续的-Reconciliation">4. 持续的 Reconciliation</h3>
<p>​	Reconciliation 其实最早是 Kubernetes 里的一个概念，表示的是<strong>确保系统的实际状态与期望状态一致的过程</strong>。具体的实现方式是在目标环境中安装一个 agent，一旦实际状态与期望状态不匹配，agent 就会进行自动修复。这里的修复比 Kubernetes 的故障自愈更高级，即使是手动修改了集群的编排清单，集群也会被恢复到 Git 仓库中的清单所描述的状态。</p>
<p>鉴于以上这些设计哲学，我们来看一下 GitOps 的工作流：</p>
<p><img src="https://raw.githubusercontent.com/Lucareful/RepoImg/main/img/2022-07-02-22-01-V2RPEM.jpg" alt="img"></p>
<ul>
<li>首先，团队中的任何一个成员都可以 Fork 仓库对配置进行更改，然后提交 Pull Request。</li>
<li>接下来会运行 CI 流水线，一般会做这么几件事情：验证配置文件、执行自动化测试、检测代码的复杂性、构建 OCI 镜像、将镜像推送到镜像仓库等等。</li>
<li>CI 流水线运行完成后，团队中拥有合并代码权限的人将会将这个 Pull Request 合并到主分支中 。一般拥有这个权限的都是研发人员、安全专家或者高级运维工程师。</li>
<li>最后会运行 CD 流水线，将变更应用到目标系统中（比如 Kubernetes 集群或者 AWS） 。</li>
</ul>
<p>​	整个过程完全自动化且透明，通过多人协作和自动化测试来保证了基础设施声明配置的健壮性。而传统的模式是其中一个工程师在自己的电脑上操作这一切，其他人不知道发生了什么，也无法对其操作进行 Review。</p>
<h3 id="Push-模式">Push 模式</h3>
<p>​	目前大多数 CI/CD 工具都使用基于 Push 的部署模式，例如 Jenkins、CircleCI 等。这种模式一般都会在 CI 流水线运行完成后执行一个命令（比如 kubectl）将应用部署到目标环境中。</p>
<p><img src="https://raw.githubusercontent.com/Lucareful/RepoImg/main/img/2022-07-02-23-12-coPxwT.jpg" alt="img"></p>
<p>这种 CD 模式的缺陷很明显：</p>
<ul>
<li>需要安装配置额外工具（比如 kubectl）；</li>
<li>需要 Kubernetes 对其进行授权；</li>
<li>需要云平台授权；</li>
<li>无法感知部署状态。也就无法感知期望状态与实际状态的偏差，需要借助额外的方案来保障一致性。</li>
</ul>
<p>​	Kubernetes 集群或者云平台对 CI 系统的授权凭证在集群或云平台的信任域之外，不受集群或云平台的安全策略保护，因此 CI 系统很容易被当成非法攻击的载体。</p>
<h3 id="Pull-模式">Pull 模式</h3>
<p>Pull 模式会在目标环境中安装一个 Agent，例如在 Kubernetes 集群中就靠 Operator 来充当这个 Agent。Operator 会周期性地监控目标环境的实际状态，并与 Git 仓库中的期望状态进行比较，如果实际状态不符合期望状态，Operator 就会更新基础设施的实际状态以匹配期望状态。</p>
<p><img src="https://jsdelivr.icloudnative.io/gh/yangchuansheng/imghosting4@main/uPic/2022-07-02-23-38-YrEEzt.jpg" alt="img"></p>
<p>只有 Git 的变更可以作为期望状态的唯一来源，除此之外，任何人都不可以对集群进行任何更改，即使你修改了，也会被 Operator 还原为期望状态，这也就是传说中的<strong>不可变基础设施</strong>。</p>
<p>目前基于 Pull 模式的 CD 工具有 <a href="https://github.com/argoproj/argo-cd/">Argo CD</a>， <a href="https://github.com/fluxcd/flux">Flux CD</a> 以及 <a href="https://github.com/kubesphere/ks-devops">ks-devops</a>。</p>
<h2 id="GitOps-的优势">GitOps 的优势</h2>
<p>​	一般 GitOps 首选的都是基于 Pull 的部署模式，因为这种模式有很多不可替代的优势。</p>
<h3 id="更强大的安全保障">更强大的安全保障</h3>
<p>​	上面已经提到了，使用 GitOps 不需要任何 Kubernetes 或者云平台的凭证来执行部署，Kubernetes 集群内的 Argo CD 或者 Flux CD 只需要访问 Git 仓库，并通过 Pull 模式来更新即可。</p>
<p>​	另一方面，Git 由用于跟踪和管理代码变更的强大密码学支持，拥有对变更进行签名以证明作者身份和来源的能力，这是保障集群安全的关键。</p>
<h3 id="Git-作为事实的唯一真实来源">Git 作为事实的唯一真实来源</h3>
<p>​	因为所有的应用包括基础设施的声明式配置都保存在 Git 中，并把 Git 作为应用系统的唯一事实来源，因此可以利用 Git 的强大功能操作所有东西，例如版本控制、历史记录、审计和回滚等等，无需使用 kubectl 这样的工具来操作。</p>
<h3 id="提高生产力">提高生产力</h3>
<p>​	Git 也是开发人员非常熟悉的工具，通过 Git 不断迭代，可以提高生产率，加快开发和部署速度，更快地推出新产品，同时提高系统的稳定性和可靠性。</p>
<h3 id="更容易合规的审计">更容易合规的审计</h3>
<p>​	使用 GitOps 的基础设施可以像任何软件项目一样使用 Git 来管理，所以同样可以对其进行质量审计。当有人需要对基础设施进行更改时，会创建一个 Pull Request，等相关人员对其进行 Code Review 之后，更改才可以应用到系统中。</p>
<h2 id="总结">总结</h2>
<p>​	GitOps 是对现有 DevOps 文化的补充，它使用 Git 这样的版本控制系统来自动部署基础设施，部署过程清晰可见，可以查看和跟踪对系统进行的任何变更，提高了生产力、安全性和合规性。而且 GitOps 提供了更优雅的可观测性，可以实时观测部署状态，并采取行动使实际状态与期望状态保持一致。</p>
<p>​	而且在 GitOps 中，整个系统都是通过声明式来描述的，天然适合云原生环境，因为 Kubernetes 也是这么设计的。</p>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s的Pod创建历程</title>
    <url>/2023/02/06/k8s%E5%88%9B%E5%BB%BAPod%E5%8E%86%E7%A8%8B/</url>
    <content><![CDATA[<h1>K8s创建Pod的历程</h1>
<blockquote>
<p>参考原文：<a href="https://icloudnative.io/posts/what-happens-when-k8s/#span-idinline-toc1span-kubectl">https://icloudnative.io/posts/what-happens-when-k8s/#span-idinline-toc1span-kubectl</a></p>
</blockquote>
<h2 id="1-kubectl">1. kubectl</h2>
<h3 id="验证和生成器">验证和生成器</h3>
<p>​	当敲下回车键以后，<code>kubectl</code> 首先会执行一些客户端验证操作，以确保不合法的请求（例如，创建不支持的资源或使用格式错误的镜像名称）将会快速失败，也不会发送给 <code>kube-apiserver</code>。通过减少不必要的负载来提高系统性能。</p>
<p>​	验证通过之后， kubectl 开始将发送给 kube-apiserver 的 HTTP 请求进行封装。<code>kube-apiserver</code> 与 etcd 进行通信，所有尝试访问或更改 Kubernetes 系统状态的请求都会通过 kube-apiserver 进行，kubectl 也不例外。kubectl 使用生成器（ <a href="https://kubernetes.io/docs/user-guide/kubectl-conventions/#generators">generators</a>）来构造 HTTP 请求。生成器是一个用来处理序列化的抽象概念。</p>
<p>​	通过 <code>kubectl run</code> 不仅可以运行 <code>deployment</code>，还可以通过指定参数 <code>--generator</code> 来部署其他多种资源类型。如果没有指定 <code>--generator</code> 参数的值，kubectl 将会自动判断资源的类型。</p>
<p>​	例如，带有参数 <code>--restart-policy=Always</code> 的资源将被部署为 Deployment，而带有参数 <code>--restart-policy=Never</code> 的资源将被部署为 Pod。同时 kubectl 也会检查是否需要触发其他操作，例如记录命令（用来进行回滚或审计）。</p>
<p>​	在 kubectl 判断出要创建一个 Deployment 后，它将使用 <code>DeploymentV1Beta1</code> 生成器从我们提供的参数中生成一个 <a href="https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/kubectl/run.go#L59">运行时对象</a>。</p>
<h3 id="API-版本协商与-API-组">API 版本协商与 API 组</h3>
<p>​	为了更容易地消除字段或者重新组织资源结构，Kubernetes 支持多个 API 版本，每个版本都在不同的 API 路径下，例如 <code>/api/v1</code> 或者 <code>/apis/extensions/v1beta1</code>。不同的 API 版本表明不同的稳定性和支持级别，更详细的描述可以参考 <a href="https://k8smeetup.github.io/docs/reference/api-overview/">Kubernetes API 概述</a>。</p>
<p>​	API 组旨在对类似资源进行分类，以便使得 Kubernetes API 更容易扩展。API 的组名在 REST 路径或者序列化对象的 <code>apiVersion</code> 字段中指定。例如，Deployment 的 API 组名是 <code>apps</code>，最新的 API 版本是 <code>v1beta2</code>，这就是为什么你要在 Deployment manifests 顶部输入 <code>apiVersion: apps/v1beta2</code>。</p>
<p>​	kubectl 在生成运行时对象后，开始为它 <a href="https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/kubectl/cmd/run.go#L580-L597">找到适当的 API 组和 API 版本</a>，然后 <a href="https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/kubectl/cmd/run.go#L598">组装成一个版本化客户端</a>，该客户端知道资源的各种 REST 语义。该阶段被称为版本协商，kubectl 会扫描 <code>remote API</code> 上的 <code>/apis</code> 路径来检索所有可能的 API 组。由于 kube-apiserver 在 <code>/apis</code> 路径上公开了 OpenAPI 格式的规范文档， 因此客户端很容易找到合适的 API。</p>
<p>​	为了提高性能，kubectl <a href="https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/kubectl/cmd/util/factory_client_access.go#L117">将 OpenAPI 规范缓存</a>到了 <code>~/.kube/cache</code> 目录。如果你想了解 API 发现的过程，请尝试删除该目录并在运行 kubectl 命令时将 <code>-v</code> 参数的值设为最大值，然后你将会看到所有试图找到这些 API 版本的HTTP 请求。参考 <a href="https://k8smeetup.github.io/docs/reference/kubectl/cheatsheet/">kubectl 备忘单</a>。</p>
<p>​	最后一步才是真正地发送 HTTP 请求。一旦请求发送之后获得成功的响应，kubectl 将会根据所需的输出格式打印 success message。</p>
<h3 id="客户端身份认证">客户端身份认证</h3>
<p>在发送 HTTP 请求之前还要进行客户端认证，这是之前没有提到的，现在可以来看一下。</p>
<p>为了能够成功发送请求，kubectl 需要先进行身份认证。用户凭证保存在 <code>kubeconfig</code> 文件中，kubectl 通过以下顺序来找到 kubeconfig 文件：</p>
<ul>
<li>如果提供了 <code>--kubeconfig</code> 参数， kubectl 就使用 –kubeconfig 参数提供的 kubeconfig 文件。</li>
<li>如果没有提供 –kubeconfig 参数，但设置了环境变量 <code>$KUBECONFIG</code>，则使用该环境变量提供的 kubeconfig 文件。</li>
<li>如果 –kubeconfig 参数和环境变量 <code>$KUBECONFIG</code> 都没有提供，kubectl 就使用默认的 kubeconfig 文件 <code>$HOME/.kube/config</code>。</li>
</ul>
<p>解析完 kubeconfig 文件后，kubectl 会确定当前要使用的上下文、当前指向的群集以及与当前用户关联的任何认证信息。如果用户提供了额外的参数（例如 –username），则优先使用这些参数覆盖 kubeconfig 中指定的值。一旦拿到这些信息之后， kubectl 就会把这些信息填充到将要发送的 HTTP 请求头中：</p>
<ul>
<li>x509 证书使用 <a href="https://github.com/kubernetes/client-go/blob/82aa063804cf055e16e8911250f888bc216e8b61/rest/transport.go#L80-L89">tls.TLSConfig</a> 发送（包括 CA 证书）。</li>
<li><code>bearer tokens</code> 在 HTTP 请求头 <code>Authorization</code> 中 <a href="https://github.com/kubernetes/client-go/blob/c6f8cf2c47d21d55fa0df928291b2580544886c8/transport/round_trippers.go#L314">发送</a>。</li>
<li>用户名和密码通过 HTTP 基本认证 <a href="https://github.com/kubernetes/client-go/blob/c6f8cf2c47d21d55fa0df928291b2580544886c8/transport/round_trippers.go#L223">发送</a>。</li>
<li><code>OpenID</code> 认证过程是由用户事先手动处理的，产生一个像 bearer token 一样被发送的 token。</li>
</ul>
<h3 id="小结补充">小结补充</h3>
<p>​	如果要对k8s的部署文件进行进一步正确性校验，可以参看这个<a href="https://github.com/instrumenta/kubeval">Kubeval</a></p>
<span id="more"></span>
<h2 id="2-kube-apiserver">2. kube-apiserver</h2>
<h3 id="认证"><a href="https://k8smeetup.github.io/docs/admin/authentication/">认证</a></h3>
<p>​	现在我们的请求已经发送成功了，接下来将会发生什么？这时候就该 <code>kube-apiserver</code> 闪亮登场了！kube-apiserver 是客户端和系统组件用来保存和检索集群状态的主要接口。为了执行相应的功能，kube-apiserver 需要能够验证请求者是合法的，这个过程被称为认证。</p>
<p>​	那么 apiserver 如何对请求进行认证呢？当 kube-apiserver 第一次启动时，它会查看用户提供的所有 <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/">CLI 参数</a>，并组合成一个合适的令牌列表。</p>
<p><strong>举个例子 :</strong> 如果提供了 <code>--client-ca-file</code> 参数，则会将 x509 客户端证书认证添加到令牌列表中；如果提供了 <code>--token-auth-file</code> 参数，则会将 breaer token 添加到令牌列表中。</p>
<p>每次收到请求时，apiserver 都会 <a href="https://github.com/kubernetes/apiserver/blob/51bebaffa01be9dc28195140da276c2f39a10cd4/pkg/authentication/request/union/union.go#L54">通过令牌链进行认证，直到某一个认证成功为止</a>：</p>
<ul>
<li><a href="https://github.com/kubernetes/apiserver/blob/51bebaffa01be9dc28195140da276c2f39a10cd4/pkg/authentication/request/x509/x509.go#L60">x509 处理程序</a>将验证 HTTP 请求是否是由 CA 根证书签名的 TLS 密钥进行编码的。</li>
<li><a href="https://github.com/kubernetes/apiserver/blob/51bebaffa01be9dc28195140da276c2f39a10cd4/pkg/authentication/request/bearertoken/bearertoken.go#L38">bearer token 处理程序</a>将验证 <code>--token-auth-file</code> 参数提供的 token 文件是否存在。</li>
<li><a href="https://github.com/kubernetes/apiserver/blob/51bebaffa01be9dc28195140da276c2f39a10cd4/plugin/pkg/authenticator/request/basicauth/basicauth.go#L37">基本认证处理程序</a>确保 HTTP 请求的基本认证凭证与本地的状态匹配。</li>
</ul>
<p>​	如果 <a href="https://github.com/kubernetes/apiserver/blob/20bfbdf738a0643fe77ffd527b88034dcde1b8e3/pkg/authentication/request/union/union.go#L71">认证失败</a>，则请求失败并返回相应的错误信息；如果验证成功，则将请求中的 <code>Authorization</code> 请求头删除，并 <a href="https://github.com/kubernetes/apiserver/blob/e30df5e70ef9127ea69d607207c894251025e55b/pkg/endpoints/filters/authentication.go#L71-L75">将用户信息添加到</a>其上下文中。这给后续的授权和准入控制器提供了访问之前建立的用户身份的能力。</p>
<h3 id="授权"><a href="https://k8smeetup.github.io/docs/admin/authorization/">授权</a></h3>
<p>​	OK，现在请求已经发送，并且 kube-apiserver 已经成功验证我们是谁，终于解脱了！</p>
<p>​	然而事情并没有结束，虽然我们已经证明了<strong>我们是合法的</strong>，但我们有权执行此操作吗？毕竟身份和权限不是一回事。为了进行后续的操作，kube-apiserver 还要对用户进行授权。</p>
<p>​	kube-apiserver 处理授权的方式与处理身份验证的方式相似：通过 kube-apiserver 的启动参数 <code>--authorization_mode</code> 参数设置。它将组合一系列授权者，这些授权者将针对每个传入的请求进行授权。如果所有授权者都拒绝该请求，则该请求会被禁止响应并且 <a href="https://github.com/kubernetes/apiserver/blob/e30df5e70ef9127ea69d607207c894251025e55b/pkg/endpoints/filters/authorization.go#L60">不会再继续响应</a>。如果某个授权者批准了该请求，则请求继续。</p>
<p>kube-apiserver 目前支持以下几种授权方法：</p>
<ul>
<li><a href="https://k8smeetup.github.io/docs/admin/authorization/webhook/">webhook</a>: 它与集群外的 HTTP(S) 服务交互。</li>
<li><a href="https://k8smeetup.github.io/docs/admin/authorization/abac/">ABAC</a>: 它执行静态文件中定义的策略。</li>
<li><a href="https://k8smeetup.github.io/docs/admin/authorization/rbac/">RBAC</a>: 它使用 <code>rbac.authorization.k8s.io</code> API Group实现授权决策，允许管理员通过 Kubernetes API 动态配置策略。</li>
<li><a href="https://k8smeetup.github.io/docs/admin/authorization/node/">Node</a>: 它确保 kubelet 只能访问自己节点上的资源。</li>
</ul>
<h3 id="准入控制"><a href="https://k8smeetup.github.io/docs/admin/admission-controllers/">准入控制</a></h3>
<p>​	突破了之前所说的认证和授权两道关口之后，客户端的调用请求就能够得到 API Server 的真正响应了吗？答案是：不能！</p>
<p>​	从 kube-apiserver 的角度来看，它已经验证了我们的身份并且赋予了相应的权限允许我们继续，但对于 Kubernetes 而言，其他组件对于应不应该允许发生的事情还是很有意见的。所以这个请求还需要通过 <code>Admission Controller</code> 所控制的一个 <code>准入控制链</code> 的层层考验，官方标准的 “关卡” 有近十个之多，而且还能自定义扩展！</p>
<p>​	虽然授权的重点是回答用户是否有权限，但准入控制器会拦截请求以确保它符合集群的更广泛的期望和规则。它们是资源对象保存到 <code>etcd</code> 之前的最后一个堡垒，封装了一系列额外的检查以确保操作不会产生意外或负面结果。不同于授权和认证只关心请求的用户和操作，<strong>准入控制还处理请求的内容，并且仅对创建、更新、删除或连接（如代理）等有效，而对读操作无效</strong>。</p>
<blockquote>
<p>准入控制器的工作方式与授权者和验证者的工作方式类似，但有一点区别：与验证链和授权链不同，如果某个准入控制器检查不通过，则整个链会中断，整个请求将立即被拒绝并且返回一个错误给终端用户。</p>
</blockquote>
<p>​	准入控制器设计的重点在于提高可扩展性，某个控制器都作为一个插件存储在 <code>plugin/pkg/admission</code> 目录中，并且与某一个接口相匹配，最后被编译到 kube-apiserver 二进制文件中。</p>
<p>​	大部分准入控制器都比较容易理解，接下来着重介绍 <code>SecurityContextDeny</code>、<code>ResourceQuota</code> 及 <code>LimitRanger</code> 这三个准入控制器。</p>
<ul>
<li><strong>SecurityContextDeny</strong> 该插件将禁止创建设置了 Security Context 的 Pod。</li>
<li><strong>ResourceQuota</strong> 不仅能限制某个 Namespace 中创建资源的数量，而且能限制某个 Namespace 中被 Pod 所请求的资源总量。该准入控制器和资源对象 <code>ResourceQuota</code> 一起实现了资源配额管理。</li>
<li><strong>LimitRanger</strong> 作用类似于上面的 ResourceQuota 控制器，针对 Namespace 资源的每个个体（Pod 与 Container 等）的资源配额。该插件和资源对象 <code>LimitRange</code> 一起实现资源配额管理。</li>
</ul>
<h2 id="3-etcd">3. etcd</h2>
<hr>
<p>到现在为止，Kubernetes 已经对该客户端的调用请求进行了全面彻底地审查，并且已经验证通过，运行它进入下一个环节。下一步 kube-apiserver 将对 HTTP 请求进行反序列化，然后利用得到的结果构建运行时对象（有点像 kubectl 生成器的逆过程），并保存到 <code>etcd</code> 中。下面我们将这个过程分解一下。</p>
<p>当收到请求时，kube-apiserver 是如何知道它该怎么做的呢？事实上，在客户端发送调用请求之前就已经产生了一系列非常复杂的流程。我们就从 kube-apiserver 二进制文件首次运行开始分析吧：</p>
<ol>
<li>当运行 kube-apiserver 二进制文件时，它会 <a href="https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/cmd/kube-apiserver/app/server.go#L119">创建一个允许 apiserver 聚合的服务链</a>。这是一种对 <code>Kubernetes API</code> 进行扩展的方式。</li>
<li>同时会创建一个 <code>generic apiserver</code> 作为默认的 apiserver。</li>
<li>然后利用 <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/config.go#L149">生成的 OpenAPI 规范</a>来填充 apiserver 的配置。</li>
<li>然后 kube-apiserver 遍历数据结构中指定的所有 API 组，并将每一个 API 组作为通用的存储抽象保存到 etcd 中。当你访问或变更资源状态时，kube-apiserver 就会调用这些 API 组。</li>
<li>每个 API 组都会遍历它的所有组版本，并且将每个 HTTP 路由 <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/groupversion.go#L92">映射到 REST 路径中</a>。</li>
<li>当请求的 METHOD 是 <code>POST</code> 时，kube-apiserver 就会将请求转交给 <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L37">资源创建处理器</a>。</li>
</ol>
<p>现在 kube-apiserver 已经知道了所有的路由及其对应的 REST 路径，以便在请求匹配时知道调用哪些处理器和键值存储。多么机智的设计！现在假设客户端的 HTTP 请求已经被 kube-apiserver 收到了：</p>
<ol>
<li>如果处理链可以将请求与已经注册的路由进行匹配，就会将该请求交给注册到该路由的 <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/handler.go#L143">专用处理器</a>来处理；如果没有任何一个路由可以匹配该请求，就会将请求转交给 <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/mux/pathrecorder.go#L248">基于路径的处理器</a>（比如当调用 <code>/apis</code> 时）；如果没有任何一个基于路径的处理器注册到该路径，请求就会被转交给 <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/mux/pathrecorder.go#L254">not found 处理器</a>，最后返回 <code>404</code>。</li>
<li>幸运的是，我们有一个名为 <code>createHandler</code> 的注册路由！它有什么作用呢？首先它会解码 HTTP 请求并进行基本的验证，例如确保请求提供的 json 与 API 资源的版本相匹配。</li>
<li>接下来进入 <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L93-L104">审计和准入控制</a>阶段。</li>
<li>然后资源将会通过 <a href="https://github.com/kubernetes/apiserver/blob/19667a1afc13cc13930c40a20f2c12bbdcaaa246/pkg/registry/generic/registry/store.go#L327">storage provider</a> 保存 <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L111">到 etcd</a> 中。默认情况下保存到 etcd 中的键的格式为 <code>&lt;namespace&gt;/&lt;name&gt;</code>，你也可以自定义。</li>
<li>资源创建过程中出现的任何错误都会被捕获，最后 <code>storage provider</code> 会执行 <code>get</code> 调用来确认该资源是否被成功创建。如果需要额外的清理工作，就会调用后期创建的处理器和装饰器。</li>
<li>最后构造 HTTP 响应并返回给客户端。</li>
</ol>
<p>原来 apiserver 做了这么多的工作，以前竟然没有发现呢！到目前为止，我们创建的 <code>Deployment</code> 资源已经保存到了 etcd 中，但 apiserver 仍然看不到它。</p>
<h2 id="4-初始化">4. 初始化</h2>
<hr>
<p>​	在一个资源对象被持久化到数据存储之后，apiserver 还无法完全看到或调度它，在此之前还要执行一系列 <a href="https://v1-13.docs.kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#initializers">Initializers</a>。Initializers是一种与资源类型相关联的控制器，它会在资源对外可用之前执行某些逻辑。如果某个资源类型没有Initializers，就会跳过此初始化步骤立即使资源对外可见。</p>
<p>​	正如 <a href="https://ahmet.im/blog/initializers/">大佬的博客</a>指出的那样，Initializers是一个强大的功能，因为它允许我们执行通用引导操作。例如：</p>
<ul>
<li>将代理边车容器注入到暴露 80 端口的 Pod 中，或者加上特定的 <code>annotation</code>。</li>
<li>将保存着测试证书的 <code>volume</code> 注入到特定命名空间的所有 Pod 中。</li>
<li>如果 <code>Secret</code> 中的密码小于 20 个字符，就组织其创建。</li>
</ul>
<p><code>initializerConfiguration</code> 资源对象允许你声明某些资源类型应该运行哪些Initializers。如果你想每创建一个 Pod 时就运行一个自定义Initializers，你可以这样做：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">InitializerConfiguration</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">custom-pod-initializer</span></span><br><span class="line"><span class="attr">initializers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">podimage.example.com</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="attr">apiVersions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">pods</span></span><br></pre></td></tr></table></figure>
<p>​	通过该配置创建资源对象 <code>InitializerConfiguration</code> 之后，就会在每个 Pod 的 <code>metadata.initializers.pending</code> 字段中添加 <code>custom-pod-initializer</code> 字段。该初始化控制器会定期扫描新的 Pod，一旦在 Pod 的 <code>pending</code> 字段中检测到自己的名称，就会执行其逻辑，执行完逻辑之后就会将 <code>pending</code> 字段下的自己的名称删除。</p>
<p>​	只有在 <code>pending</code> 字段下的列表中的第一个Initializers可以对资源进行操作，当所有的Initializers执行完成，并且 <code>pending</code> 字段为空时，该对象就会被认为初始化成功。</p>
<p>​	<strong>你可能会注意到一个问题：如果 kube-apiserver 不能显示这些资源，那么用户级控制器是如何处理资源的呢？</strong></p>
<p>​	为了解决这个问题，kube-apiserver 暴露了一个 <code>?includeUninitialized</code> 查询参数，它会返回所有的资源对象（包括未初始化的）。</p>
<h2 id="5-控制循环">5. 控制循环</h2>
<hr>
<h3 id="Deployments-controller">Deployments controller</h3>
<p>​	到了这个阶段，我们的 Deployment 记录已经保存在 etcd 中，并且所有的初始化逻辑都执行完成，接下来的阶段将会涉及到该资源所依赖的拓扑结构。在 Kubernetes 中，Deployment 实际上只是一系列 <code>Replicaset</code> 的集合，而 Replicaset 是一系列 <code>Pod</code> 的集合。那么 Kubernetes 是如何从一个 HTTP 请求按照层级结构依次创建这些资源的呢？其实这些工作都是由 Kubernetes 内置的 <code>Controller</code>(控制器) 来完成的。</p>
<p>​	Kubernetes 在整个系统中使用了大量的 Controller，Controller 是一个用于将系统状态从“当前状态”修正到“期望状态”的异步脚本。所有 Controller 都通过 <code>kube-controller-manager</code> 组件并行运行，每种 Controller 都负责一种具体的控制流程。首先介绍一下 <code>Deployment Controller</code>：</p>
<p>​	将 Deployment 记录存储到 etcd 并初始化后，就可以通过 kube-apiserver 使其可见，然后 <code>Deployment Controller</code> 就会检测到它（它的工作就是负责监听 Deployment 记录的更改）。在我们的例子中，控制器通过一个 <code>Informer</code> <a href="https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/controller/deployment/deployment_controller.go#L122">注册一个创建事件的特定回调函数</a>（更多信息参加下文）。</p>
<p>当 Deployment 第一次对外可见时，该 Controller 就会 <a href="https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/controller/deployment/deployment_controller.go#L170">将该资源对象添加到内部工作队列</a>，然后开始处理这个资源对象：</p>
<blockquote>
<p>通过使用标签选择器查询 kube-apiserver 来 <a href="https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/controller/deployment/deployment_controller.go#L633">检查</a>该 Deployment 是否有与其关联的 <code>ReplicaSet</code> 或 <code>Pod</code> 记录。</p>
</blockquote>
<p>有趣的是，这个同步过程是状态不可知的，它核对新记录与核对已经存在的记录采用的是相同的方式。</p>
<p>在意识到没有与其关联的 <code>ReplicaSet</code> 或 <code>Pod</code> 记录后，Deployment Controller 就会开始执行 <a href="https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/controller/deployment/sync.go#L385">弹性伸缩流程</a>：</p>
<blockquote>
<p>创建 ReplicaSet 资源，为其分配一个标签选择器并将其版本号设置为 1。</p>
</blockquote>
<p>ReplicaSet 的 <code>PodSpec</code> 字段从 Deployment 的 manifest 以及其他相关元数据中复制而来。有时 Deployment 记录在此之后也需要更新（例如，如果设置了 <code>process deadline</code>）。</p>
<p>​	当完成以上步骤之后，该 Deployment 的 <code>status</code> 就会被更新，然后重新进入与之前相同的循环，等待 Deployment 与期望的状态相匹配。由于 Deployment Controller 只关心 ReplicaSet，因此需要通过 <code>ReplicaSet Controller</code> 来继续协调。</p>
<h3 id="ReplicaSets-controller">ReplicaSets controller</h3>
<p>​	在前面的步骤中，Deployment Controller 创建了第一个 ReplicaSet，但仍然还是没有 Pod，这时候就该 <code>ReplicaSet Controller</code> 登场了！ReplicaSet Controller 的工作是监视 ReplicaSets 及其相关资源（Pod）的生命周期。和大多数其他 Controller 一样，它通过触发某些事件的处理器来实现此目的。</p>
<p>​	当创建 ReplicaSet 时（由 Deployment Controller 创建），RS Controller <a href="https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/controller/replicaset/replica_set.go#L583">检查新 ReplicaSet 的状态</a>，并检查当前状态与期望状态之间存在的偏差，然后通过 <a href="https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/controller/replicaset/replica_set.go#L460">调整 Pod 的副本数</a>来达到期望的状态。</p>
<p>​	Pod 的创建也是批量进行的，从 <code>SlowStartInitialBatchSize</code> 开始，然后在每次成功的迭代中以一种 <code>slow start</code> 操作加倍。这样做的目的是在大量 Pod 启动失败时（例如，由于资源配额），可以减轻 kube-apiserver 被大量不必要的 HTTP 请求吞没的风险。如果创建失败，最好能够优雅地失败，并且对其他的系统组件造成的影响最小！</p>
<p>​	Kubernetes 通过 <code>Owner References</code>（在子级资源的某个字段中引用其父级资源的 ID） 来构造严格的资源对象层级结构。这确保了一旦 Controller 管理的资源被删除（级联删除），子资源就会被垃圾收集器删除，同时还为父级资源提供了一种有效的方式来避免他们竞争同一个子级资源（想象两对父母都认为他们拥有同一个孩子的场景）。</p>
<p>​	Owner References 的另一个好处是：它是有状态的。如果有任何 Controller 重启了，那么由于资源对象的拓扑关系与 Controller 无关，该操作不会影响到系统的稳定运行。这种对资源隔离的重视也体现在 Controller 本身的设计中：Controller 不能对自己没有明确拥有的资源进行操作，它们应该选择对资源的所有权，互不干涉，互不共享。</p>
<p>有时系统中也会出现孤儿（orphaned）资源，通常由以下两种途径产生：</p>
<ul>
<li>父级资源被删除，但子级资源没有被删除</li>
<li>垃圾收集策略禁止删除子级资源</li>
</ul>
<p>​	当发生这种情况时，Controller 将会确保孤儿资源拥有新的 <code>Owner</code>。多个父级资源可以相互竞争同一个孤儿资源，但只有一个会成功（其他父级资源会收到验证错误）。</p>
<h3 id="Informers">Informers</h3>
<p>你可能已经注意到，某些 Controller（例如 RBAC 授权器或 Deployment Controller）需要先检索集群状态然后才能正常运行。拿 RBAC 授权器举例，当请求进入时，授权器会将用户的初始状态缓存下来，然后用它来检索与 etcd 中的用户关联的所有 角色（<code>Role</code>）和 角色绑定（<code>RoleBinding</code>）。那么问题来了，Controller 是如何访问和修改这些资源对象的呢？事实上 Kubernetes 是通过 <code>Informer</code> 机制来解决这个问题的。</p>
<p>Infomer 是一种模式，它允许 Controller 查找缓存在本地内存中的数据(这份数据由 Informer 自己维护)并列出它们感兴趣的资源。</p>
<p>虽然 Informer 的设计很抽象，但它在内部实现了大量的对细节的处理逻辑（例如缓存），缓存很重要，因为它不但可以减少对 Kubenetes API 的直接调用，同时也能减少 Server 和 Controller 的大量重复性工作。通过使用 Informer，不同的 Controller 之间以线程安全（Thread safety）的方式进行交互，而不必担心多个线程访问相同的资源时会产生冲突。</p>
<p>有关 Informer 的更多详细解析，请参考这篇文章： <a href="https://borismattijssen.github.io/articles/kubernetes-informers-controllers-reflectors-stores">Kubernetes: Controllers, Informers, Reflectors and Stores</a></p>
<h3 id="Scheduler">Scheduler</h3>
<p>当所有的 Controller 正常运行后，etcd 中就会保存一个 Deployment、一个 ReplicaSet 和 三个 Pod 资源记录，并且可以通过 kube-apiserver 查看。然而，这些 Pod 资源现在还处于 <code>Pending</code> 状态，因为它们还没有被调度到集群中合适的 Node 上运行。这个问题最终要靠调度器（Scheduler）来解决。</p>
<p><code>Scheduler</code> 作为一个独立的组件运行在集群控制平面上，工作方式与其他 Controller 相同：监听实际并将系统状态调整到期望的状态。具体来说，Scheduler 的作用是将待调度的 Pod 按照特定的算法和调度策略绑定（Binding）到集群中某个合适的 Node 上，并将绑定信息写入 etcd 中（它会过滤其 PodSpec 中 <code>NodeName</code> 字段为空的 Pod），默认的调度算法的工作方式如下：</p>
<ol>
<li>当 Scheduler 启动时，会 <a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/plugin/pkg/scheduler/algorithmprovider/defaults/defaults.go#L65-L81">注册一个默认的预选策略链</a>，这些 <code>预选策略</code> 会对备选节点进行评估，判断备选节点是否 <a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/plugin/pkg/scheduler/core/generic_scheduler.go#L117">满足备选 Pod 的需求</a>。例如，如果 PodSpec 字段限制了 CPU 和内存资源，那么当备选节点的资源容量不满足备选 Pod 的需求时，备选 Pod 就不会被调度到该节点上（<strong>资源容量=备选节点资源总量-节点中已存在 Pod 的所有容器的需求资源（CPU 和内存）的总和</strong>）</li>
<li>一旦筛选出符合要求的候选节点，就会采用 <code>优选策略</code> 计算出每个候选节点的积分，然后对这些候选节点进行排序，积分最高者胜出。例如，为了在整个系统中分摊工作负载，这些优选策略会从备选节点列表中选出资源消耗最小的节点。每个节点通过优选策略时都会算出一个得分，计算各项得分，最终选出分值大的节点作为优选的结果。</li>
</ol>
<p>一旦找到了合适的节点，Scheduler 就会创建一个 <code>Binding</code> 对象，该对象的 <code>Name</code> 和 <code>Uid</code> 与 Pod 相匹配，并且其 <code>ObjectReference</code> 字段包含所选节点的名称，然后通过 <code>POST</code> 请求 <a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/plugin/pkg/scheduler/factory/factory.go#L1095">发送给 apiserver</a>。</p>
<p>当 kube-apiserver 接收到此 Binding 对象时，注册吧会将该对象<strong>反序列化</strong>并更新 Pod 资源中的以下字段：</p>
<ul>
<li>将 <code>NodeName</code> 的值设置为 ObjectReference 中的 NodeName。</li>
<li>添加相关的注释。</li>
<li>将 <code>PodScheduled</code> 的 <code>status</code> 值设置为 True。可以通过 kubectl 来查看：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get &lt;PODNAME&gt; -o go-template=<span class="string">&#x27;&#123;&#123;range .status.conditions&#125;&#125;&#123;&#123;if eq .type &quot;PodScheduled&quot;&#125;&#125;&#123;&#123;.status&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>一旦 Scheduler 将 Pod 调度到某个节点上，该节点的 <code>Kubelet</code> 就会接管该 Pod 并开始部署。</p>
<blockquote>
<p>预选策略和优选策略都可以通过 <code>–policy-config-file</code> 参数来扩展，如果默认的调度器不满足要求，还可以部署自定义的调度器。如果 <code>podSpec.schedulerName</code> 的值设置为其他的调度器，则 Kubernetes 会将该 Pod 的调度转交给那个调度器。</p>
</blockquote>
<h2 id="6-Kubelet">6. Kubelet</h2>
<hr>
<h3 id="Pod-同步">Pod 同步</h3>
<p>现在，所有的 Controller 都完成了工作，我们来总结一下：</p>
<ul>
<li>HTTP 请求通过了认证、授权和准入控制阶段。</li>
<li>一个 Deployment、ReplicaSet 和三个 Pod 资源被持久化到 etcd 存储中。</li>
<li>然后运行了一系列Initializers。</li>
<li>最后每个 Pod 都被调度到合适的节点。</li>
</ul>
<p>然而到目前为止，所有的状态变化仅仅只是针对保存在 etcd 中的资源记录，接下来的步骤涉及到运行在工作节点之间的 Pod 的分布状况，这是分布式系统（比如 Kubernetes）的关键因素。这些任务都是由 <code>Kubelet</code> 组件完成的，让我们开始吧！</p>
<p>在 Kubernetes 集群中，每个 Node 节点上都会启动一个 Kubelet 服务进程，该进程用于处理 Scheduler 下发到本节点的任务，管理 Pod 的生命周期，包括挂载卷、容器日志记录、垃圾回收以及其他与 Pod 相关的事件。</p>
<p>如果换一种思维模式，你可以把 Kubelet 当成一种特殊的 Controller，它每隔 20 秒（可以自定义）向 kube-apiserver 通过 <code>NodeName</code> 获取自身 Node 上所要运行的 Pod 清单。一旦获取到了这个清单，它就会通过与自己的内部缓存进行比较来检测新增加的 Pod，如果有差异，就开始同步 Pod 列表。我们来详细分析一下同步过程：</p>
<ol>
<li>如果 Pod 正在创建， Kubelet 就会 <a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet.go#L1519">记录一些在 <code>Prometheus</code> 中用于追踪 Pod 启动延时的指标</a>。</li>
<li>然后生成一个 <code>PodStatus</code> 对象，它表示 Pod 当前阶段的状态。Pod 的状态(<code>Phase</code>) 是 Pod 在其生命周期中的最精简的概要，包括 <code>Pending</code>，<code>Running</code>，<code>Succeeded</code>，<code>Failed</code> 和 <code>Unkown</code> 这几个值。状态的产生过程非常过程，所以很有必要深入了解一下背后的原理：</li>
</ol>
<ul>
<li>
<p>首先串行执行一系列 Pod 同步处理器（<code>PodSyncHandlers</code>），每个处理器检查检查 Pod 是否应该运行在该节点上。当所有的处理器都认为该 Pod 不应该运行在该节点上，则 Pod 的 <code>Phase</code> 值就会变成 <code>PodFailed</code>，并且将该 Pod 从该节点上驱逐出去。例如当你创建一个 <code>Job</code> 时，如果 Pod 失败重试的时间超过了 <code>spec.activeDeadlineSeconds</code> 设置的值，就会将 Pod 从该节点驱逐出去。</p>
</li>
<li>
<p>接下来，Pod 的 Phase 值由 <code>init 容器</code> 和应用容器的状态共同来决定。因为目前容器还没有启动，容器被视为 <a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet_pods.go#L1244">处于等待阶段</a>，如果 Pod 中至少有一个容器处于等待阶段，则其 <code>Phase</code> 值为 <a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet_pods.go#L1258-L1261">Pending</a>。</p>
</li>
<li>
<p>最后，Pod 的 <code>Condition</code> 字段由 Pod 内所有容器的状态决定。现在我们的容器还没有被容器运行时创建，所以 <a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/status/generate.go#L70-L81"><code>PodReady</code> 的状态被设置为 <code>False</code></a>。可以通过 kubectl 查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get &lt;PODNAME&gt; -o go-template=<span class="string">&#x27;&#123;&#123;range .status.conditions&#125;&#125;&#123;&#123;if eq .type &quot;Ready&quot;&#125;&#125;&#123;&#123;.status&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>生成 PodStatus 之后（Pod 中的 <code>status</code> 字段），Kubelet 就会将它发送到 Pod 的状态管理器，该管理器的任务是通过 apiserver 异步更新 etcd 中的记录。</li>
<li>接下来运行一系列<strong>准入处理器</strong>来确保该 Pod 是否具有相应的权限（包括强制执行 <a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet.go#L883-L884"><code>AppArmor</code> 配置文件和 <code>NO_NEW_PRIVS</code></a>），被准入控制器拒绝的 Pod 将一直保持 <code>Pending</code> 状态。</li>
<li>如果 Kubelet 启动时指定了 <code>cgroups-per-qos</code> 参数，Kubelet 就会为该 Pod 创建 <code>cgroup</code> 并进行相应的资源限制。这是为了更方便地对 Pod 进行服务质量（QoS）管理。</li>
<li>然后为 Pod 创建相应的目录，包括 Pod 的目录（<code>/var/run/kubelet/pods/&lt;podID&gt;</code>），该 Pod 的卷目录（<code>&lt;podDir&gt;/volumes</code>）和该 Pod 的插件目录（<code>&lt;podDir&gt;/plugins</code>）。</li>
<li><strong>卷管理器</strong>会 <a href="https://github.com/kubernetes/kubernetes/blob/2723e06a251a4ec3ef241397217e73fa782b0b98/pkg/kubelet/volumemanager/volume_manager.go#L330">挂载 <code>Spec.Volumes</code> 中定义的相关数据卷，然后等待是否挂载成功</a>。根据挂载卷类型的不同，某些 Pod 可能需要等待更长的时间（比如 NFS 卷）。</li>
<li><a href="https://github.com/kubernetes/kubernetes/blob/dd9981d038012c120525c9e6df98b3beb3ef19e1/pkg/kubelet/kubelet_pods.go#L788">从 apiserver 中检索</a> <code>Spec.ImagePullSecrets</code> 中定义的所有 <code>Secret</code>，然后将其注入到容器中。</li>
<li>最后通过容器运行时接口（<code>Container Runtime Interface（CRI）</code>）开始启动容器（下面会详细描述）。</li>
</ol>
<h3 id="CRI-与-pause-容器">CRI 与 pause 容器</h3>
<p>到了这个阶段，大量的初始化工作都已经完成，容器已经准备好开始启动了，而容器是由<strong>容器运行时</strong>（例如 <code>Docker</code> 和 <code>Rkt</code>）启动的。</p>
<p>为了更容易扩展，Kubelet 从 1.5.0 开始通过<strong>容器运行时接口</strong>与容器运行时（Container Runtime）交互。简而言之，CRI 提供了 Kubelet 和特定的运行时之间的抽象接口，它们之间通过 <a href="https://github.com/google/protobuf">协议缓冲区</a>（它像一个更快的 JSON）和 <a href="https://grpc.io/">gRPC API</a>（一种非常适合执行 Kubernetes 操作的 API）。这是一个非常酷的想法，通过使用 Kubelet 和运行时之间定义的契约关系，容器如何编排的具体实现细节已经变得无关紧要。由于不需要修改 Kubernetes 的核心代码，开发者可以以最小的开销添加新的运行时。</p>
<p>不好意思有点跑题了，让我们继续回到容器启动的阶段。第一次启动 Pod 时，Kubelet 会通过 <code>Remote Procedure Command</code>(RPC) 协议调用 <a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/pkg/kubelet/kuberuntime/kuberuntime_sandbox.go#L51">RunPodSandbox</a>。<code>sandbox</code> 用于描述一组容器，例如在 Kubernetes 中它表示的是 Pod。<code>sandbox</code> 是一个很宽泛的概念，所以对于其他没有使用容器的运行时仍然是有意义的（比如在一个基于 <code>hypervisor</code> 的运行时中，sandbox 可能指的就是虚拟机）。</p>
<p>我们的例子中使用的容器运行时是 Docker，创建 sandbox 时首先创建的是 <code>pause</code> 容器。pause 容器作为同一个 Pod 中所有其他容器的基础容器，它为 Pod 中的每个业务容器提供了大量的 Pod 级别资源，这些资源都是 Linux 命名空间（包括网络命名空间，IPC 命名空间和 PID 命名空间）。</p>
<p>pause 容器提供了一种方法来管理所有这些命名空间并允许业务容器共享它们，在同一个网络命名空间中的好处是：同一个 Pod 中的容器可以使用 <code>localhost</code> 来相互通信。pause 容器的第二个功能与 PID 命名空间的工作方式相关，在 PID 命名空间中，进程之间形成一个树状结构，一旦某个子进程由于父进程的错误而变成了“孤儿进程”，其便会被 <code>init</code> 进程进行收养并最终回收资源。关于 pause 工作方式的详细信息可以参考： <a href="https://www.ianlewis.org/en/almighty-pause-container">The Almighty Pause Container</a>。</p>
<p>一旦创建好了 pause 容器，下面就会开始检查磁盘状态然后开始启动业务容器。</p>
<h3 id="CNI-和-Pod-网络">CNI 和 Pod 网络</h3>
<p>现在我们的 Pod 已经有了基本的骨架：一个共享所有命名空间以允许业务容器在同一个 Pod 里进行通信的 pause 容器。但现在还有一个问题，那就是容器的网络是如何建立的？</p>
<p>当 Kubelet 为 Pod 创建网络时，它会将创建网络的任务交给 <code>CNI</code> 插件。CNI 表示容器网络接口（Container Network Interface），和容器运行时的运行方式类似，它也是一种抽象，允许不同的网络提供商为容器提供不同的网络实现。通过将 json 配置文件（默认在 <code>/etc/cni/net.d</code> 路径下）中的数据传送到相关的 CNI 二进制文件（默认在 <code>/opt/cni/bin</code> 路径下）中，cni 插件可以给 pause 容器配置相关的网络，然后 Pod 中其他的容器都使用 pause 容器的网络。下面是一个简单的示例配置文件：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.3.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cnio0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isGateway&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ipMasq&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ipam&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;host-local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ranges&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;POD_CIDR&#125;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;routes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;dst&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0/0&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>CNI 插件还会通过 <code>CNI_ARGS</code> 环境变量为 Pod 指定其他的元数据，包括 Pod 名称和命名空间。</p>
<p>下面的步骤因 CNI 插件而异，我们以 <code>bridge</code> 插件举例：</p>
<ul>
<li>该插件首先会在根网络命名空间（也就是宿主机的网络命名空间）中设置本地 Linux 网桥，以便为该主机上的所有容器提供网络服务。</li>
<li>然后它会将一个网络接口（<code>veth</code> 设备对的一端）插入到 pause 容器的网络命名空间中，并将另一端连接到网桥上。你可以这样来理解 veth 设备对：它就像一根很长的管道，一端连接到容器，一端连接到根网络命名空间中，数据包就在管道中进行传播。</li>
<li>接下来 json 文件中指定的 <code>IPAM</code> Plugin 会为 pause 容器的网络接口分配一个 IP 并设置相应的路由，现在 Pod 就有了自己的 IP。
<ul>
<li>IPAM Plugin 的工作方式和 CNI Plugin 类似：通过二进制文件调用并具有标准化的接口，每一个 IPAM Plugin 都必须要确定容器网络接口的 IP、子网以及网关和路由，并将信息返回给 CNI 插件。最常见的 IPAM Plugin 是 <code>host-local</code>，它从预定义的一组地址池中为容器分配 IP 地址。它将地址池的信息以及分配信息保存在主机的文件系统中，从而确保了同一主机上每个容器的 IP 地址的唯一性。</li>
</ul>
</li>
<li>最后 Kubelet 会将集群内部的 <code>DNS</code> 服务器的 <code>Cluster IP</code> 地址传给 CNI 插件，然后 CNI 插件将它们写到容器的 <code>/etc/resolv.conf</code> 文件中。</li>
</ul>
<p>一旦完成了上面的步骤，CNI 插件就会将操作的结果以 json 的格式返回给 Kubelet。</p>
<h3 id="跨主机容器网络">跨主机容器网络</h3>
<p>到目前为止，我们已经描述了容器如何与宿主机进行通信，但跨主机之间的容器如何通信呢？</p>
<p>​	通常情况下使用 <code>overlay</code> 网络来进行跨主机容器通信，这是一种动态同步多个主机间路由的方法。 其中最常用的 overlay 网络插件是 <code>flannel</code>，flannel 具体的工作方式可以参考 <a href="https://github.com/coreos/flannel">CoreOS 的文档</a>。</p>
<h3 id="容器启动">容器启动</h3>
<p>所有网络都配置完成后，接下来就开始真正启动业务容器了！</p>
<p>一旦 sanbox 完成初始化并处于 <code>active</code> 状态，Kubelet 就可以开始为其创建容器了。首先 <a href="https://github.com/kubernetes/kubernetes/blob/5adfb24f8f25a0d57eb9a7b158db46f9f46f0d80/pkg/kubelet/kuberuntime/kuberuntime_manager.go#L690">启动 PodSpec 中定义的 init 容器</a>，然后再启动业务容器。具体过程如下：</p>
<ol>
<li>首先拉取容器的镜像。如果是私有仓库的镜像，就会利用 PodSpec 中指定的 Secret 来拉取该镜像。</li>
<li>然后通过 CRI 接口创建容器。Kubelet 向 PodSpec 中填充了一个 <code>ContainerConfig</code> 数据结构（在其中定义了命令，镜像，标签，挂载卷，设备，环境变量等待），然后通过 <code>protobufs</code> 发送给 CRI 接口。对于 Docker 来说，它会将这些信息反序列化并填充到自己的配置信息中，然后再发送给 <code>Dockerd</code> 守护进程。在这个过程中，它会将一些元数据标签（例如容器类型，日志路径，dandbox ID 等待）添加到容器中。</li>
<li>接下来会使用 CPU 管理器来约束容器，这是 Kubelet 1.8 中新添加的 alpha 特性，它使用 <code>UpdateContainerResources</code> CRI 方法将容器分配给本节点上的 CPU 资源池。</li>
<li>最后容器开始真正 <a href="https://github.com/kubernetes/kubernetes/blob/5f9f4a1c5939436fa320e9bc5973a55d6446e59f/pkg/kubelet/kuberuntime/kuberuntime_container.go#L135">启动</a>。</li>
<li>如果 Pod 中配置了容器生命周期钩子（Hook），容器启动之后就会运行这些 <code>Hook</code>。Hook 的类型包括两种：<code>Exec</code>（执行一段命令） 和 <code>HTTP</code>（发送HTTP请求）。如果 PostStart Hook 启动的时间过长、挂起或者失败，容器将永远不会变成 <code>running</code> 状态。</li>
</ol>
<h1>总结</h1>
<p><img src="https://raw.githubusercontent.com/Lucareful/RepoImg/main/img/Pod%E5%88%9B%E5%BB%BA%E5%8E%86%E7%A8%8B.jpg" alt="Pod创建历程"></p>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>GO 代码风格指南</title>
    <url>/2023/02/06/golang%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1>GO 代码风格指南</h1>
<h2 id="风格原则">风格原则</h2>
<p>​	有一些总体原则总结了如何考虑编写可读的 Go 代码。以下是可读代码的属性，按重要性排序：</p>
<ol>
<li><strong><a href="https://google.github.io/styleguide/go/guide#clarity">清晰</a></strong>：代码的目的和基本原理对读者来说是清楚的。</li>
<li><strong><a href="https://google.github.io/styleguide/go/guide#simplicity">简单性</a></strong>：代码以尽可能简单的方式实现其目标。</li>
<li><strong><a href="https://google.github.io/styleguide/go/guide#concision">简洁</a></strong>：代码具有高信噪比。</li>
<li><strong><a href="https://google.github.io/styleguide/go/guide#maintainability">可维护性</a></strong>：代码的编写使其易于维护。</li>
<li><strong><a href="https://google.github.io/styleguide/go/guide#consistency">一致性</a></strong>：代码与更广泛的 Google 代码库一致。</li>
</ol>
<span id="more"></span>
<h2 id="命名">命名</h2>
<h3 id="下划线">下划线</h3>
<p>Go 中的名称通常不应包含下划线。这个原则有三个例外：</p>
<ol>
<li>仅由生成的代码导入的包名称可能包含下划线。有关如何选择多词包名称的更多详细信息，请参阅包<a href="https://google.github.io/styleguide/go/decisions#package-names">名称</a></li>
<li>文件中的测试、基准和示例函数名称<code>*_test.go</code>可能包含下划线。</li>
<li>与操作系统或 cgo 互操作的低级库可能会重用标识符，如<a href="https://pkg.go.dev/syscall#pkg-constants"><code>syscall</code></a>. 在大多数代码库中，这预计是非常罕见的。</li>
</ol>
<h3 id="包名">包名</h3>
<p>​	Go 包名称应该简短并且只包含小写字母。由多个单词组成的包名称应全部小写。例如，包<a href="https://pkg.go.dev/text/tabwriter"><code>tabwriter</code></a>未命名为<code>tabWriter</code>、<code>TabWriter</code>或 <code>tab_writer</code>。</p>
<p>​	避免选择可能被常用局部变量名<a href="https://google.github.io/styleguide/go/best-practices#shadowing">遮蔽的包名。</a>例如，<code>usercount</code>是一个比 更好的包名 <code>count</code>，因为<code>count</code>是一个常用的变量名。</p>
<p>​	Go 包名称不应该有下划线。如果您需要导入名称中确实有一个包（通常来自生成的或第三方代码），则必须在导入时将其重命名为适合在 Go 代码中使用的名称。</p>
<p>一个例外是仅由生成的代码导入的包名称可能包含下划线。具体例子包括：</p>
<ul>
<li>使用<code>_test</code>外部测试包的后缀，例如集成测试</li>
<li>使用<a href="https://go.dev/blog/examples">包级文档示例</a><code>_test</code>的后缀</li>
</ul>
<p>​	避免使用无意义的包名称，例如<code>util</code>, <code>utility</code>, <code>common</code>,<code>helper</code>等。查看更多关于 <a href="https://google.github.io/styleguide/go/best-practices#util-packages">所谓的“实用程序包”</a>的信息。</p>
<p>​	当导入的包被重命名（例如<code>import foopb &quot;path/to/foo_go_proto&quot;</code>）时，包的本地名称必须符合上述规则，因为本地名称决定了包中的符号在文件中的引用方式。如果给定的导入在多个文件中重命名，特别是在相同或附近的包中，则应尽可能使用相同的本地名称以保持一致性。</p>
<blockquote>
<p>另请参阅：<a href="https://go.dev/blog/package-names">https://go.dev/blog/package-names</a></p>
</blockquote>
<h3 id="参数别名">参数别名</h3>
<p><a href="https://golang.org/ref/spec#Method_declarations">接收器</a>变量名称必须是：</p>
<ul>
<li>短（通常是一两个字母的长度）</li>
<li>类型本身的缩写</li>
<li>一致地应用于该类型的每个接收器</li>
</ul>
<table>
<thead>
<tr>
<th>长名</th>
<th>更好的名字</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>func (tray Tray)</code></td>
<td><code>func (t Tray)</code></td>
</tr>
<tr>
<td><code>func (info *ResearchInfo)</code></td>
<td><code>func (ri *ResearchInfo)</code></td>
</tr>
<tr>
<td><code>func (this *ReportWriter)</code></td>
<td><code>func (w *ReportWriter)</code></td>
</tr>
<tr>
<td><code>func (self *Scanner)</code></td>
<td><code>func (s *Scanner)</code></td>
</tr>
</tbody>
</table>
<h3 id="常量名称">常量名称</h3>
<p>​	常量名称必须像 Go 中的所有其他名称一样使用<a href="https://google.github.io/styleguide/go/guide#mixed-caps">MixedCaps</a>（<a href="https://tour.golang.org/basics/3">导出</a> 的常量以大写字母开头，而未导出的常量以小写字母开头。）即使它打破了其他语言的约定，这也适用。</p>
<p>​	<strong>常量名称不应是其值的派生词，而应解释值的含义。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">const</span> MaxPacketSize = <span class="number">512</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    ExecuteBit = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span></span><br><span class="line">    WriteBit</span><br><span class="line">    ReadBit</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>不要使用非 MixedCaps 常量名称或带有<code>K</code>前缀的常量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="keyword">const</span> MAX_PACKET_SIZE = <span class="number">512</span></span><br><span class="line"><span class="keyword">const</span> kMaxBufferSize = <span class="number">1024</span></span><br><span class="line"><span class="keyword">const</span> KMaxUsersPergroup = <span class="number">500</span></span><br></pre></td></tr></table></figure>
<p>根据它们的角色而不是它们的值来命名常量。如果一个常量除了它的值之外没有其他作用，那么就没有必要将它定义为一个常量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="keyword">const</span> Twelve = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    UserNameColumn = <span class="string">&quot;username&quot;</span></span><br><span class="line">    GroupColumn    = <span class="string">&quot;group&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="缩写词">缩写词</h3>
<p>​	名称中的首字母缩略词或首字母缩略词（例如，<code>URL</code>和<code>NATO</code>）应该具有相同的大小写。<code>URL</code>应显示为<code>URL</code>或<code>url</code>（如<code>urlPony</code>, 或 <code>URLPony</code>），绝不能显示为<code>Url</code>. 这也适用于<code>ID</code>“标识符”的缩写；写<code>appID</code>而不是<code>appId</code>。</p>
<ul>
<li>在具有多个首字母缩写词的名称中（例如<code>XMLAPI</code>，因为它包含<code>XML</code> and <code>API</code>），给定首字母缩写词中的每个字母都应该具有相同的大小写，但名称中的每个首字母缩写词不需要具有相同的大小写。</li>
<li>在首字母缩写包含小写字母（例如<code>DDoS</code>, <code>iOS</code>, <code>gRPC</code>）的名称中，首字母缩写应该像在标准散文中一样出现，除非您需要为了<a href="https://golang.org/ref/spec#Exported_identifiers">导出</a>性而更改第一个字母。在这些情况下，整个首字母大写应该是相同的情况（例如<code>ddos</code>, <code>IOS</code>, <code>GRPC</code>）。</li>
</ul>
<table>
<thead>
<tr>
<th>初始主义</th>
<th>范围</th>
<th>正确的</th>
<th>不正确</th>
</tr>
</thead>
<tbody>
<tr>
<td>XML API</td>
<td>已出口</td>
<td><code>XMLAPI</code></td>
<td><code>XmlApi</code>, <code>XMLApi</code>, <code>XmlAPI</code>,<code>XMLapi</code></td>
</tr>
<tr>
<td>XML API</td>
<td>未出口</td>
<td><code>xmlAPI</code></td>
<td><code>xmlapi</code>,<code>xmlApi</code></td>
</tr>
<tr>
<td>iOS</td>
<td>已出口</td>
<td><code>IOS</code></td>
<td><code>Ios</code>,<code>IoS</code></td>
</tr>
<tr>
<td>iOS</td>
<td>未出口</td>
<td><code>iOS</code></td>
<td><code>ios</code></td>
</tr>
<tr>
<td>gRPC</td>
<td>已出口</td>
<td><code>GRPC</code></td>
<td><code>Grpc</code></td>
</tr>
<tr>
<td>gRPC</td>
<td>未出口</td>
<td><code>gRPC</code></td>
<td><code>grpc</code></td>
</tr>
<tr>
<td>分布式拒绝服务</td>
<td>已出口</td>
<td><code>DDoS</code></td>
<td><code>DDOS</code>,<code>Ddos</code></td>
</tr>
<tr>
<td>分布式拒绝服务</td>
<td>未出口</td>
<td><code>ddos</code></td>
<td><code>dDoS</code>,<code>dDOS</code></td>
</tr>
</tbody>
</table>
<h3 id="函数名称">函数名称</h3>
<p>​	函数和方法名称不应使用<code>Get</code>或<code>get</code>前缀，除非底层概念使用单词“get”（例如 HTTP GET）。更喜欢直接以名词开头的名称，例如使用<code>Counts</code>over <code>GetCounts</code>。</p>
<p>如果该函数涉及执行复杂的计算或执行远程调用，则可以使用不同的词（如<code>Compute</code>或）代替，以向读者清楚地表明函数调用可能需要时间并且可能会阻塞或失败。<code>Fetch Get</code></p>
<h3 id="变量名">变量名</h3>
<p>一般的经验法则是，名称的长度应与其范围的大小成正比，并与其在该范围内使用的次数成反比。在文件范围内创建的变量可能需要多个单词，而作用域为单个内部块的变量可能是单个单词甚至只是一两个字符，以保持代码清晰并避免无关信息。</p>
<p>这是一个粗略的基线。这些数字准则不是严格的规则。根据上下文、<a href="https://google.github.io/styleguide/go/guide#clarity">清晰度</a>和<a href="https://google.github.io/styleguide/go/guide#concision">简洁</a>性应用判断。</p>
<ul>
<li>小范围是执行一两个小操作的范围，比如 1-7 行。</li>
<li>中等范围是一些小的或一个大的操作，比如 8-15 行。</li>
<li>大范围是一个或几个大操作，比如 15-25 行。</li>
<li>非常大的范围是指超过一页（例如，超过 25 行）的任何内容。</li>
</ul>
<p>在小范围内可能非常清楚的名称（例如，<code>c</code>对于计数器）在较大范围内可能是不够的，并且需要澄清以提醒读者其在代码中的目的。一个作用域中有很多变量，或者表示相似值或概念的变量，可能需要比作用域建议的更长的变量名称。</p>
<p>概念的特殊性也有助于保持变量名称的简洁。例如，假设只有一个数据库在使用，像<code>db</code>这样的短变量名通常可能为非常小的范围保留，即使范围非常大也可能保持完全清晰。在这种情况下，根据范围的大小，单个词 <code>database</code>可能是可以接受的，但不是必需的，因为这<code>db</code>是一个非常常见的词缩写，几乎没有其他解释。</p>
<p>局部变量的名称应该反映它包含的内容以及它在当前上下文中的使用方式，而不是值的来源。例如，通常情况下最佳局部变量名称与结构或协议缓冲区字段名称不同。</p>
<p>一般来说：</p>
<ul>
<li>
<p>像<code>count</code>或这样的单词名称<code>options</code>是一个很好的起点。</p>
</li>
<li>
<p>可以添加其他词来消除相似名称的歧义，例如 <code>userCount</code>and <code>projectCount</code>。</p>
</li>
<li>
<p>不要为了节省打字而简单地放下字母。例如<code>Sandbox</code>比 更受欢迎<code>Sbx</code>，特别是对于导出的名称。</p>
</li>
<li>
<p>从大多数变量名中 省略</p>
<p>类型和类似类型的词。</p>
<ul>
<li>对于数字，<code>userCount</code>是比<code>numUsers</code>or 更好的名称<code>usersInt</code>。</li>
<li>对于切片，<code>users</code>是一个比<code>userSlice</code>.</li>
<li>如果范围内有两个版本的值，则包含类似类型的限定符是可以接受的，例如，您可能将输入存储在解析值中<code>ageString</code>并<code>age</code>用于解析值。</li>
</ul>
</li>
<li>
<p><a href="https://google.github.io/styleguide/go/decisions#repetitive-in-context">省略周围上下文</a>清楚的词。例如，在一个<code>UserCount</code>方法的实现中，调用的一个局部变量 <code>userCount</code>很可能是多余的；<code>count</code>, <code>users</code>, 甚至<code>c</code>都一样可读。</p>
</li>
</ul>
<h4 id="单字母变量名">单字母变量名</h4>
<p>单字母变量名可能是减少 <a href="https://google.github.io/styleguide/go/decisions#repetition">重复</a>的有用工具，但也可能使代码不必要地变得不透明。将它们的使用限制在完整单词很明显以及它会重复出现以代替单字母变量的情况。</p>
<p>一般来说：</p>
<ul>
<li>对于<a href="https://google.github.io/styleguide/go/decisions#receiver-names">方法接收者变量</a>，首选一个字母或两个字母的名称。</li>
<li>对常见类型使用熟悉的变量名通常很有帮助：
<ul>
<li><code>r</code>对于一个<code>io.Reader</code>或<code>*http.Request</code></li>
<li><code>w</code>对于一个<code>io.Writer</code>或<code>http.ResponseWriter</code></li>
</ul>
</li>
<li>单字母标识符作为整数循环变量是可接受的，特别是对于索引（例如，<code>i</code>）和坐标（例如，<code>x</code>和<code>y</code>）。</li>
<li>当范围很短时，缩写可以是可接受的循环标识符，例如<code>for _, n := range nodes &#123; ... &#125;</code>.</li>
</ul>
<h3 id="重复">重复</h3>
<p>​	一段 Go 源代码应该避免不必要的重复。一个常见的来源是重复名称，其中通常包含不必要的单词或重复其上下文或类型。如果相同或相似的代码段在很近的地方多次出现，代码本身也可能是不必要的重复。</p>
<p>重复命名可以有多种形式，包括：</p>
<h4 id="包与导出的符号名称">包与导出的符号名称</h4>
<p>​	命名导出的符号时，包的名称始终在包外可见，因此应减少或消除两者之间的冗余信息。如果一个包仅导出一种类型并且它以包本身命名，则构造函数的规范名称是<code>New</code>if one is required。</p>
<blockquote>
<p>**示例：**重复名称 -&gt; 更好的名称</p>
<ul>
<li><code>widget.NewWidget</code>-&gt;<code>widget.New</code></li>
<li><code>widget.NewWidgetWithName</code>-&gt;<code>widget.NewWithName</code></li>
<li><code>db.LoadFromDatabase</code>-&gt;<code>db.Load</code></li>
<li><code>goatteleportutil.CountGoatsTeleported</code>-&gt;<code>gtutil.CountGoatsTeleported</code> 或<code>goatteleport.Count</code></li>
<li><code>myteampb.MyTeamMethodRequest</code>-&gt;<code>mtpb.MyTeamMethodRequest</code>或 <code>myteampb.MethodRequest</code></li>
</ul>
</blockquote>
<h4 id="变量名与类型">变量名与类型</h4>
<p>​	编译器总是知道变量的类型，并且在大多数情况下，读者也可以通过变量的使用方式清楚地知道变量是什么类型。如果一个变量的值在同一范围内出现两次，则只需明确变量的类型。</p>
<table>
<thead>
<tr>
<th>重复名称</th>
<th>更好的名字</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>var numUsers int</code></td>
<td><code>var users int</code></td>
</tr>
<tr>
<td><code>var nameString string</code></td>
<td><code>var name string</code></td>
</tr>
<tr>
<td><code>var primaryProject *Project</code></td>
<td><code>var primary *Project</code></td>
</tr>
</tbody>
</table>
<p>如果该值以多种形式出现，则可以使用像<code>raw</code>and<code>parsed</code>或底层表示这样的额外词来澄清：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line">limitStr := r.FormValue(<span class="string">&quot;limit&quot;</span>)</span><br><span class="line">limit, err := strconv.Atoi(limitStr)</span><br><span class="line"><span class="comment">// Good:</span></span><br><span class="line">limitRaw := r.FormValue(<span class="string">&quot;limit&quot;</span>)</span><br><span class="line">limit, err := strconv.Atoi(limitRaw)</span><br></pre></td></tr></table></figure>
<h4 id="外部上下文与本地名称">外部上下文与本地名称</h4>
<p>​	包含来自周围上下文信息的名称通常会产生额外的噪音而没有任何好处。包名、方法名、类型名、函数名、导入路径，甚至文件名都可以提供自动限定其中所有名称的上下文。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="comment">// In package &quot;ads/targeting/revenue/reporting&quot;</span></span><br><span class="line"><span class="keyword">type</span> AdsTargetingRevenueReport <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Project)</span></span> ProjectName() <span class="type">string</span></span><br><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="comment">// In package &quot;ads/targeting/revenue/reporting&quot;</span></span><br><span class="line"><span class="keyword">type</span> Report <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Project)</span></span> Name() <span class="type">string</span></span><br><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="comment">// In package &quot;sqldb&quot;</span></span><br><span class="line"><span class="keyword">type</span> DBConnection <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="comment">// In package &quot;sqldb&quot;</span></span><br><span class="line"><span class="keyword">type</span> Connection <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="comment">// In package &quot;ads/targeting&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Process</span><span class="params">(in *pb.FooProto)</span></span> *Report &#123;</span><br><span class="line">    adsTargetingID := in.GetAdsTargetingID()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="comment">// In package &quot;ads/targeting&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Process</span><span class="params">(in *pb.FooProto)</span></span> *Report &#123;</span><br><span class="line">    id := in.GetAdsTargetingID()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	重复通常应该在符号用户的上下文中进行评估，而不是孤立地进行评估。例如，下面的代码有很多名称，在某些情况下可能没问题，但在上下文中是多余的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> UserCount() (userCount <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> userCountInt64 <span class="type">int64</span></span><br><span class="line">    <span class="keyword">if</span> dbLoadError := db.LoadFromDatabase(<span class="string">&quot;count(distinct users)&quot;</span>, &amp;userCountInt64); dbLoadError != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;failed to load user count: %s&quot;</span>, dbLoadError)</span><br><span class="line">    &#125;</span><br><span class="line">    userCount = <span class="type">int</span>(userCountInt64)</span><br><span class="line">    <span class="keyword">return</span> userCount, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相反，通常可以省略有关从上下文或用法中清楚的名称的信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> UserCount() (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="type">int64</span></span><br><span class="line">    <span class="keyword">if</span> err := db.Load(<span class="string">&quot;count(distinct users)&quot;</span>, &amp;count); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;failed to load user count: %s&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int</span>(count), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="imports">imports</h2>
<h3 id="导入重命名">导入重命名</h3>
<p>​	<em>只应重命名导入以避免与其他导入的名称冲突</em>。（由此推论，<a href="https://google.github.io/styleguide/go/decisions#package-names">好的包名</a>不应该需要重命名。）在名称冲突的情况下，更愿意重命名最本地或特定于项目的导入。包的本地名称（别名）必须遵循 <a href="https://google.github.io/styleguide/go/decisions#package-names">包命名指南</a>，包括禁止使用下划线和大写字母。</p>
<p>​	生成的 protocol buffer 包必须重命名以从名称中删除下划线，并且它们的别名必须有<code>pb</code>后缀。有关详细信息，请参阅 <a href="https://google.github.io/styleguide/go/best-practices#import-protos">原型和存根最佳实践</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Good:</span><br><span class="line">import (</span><br><span class="line">    fspb &quot;path/to/package/foo_service_go_proto&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>导入的包名称没有有用的识别信息（例如 <code>package v1</code>）应该重命名以包括以前的路径组件。重命名必须与导入相同包的其他本地文件一致，并且可以包括版本号。</p>
<p>**注意：**最好重命名包以符合 <a href="https://google.github.io/styleguide/go/decisions#package-names">良好的包名称</a>，但这对于 vendored 目录中的包通常不可行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Good:</span><br><span class="line">import (</span><br><span class="line">    core &quot;github.com/kubernetes/api/core/v1&quot;</span><br><span class="line">    meta &quot;github.com/kubernetes/apimachinery/pkg/apis/meta/v1beta1&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>​	如果您需要导入一个名称与您要使用的公共局部变量名称（例如<code>url</code>, <code>ssh</code>）冲突的包，并且您希望重命名该包，首选方法是使用<code>pkg</code>后缀（例如<code>urlpkg</code>）。请注意，可以使用局部变量隐藏包；仅当此类变量在范围内时仍需要使用包时，才需要重命名。</p>
<h3 id="导入分组">导入分组</h3>
<p>导入应分为两组：</p>
<ul>
<li>标准库包</li>
<li>其他（项目和销售）包</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Good:</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;hash/adler32&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line"></span><br><span class="line">    &quot;github.com/dsnet/compress/flate&quot;</span><br><span class="line">    &quot;golang.org/x/text/encoding&quot;</span><br><span class="line">    &quot;google.golang.org/protobuf/proto&quot;</span><br><span class="line">    foopb &quot;myproj/foo/proto/proto&quot;</span><br><span class="line">    _ &quot;myproj/rpc/protocols/dial&quot;</span><br><span class="line">    _ &quot;myproj/security/auth/authhooks&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>​	将项目包分成多个组是可以接受的，例如，如果您想要一个单独的组来重命名、import-only-for-side-effects 或另一个特殊的导入组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;hash/adler32&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/dsnet/compress/flate&quot;</span></span><br><span class="line">    <span class="string">&quot;golang.org/x/text/encoding&quot;</span></span><br><span class="line">    <span class="string">&quot;google.golang.org/protobuf/proto&quot;</span></span><br><span class="line"></span><br><span class="line">    foopb <span class="string">&quot;myproj/foo/proto/proto&quot;</span></span><br><span class="line"></span><br><span class="line">    _ <span class="string">&quot;myproj/rpc/protocols/dial&quot;</span></span><br><span class="line">    _ <span class="string">&quot;myproj/security/auth/authhooks&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>​	<strong>注意：</strong><a href="https://google.github.io/styleguide/go/golang.org/x/tools/cmd/goimports">goimports</a>工具不支持维护可选组 - 超出标准库和 Google 导入之间强制分离所需的拆分。额外的导入子组需要作者和审稿人的注意，以保持符合状态。</p>
<p>​	也是 AppEngine 应用程序的 Google 程序应该有一个单独的组用于 AppEngine 导入。</p>
<h3 id="导入“空白”-import">导入“空白” ( <code>import _</code>)</h3>
<p>仅为了副作用<code>import _ &quot;package&quot;</code>而导入的包（使用语法 ）只能在主包或需要它们的测试中导入。</p>
<p>此类软件包的一些示例包括：</p>
<ul>
<li><a href="https://pkg.go.dev/time/tzdata">时间/tzdata</a></li>
<li>图像处理代码中的<a href="https://pkg.go.dev/image/jpeg">image/jpeg</a></li>
</ul>
<p>避免在库包中导入空白，即使库间接依赖于它们。将副作用导入限制到主包有助于控制依赖性，并使得编写依赖于不同导入的测试成为可能，而不会发生冲突或浪费构建成本。</p>
<p>以下是此规则的唯一例外情况：</p>
<ul>
<li>您可以使用空白导入绕过 <a href="https://github.com/bazelbuild/rules_go/blob/master/go/nogo.rst">nogo 静态检查器中对不允许导入的检查</a>。</li>
<li>您可以在使用编译器指令的源文件中使用<a href="https://pkg.go.dev/embed">嵌入</a>包的空白导入。<code>//go:embed</code></li>
</ul>
<p>**提示：**如果您创建的库包间接依赖于生产中的副作用导入，请记录预期用途。</p>
<h3 id="导入“点”-import">导入“点”( <code>import .</code>)</h3>
<p>​	<code>import .</code>表单是一种语言功能，允许将从另一个包导出的标识符无条件地带到当前包中。有关更多信息，请参阅<a href="https://go.dev/ref/spec#Import_declarations">语言规范</a>。</p>
<p>不要在 Google 代码库<strong>中</strong>使用此功能；这使得更难判断功能来自何处。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="keyword">package</span> foo_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bar/testutil&quot;</span> <span class="comment">// also imports &quot;foo&quot;</span></span><br><span class="line">    . <span class="string">&quot;foo&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myThing = Bar() <span class="comment">// Bar defined in package foo; no qualification needed.</span></span><br><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">package</span> foo_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bar/testutil&quot;</span> <span class="comment">// also imports &quot;foo&quot;</span></span><br><span class="line">    <span class="string">&quot;foo&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myThing = foo.Bar()</span><br></pre></td></tr></table></figure>
<h2 id="错误">错误</h2>
<h3 id="返回错误">返回错误</h3>
<p>​	用于<code>error</code>表示函数可能会失败。按照惯例，<code>error</code>是最后一个结果参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Good</span><span class="params">()</span></span> <span class="type">error</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>​	返回<code>nil</code>错误是表示操作成功的惯用方式，否则可能会失败。如果函数返回错误，除非另有明确说明，否则调用者必须将所有非错误返回值视为未指定。通常，非错误返回值是它们的零值，但这不能假设。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoodLookup</span><span class="params">()</span></span> (*Result, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	返回错误的导出函数应该使用<code>error</code>类型返回它们。具体的错误类型容易受到细微错误的影响：具体的<code>nil</code>指针可以包装到接口中，从而变成非零值（请参阅 <a href="https://golang.org/doc/faq#nil_error">主题上的 Go FAQ 条目</a>）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bad</span><span class="params">()</span></span> *os.PathError &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>​	<strong>提示</strong>：带有<code>context.Context</code>参数的函数通常应返回一个<code>error</code>，以便调用者可以确定在函数运行时上下文是否被取消。</p>
<h3 id="错误字符串">错误字符串</h3>
<p>​	错误字符串不应大写（除非以导出名称、专有名词或首字母缩写词开头）并且不应以标点符号结尾。这是因为错误字符串通常在打印给用户之前出现在其他上下文中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line">err := fmt.Errorf(<span class="string">&quot;Something bad happened.&quot;</span>)</span><br><span class="line"><span class="comment">// Good:</span></span><br><span class="line">err := fmt.Errorf(<span class="string">&quot;something bad happened&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>​	另一方面，完整显示消息（日志记录、测试失败、API 响应或其他 UI）的样式取决于，但通常应大写。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line">log.Infof(<span class="string">&quot;Operation aborted: %v&quot;</span>, err)</span><br><span class="line">log.Errorf(<span class="string">&quot;Operation aborted: %v&quot;</span>, err)</span><br><span class="line">t.Errorf(<span class="string">&quot;Op(%q) failed unexpectedly; err=%v&quot;</span>, args, err)</span><br></pre></td></tr></table></figure>
<h3 id="处理错误">处理错误</h3>
<p>​	遇到错误的代码应该慎重选择如何处理它。<code>_</code>使用变量丢弃错误通常是不合适的。如果函数返回错误，请执行以下操作之一：</p>
<ul>
<li>立即处理并解决错误。</li>
<li>将错误返回给调用者。</li>
<li>在特殊情况下，请致电<a href="https://pkg.go.dev/github.com/golang/glog#Fatal"><code>log.Fatal</code></a>或（如果绝对必要） <code>panic</code>。</li>
</ul>
<p><strong>注意：</strong> <code>log.Fatalf</code>不是标准库日志。参见 [#logging]。</p>
<p>​	在极少数情况下，忽略或丢弃错误是合适的（例如<a href="https://pkg.go.dev/bytes#Buffer.Write"><code>(*bytes.Buffer).Write</code></a>，记录的调用永远不会失败），随附的注释应该解释为什么这是安全的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">var</span> b *bytes.Buffer</span><br><span class="line"></span><br><span class="line">n, _ := b.Write(p) <span class="comment">// never returns a non-nil error</span></span><br></pre></td></tr></table></figure>
<p>有关错误处理的更多讨论和示例，请参阅 <a href="http://golang.org/doc/effective_go.html#errors">Effective Go</a> and <a href="https://google.github.io/styleguide/go/best-practices.html#error-handling">best practices</a>。</p>
<h3 id="带内错误">带内错误</h3>
<p>​	在 C 和类似语言中，函数返回值（如 -1、null 或空字符串）以表示错误或缺少结果是很常见的。这称为带内错误处理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="comment">// Lookup returns the value for key or -1 if there is no mapping for key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>
<p>​	未能检查带内错误值可能会导致错误，并将错误归因于错误的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="comment">// The following line returns an error that Parse failed for the input value,</span></span><br><span class="line"><span class="comment">// whereas the failure was that there is no mapping for missingKey.</span></span><br><span class="line"><span class="keyword">return</span> Parse(Lookup(missingKey))</span><br></pre></td></tr></table></figure>
<p>​	Go 对多个返回值的支持提供了更好的解决方案（请参阅 <a href="http://golang.org/doc/effective_go.html#multiple-returns">Effective Go 部分的多个返回值</a>）。函数不应要求客户端检查带内错误值，而应返回一个附加值以指示其其他返回值是否有效。这个返回值可能是一个错误，也可能是一个布尔值，无需解释，应该是最终的返回值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="comment">// Lookup returns the value for key or ok=false if there is no mapping for key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(key <span class="type">string</span>)</span></span> (value <span class="type">string</span>, ok <span class="type">bool</span>)</span><br></pre></td></tr></table></figure>
<p>​	此 API 可防止调用者错误写入<code>Parse(Lookup(key))</code>而导致编译时错误，因为<code>Lookup(key)</code>它有 2 个输出。</p>
<p>以这种方式返回错误鼓励更健壮和明确的错误处理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line">value, ok := Lookup(key)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;no value for %q&quot;</span>, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Parse(value)</span><br></pre></td></tr></table></figure>
<p>​	一些标准库函数，如 package中的函数<code>strings</code>，返回带内错误值。这极大地简化了字符串操作代码，但代价是需要程序员更加勤奋。一般来说，Google 代码库中的 Go 代码应该为错误返回额外的值。</p>
<h3 id="缩进错误流程">缩进错误流程</h3>
<p>​	在继续您的代码的其余部分之前处理错误。这通过使读者能够快速找到正常路径来提高代码的可读性。同样的逻辑适用于任何测试条件然后以终止条件结束的块（例如<code>return</code>，，，<code>panic</code>）<code>log.Fatal</code>。</p>
<p>​	如果不满足终止条件，则运行的代码应出现在<code>if</code> 块之后，并且不应在<code>else</code>子句中缩进。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// or continue, etc.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// normal code</span></span><br><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// normal code that looks abnormal due to indentation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>**提示：**如果您在多行代码中使用一个变量，通常不值得使用<code>if</code>-with-initializer 样式。在这些情况下，通常最好将声明移出并使用标准<code>if</code> 语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line">x, err := f()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// error handling</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lots of code that uses x</span></span><br><span class="line"><span class="comment">// across multiple lines</span></span><br><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="keyword">if</span> x, err := f(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// error handling</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// lots of code that uses x</span></span><br><span class="line">  <span class="comment">// across multiple lines</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>有关详细信息，请参阅<a href="https://google.github.io/styleguide/go/index.html#gotip">Go 技巧 #1：视线</a>和 <a href="https://testing.googleblog.com/2017/06/code-health-reduce-nesting-reduce.html">TotT：通过减少嵌套</a> 来降低代码复杂性。</p>
<h2 id="文字格式语法">文字格式语法</h2>
<h3 id="无切片">无切片</h3>
<p>​	<code>nil</code>对于大多数用途，空切片和空切片之间没有功能差异。内置函数在切片上的表现<code>len</code>和<code>cap</code>预期一样。<code>nil</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span>         <span class="comment">// nil</span></span><br><span class="line"></span><br><span class="line">fmt.Println(s)      <span class="comment">// []</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// 0</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s)) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> s &#123;...&#125;   <span class="comment">// no-op</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">42</span>)</span><br><span class="line">fmt.Println(s)      <span class="comment">// [42]</span></span><br></pre></td></tr></table></figure>
<p>​	如果您将空切片声明为局部变量（尤其是如果它可以作为返回值的来源），则首选 nil 初始化以降低调用者出现错误的风险。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">var</span> t []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad:</span></span><br><span class="line">t := []<span class="type">string</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>​	不要创建强制其客户区分 nil 和空切片的 API。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="comment">// Ping pings its targets.</span></span><br><span class="line"><span class="comment">// Returns hosts that successfully responded.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ping</span><span class="params">(hosts []<span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="comment">// Ping pings its targets and returns a list of hosts</span></span><br><span class="line"><span class="comment">// that successfully responded. Can be empty if the input was empty.</span></span><br><span class="line"><span class="comment">// nil signifies that a system error occurred.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ping</span><span class="params">(hosts []<span class="type">string</span>)</span></span> []<span class="type">string</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>​	在设计接口时，避免区分<code>nil</code>切片和<code>nil</code>非零长度切片，因为这会导致细微的编程错误。这通常是通过使用<code>len</code>to 检查是否为空来完成的，而不是<code>== nil</code>.</p>
<p>​	此实现接受两个<code>nil</code>和零长度切片为“空”：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="comment">// describeInts describes s with the given prefix, unless s is empty.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describeInts</span><span class="params">(prefix <span class="type">string</span>, s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(prefix, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	而不是依赖于区别作为 API 的一部分：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maybeInts</span><span class="params">()</span></span> []<span class="type">int</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// describeInts describes s with the given prefix; pass nil to skip completely.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describeInts</span><span class="params">(prefix <span class="type">string</span>, s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// The behavior of this function unintentionally changes depending on what</span></span><br><span class="line">  <span class="comment">// maybeInts() returns in &#x27;empty&#x27; cases (nil or []int&#123;&#125;).</span></span><br><span class="line">  <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(prefix, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">describeInts(<span class="string">&quot;Here are some ints:&quot;</span>, maybeInts())</span><br></pre></td></tr></table></figure>
<p>有关进一步讨论，请参阅<a href="https://google.github.io/styleguide/go/decisions#in-band-errors">带内错误</a>。</p>
<h3 id="函数格式化">函数格式化</h3>
<p>函数或方法声明的签名应保留在一行中以避免<a href="https://google.github.io/styleguide/go/decisions#indentation-confusion">缩进混淆</a>。</p>
<p>函数参数列表可以构成 Go 源文件中最长的几行。但是，它们先于缩进的变化，因此很难以不使后续行看起来像函数体的一部分的方式以令人困惑的方式断行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *SomeType)</span></span> SomeLongFunctionName(foo1, foo2, foo3 <span class="type">string</span>,</span><br><span class="line">    foo4, foo5, foo6 <span class="type">int</span>) &#123;</span><br><span class="line">    foo7 := bar(foo1)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请参阅<a href="https://google.github.io/styleguide/go/best-practices#funcargs">最佳实践</a>，了解一些选项，以缩短函数的调用站点，否则会有很多参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line">good := foo.Call(long, CallOptions&#123;</span><br><span class="line">    Names:   list,</span><br><span class="line">    Of:      of,</span><br><span class="line">    The:     parameters,</span><br><span class="line">    Func:    all,</span><br><span class="line">    Args:    on,</span><br><span class="line">    Now:     separate,</span><br><span class="line">    Visible: lines,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Bad:</span></span><br><span class="line">bad := foo.Call(</span><br><span class="line">    long,</span><br><span class="line">    list,</span><br><span class="line">    of,</span><br><span class="line">    parameters,</span><br><span class="line">    all,</span><br><span class="line">    on,</span><br><span class="line">    separate,</span><br><span class="line">    lines,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>通常可以通过分解出局部变量来缩短行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line">local := helper(some, parameters, here)</span><br><span class="line">good := foo.Call(list, of, parameters, local)</span><br></pre></td></tr></table></figure>
<p>​	同样，函数和方法调用不应仅根据行长度来分开。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line">good := foo.Call(long, list, of, parameters, all, on, one, line)</span><br><span class="line"><span class="comment">// Bad:</span></span><br><span class="line">bad := foo.Call(long, list, of, parameters,</span><br><span class="line">    with, arbitrary, line, breaks)</span><br></pre></td></tr></table></figure>
<p>​	不要为特定的函数参数添加注释。相反，使用 <a href="https://google.github.io/styleguide/go/best-practices#option-structure">选项结构</a>或向函数文档添加更多详细信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line">good := server.New(ctx, server.Options&#123;Port: <span class="number">42</span>&#125;)</span><br><span class="line"><span class="comment">// Bad:</span></span><br><span class="line">bad := server.New(</span><br><span class="line">    ctx,</span><br><span class="line">    <span class="number">42</span>, <span class="comment">// Port</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>​	如果调用站点长得让人不舒服，请考虑重构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="comment">// Sometimes variadic arguments can be factored out</span></span><br><span class="line">replacements := []<span class="type">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;from&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="comment">// related values can be formatted adjacent to one another</span></span><br><span class="line">    <span class="string">&quot;source&quot;</span>, <span class="string">&quot;dest&quot;</span>,</span><br><span class="line">    <span class="string">&quot;original&quot;</span>, <span class="string">&quot;new&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the replacement struct as inputs to NewReplacer.</span></span><br><span class="line">replacer := strings.NewReplacer(replacements...)</span><br></pre></td></tr></table></figure>
<p>​	如果 API 无法更改或本地调用异常（无论调用是否太长），如果有助于理解调用，则始终允许添加换行符。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line">canvas.RenderCube(cube,</span><br><span class="line">    x0, y0, z0,</span><br><span class="line">    x0, y0, z1,</span><br><span class="line">    x0, y1, z0,</span><br><span class="line">    x0, y1, z1,</span><br><span class="line">    x1, y0, z0,</span><br><span class="line">    x1, y0, z1,</span><br><span class="line">    x1, y1, z0,</span><br><span class="line">    x1, y1, z1,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>请注意，上例中的线条并未环绕在特定的列边界处，而是根据坐标三元组进行分组。</p>
<p>​	函数内的长字符串字面值不应因行长而被打断。对于包含此类字符串的函数，可以在字符串格式后添加换行符，并且可以在下一行或后续行提供参数。关于换行符应该去哪里的决定最好基于输入的语义分组，而不是纯粹基于行的长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line">log.Warningf(<span class="string">&quot;Database key (%q, %d, %q) incompatible in transaction started by (%q, %d, %q)&quot;</span>,</span><br><span class="line">    currentCustomer, currentOffset, currentKey,</span><br><span class="line">    txCustomer, txOffset, txKey)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad:</span></span><br><span class="line">log.Warningf(<span class="string">&quot;Database key (%q, %d, %q) incompatible in&quot;</span>+</span><br><span class="line">    <span class="string">&quot; transaction started by (%q, %d, %q)&quot;</span>,</span><br><span class="line">    currentCustomer, currentOffset, currentKey, txCustomer,</span><br><span class="line">    txOffset, txKey)</span><br></pre></td></tr></table></figure>
<h3 id="条件和循环">条件和循环</h3>
<p>​	声明<code>if</code>不应断行；多行<code>if</code>子句会导致 <a href="https://google.github.io/styleguide/go/decisions#indentation-confusion">缩进混乱</a>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="comment">// The second if statement is aligned with the code within the if block, causing</span></span><br><span class="line"><span class="comment">// indentation confusion.</span></span><br><span class="line"><span class="keyword">if</span> db.CurrentStatusIs(db.InTransaction) &amp;&amp;</span><br><span class="line">    db.ValuesEqual(db.TransactionKey(), row.Key()) &#123;</span><br><span class="line">    <span class="keyword">return</span> db.Errorf(db.TransactionError, <span class="string">&quot;query failed: row (%v): key does not match transaction key&quot;</span>, row)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不需要短路行为，可以直接提取布尔操作数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line">inTransaction := db.CurrentStatusIs(db.InTransaction)</span><br><span class="line">keysMatch := db.ValuesEqual(db.TransactionKey(), row.Key())</span><br><span class="line"><span class="keyword">if</span> inTransaction &amp;&amp; keysMatch &#123;</span><br><span class="line">    <span class="keyword">return</span> db.Error(db.TransactionError, <span class="string">&quot;query failed: row (%v): key does not match transaction key&quot;</span>, row)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能还可以提取其他局部变量，尤其是在条件已经重复的情况下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line">uid := user.GetUniqueUserID()</span><br><span class="line"><span class="keyword">if</span> db.UserIsAdmin(uid) || db.UserHasPermission(uid, perms.ViewServerConfig) || db.UserHasPermission(uid, perms.CreateGroup) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="keyword">if</span> db.UserIsAdmin(user.GetUniqueUserID()) || db.UserHasPermission(user.GetUniqueUserID(), perms.ViewServerConfig) || db.UserHasPermission(user.GetUniqueUserID(), perms.CreateGroup) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>if</code>包含闭包或多行结构文字的语句应确保<a href="https://google.github.io/styleguide/go/decisions#literal-matching-braces">大括号匹配</a>以避免 <a href="https://google.github.io/styleguide/go/decisions#indentation-confusion">缩进混淆</a>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">if</span> err := db.RunInTransaction(<span class="function"><span class="keyword">func</span><span class="params">(tx *db.TX)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tx.Execute(userUpdate, x, y, z)</span><br><span class="line">&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;user update failed: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">if</span> _, err := client.Update(ctx, &amp;upb.UserUpdateRequest&#123;</span><br><span class="line">    ID:   userID,</span><br><span class="line">    User: user,</span><br><span class="line">&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;user update failed: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，不要尝试在<code>for</code>语句中插入人为的换行符。如果没有优雅的重构方式，你总是可以让这条线很长：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">for</span> i, max := <span class="number">0</span>, collection.Size(); i &lt; max &amp;&amp; !collection.HasPendingWriters(); i++ &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，通常有：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">for</span> i, max := <span class="number">0</span>, collection.Size(); i &lt; max; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> collection.HasPendingWriters() &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>switch</code>和<code>case</code>语句也应该保持在一行中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">switch</span> good := db.TransactionStatus(); good &#123;</span><br><span class="line"><span class="keyword">case</span> db.TransactionStarting, db.TransactionActive, db.TransactionWaiting:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> db.TransactionCommitted, db.NoTransaction:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="keyword">switch</span> bad := db.TransactionStatus(); bad &#123;</span><br><span class="line"><span class="keyword">case</span> db.TransactionStarting,</span><br><span class="line">    db.TransactionActive,</span><br><span class="line">    db.TransactionWaiting:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> db.TransactionCommitted,</span><br><span class="line">    db.NoTransaction:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果行太长，缩进所有的案例并用空行分隔它们以避免<a href="https://google.github.io/styleguide/go/decisions#indentation-confusion">缩进混淆</a>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">switch</span> db.TransactionStatus() &#123;</span><br><span class="line"><span class="keyword">case</span></span><br><span class="line">    db.TransactionStarting,</span><br><span class="line">    db.TransactionActive,</span><br><span class="line">    db.TransactionWaiting,</span><br><span class="line">    db.TransactionCommitted:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> db.NoTransaction:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在比较变量和常量的条件语句中，将变量值放在相等运算符的左侧：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">if</span> result == <span class="string">&quot;foo&quot;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取而代之的是常数首先出现的不太清晰的措辞（<a href="https://en.wikipedia.org/wiki/Yoda_conditions">“Yoda style conditionals”</a>）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;foo&quot;</span> == result &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复制">复制</h2>
<p>为避免意外的别名和类似错误，从另一个包复制结构时要小心。例如，<code>sync.Mutex</code> 不得复制诸如此类的同步对象。</p>
<p>该<code>bytes.Buffer</code>类型包含一个<code>[]byte</code>切片，并且作为对小字符串的优化，还包含一个切片可能引用的小字节数组。如果您复制 a <code>Buffer</code>，则副本中的切片可能会为原始数组设置别名，从而导致后续方法调用产生令人惊讶的效果。</p>
<p><code>T</code>通常，如果类型的方法与指针类型关联，则不要复制该类型的值<code>*T</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line">b1 := bytes.Buffer&#123;&#125;</span><br><span class="line">b2 := b1</span><br></pre></td></tr></table></figure>
<p>调用采用值接收器的方法可以隐藏副本。当您编写 API 时，如果您的结构包含不应复制的字段，您通常应该获取和返回指针类型。</p>
<p>这些是可以接受的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">type</span> Record <span class="keyword">struct</span> &#123;</span><br><span class="line">  buf bytes.Buffer</span><br><span class="line">  <span class="comment">// other fields omitted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Record &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Record)</span></span> Process(...) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consumer</span><span class="params">(r *Record)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>但这些通常是错误的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="keyword">type</span> Record <span class="keyword">struct</span> &#123;</span><br><span class="line">  buf bytes.Buffer</span><br><span class="line">  <span class="comment">// other fields omitted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Record)</span></span> Process(...) &#123;...&#125; <span class="comment">// Makes a copy of r.buf</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consumer</span><span class="params">(r Record)</span></span> &#123;...&#125; <span class="comment">// Makes a copy of r.buf</span></span><br></pre></td></tr></table></figure>
<p>本指南也适用于复印<code>sync.Mutex</code>。</p>
<h3 id="接口">接口</h3>
<p>​	Go接口通常属于使用接口类型值的包，而不是<em>实现</em>接口类型的包。实施包应该返回具体的（通常是指针或结构）类型。这样，无需大量重构即可将新方法添加到实现中。有关详细信息，请参阅<a href="https://google.github.io/styleguide/go/index.html#gotip">GoTip #49：接受接口，返回具体类型</a> 。</p>
<p>​	不要从使用接口的 API 导出接口的<a href="https://abseil.io/resources/swe-book/html/ch13.html#techniques_for_using_test_doubles">测试替身</a>实现。相反，设计 API 以便可以使用<a href="https://google.github.io/styleguide/go/best-practices#use-real-transports">实际实现</a>的<a href="https://abseil.io/resources/swe-book/html/ch12.html#test_via_public_apis">公共 API</a>对其进行测试。有关详细信息，请参阅 <a href="https://google.github.io/styleguide/go/index.html#gotip">GoTip #42：编写用于测试的存根</a>。即使在使用真实实现不可行的情况下，也可能没有必要引入一个完全覆盖真实类型中所有方法的接口；消费者可以创建一个仅包含其所需方法的接口，如 <a href="https://google.github.io/styleguide/go/index.html#gotip">GoTip #78：最小可行接口</a>中所示。</p>
<p>​	要测试使用 Stubby RPC 客户端的包，请使用真实的客户端连接。如果无法在测试中运行真实服务器，Google 的内部做法是使用内部 rpctest 包（即将推出！）获取到本地 [test double] 的真实客户端连接。</p>
<p>​	不要在使用之前定义接口（请参阅 <a href="https://testing.googleblog.com/2017/08/code-health-eliminate-yagni-smells.html">TotT：代码健康：消除 YAGNI 气味</a>）(YAGNI: <em><strong>你不需要它（ You Aren’t Gonna Need It</strong></em>)。如果没有实际的使用示例，就很难判断一个接口是否必要，更不用说它应该包含哪些方法了。</p>
<blockquote>
<p>软件开发的大部分成本是维护成本。<strong>减少维护成本的一个方法是：“只在当你真正需要它时，才去编写它”</strong>。</p>
</blockquote>
<p>如果包的用户不需要为他们传递不同的类型，请不要使用接口类型参数。</p>
<p><code>不要导出包的用户不需要的接口</code>。</p>
<p>**TODO：**在接口上写一个更深入的文档并在此处链接到它。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">package</span> consumer <span class="comment">// consumer.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Thinger <span class="keyword">interface</span> &#123; Thing() <span class="type">bool</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">(t Thinger)</span></span> <span class="type">string</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">package</span> consumer <span class="comment">// consumer_test.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeThinger <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t fakeThinger)</span></span> Thing() <span class="type">bool</span> &#123; ... &#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> Foo(fakeThinger&#123;...&#125;) == <span class="string">&quot;x&quot;</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="keyword">package</span> producer</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Thinger <span class="keyword">interface</span> &#123; Thing() <span class="type">bool</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> defaultThinger <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t defaultThinger)</span></span> Thing() <span class="type">bool</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewThinger</span><span class="params">()</span></span> Thinger &#123; <span class="keyword">return</span> defaultThinger&#123; ... &#125; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">package</span> producer</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Thinger <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Thinger)</span></span> Thing() <span class="type">bool</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewThinger</span><span class="params">()</span></span> Thinger &#123; <span class="keyword">return</span> Thinger&#123; ... &#125; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="传值">传值</h2>
<blockquote>
<p>不要为了节省几个字节而将指针作为函数参数传递。</p>
</blockquote>
<p>​	如果一个函数<code>x</code>只读取它的参数<code>*x</code>，那么这个参数不应该是一个指针。这方面的常见实例包括传递一个指向字符串 ( <code>*string</code>) 的指针或一个指向接口值 ( <code>*io.Reader</code>) 的指针。在这两种情况下，值本身都是固定大小的，可以直接传递。</p>
<p>​	此建议不适用于大型结构，甚至可能会增加大小的小型结构。特别是，protocol buffer 消息通常应该由指针而不是值来处理。指针类型满足 <code>proto.Message</code>接口（被 , 等接受<code>proto.Marshal</code>）<code>protocmp.Transform</code>，并且协议缓冲区消息可能非常大，并且通常会随着时间的推移而变大。</p>
<h3 id="接收器类型">接收器类型</h3>
<p>​	方法<a href="https://golang.org/ref/spec#Method_declarations">接收者</a>可以作为值或指针传递，就好像它是常规函数参数一样。选择哪个应该基于该方法应该属于哪个<a href="https://golang.org/ref/spec#Method_sets">方法集</a>。</p>
<p>​	**正确性胜过速度或简单性。**在某些情况下，您必须使用指针值。在其他情况下，如果您对代码将如何增长没有很好的了解，则为大型类型选择指针或作为面向未来的指针，并为简单的<a href="https://en.wikipedia.org/wiki/Passive_data_structure">普通旧数据</a>使用值。</p>
<p>下面的列表更详细地说明了每个案例：</p>
<ul>
<li>
<p>如果接收者是一个切片并且该方法不重新切片或重新分配切片，请使用值而不是指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">type</span> Buffer []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Buffer)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(b) &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果该方法需要改变接收者，则接收者必须是一个指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Inc() &#123; *c++ &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See https://pkg.go.dev/container/heap.</span></span><br><span class="line"><span class="keyword">type</span> Queue []Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> Push(x Item) &#123; *q = <span class="built_in">append</span>([]Item&#123;x&#125;, *q...) &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果接收者是一个包含 <a href="https://google.github.io/styleguide/go/decisions#copying">无法安全复制</a>的字段的结构，请使用指针接收者。常见的例子是<a href="https://pkg.go.dev/sync#Mutex"><code>sync.Mutex</code></a>和其他同步类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.Mutex</span><br><span class="line">    total <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Inc() &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    c.total++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**提示：**检查类型的<a href="https://pkg.go.dev/time#example-Duration">Godoc</a>以获取有关复制是否安全的信息。</p>
</li>
<li>
<p>如果接收器是“大”结构或数组，指针接收器可能更有效。传递结构等同于将其所有字段或元素作为参数传递给方法。如果这看起来太大而不能 <a href="https://google.github.io/styleguide/go/decisions#pass-values">按值传递</a>，那么指针是一个不错的选择。</p>
</li>
<li>
<p>对于将调用或与其他修改接收器的函数同时运行的方法，如果这些修改对您的方法不可见，请使用一个值；否则使用指针。</p>
</li>
<li>
<p>如果接收器是一个结构或数组，其中任何一个元素都是指向可能发生变化的东西的指针，则更喜欢指针接收器以使读者清楚地了解可变性的意图。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    m *Metric</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Inc() &#123;</span><br><span class="line">    c.m.Add(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果接收者是<a href="https://pkg.go.dev/builtin">内置类型</a>，例如整数或字符串，不需要修改，则使用值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">type</span> User <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> String() &#123; <span class="keyword">return</span> <span class="type">string</span>(u) &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果接收者是映射、函数或通道，请使用值而不是指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="comment">// See https://pkg.go.dev/net/http#Header.</span></span><br><span class="line"><span class="keyword">type</span> Header <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span></span> Add(key, value <span class="type">string</span>) &#123; <span class="comment">/* omitted */</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果接收者是一个“小”数组或结构，它自然是一个没有可变字段和指针的值类型，那么值接收者通常是正确的选择。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Good:</span><br><span class="line">// See https://pkg.go.dev/time#Time.</span><br><span class="line">type Time struct &#123; /* omitted */ &#125;</span><br><span class="line"></span><br><span class="line">func (t Time) Add(d Duration) Time &#123; /* omitted */ &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如有疑问，请使用指针接收器。</p>
</li>
</ul>
<p>作为一般准则，更喜欢使类型的方法全部为指针方法或全部为值方法。</p>
<p>**注意：**关于将值或指针传递给函数是否会影响性能，存在很多错误信息。编译器可以选择将指针传递给堆栈上的值以及复制堆栈上的值，但在大多数情况下，这些考虑不应超过代码的可读性和正确性。当性能确实很重要时，重要的是在决定一种方法优于另一种方法之前，用一个现实的基准来分析这两种方法。</p>
<h3 id="switch和break"><code>switch</code>和<code>break</code></h3>
<p>​	不要在子句<code>break</code>末尾使用没有目标标签的<code>switch</code> 语句；他们是多余的。与 C 和 Java 不同，<code>switch</code>Go 中的子句会自动中断，并且需要一条<code>fallthrough</code>语句来实现 C 风格的行为。<code>break</code>如果您想阐明空子句的目的，请使用注释而不是。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>:</span><br><span class="line">    buf.WriteString(x)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;C&quot;</span>:</span><br><span class="line">    <span class="comment">// handled outside of the switch statement</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unknown value: %q&quot;</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>:</span><br><span class="line">    buf.WriteString(x)</span><br><span class="line">    <span class="keyword">break</span> <span class="comment">// this break is redundant</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;C&quot;</span>:</span><br><span class="line">    <span class="keyword">break</span> <span class="comment">// this break is redundant</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unknown value: %q&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>**注意：**如果<code>switch</code>子句在<code>for</code>循环内，则使用<code>break</code>within <code>switch</code>不会退出封闭<code>for</code>循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> x &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">     <span class="keyword">break</span> <span class="comment">// exits the switch, not the loop</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for</code>要退出封闭循环，请在语句上使用标签：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">loop:</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> x &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">       <span class="keyword">break</span> loop <span class="comment">// exits the loop</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></blockquote>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>代码风格</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊链路追踪 OpenTracing</title>
    <url>/2023/02/06/%E8%81%8A%E8%81%8A%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%20OpenTracing/</url>
    <content><![CDATA[<h1>聊聊链路追踪 <code>OpenTracing</code></h1>
<h2 id="什么是-Tracing">什么是 Tracing</h2>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/img/logging-metrics-tracing.o.png" alt="Logging Metrics Tracing"></p>
<p>对 Tracing 的定义是，在软件工程中，Tracing 指使用特定的日志记录程序的执行信息，与之相近的还有两个概念，它们分别是 Logging 和 Metrics。</p>
<ul>
<li>Logging：用于记录离散的事件，包含程序执行到某一点或某一阶段的详细信息。</li>
<li>Metrics：可聚合的数据，且通常是固定类型的时序数据，包括 Counter、Gauge、Histogram 等。</li>
<li>Tracing：记录单个请求的处理流程，其中包括服务调用和处理时长等信息。</li>
</ul>
<p>同时这三种定义相交的情况也比较常见。</p>
<ul>
<li>Logging &amp; Metrics：可聚合的事件。例如分析某对象存储的 <code>Nginx</code> 日志，统计某段时间内 GET、PUT、DELETE、OPTIONS 操作的总数。</li>
<li>Metrics &amp; Tracing：单个请求中的可计量数据。例如 <code>SQL</code> 执行总时长、<code>gRPC</code> 调用总次数。</li>
<li>Tracing &amp; Logging：请求阶段的标签数据。例如在 Tracing 的信息中标记详细的错误原因。</li>
</ul>
<p>针对每种分析需求，我们都有非常强大的集中式分析工具。</p>
<ul>
<li>
<p>Logging：<a href="https://www.elastic.co/">ELK</a>，近几年势头最猛的日志分析服务，无须多言。</p>
</li>
<li>
<p>Metrics：<a href="https://prometheus.io/">Prometheus</a>，第二个加入 <code>CNCF</code> 的开源项目，非常好用。</p>
</li>
<li>
<p>Tracing：<a href="http://opentracing.io/">OpenTracing</a> 和 <a href="https://www.jaegertracing.io/">Jaeger</a>，Jaeger 是 <code>Uber </code>开源的一个兼容 <code>OpenTracing</code> 标准的分布式追踪服务。目前 Jaeger 也加入了 <code>CNCF</code>。</p>
</li>
</ul>
<h2 id="原理">原理</h2>
<p>​	分布式追踪系统大体分为三个部分，数据采集、数据持久化、数据展示。数据采集是指在代码中埋点，设置请求中要上报的阶段，以及设置当前记录的阶段隶属于哪个上级阶段。数据持久化则是指将上报的数据落盘存储，例如 Jaeger 就支持多种存储后端，可选用 <code>Cassandra</code> 或者 <code>Elasticsearch</code>。数据展示则是前端根据 Trace ID 查询与之关联的请求阶段，并在界面上呈现。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/img/request-demonstration.o.png" alt="Request Demonstration"></p>
<p>上图是一个请求的流程例子，请求从客户端发出，到达负载均衡，再依次进行认证、计费，最后取到目标资源。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/img/opentracing-demonstration.o.png" alt="OpenTracing Demonstration"></p>
<p>请求过程被采集之后，会以上图的形式呈现，横坐标是时间，圆角矩形是请求的执行的各个阶段。</p>
<span id="more"></span>
<h2 id="发展历史">发展历史</h2>
<p>​	早在 2005 年，Google 就在内部部署了一套分布式追踪系统 Dapper，并发表了一篇论文<a href="https://ai.google/research/pubs/pub36356">《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》</a>，阐述了该分布式追踪系统的设计和实现，可以视为分布式追踪领域的鼻祖。随后出现了受此启发的开源实现，如 Zipkin、SourceGraph 开源的 Appdash、Red Hat 的 Hawkular APM、Uber 开源的 Jaeger 等。但各家的分布式追踪方案是互不兼容的，这才诞生了 OpenTracing。</p>
<p>​	OpenTracing 是一个 Library，定义了一套通用的数据上报接口，要求各个分布式追踪系统都来实现这套接口。这样一来，应用程序只需要对接 OpenTracing，而无需关心后端采用的到底什么分布式追踪系统，因此开发者可以无缝切换分布式追踪系统，也使得在通用代码库增加对分布式追踪的支持成为可能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/img/opentracing-diagram.o.png" alt="OpenTracing Diagram"></p>
<h3 id="数据模型">数据模型</h3>
<blockquote>
<p>a <strong>Trace</strong> can be thought of as a directed acyclic graph (DAG) of <strong>Spans</strong>。- Trace 是多个 Span 组成的有向非循环图。</p>
</blockquote>
<p>这部分在 OpenTracing 的规范中写的非常清楚，下面只大概翻译一下其中的关键部分，细节可参考原始文档 <a href="https://github.com/opentracing/specification/blob/master/specification.md">《The OpenTracing Semantic Specification》</a>。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Causal relationships between Spans in a single Trace</span><br><span class="line"></span><br><span class="line">        [Span A]  ←←←(the root span)</span><br><span class="line">            |</span><br><span class="line">     +------+------+</span><br><span class="line">     |             |</span><br><span class="line"> [Span B]      [Span C] ←←←(Span C is a `ChildOf` Span A)</span><br><span class="line">     |             |</span><br><span class="line"> [Span D]      +---+-------+</span><br><span class="line">               |           |</span><br><span class="line">           [Span E]    [Span F] &gt;&gt;&gt; [Span G] &gt;&gt;&gt; [Span H]</span><br><span class="line">                                       ↑</span><br><span class="line">                                       ↑</span><br><span class="line">                                       ↑</span><br><span class="line">                         (Span G `FollowsFrom` Span F)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Trace 是调用链，每个调用链由多个 Span 组成。Span 的单词含义是范围，可以理解为某个处理阶段。Span 和 Span 的关系称为 Reference。上图中，总共有标号为 A-H 的 8 个阶段。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Temporal relationships between Spans in a single Trace</span><br><span class="line"></span><br><span class="line">––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–&gt; time</span><br><span class="line"></span><br><span class="line"> [Span A···················································]</span><br><span class="line">   [Span B··············································]</span><br><span class="line">      [Span D··········································]</span><br><span class="line">    [Span C········································]</span><br><span class="line">         [Span E·······]        [Span F··] [Span G··] [Span H··]</span><br></pre></td></tr></table></figure>
<p>上图是按照时间顺序呈现的调用链。</p>
<p>每个阶段（Span）包含如下状态：</p>
<ul>
<li>操作名称</li>
<li>起始时间</li>
<li>结束时间</li>
<li>一组零或多个键:值结构的 <strong>Span标签</strong> ( span Tags)。键必须是字符串。值可以是字符串，布尔或数值类型.</li>
<li>一组零或多个 <strong>Span日志</strong> (span Logs)，其中每个都是一个键:值映射并与一个时间戳配对。键必须是字符串，值可以是任何类型。 并非所有的 OpenTracing 实现都必须支持每种值类型。</li>
<li>阶段上下文（SpanContext），其中包含 Trace ID 和 Span ID</li>
<li>引用关系（References）：零或多个因果相关的 <strong>Span</strong> 间的 <strong>References</strong> (通过那些相关的 <strong>Span</strong> 的 <strong>SpanContext</strong> )</li>
</ul>
<p>每个 <strong>SpanContext</strong> 封装了如下状态:</p>
<ul>
<li>任何需要跟跨进程 <strong>Span</strong> 关联的，依赖于 OpenTracing 实现的状态(例如 Trace 和 Span 的 id)</li>
<li>键:值结构的跨进程的 <strong>Baggage Items</strong>（区别于 span tag，baggage 是全局范围，在 span 间保持传递，而tag 是 span 内部，不会被子 span 继承使用。）</li>
</ul>
<p>​	阶段（Span）可以有 <code>ChildOf</code> 和 <code>FollowsFrom</code> 两种引用关系。<code>ChildOf</code> 用于表示父子关系，即在某个阶段中发生了另一个阶段，是最常见的阶段关系，典型的场景如调用 RPC 接口、执行 SQL、写数据。<code>FollowsFrom</code> 表示跟随关系，意为在某个阶段之后发生了另一个阶段，用来描述顺序执行关系。</p>
<h3 id="一个-Trace-的-json-案例">一个 Trace 的 json 案例</h3>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;traceID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;790e003e22209ca4&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;spans&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;traceID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;790e003e22209ca4&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;spanID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;790e003e22209ca4&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;flags&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;operationName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;say-hello&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;references&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;startTime&quot;</span><span class="punctuation">:</span> <span class="number">1611318627992154</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;duration&quot;</span><span class="punctuation">:</span> <span class="number">524139</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sampler.type&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;const&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sampler.param&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bool&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello-to&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This trace&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;internal.span.format&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;proto&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;logs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;processID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;p1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;warnings&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;traceID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;790e003e22209ca4&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;spanID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;d32970aca4d7a39b&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;flags&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;operationName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;format-string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;references&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;startTime&quot;</span><span class="punctuation">:</span> <span class="number">1611318628080551</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;duration&quot;</span><span class="punctuation">:</span> <span class="number">432791</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;span.kind&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;client&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http.method&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http.url&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://localhost:8081/api/format/This trace&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;internal.span.format&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;proto&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;logs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1611318628510535</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;event&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string.Format&quot;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello, This trace!&quot;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">]</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;processID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;p1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;warnings&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;traceID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;790e003e22209ca4&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;spanID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4b73f8e8e77fe9dc&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;flags&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;operationName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;print-hello&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;references&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;startTime&quot;</span><span class="punctuation">:</span> <span class="number">1611318628515966</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;duration&quot;</span><span class="punctuation">:</span> <span class="number">259</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;internal.span.format&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;proto&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;logs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1611318628516206</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;event&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WriteLine&quot;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">]</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;processID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;p1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;warnings&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;processes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;p1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;serviceName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello-world&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hostname&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Whuanle-PC&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ip&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.20.240.1&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaeger.version&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CSharp-0.4.2.0&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;warnings&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;errors&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="建议使用方式">建议使用方式</h2>
<p>​	首先假设某微服务已经有了中心化的日志收集和处理系统，如果还没有的话，强烈建议部署一套 ELK。再假设对于每一个请求，都会有一个贯穿整个请求流程的 Request ID，如果还没有的话，强烈建议加一个。以上准备完毕后，可以选取一个分布式追踪系统，集成到服务当中，建议采用 Jaeger。重点在最后，在 Trace 的起始处，将 Trace ID 设置为 Request ID，这么一来就打通了日志系统和分布式追踪系统，可以使用同一个 ID 查询请求的事件流和日志流，从此开启了上帝视角。</p>
<h2 id="具体使用">具体使用</h2>
<p>​	脱离分布式追踪系统单独讲 OpenTracing 的使用方法的话，意义不大，所以本文就不介绍具体的使用方法，之后会以 Jaeger 为例，解释如何给微服务增加分布式追踪，以及如何与现有的日志系统集合。</p>
<p>如果想简单了解一下使用方式，可参考 OpenTracing 的<a href="http://opentracing.io/documentation/pages/quick-start.html">《Quick Start》</a>。</p>
<h2 id="非入侵式">非入侵式</h2>
<p>​	除了通过修改应用程序代码增加分布式追踪之外，还有一种不需要修改代码的非入侵的方式，那就是 Service Mesh。Service Mesh 一般会被翻译成服务啮合层，它是在网络层面做文章，通过 Sidecar 的方式为 Pod 增加一层代理，通过这层网络代理来实现一些服务治理的功能，因为是工作在网络层面，可以做到跨语言、非入侵。<a href="https://istio.io/">Istio</a> 则是目前最成熟的 Service Mash 工具，支持启用分布式追踪服务。Istio 会修改微服务之间发送的网络请求，在请求中注入 Trace 和 Span 标记，再将采集到的数据发送到支持 OpenTracing 的分布式追踪服务中，从而拿到请求在微服务中的调用链。当然这种方式也有缺点，它无法追踪某个微服务内部的调用过程，并且目前阶段 Istio 只能追踪 HTTP 请求，能够覆盖的范围比较有限。如果想追踪更详细的数据，还是需要在中间件和代码中埋点，不过好在埋点的过程并不复杂，不会成为一个额外的负担。</p>
<h1>实战环节</h1>
<h3 id="opentelemetry-POC">opentelemetry POC</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;context&quot;</span></span><br><span class="line">  <span class="string">&quot;io&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">  <span class="string">&quot;os/signal&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;go.opentelemetry.io/otel&quot;</span></span><br><span class="line">  <span class="string">&quot;go.opentelemetry.io/otel/attribute&quot;</span></span><br><span class="line">  <span class="string">&quot;go.opentelemetry.io/otel/exporters/stdout/stdouttrace&quot;</span></span><br><span class="line">  <span class="string">&quot;go.opentelemetry.io/otel/sdk/resource&quot;</span></span><br><span class="line">  <span class="string">&quot;go.opentelemetry.io/otel/sdk/trace&quot;</span></span><br><span class="line">  semconv <span class="string">&quot;go.opentelemetry.io/otel/semconv/v1.4.0&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newExporter</span><span class="params">(w io.Writer)</span></span> (trace.SpanExporter, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> stdouttrace.New(</span><br><span class="line">    stdouttrace.WithWriter(w),</span><br><span class="line">    <span class="comment">// Use human-readable output.</span></span><br><span class="line">    stdouttrace.WithPrettyPrint(),</span><br><span class="line">    <span class="comment">// Do not print timestamps for the demo.</span></span><br><span class="line">    stdouttrace.WithoutTimestamps(),</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newResource</span><span class="params">()</span></span> *resource.Resource &#123;</span><br><span class="line">  r, _ := resource.Merge(</span><br><span class="line">    resource.Default(),</span><br><span class="line">    resource.NewWithAttributes(</span><br><span class="line">      semconv.SchemaURL,</span><br><span class="line">      semconv.ServiceNameKey.String(<span class="string">&quot;fib&quot;</span>),</span><br><span class="line">      semconv.ServiceVersionKey.String(<span class="string">&quot;v0.1.0&quot;</span>),</span><br><span class="line">      attribute.String(<span class="string">&quot;environment&quot;</span>, <span class="string">&quot;demo&quot;</span>),</span><br><span class="line">    ),</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  l := log.New(os.Stdout, <span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write telemetry data to a file.</span></span><br><span class="line">  f, err := os.Create(<span class="string">&quot;traces.txt&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    l.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">  exp, err := newExporter(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    l.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tp := trace.NewTracerProvider(</span><br><span class="line">    trace.WithBatcher(exp),</span><br><span class="line">    trace.WithResource(newResource()),</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := tp.Shutdown(context.Background()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      l.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  otel.SetTracerProvider(tp)</span><br><span class="line"></span><br><span class="line">  sigCh := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">  signal.Notify(sigCh, os.Interrupt)</span><br><span class="line"></span><br><span class="line">  errCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>)</span><br><span class="line">  app := NewApp(os.Stdin, l)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    errCh &lt;- app.Run(context.Background())</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-sigCh:</span><br><span class="line">    l.Println(<span class="string">&quot;\ngoodbye&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">case</span> err := &lt;-errCh:</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      l.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;context&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;io&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;go.opentelemetry.io/otel&quot;</span></span><br><span class="line">  <span class="string">&quot;go.opentelemetry.io/otel/attribute&quot;</span></span><br><span class="line">  <span class="string">&quot;go.opentelemetry.io/otel/codes&quot;</span></span><br><span class="line">  <span class="string">&quot;go.opentelemetry.io/otel/trace&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;fib&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">(n <span class="type">uint</span>)</span></span> (<span class="type">uint64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">uint64</span>(n), <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> n2, n1 <span class="type">uint64</span> = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="type">uint</span>(<span class="number">2</span>); i &lt; n; i++ &#123;</span><br><span class="line">    n2, n1 = n1, n1+n2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n1 + n2, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> App <span class="keyword">struct</span> &#123;</span><br><span class="line">  r io.Reader</span><br><span class="line">  l *log.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewApp</span><span class="params">(r io.Reader, l *log.Logger)</span></span> *App &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;App&#123;r, l&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span></span> Run(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// Each execution of the run loop, we should get a new &quot;root&quot; span and context.</span></span><br><span class="line">    newCtx, span := otel.Tracer(name).Start(ctx, <span class="string">&quot;Run&quot;</span>)</span><br><span class="line"></span><br><span class="line">    n, err := a.Poll(newCtx)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      span.End()</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    a.Write(newCtx, n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span></span> Poll(ctx context.Context) (<span class="type">uint</span>, <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">  _, span := otel.Tracer(name).Start(ctx, <span class="string">&quot;Poll&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">defer</span> span.End()</span><br><span class="line"></span><br><span class="line">  a.l.Print(<span class="string">&quot;What Fibonacci number would you like to konw: &quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> n <span class="type">uint</span></span><br><span class="line">  _, err := fmt.Fscanf(a.r, <span class="string">&quot;%d\n&quot;</span>, &amp;n)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Store n as a string to not overflow an int64.</span></span><br><span class="line">  nStr := strconv.FormatUint(<span class="type">uint64</span>(n), <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">  span.SetAttributes(attribute.String(<span class="string">&quot;request.n&quot;</span>, nStr))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span></span> Write(ctx context.Context, n <span class="type">uint</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> span trace.Span</span><br><span class="line">  ctx, span = otel.Tracer(name).Start(ctx, <span class="string">&quot;Poll&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> span.End()</span><br><span class="line"></span><br><span class="line">  f, err := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> (<span class="type">uint64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    _, span := otel.Tracer(name).Start(ctx, <span class="string">&quot;Fibonacci&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> span.End()</span><br><span class="line">    f, err := Fibonacci(n)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      span.RecordError(err)</span><br><span class="line">      span.SetStatus(codes.Error, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f, err</span><br><span class="line">  &#125;(ctx)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    a.l.Printf(<span class="string">&quot;Fibonacci(%d): %v\n&quot;</span>, n, err)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    a.l.Printf(<span class="string">&quot;Fibonacci(%d)= %d\n&quot;</span>, n, f)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Jaeger-安装">Jaeger 安装</h2>
<ul>
<li>docker-compose 文件安装</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:7.14.2</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic-jaeger</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;127.0.0.1:9200:9200&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;127.0.0.1:9300:9300&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">on-failure</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=jaeger-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.type=single-node</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http.host=0.0.0.0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">transport.host=127.0.0.1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ES_JAVA_OPTS=-Xms512m</span> <span class="string">-Xmx512m</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">xpack.security.enabled=false</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">E:\data\es:/usr/share/elasticsearch/data</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">jaeger-collector:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jaegertracing/jaeger-collector</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;14269:14269&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;14268:14268&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;14267:14267&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9411:9411&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic-jaeger</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">on-failure</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPAN_STORAGE_TYPE=elasticsearch</span></span><br><span class="line">    <span class="attr">command:</span> [</span><br><span class="line">      <span class="string">&quot;--es.server-urls=http://elasticsearch:9200&quot;</span>,</span><br><span class="line">      <span class="string">&quot;--es.num-shards=1&quot;</span>,</span><br><span class="line">      <span class="string">&quot;--es.num-replicas=0&quot;</span>,</span><br><span class="line">      <span class="string">&quot;--log-level=error&quot;</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">jaeger-agent:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jaegertracing/jaeger-agent</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">jaeger-agent</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;--reporter.grpc.host-port=jaeger-collector:14267&quot;</span>]</span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5775:5775/udp&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6831:6831/udp&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6832:6832/udp&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5778:5778&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic-jaeger</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">on-failure</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPAN_STORAGE_TYPE=elasticsearch</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">jaeger-collector</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">jaeger-query:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jaegertracing/jaeger-query</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPAN_STORAGE_TYPE=elasticsearch</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">no_proxy=localhost</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;16686:16686&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;16687:16687&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic-jaeger</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">on-failure</span></span><br><span class="line">    <span class="attr">command:</span> [</span><br><span class="line">      <span class="string">&quot;--es.server-urls=http://elasticsearch:9200&quot;</span>,</span><br><span class="line">      <span class="string">&quot;--span-storage.type=elasticsearch&quot;</span>,</span><br><span class="line">      <span class="string">&quot;--log-level=debug&quot;</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">jaeger-agent</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">esdata:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">elastic-jaeger:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>
<h2 id="http和grpc中使用-Jaeger">http和grpc中使用 Jaeger</h2>
<h2 id="1-Gin">1. Gin</h2>
<p>通过 Middleware 可以追踪到最外层的 Handler，更深层方法需要追踪的话可以通过<code>ctx</code>将<code>span</code>传递到各个方法中去进一步追踪。</p>
<p>http 请求使用 request.Header 做载体。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;context&quot;</span></span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">  <span class="string">&quot;github.com/opentracing/opentracing-go&quot;</span></span><br><span class="line">  <span class="string">&quot;github.com/opentracing/opentracing-go/ext&quot;</span></span><br><span class="line">  <span class="string">&quot;i-go/apm/trace/config&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Jaeger 通过 middleware 将 tracer 和 ctx 注入到 gin.Context 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Jaeger</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> parentSpan opentracing.Span</span><br><span class="line">    tracer, closer := config.NewTracer(<span class="string">&quot;gin-demo&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> closer.Close()</span><br><span class="line">    <span class="comment">// 直接从 c.Request.Header 中提取 span,如果没有就新建一个</span></span><br><span class="line">    spCtx, err := opentracing.GlobalTracer().Extract(opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(c.Request.Header))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      parentSpan = tracer.StartSpan(c.Request.URL.Path)</span><br><span class="line">      <span class="keyword">defer</span> parentSpan.Finish()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parentSpan = opentracing.StartSpan(</span><br><span class="line">        c.Request.URL.Path,</span><br><span class="line">        opentracing.ChildOf(spCtx),</span><br><span class="line">        opentracing.Tag&#123;Key: <span class="type">string</span>(ext.Component), Value: <span class="string">&quot;HTTP&quot;</span>&#125;,</span><br><span class="line">        ext.SpanKindRPCServer,</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">defer</span> parentSpan.Finish()</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 然后存到 g.ctx 中 供后续使用</span></span><br><span class="line">    c.Set(<span class="string">&quot;tracer&quot;</span>, tracer)</span><br><span class="line">    c.Set(<span class="string">&quot;ctx&quot;</span>, opentracing.ContextWithSpan(context.Background(), parentSpan))</span><br><span class="line">    c.Next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 gin 中添加这个 middleware 即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">e := gin.New() e.Use(middleware.Jaeger()) </span><br></pre></td></tr></table></figure>
<p>需要更细粒度的追踪，只需要将 span 传递到各个方法即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(e *gin.Engine)</span></span> &#123;</span><br><span class="line">  e.GET(<span class="string">&quot;/ping&quot;</span>, Ping)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ping</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  psc, _ := c.Get(<span class="string">&quot;ctx&quot;</span>)</span><br><span class="line">  ctx := psc.(context.Context)</span><br><span class="line">  doPing1(ctx)</span><br><span class="line">  doPing2(ctx)</span><br><span class="line">  c.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doPing1</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">  span, _ := opentracing.StartSpanFromContext(ctx, <span class="string">&quot;doPing1&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> span.Finish()</span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">  fmt.Println(<span class="string">&quot;pong&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doPing2</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">  span, _ := opentracing.StartSpanFromContext(ctx, <span class="string">&quot;doPing2&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> span.Finish()</span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">  fmt.Println(<span class="string">&quot;pong&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-gRPC">2. gRPC</h2>
<p>追踪 gRPC 则通过拦截器实现。</p>
<ul>
<li>这里使用使用 gRPC 的metadata 来做载体。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ClientInterceptor</span><span class="params">(tracer opentracing.Tracer)</span></span> grpc.UnaryClientInterceptor &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, method <span class="type">string</span>, req, reply <span class="keyword">interface</span>&#123;&#125;, cc *grpc.ClientConn,</span></span></span><br><span class="line"><span class="params"><span class="function">    invoker grpc.UnaryInvoker, opts ...grpc.CallOption)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    span, _ := opentracing.StartSpanFromContext(ctx,</span><br><span class="line">      <span class="string">&quot;call gRPC&quot;</span>,</span><br><span class="line">      opentracing.Tag&#123;Key: <span class="type">string</span>(ext.Component), Value: <span class="string">&quot;gRPC&quot;</span>&#125;,</span><br><span class="line">      ext.SpanKindRPCClient)</span><br><span class="line">    <span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line">    md, ok := metadata.FromOutgoingContext(ctx)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      md = metadata.New(<span class="literal">nil</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      md = md.Copy()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err := tracer.Inject(span.Context(), opentracing.TextMap, MDReaderWriter&#123;md&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      span.LogFields(log.String(<span class="string">&quot;inject-error&quot;</span>, err.Error()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newCtx := metadata.NewOutgoingContext(ctx, md)</span><br><span class="line">    err = invoker(newCtx, method, req, reply, cc, opts...)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      span.LogFields(log.String(<span class="string">&quot;call-error&quot;</span>, err.Error()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServerInterceptor</span><span class="params">(tracer opentracing.Tracer)</span></span> grpc.UnaryServerInterceptor &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (</span><br><span class="line">    resp <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) &#123;</span><br><span class="line">    md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      md = metadata.New(<span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 服务端拦截器则是在MD中把 span提取出来</span></span><br><span class="line">    spanContext, err := tracer.Extract(opentracing.TextMap, MDReaderWriter&#123;md&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != opentracing.ErrSpanContextNotFound &#123;</span><br><span class="line">      fmt.Print(<span class="string">&quot;extract from metadata error: &quot;</span>, err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      span := tracer.StartSpan(</span><br><span class="line">        info.FullMethod,</span><br><span class="line">        ext.RPCServerOption(spanContext),</span><br><span class="line">        opentracing.Tag&#123;Key: <span class="type">string</span>(ext.Component), Value: <span class="string">&quot;gRPC&quot;</span>&#125;,</span><br><span class="line">        ext.SpanKindRPCServer,</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">defer</span> span.Finish()</span><br><span class="line">      ctx = opentracing.ContextWithSpan(ctx, span)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MDReaderWriter 结构如下</p>
<blockquote>
<p>为了做载体，必须要实现 <code>opentracing.TextMapWriter</code> <code>opentracing.TextMapReader</code> 这两个接口。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TextMapWriter is the Inject() carrier for the TextMap builtin format.With</span></span><br><span class="line"><span class="comment">// it, the caller can encode a SpanContext for propagation as entries in a map</span></span><br><span class="line"><span class="comment">// of unicode strings.</span></span><br><span class="line"><span class="keyword">type</span> TextMapWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">   Set(key, val <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TextMapReader is the Extract() carrier for the TextMap builtin format. With it,</span></span><br><span class="line"><span class="comment">// the caller can decode a propagated SpanContext as entries in a map of</span></span><br><span class="line"><span class="comment">// unicode strings.</span></span><br><span class="line"><span class="keyword">type</span> TextMapReader <span class="keyword">interface</span> &#123;</span><br><span class="line">   ForeachKey(handler <span class="function"><span class="keyword">func</span><span class="params">(key, val <span class="type">string</span>)</span></span> <span class="type">error</span>) <span class="type">error</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// tracer</span></span><br><span class="line">  tracer, closer := config.NewTracer(<span class="string">&quot;gRPC-hello&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> closer.Close()</span><br><span class="line"></span><br><span class="line">  ctx, cancel := context.WithTimeout(context.Background(), time.Second*<span class="number">5</span>)</span><br><span class="line">  <span class="keyword">defer</span> cancel()</span><br><span class="line">  <span class="comment">// conn</span></span><br><span class="line">  conn, err := grpc.DialContext(</span><br><span class="line">    ctx,</span><br><span class="line">    <span class="string">&quot;localhost:50051&quot;</span>,</span><br><span class="line">    grpc.WithInsecure(),</span><br><span class="line">    grpc.WithBlock(),</span><br><span class="line">    grpc.WithUnaryInterceptor(</span><br><span class="line">      grpcMiddleware.ChainUnaryClient(</span><br><span class="line">        interceptor.ClientInterceptor(tracer),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;grpc conn err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  client := proto.NewHelloClient(conn)</span><br><span class="line">  r, err := client.SayHello(context.Background(), &amp;proto.HelloReq&#123;Name: <span class="string">&quot;xiaoming&quot;</span>&#125;)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;could not greet: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  log.Printf(<span class="string">&quot;Greeting: %s&quot;</span>, r.Message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后建立连接或者启动服务的时候把拦截器添加上即可</p>
<p><strong>建立连接</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// tracer</span></span><br><span class="line">  tracer, closer := config.NewTracer(<span class="string">&quot;gRPC-hello&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> closer.Close()</span><br><span class="line"></span><br><span class="line">  ctx, cancel := context.WithTimeout(context.Background(), time.Second*<span class="number">5</span>)</span><br><span class="line">  <span class="keyword">defer</span> cancel()</span><br><span class="line">  <span class="comment">// conn</span></span><br><span class="line">  conn, err := grpc.DialContext(</span><br><span class="line">    ctx,</span><br><span class="line">    <span class="string">&quot;localhost:50051&quot;</span>,</span><br><span class="line">    grpc.WithInsecure(),</span><br><span class="line">    grpc.WithBlock(),</span><br><span class="line">    grpc.WithUnaryInterceptor(</span><br><span class="line">      grpcMiddleware.ChainUnaryClient(</span><br><span class="line">        interceptor.ClientInterceptor(tracer),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;grpc conn err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  client := proto.NewHelloClient(conn)</span><br><span class="line">  r, err := client.SayHello(context.Background(), &amp;proto.HelloReq&#123;Name: <span class="string">&quot;xiaoming&quot;</span>&#125;)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;could not greet: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  log.Printf(<span class="string">&quot;Greeting: %s&quot;</span>, r.Message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>启动服务</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;50051&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  tracer, closer := config.NewTracer(<span class="string">&quot;gRPC-hello&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> closer.Close()</span><br><span class="line">  <span class="comment">// UnaryInterceptor</span></span><br><span class="line">  s := grpc.NewServer(grpc.UnaryInterceptor(</span><br><span class="line">    grpc_middleware.ChainUnaryServer(</span><br><span class="line">      interceptor.ServerInterceptor(tracer),</span><br><span class="line">    ),</span><br><span class="line">  ))</span><br><span class="line">  proto.RegisterHelloServer(s, &amp;helloServer&#123;&#125;)</span><br><span class="line">  <span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>参考文章</h1>
<ul>
<li>
<p><a href="https://www.lixueduan.com/posts/tracing/04-jaeger-gin-grpc/">https://www.lixueduan.com/posts/tracing/04-jaeger-gin-grpc/</a></p>
</li>
<li>
<p><a href="https://pjw.io/articles/2018/05/08/opentracing-explanations/#section-3">https://pjw.io/articles/2018/05/08/opentracing-explanations/#section-3</a></p>
</li>
<li>
<p><a href="https://wu-sheng.gitbooks.io/opentracing-io/content/">https://wu-sheng.gitbooks.io/opentracing-io/content/</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/479209788">https://zhuanlan.zhihu.com/p/479209788</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>CloudNative</category>
      </categories>
      <tags>
        <tag>open tracing</tag>
      </tags>
  </entry>
  <entry>
    <title>go get 私有库解决方案</title>
    <url>/2023/02/06/golang%20go%20get%20%E7%A7%81%E6%9C%89%E5%BA%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1>golang go get 私有库解决方案</h1>
<blockquote>
<p>注意：go get 只支持 https协议的库路径 :bangbang:</p>
</blockquote>
<h2 id="前言">前言</h2>
<p>​		在我们开发过程中会自己封装一些工具库，在某个项目中使用。但是如果有别的项目想使用你封装的库，那么此时你就需要将工具库封装为一个<code>go module</code>，给其它项目导入。一般公司内部的库是不对外开放的，这时候就需要搭建代理去拉取私有仓库</p>
<h2 id="原理架构图">原理架构图</h2>
<p><img src="https://tonybai.com/wp-content/uploads/the-approach-to-go-get-private-go-module-in-house-9.png" alt="img"></p>
<span id="more"></span>
<h2 id="准备工作">准备工作</h2>
<h3 id="nginx-搭建">nginx 搭建</h3>
<p>​		详细安装教程可以参考这篇：<a href="https://blog.csdn.net/t8116189520/article/details/81909574">https://blog.csdn.net/t8116189520/article/details/81909574</a></p>
<p><code>nginx</code> 配置文件</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  <span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> xxx.xxx.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>           /etc/nginx/ssl/xxx.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>       /etc/nginx/ssl/xxx.key;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ssl验证相关配置</span></span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">5m</span>;    <span class="comment"># 缓存有效期</span></span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    <span class="comment">#加密算法</span></span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;    <span class="comment"># 安全链接可选的加密协议</span></span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;   <span class="comment"># 使用服务器端的首选算法</span></span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;</span><br><span class="line">      <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h3 id="govanityurls-配置"><a href="https://github.com/bigwhite/govanityurls">govanityurls</a> 配置</h3>
<blockquote>
<p>Use a custom domain in your Go import path</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go install github.com/Lucareful/govanityurls@v1.0.3   # 我封装了一些，匹配全路由</span><br></pre></td></tr></table></figure>
<h4 id="编辑-vanity-yaml文件">编辑 <code>vanity.yaml</code>文件</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代理路由匹配的前缀</span></span><br><span class="line"><span class="string">/xxx/xxx:</span></span><br><span class="line">      <span class="attr">repo:</span> <span class="string">https://真实的私有仓库地址</span></span><br><span class="line">      <span class="attr">vsc:</span> <span class="string">git</span></span><br></pre></td></tr></table></figure>
<h4 id="设置-govanityurls-为守护进程启动">设置 govanityurls 为守护进程启动</h4>
<h5 id="systemd">systemd</h5>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建服务文件 /etc/systemd/system/vanity.service</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件内容</span></span><br><span class="line">[<span class="string">Unit</span>]</span><br><span class="line"><span class="string">Description=</span> <span class="string">Custom</span> <span class="string">domain</span> <span class="string">in</span> <span class="string">your</span> <span class="string">Go</span> <span class="string">import</span> <span class="string">path</span></span><br><span class="line"><span class="string">After=network.target</span></span><br><span class="line"></span><br><span class="line">[<span class="string">Service</span>]</span><br><span class="line"><span class="string">Type=simple</span></span><br><span class="line"><span class="string">WorkingDirectory=/root/govanityurls/</span>             <span class="comment"># vanity.yaml 文件存放的路径</span></span><br><span class="line"><span class="string">ExecStart=/home/gopath/bin/govanityurls</span> <span class="string">-host</span> <span class="string">xxxx.xxx.com(nginx代理的域名)</span></span><br><span class="line"><span class="string">Restart=always</span></span><br><span class="line"></span><br><span class="line">[<span class="string">Install</span>]</span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br></pre></td></tr></table></figure>
<h5 id="supervisord">supervisord</h5>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[program:govanityurls]</span></span><br><span class="line"><span class="attr">directory</span> = /root/govanityurls              <span class="comment"># vanity.yaml 文件存放的路径</span></span><br><span class="line"><span class="attr">command</span> = /home/gopath/bin/govanityurls -host xxxx.xxx.com(nginx代理的域名)</span><br><span class="line"><span class="attr">autostart</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">startsecs</span> = <span class="number">5</span></span><br><span class="line"><span class="attr">autorestart</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">startretries</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">user</span> = root</span><br><span class="line"><span class="attr">redirect_stderr</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span> = <span class="number">20</span>MB</span><br><span class="line"><span class="attr">stdout_logfile_backups</span> = <span class="number">20</span></span><br><span class="line"><span class="attr">stopasgroup</span>=<span class="literal">false</span></span><br><span class="line"><span class="attr">killasgroup</span>=<span class="literal">false</span></span><br><span class="line"><span class="attr">stdout_logfile</span> = /root/log/go.log</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>​	上面的架构设计中参照了tonybai<a href="https://tonybai.com/2021/09/03/the-approach-to-go-get-private-go-module-in-house/">小厂内部私有go模块拉取方案</a>，我在此省略了了goproxy的搭建，只为私有库搭建了一个代理，公有库从公共module获取即可。</p>
<p><img src="https://tonybai.com/wp-content/uploads/the-approach-to-go-get-private-go-module-in-house-7.png" alt="img"></p>
<h1>参考资料</h1>
<ul>
<li><a href="https://tonybai.com/2021/09/03/the-approach-to-go-get-private-go-module-in-house/">小厂内部私有Go module拉取方案</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html">systemd 实战教程</a></li>
<li><a href="https://denyu95.github.io/2019/04/29/%E5%AE%9A%E5%88%B6go-get%E7%9A%84%E5%8C%85%E8%B7%AF%E5%BE%84/">定制go get的包路径</a></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>go module</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang Sync.Once 的探究</title>
    <url>/2023/02/06/Sync.Once%20%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="sync-Once-的用法"><code>sync.Once</code> 的用法</h2>
<p>​    在多数情况下，<code>sync.Once</code> 被用于控制变量的初始化，这个变量的读写通常遵循单例模式，满足这三个条件：</p>
<ul>
<li>当且仅当第一次读某个变量时，进行初始化（写操作）</li>
<li>变量被初始化过程中，所有读都被阻塞（读操作；当变量初始化完成后，读操作继续进行）</li>
<li>变量仅初始化一次，初始化完成后驻留在内存里</li>
</ul>
<h3 id="实例化一次客户端">实例化一次客户端</h3>
<p>​	在标准库中不乏有大量 <code>sync.Once</code> 的使用案例，在 <code>strings</code> 包中 <code>replace.go</code> 里实现字符串批量替换功能时，需要预编译生成替换规则，即采用不同的替换算法并创建相关算法实例，因 <code>strings.Replacer</code> 实现是线程安全且支持规则复用，在第一次解析替换规则并创建对应算法实例后，可以并发的进行字符串替换操作，避免多次解析替换规则浪费资源。</p>
<p>先看一下 <code>strings.Replacer</code> 的结构定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// source: strings/replace.go</span></span><br><span class="line"><span class="keyword">type</span> Replacer <span class="keyword">struct</span> &#123;</span><br><span class="line">  once   sync.Once <span class="comment">// guards buildOnce method</span></span><br><span class="line">  r      replacer</span><br><span class="line">  oldnew []<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	这里定义了 <code>once sync.Once</code> 用来控制 <code>r replacer</code> 替换算法初始化，当我们使用 <code>strings.NewReplacer</code> 创建 <code>strings.Replacer</code> 时，这里采用惰性算法，并没有在这时进行 <code>build</code> 解析替换规则并创建对应算法实例，而是在执行替换时( <code>Replacer.Replace</code> 和 <code>Replacer.WriteString</code>)进行的, <code>r.once.Do(r.buildOnce)</code> 使用 <code>sync.Once</code> 的 <code>Do</code> 方法保证只有在首次执行时才会执行 <code>buildOnce</code> 方法，而在 <code>buildOnce</code> 中调用 <code>build</code> 解析替换规则并创建对应算法实例，在 <code>buildOnce</code> 中进行赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// source: strings/replace.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReplacer</span><span class="params">(oldnew ...<span class="type">string</span>)</span></span> *Replacer &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(oldnew)%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;strings.NewReplacer: odd argument count&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;Replacer&#123;oldnew: <span class="built_in">append</span>([]<span class="type">string</span>(<span class="literal">nil</span>), oldnew...)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replacer)</span></span> buildOnce() &#123;</span><br><span class="line">  r.r = r.build()</span><br><span class="line">  r.oldnew = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Replacer)</span></span> build() replacer &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replacer)</span></span> Replace(s <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  r.once.Do(r.buildOnce)</span><br><span class="line">  <span class="keyword">return</span> r.r.Replace(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replacer)</span></span> WriteString(w io.Writer, s <span class="type">string</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">  r.once.Do(r.buildOnce)</span><br><span class="line">  <span class="keyword">return</span> r.r.WriteString(w, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	简单来说，<code>once.Do</code> 中的函数只会执行一次，并保证 <code>once.Do</code> 返回时，传入 <code>Do</code> 的函数已经执行完成。多个 <code>goroutine</code> 同时执行 <code>once.Do</code> 的时候，可以保证抢占到 <code>once.Do</code> 执行权的 <code>goroutine</code> 执行完 <code>once.Do</code> 后，其他 <code>goroutine</code> 才能得到返回。</p>
<p>​	<strong><code>once.Do</code> 接收一个函数作为参数，该函数不接受任何参数，不返回任何参数。具体做什么由使用方决定，错误处理也由使用方控制，对函数初始化的结果也由使用方进行保存</strong>。</p>
<span id="more"></span>
<h3 id="资源清理退出">资源清理退出</h3>
<p>​	一种错误处理的例子 <code>exec.closeOnce</code>，<code>exec.closeOnce</code> 保证了重复关闭文件，永远只执行一次，并且总是返回首次关闭产生的错误信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// source: os/exec/exec.go</span></span><br><span class="line"><span class="keyword">type</span> closeOnce <span class="keyword">struct</span> &#123;</span><br><span class="line">  *os.File</span><br><span class="line"></span><br><span class="line">  once sync.Once</span><br><span class="line">  err  <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *closeOnce)</span></span> Close() <span class="type">error</span> &#123;</span><br><span class="line">  c.once.Do(c.<span class="built_in">close</span>)</span><br><span class="line">  <span class="keyword">return</span> c.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *closeOnce)</span></span> <span class="built_in">close</span>() &#123;</span><br><span class="line">  c.err = c.File.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="nsq的停止">nsq的停止</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// source: apps/nsqd/main.go</span></span><br><span class="line"><span class="keyword">type</span> program <span class="keyword">struct</span> &#123;</span><br><span class="line">  once sync.Once</span><br><span class="line">  nsqd *nsqd.NSQD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  prg := &amp;program&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> err := svc.Run(prg, syscall.SIGINT, syscall.SIGTERM); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logFatal(<span class="string">&quot;%s&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *program)</span></span> Stop() <span class="type">error</span> &#123;</span><br><span class="line">  p.once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.nsqd.Exit()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="常见的单例模式">常见的单例模式</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   onceHost  sync.Once</span><br><span class="line">   hostQueue *mq.PubSub</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getHostInstance</span><span class="params">()</span></span> *mq.PubSub &#123;</span><br><span class="line"></span><br><span class="line">   onceHost.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"></span><br><span class="line">      hostQueue, err = mq.NewPubSub(context.Background())</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Error(err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> hostQueue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>参考链接</h1>
<ul>
<li><a href="https://blog.thinkeridea.com/202101/go/exsync/once.html">https://blog.thinkeridea.com/202101/go/exsync/once.html</a></li>
<li><a href="https://github.com/nsqio/nsq/blob/master/apps/nsqd/main.go">https://github.com/nsqio/nsq/blob/master/apps/nsqd/main.go</a></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>once</tag>
      </tags>
  </entry>
  <entry>
    <title>服务配置和热更新</title>
    <url>/2023/02/06/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%92%8C%E7%83%AD%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h1>程序配置服务和热更新</h1>
<h2 id="前言">前言</h2>
<p>​	在开发过程中，因为不同环境中有不同的配置，所以往往一个项目要同时保存着不同环境的配置文件（<code>dev</code>，<code>test</code>，<code>staging</code>，<code>prd</code>）等。如果没有一个方便简洁的管理这些配置文件方式，排查问题也会变的麻烦。接下来介绍几种我所经历的几种配置文件管理方案</p>
<h2 id="git-分支管理">git 分支管理</h2>
<p>​	顾名思义就是利用 <code>git</code> 的分支来管理不同环境的配置，比如<code>dev</code>分支就是对应存放这<code>dev</code>的配置文件。</p>
<h3 id="优点">优点</h3>
<ul>
<li>分支管理更符合开发的代码习惯，只关心本分支的代码和配置</li>
</ul>
<h3 id="缺点">缺点</h3>
<ul>
<li>不符合<code>git-flow</code>流程，如果<code>test</code>配置有改动，那么就要直接编辑<code>test</code>分支代码，而不是从<code>dev</code>分支合并过去。排查配置相关问题不友善</li>
<li>一份配置文件就一个分支，维护代价太大，有些舍本琢末了。</li>
</ul>
<h3 id="热更新方案无">热更新方案无</h3>
<h2 id="所有配置文件都放在项目下">所有配置文件都放在项目下</h2>
<p>​	这种方式就是把所有的配置文件集中放在项目下的某个目录，用环境变量的方式去加载指定的配置文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> env&#123;</span><br><span class="line">        <span class="keyword">case</span>:<span class="string">&quot;dev&quot;</span>:</span><br><span class="line">        load(<span class="string">&quot;dev.config&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span>:<span class="string">&quot;test&quot;</span>:</span><br><span class="line">        load(<span class="string">&quot;test.config&quot;</span>)</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        load(<span class="string">&quot;local.config&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优点-2">优点</h3>
<ul>
<li>配置统一集中管理，修改方便</li>
</ul>
<h3 id="缺点-2">缺点</h3>
<ul>
<li>配置文件过多容易使项目结构变的“难看”，判断依赖过多，不优雅。</li>
<li>无法做到热更新，配置更改需要重新发布代码</li>
</ul>
<h3 id="热更新方案无-2">热更新方案无</h3>
<h2 id="配置中心">配置中心</h2>
<p>​	将配置文件都放到三方的服务中保管，比如<code>nacos</code>、<code>Apollo</code>等配置中心</p>
<ul>
<li>nacos：<a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">https://nacos.io/zh-cn/docs/what-is-nacos.html</a></li>
<li>Apollo：<a href="https://www.apolloconfig.com/#/zh/README">https://www.apolloconfig.com/#/zh/README</a></li>
</ul>
<h3 id="优点-3">优点</h3>
<ul>
<li>集中化管理配置，配置文件“不落地”</li>
<li>有相关 <code>sdk</code> 调用，支持热更新等高级功能</li>
</ul>
<h3 id="缺点-3">缺点</h3>
<ul>
<li>要维护一个高可用的 三方服务 增加了维护成本</li>
</ul>
<h3 id="热更新方案">热更新方案</h3>
<ul>
<li>需要另外编码去开发</li>
</ul>
<span id="more"></span>
<h2 id="云原生方式管理-推荐">云原生方式管理(推荐)</h2>
<p>​	将应用配置和密匙等文件交由<code>k8s</code>的<code>configMap</code>、<code>secret</code>来管理，容器启动时候，直接将<code>configMap</code>、<code>secret</code>挂载进<code>pod</code>即可使用</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">my-nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">harbor-001.jimmysong.io/library/nginx:1.9</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/config</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">          <span class="attr">configMap:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">special-config</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">special-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">log_level:</span> <span class="string">INFO</span></span><br></pre></td></tr></table></figure>
<h3 id="相关资料连接">相关资料连接</h3>
<ul>
<li>
<p><code>pod </code>挂载 <code>configMap</code>：<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/">https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/</a></p>
</li>
<li>
<p><code>configMap</code> 挂载后热更新实验：<a href="https://jimmysong.io/kubernetes-handbook/concepts/configmap-hot-update.html">https://jimmysong.io/kubernetes-handbook/concepts/configmap-hot-update.html</a></p>
</li>
<li>
<p>将多个<code>secret</code>或<code>configMap</code>挂载到一个目录下：<a href="https://stackoverflow.com/questions/59855142/use-a-single-volume-to-mount-multiple-files-from-secrets-or-configmaps">https://stackoverflow.com/questions/59855142/use-a-single-volume-to-mount-multiple-files-from-secrets-or-configmaps</a></p>
</li>
</ul>
<h3 id="热更新方案-2">热更新方案</h3>
<p>采用一个三方插件监控 <code>secret</code>和<code>configMap</code>变动，如果有变动，则更新<code>pod</code>做到热更新</p>
<ul>
<li><a href="https://github.com/stakater/Reloader">https://github.com/stakater/Reloader</a></li>
</ul>
<h1>总结</h1>
<p>​	以上几种方式都是笔者个人开发中所使用或经历过的，对于一般的传统小型程序采用git或者都放入一个项目下即可，如果是公司的业务都上云了，服务都在<code>k8s</code>中那么最后一种云原生的管理方式是我个人比较推荐的。</p>
]]></content>
      <categories>
        <category>架构思考</category>
      </categories>
      <tags>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 变量声明指南</title>
    <url>/2023/02/06/%E6%B5%85%E6%9E%90%20Golang,make,new,=,var%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1>golang var、:=、new、make区别及使用</h1>
<p>​    go里面的几大变量“类型”(不严谨，只是个人在使用的时候常用到的结构的一个划分)</p>
<ul>
<li>（1） 值类型：<code> int</code>， <code>string</code>， <code>struct</code> 等</li>
<li>（2） 引用类型：主要是 <code>map</code>, <code>slice</code>,<code>chan</code> 这三个引用（<code>make</code>创建内存的）</li>
<li>（3）指针类型：<code>*int64</code>， <code>*struct</code>等</li>
</ul>
<h2 id="var-vs"><code>var</code> vs <code>:=</code></h2>
<p>​	对于值类型的变量，我们通过var 声明(包括结构体)，系统会默认为他分配内存空间，并赋该类型的零值。</p>
<p>如下，我们声明一个int类型变量i，输出为0。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">fmt.Println(i) <span class="comment">// i = 0 (类型零值)</span></span><br></pre></td></tr></table></figure>
<p><code>var</code>和<code>:=</code>之间实际上存在差异，<strong>采用<code>:=</code>允许重新声明变量</strong>。</p>
<blockquote>
<p>与常规变量声明不同，<code>:=</code>声明可以重新声明变量，前提是它们最初在同一块中以相同类型声明，并且至少有一个非空白变量是新的。因此，重新声明只能出现在多变量短声明中。</p>
<p>重新声明不引入新变量；它只是为原始值分配一个新值。</p>
</blockquote>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">field1, offset := nextField(str, <span class="number">0</span>)</span><br><span class="line">field2, offset := nextField(str, offset)  <span class="comment">// 重新声明偏移量(可重入)</span></span><br><span class="line"></span><br><span class="line">a, a := <span class="number">1</span>, <span class="number">2</span>                              <span class="comment">// 非法：如果在别处声明了 a，则双重声明 a 或没有新变量</span></span><br></pre></td></tr></table></figure>
<p>所以我会说<code>:=</code>运算符不是纯粹的声明，而是更像声明和分配。不允许在顶层重新声明，因此也不允许短声明。另一个原因可能是语法简单。<code>type</code>在 Go 中，所有顶级表单都以<code>var</code> 或 <code>func</code> 开头。</p>
<blockquote>
<p>建议：重复声明的变量用 <code>:=</code>，比如 err 的声明，使用的值或全局变量（不推荐大量使用）用 var， 如 var fields []string</p>
</blockquote>
<span id="more"></span>
<h2 id="new函数"><strong>new函数</strong></h2>
<p>来看一下new函数的签名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span></span>*Type</span><br></pre></td></tr></table></figure>
<p>​	它只接受一个参数，这个参数是一个类型，分配好内存后，返回一个指向该类型内存地址的指针。同时把分配的内存置为零，也就是类型的零值。但是实际在工程使用中，通常是直接声明指针使用，不需要 new 操作。</p>
<p>如果我们声明一个指针类型的变量，系统不会为他分配内存，默认就是<code>nil</code>。此时如果你想直接使用，那么系统会抛异常。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> j *<span class="type">int</span></span><br><span class="line">fmt.Println(j)</span><br><span class="line">*j = <span class="number">10</span>  <span class="comment">//invalid memory address or nil pointer dereference</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也就是说，空指针还没有内存分配，是不能使用的。那么要想使用，此时就需要new出场啦。</span></span><br><span class="line"><span class="keyword">var</span> j *<span class="type">int</span></span><br><span class="line">j = <span class="built_in">new</span>(<span class="type">int</span>)  <span class="comment">// 让j里面的内容指向一块分配好的内存地址，地址里面设置int的零值：0</span></span><br><span class="line">fmt.Println(j)</span><br><span class="line">fmt.Println(*j)</span><br><span class="line">*j = <span class="number">10</span></span><br><span class="line">fmt.Println(*j)</span><br><span class="line"><span class="comment">// 声明指针类型变量后，通过new为他分配内存，有了内存空间，这个变量就可以自由的使用了。</span></span><br></pre></td></tr></table></figure>
<h2 id="Make函数"><strong>Make函数</strong></h2>
<blockquote>
<p><code>make</code>和<code>new</code>不同，<code>make</code> 用于 <code>map</code>, <code>slice</code>,<code>chan</code> 的内存创建，因为他们三个是引用类型，直接返回这三个类型本身。</p>
</blockquote>
<p>make签名是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span></span> Type</span><br></pre></td></tr></table></figure>
<p>make 是<strong>分配内存并初始化，初始化并不是置为零值(而是将地址空间的值二进制为都设置为0)</strong>。</p>
<p>与new一样，它的第一个参数也是一个类型，但是不一样的是，make返回的是传入的类型，而不是指针！</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">//声明管道类型变量c，此时c还是nil，不可用</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v \\n&quot;</span>,c) <span class="comment">//(chan int)(nil)</span></span><br><span class="line"></span><br><span class="line">c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v&quot;</span>, c) <span class="comment">//(chan int)(0xc000062060)</span></span><br></pre></td></tr></table></figure>
<p>声明管道类型变量c，此时c还是nil，不可用；通过make来分配内存并初始化，c就获得了内存可以使用了。所以，我们在使用map, slice,chan 的时候，需要先对他们用make初始化，然后在进行操作。</p>
<h1><strong>总结</strong></h1>
<ul>
<li><code>new </code>和<code>make</code>都是Go语言的两个内建函数，用于分配内存</li>
<li><code>new</code> 一般用来返回指针类型（一般不用），make返回引用类型（<code>map</code>,<code> slice</code>,<code>chan </code>这三个引用)</li>
<li><code>var</code>声明的 基本类型和<code>struct</code>这种已经分配了内存，并且赋零值了。</li>
</ul>
<h1>参考链接</h1>
<ul>
<li><a href="https://stackoverflow.com/questions/21657446/var-vs-in-go">https://stackoverflow.com/questions/21657446/var-vs-in-go</a></li>
<li><a href="https://stackoverflow.com/questions/25358130/what-is-the-difference-between-new-and-make">https://stackoverflow.com/questions/25358130/what-is-the-difference-between-new-and-make</a></li>
<li><a href="https://stackoverflow.com/questions/9320862/why-would-i-make-or-new?noredirect=1&amp;lq=1">https://stackoverflow.com/questions/9320862/why-would-i-make-or-new?noredirect=1&amp;lq=1</a></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>syntax</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Project Layout 最佳实践</title>
    <url>/2023/02/06/Golang%20%E5%90%8E%E7%AB%AF%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1>Golang Project Layout 最佳实践</h1>
<h2 id="鲍勃叔叔干净的架构（Uncle-Bob）">鲍勃叔叔干净的架构（Uncle Bob）</h2>
<p><img src="https://raw.githubusercontent.com/Lucareful/RepoImg/main/img/image-20220609141505914.png" alt="clean arch"></p>
<h3 id="依赖规则">依赖规则</h3>
<ul>
<li>同心圆代表软件的不同领域。</li>
<li>一般来说，你走得越远，软件的层次就越高。外圈是机制。内圈是政策。</li>
</ul>
<p>​     使这个架构工作的最重要的规则是<code>依赖规则</code>。这条规则说<code>源代码依赖只能指向内部</code>。内圈中的任何人都无法对外圈中的事物一无所知。特别是，在外圈中声明的事物的名称不能被内圈中的代码提及。这包括函数、类。变量或任何其他命名的软件实体。</p>
<p>​     同样，在外圈中使用的数据格式不应该被内圈使用，特别是如果这些格式是由外圈中的框架生成的。我们不希望外圈的任何东西影响内圈。</p>
<span id="more"></span>
<h3 id="实体-entity">实体(<code>entity</code>)</h3>
<p>​    实体封装了企业范围的业务规则。实体可以是具有方法的对象，也可以是一组数据结构和函数。只要实体可以被企业中的许多不同应用程序使用，这并不重要。</p>
<p>​    如果您没有企业，而只是编写单个应用程序，则这些实体是应用程序的业务对象。它们封装了最一般和高级的规则。当外部变化时，它们最不可能改变。例如，您不会期望这些对象受到页面导航或安全性更改的影响。对任何特定应用程序的操作更改都不应影响实体层。</p>
<h3 id="使用案例-usecase">使用案例(<code>usecase</code>)</h3>
<p>​    此层中的软件包含<code>特定于应用程序的业务规则</code>。它封装并实现了系统的所有用例。这些用例协调进出实体的数据流，并指示这些实体使用其<code>企业范围</code>的业务规则来实现用例的目标。</p>
<p>​    我们预计此层中的更改不会影响实体。我们也不希望此层受到外部性更改（如数据库、UI 或任何通用框架）的影响。这一层与此类问题隔离开来。</p>
<p>​    但是，我们确实预计对应用程序操作的更改将影响用例，从而影响该层中的软件。如果用例的细节发生变化，那么这一层中的一些代码肯定会受到影响。</p>
<h3 id="接口适配器-interface-adapter">接口适配器(<code>interface adapter</code>)</h3>
<p>​    该层中的软件是一组适配器，可将数据从最适合用例和实体的格式转换为最适合某些外部机构（如数据库或 Web）的格式。例如，正是这一层将完全包含 <code>GUI</code> 的 <code>MVC</code> 架构。<code>Presenters</code>、<code>Views</code> 和 <code>Controllers</code> 都属于这里。模型可能只是从控制器传递到用例，然后从用例返回到演示者和视图的数据结构。</p>
<p>​    类似地，在这一层中，数据从对实体和用例最方便的形式转换为对正在使用的任何持久性框架最方便的形式。即数据库。这个圈子内的任何代码都不应该对数据库有任何了解。如果数据库是 SQL 数据库，那么所有的 SQL 都应该限制在这一层，特别是限制在这一层与数据库有关的部分。</p>
<p>在这一层中还有任何其他适配器，用于将数据从某种外部形式（例如外部服务）转换为用例和实体使用的内部形式</p>
<h3 id="框架和驱动器（Frameworks-and-Drivers）">框架和驱动器（Frameworks and Drivers）</h3>
<p>​    最外层一般由框架和工具组成，如数据库、Web 框架等。一般在这一层你不会写太多代码，除了向内与下一个循环通信的胶水代码。</p>
<p>​    这一层是所有细节的所在。网络是一个细节。数据库是一个细节。我们把这些东西放在外面，它们不会造成什么伤害。</p>
<h3 id="圈和边界">圈和边界</h3>
<p>​    源代码依赖项总是指向内部。随着向内移动，抽象级别会增加。最外圈是低层次的具体细节。随着您向内移动，软件变得更加抽象，并封装了更高级别的策略。最内圈是最普通的。</p>
<p>​    通常，<strong>跨越边界的数据是简单的数据结构</strong>。如果您愿意，可以使用基本结构或简单的数据传输对象。或者数据可以只是函数调用中的参数。或者你可以将它打包成一个 hashmap，或者将它构造成一个对象。重要的是，<strong>隔离的、简单的数据结构可以跨越边界传递</strong>。我们不想欺骗和传递实体或数据库行。我们不希望数据结构有任何违反<em>依赖规则的依赖</em>。</p>
<p>​    例如，许多数据库框架返回方便的数据格式以响应查询。我们可以称其为 Row Structure。我们不想跨边界向内传递该行结构。这将违反依赖规则，因为它会迫使内圈了解外圈。</p>
<p>所以当我们越界传递数据时，总是采用最方便内圈的形式。</p>
<h3 id="结论">结论</h3>
<p>​    遵守这些简单的规则并不难，并且会为您省去很多麻烦。通过将软件分层并遵守依赖规则，您将创建一个本质上可测试的系统，并具有所有暗示的好处。当系统的任何外部部件（如数据库或 Web 框架）过时时，您可以轻松替换那些过时的元素。</p>
<h2 id="从-kratos-框架入手">从 kratos 框架入手</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">application</span><br><span class="line">|____api</span><br><span class="line">| |____helloworld</span><br><span class="line">| | |____v1</span><br><span class="line">| | |____errors</span><br><span class="line">|____cmd</span><br><span class="line">| |____helloworld</span><br><span class="line">|____configs</span><br><span class="line">|____internal</span><br><span class="line">| |____conf</span><br><span class="line">| |____data</span><br><span class="line">| |____biz</span><br><span class="line">| |____service</span><br><span class="line">| |____server</span><br><span class="line">|____test</span><br><span class="line">|____pkg</span><br><span class="line">|____go.mod</span><br><span class="line">|____go.sum</span><br><span class="line">|____LICENSE</span><br><span class="line">|____README.md</span><br></pre></td></tr></table></figure>
<h3 id="应用目录">应用目录</h3>
<h4 id="cmd">/cmd</h4>
<p>​     本项目的主干。</p>
<p>​	每个应用程序的目录名应该与你想要的可执行文件的名称相匹配（例如，<code>/cmd/myapp</code>）。 不要在这个目录中放置太多代码。如果你认为代码可以导入并在其他项目中使用，那么它应该位于 <code>/pkg</code> 目录中。如果代码不是可重用的，或者你不希望其他人重用它，请将该代码放到 <code>/internal</code> 目录中。</p>
<h4 id="internal">/internal</h4>
<p>​      私有应用程序和库代码。</p>
<p>​      这是你不希望其他人在其应用程序或库中导入代码。请注意，这个布局模式是由 Go 编译器本身执行的。有关更多细节，请参阅 Go 1.4 release notes。注意，你并不局限于顶级 <code>internal</code> 目录。在项目树的任何级别上都可以有多个内部目录。 你可以选择向 <code>internal</code> 包中添加一些额外的结构，以分隔共享和非共享的内部代码。这不是必需的(特别是对于较小的项目)，但是最好有有可视化的线索来显示预期的包的用途。你的实际应用程序代码可以放在 <code>/internal/app</code> 目录下（例如 <code>/internal/app/myapp</code>），这些应用程序共享的代码可以放在 <code>/internal/pkg</code> 目录下（例如 /internal/pkg/myprivlib）。 因为我们习惯把相关的服务，比如账号服务，内部有 rpc、job、admin 等，相关的服务整合一起后，需要区分 app。单一的服务，可以去掉 <code>/internal/myapp</code>。</p>
<h4 id="pkg">/pkg</h4>
<p>​     外部应用程序可以使用的库代码（例如 <code>/pkg/mypubliclib</code>）。</p>
<p>​	其他项目会导入这些库，所以在这里放东西之前要三思:-)注意，<code>internal</code> 目录是确保私有包不可导入的更好方法，因为它是由 Go 强制执行的。<code>/pkg</code> 目录仍然是一种很好的方式，可以显式地表示该目录中的代码对于其他人来说是安全使用的好方法。</p>
<blockquote>
<p>/pkg 目录内，可以参考 go 标准库的组织方式，按照功能分类。/internla/pkg 一般用于项目内的 跨多个应用的公共共享代码，但其作用域仅在单个项目工程内。</p>
</blockquote>
<h3 id="服务应用目录">服务应用目录</h3>
<h4 id="api">/api</h4>
<pre><code>API 协议定义目录，services.proto protobuf 文件，以及生成的 go 文件。我们通常把 api 文档直接在 proto 文件中描述。
</code></pre>
<h4 id="configs">/configs</h4>
<pre><code>配置文件模板或默认配置。
</code></pre>
<h4 id="test">/test</h4>
<p>​	 额外的外部测试应用程序和测试数据。你可以随时根据需求构造 /test 目录。对于较大的项目，有一个数据子目录是有意义的。例如，你可以使用 /test/data 或 /test/testdata (如果你需要忽略目录中的内容)。请注意，Go 还会忽略以 “.” 或 “_” 开头的目录或文件，因此在如何命名测试数据目录方面有更大的灵活性。</p>
<h3 id="服务内部目录">服务内部目录</h3>
<p>​	Application 目录下有 api、cmd、configs、internal、pkg 目录，目录里一般还会放置 README、CHANGELOG、OWNERS。internal 是为了避免有同业务下有人跨目录引用了内部的 data、biz、service、server 等内部 struct。</p>
<h4 id="data">data</h4>
<p>​	业务数据访问，包含 cache、db 等封装，实现了 biz 的 repo 接口。我们可能会把 data 与 dao 混淆在一起，data 偏重业务的含义，它所要做的是将领域对象重新拿出来，我们去掉了 DDD 的 infra层。</p>
<h4 id="biz">biz</h4>
<p>​	业务逻辑的组装层，类似 DDD 的 domain 层，data 类似 DDD 的 repo，repo 接口在这里定义，使用依赖倒置的原则。</p>
<h4 id="service">service</h4>
<p>​	实现了 api 定义的服务层，类似 DDD 的 application 层，处理 DTO 到 biz 领域实体的转换（DTO -&gt; DO），同时协同各类 biz 交互，但是不应处理复杂逻辑。</p>
<h4 id="server">server</h4>
<p>​	为http和grpc实例的创建和配置，以及注册对应的 service 。</p>
<h3 id="总结">总结</h3>
<p>​	在实际 go 项目开发中，一定要灵活运用，当然也可以完全不按照这样架构分层、包设计的规则，一切以项目的大小、业务的复杂度、个人专业技能认知的广度和深度、时间的紧迫度为准。</p>
<h2 id="github上优秀的项目">github上优秀的项目</h2>
<h3 id="go-clean-arch">go-clean-arch</h3>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/img/clean-arch.png" alt="golang clean architecture"></p>
<p>​	此项目有 4 个域层</p>
<ul>
<li>模型层</li>
<li>存储库层</li>
<li>用例层</li>
<li>交付层</li>
</ul>
<h3 id="go-clean-template">go-clean-template</h3>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/img/layers-2.png" alt="例"></p>
<h3 id="服务流向">服务流向</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP &gt; usecase</span><br><span class="line">          usecase &gt; repository</span><br><span class="line">          usecase &lt; repository</span><br><span class="line">          usecase &gt; webapi</span><br><span class="line">          usecase &lt; webapi</span><br><span class="line">          usecase &gt; RPC</span><br><span class="line">          usecase &lt; RPC</span><br><span class="line">          usecase &gt; repository</span><br><span class="line">          usecase &lt; repository</span><br><span class="line">   HTTP &lt; usecase</span><br></pre></td></tr></table></figure>
<h2 id="参考文章">参考文章</h2>
<ul>
<li>
<p><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Coder Blog</a></p>
</li>
<li>
<p><a href="https://go-kratos.dev/blog/go-project-layout">Go工程化 - Project Layout 最佳实践 | Kratos (go-kratos.dev)</a></p>
</li>
<li>
<p><a href="https://juejin.cn/post/6904595334693912584">Golang进阶4-Go 工程化实践和配置中心 - 掘金 (juejin.cn)</a></p>
</li>
<li>
<p><a href="https://github.com/bxcodec/go-clean-arch">bxcodec/go-clean-arch: Go (Golang) Clean Architecture based on Reading Uncle Bob’s Clean Architecture (github.com)</a></p>
</li>
<li>
<p><a href="https://github.com/evrone/go-clean-template">evrone/go-clean-template: Clean Architecture template for Golang services (github.com)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Project Layout</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang error 处理最佳实践</title>
    <url>/2023/02/06/golang%20error%20%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1>golang error 处理最佳实践</h1>
<h2 id="错误类型定义">错误类型定义</h2>
<ul>
<li>Go 中<code>error</code> 类型是一个接口类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本上，<code>error</code> 是实现该接口任何内容，它将错误消息作为字符串返回。</p>
<h2 id="构造错误">构造错误</h2>
<p>​    可以使用 Go 的内置或包动态构造错误。</p>
<p>​    例如，以下函数使用包返回带有静态错误消息的新错误：<code>errors fmt errors</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;errors&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;something didn&#x27;t work&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	同样，该包可用于向错误添加动态数据。</p>
<p>​	例如：<code>fmt int string error</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;can&#x27;t divide &#x27;%d&#x27; by zero&quot;</span>, a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，当用于用格式动词包装另一个错误时，这将非常有用 <code>fmt.Errorf %w</code></p>
<p>在上面的示例中，还有其他一些重要事项需要注意。</p>
<ul>
<li>错误可以返回为<code>nil</code> ，它是 Go 中 <code>error</code> 的默认值或<code>零值</code>。这很重要，因为检查是确定是否遇到错误的惯用方法（替换您可能在其他编程语言中熟悉的 / 语句）。<code>if err != nil </code></li>
<li>错误通常作为函数中的最后一个参数返回。因此，在上面的示例中，我们按该顺序返回 <code>int</code>和 <code>nil</code> 。</li>
<li>当我们返回错误时，函数返回的其他参数通常作为其默认的<code>零值</code>返回。函数的用户可能期望，如果返回非<code>nil</code> 错误，则返回的其他参数不相关。</li>
<li>最后，错误消息通常以小写形式编写，不以标点符号结尾。但是可以例外，例如，当包含专有名词，以大写字母开头的函数名称等。</li>
</ul>
<span id="more"></span>
<h2 id="定义预期错误">定义预期错误</h2>
<p>​    <code>Go</code> 中的另一个重要技术是定义预期的错误，以便可以在代码的其他部分中显式检查它们。当遇到某种类型的错误时需要执行不同的代码分支时，这将非常有用。</p>
<h3 id="关于-errors-Is-和-errors-As">关于  <code>errors.Is()</code> 和 <code>errors.As() </code></h3>
<blockquote>
<p>如果我们想检查给定错误是否与另一个特定错误匹配，我们需要使用包中<code>Is()</code>的函数<code>errors</code>。如果我们对错误是否属于给定类型感兴趣，我们应该调用该<code>As()</code>函数。<code>errors.Is()</code></p>
</blockquote>
<h4 id="errors-Is-功能"><code>errors.Is()</code>功能</h4>
<blockquote>
<p>此函数适合没有经过包装的错误</p>
</blockquote>
<p>​    在下面的示例中，我们可以看到该函数<code>validateInput</code>为<code>badInput</code>. 此错误<code>ErrBadInput</code>包含在由<code>fmt.Errorf()</code>.</p>
<p>​     使用该<code>Is(err, target error) bool</code>函数，我们可以检测到<code>ErrBadInput</code>它是否被包装，因为该函数检查包装错误链中的任何错误是否与目标匹配。</p>
<p>因此，这种形式应该比<code>if err == ErrBadInput</code>更可取。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> badInput = <span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrBadInput = errors.New(<span class="string">&quot;bad input&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateInput</span><span class="params">(input <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> input == badInput &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;validateInput: %w&quot;</span>, ErrBadInput)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    input := badInput</span><br><span class="line"></span><br><span class="line">    err := validateInput(input)</span><br><span class="line">    <span class="keyword">if</span> errors.Is(err, ErrBadInput) &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;bad input error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bad input error</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;errors&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrorString1 = errors.New(<span class="string">&quot;test b&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  err := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;I am %w&quot;</span>, ErrorString1)</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> errors.Is(err, ErrorString1) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;err b&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">err b</span><br></pre></td></tr></table></figure>
<h4 id="errors-As-功能"><code>errors.As()</code>功能</h4>
<blockquote>
<p>此函数将错误进行了包装</p>
</blockquote>
<p>​    与 类似<code>Is()</code>，<code>As(err error, target interface&#123;&#125;) bool</code>检查包装错误链中的任何错误是否与目标匹配。不同之处在于此函数检查错误是否具有特定类型，不像<code>Is()</code>，它检查它是否是特定的错误对象。</p>
<p>因为<code>As</code>考虑到整个错误链，它应该比类型断言更可取<code>if e, ok := err.(*BadInputError); ok</code>。</p>
<blockquote>
<p>target<code>函数的参数``As(err error, target interface&#123;&#125;) bool</code>应该<strong>是指向错误类型的指针</strong>，在这种情况下是<code>*BadInputError</code></p>
</blockquote>
<p>复制</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> badInput = <span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BadInputError <span class="keyword">struct</span> &#123;</span><br><span class="line">    input <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *BadInputError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;bad input: %s&quot;</span>, e.input)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateInput</span><span class="params">(input <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> input == badInput &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;validateInput: %w&quot;</span>, &amp;BadInputError&#123;input: input&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    input := badInput</span><br><span class="line"></span><br><span class="line">    err := validateInput(input)</span><br><span class="line">    <span class="keyword">var</span> badInputErr *BadInputError</span><br><span class="line">    <span class="keyword">if</span> errors.As(err, &amp;badInputErr) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;bad input error occured: %s\n&quot;</span>, badInputErr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义哨兵错误">定义哨兵错误</h3>
<p>​    基于前面的函数，我们可以通过预先定义<code>Sentinel</code>错误来改进错误信令。调用函数可以使用以下命令显式检查此错误：<code>errors.Is</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrDivideByZero = errors.New(<span class="string">&quot;divide by zero&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, ErrDivideByZero</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">10</span>, <span class="number">0</span></span><br><span class="line">    result, err := Divide(a, b)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> errors.Is(err, ErrDivideByZero):</span><br><span class="line">            fmt.Println(<span class="string">&quot;divide by zero error&quot;</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;unexpected division error: %s\n&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d / %d = %d\n&quot;</span>, a, b, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义自定义错误类型">定义自定义错误类型</h3>
<p>使用上述策略可以涵盖许多错误处理用例，但是，有时您可能需要更多功能。也许您希望错误携带其他数据字段，或者错误的消息在打印时应使用动态值填充自身。这些可以通过自定义错误类型实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DivisionError <span class="keyword">struct</span> &#123;</span><br><span class="line">    IntA <span class="type">int</span></span><br><span class="line">    IntB <span class="type">int</span></span><br><span class="line">    Msg  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *DivisionError)</span></span> Error() <span class="type">string</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> e.Msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, &amp;DivisionError&#123;</span><br><span class="line">            Msg: fmt.Sprintf(<span class="string">&quot;cannot divide &#x27;%d&#x27; by zero&quot;</span>, a),</span><br><span class="line">            IntA: a, IntB: b,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">10</span>, <span class="number">0</span></span><br><span class="line">    result, err := Divide(a, b)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> divErr *DivisionError</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> errors.As(err, &amp;divErr):</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%d / %d is not mathematically valid: %s\n&quot;</span>,</span><br><span class="line">              divErr.IntA, divErr.IntB, divErr.Error())</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;unexpected division error: %s\n&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d / %d = %d\n&quot;</span>, a, b, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="error-are-value">error are value</h2>
<blockquote>
<p>无论你做什么，都要始终检查你的错误！</p>
</blockquote>
<h3 id="bufio的设计"><code>bufio</code>的设计</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">scanner := bufio.NewScanner(input)</span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">    token := scanner.Text()</span><br><span class="line">    <span class="comment">// process token</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// process the error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span></span> Scan() (token []<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">scanner := bufio.NewScanner(input)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    token, err := scanner.Scan()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err <span class="comment">// or maybe break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// process token</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件error处理">文件<code>error</code>处理</h3>
<p>​    改进前</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, err = fd.Write(p0[a:b])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">_, err = fd.Write(p1[c:d])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">_, err = fd.Write(p2[e:f])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// and so on</span></span><br></pre></td></tr></table></figure>
<p>​    改进方法1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> errWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    w   io.Writer</span><br><span class="line">    err <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ew *errWriter)</span></span> write(buf []<span class="type">byte</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ew.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    _, ew.err = ew.w.Write(buf)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ew := &amp;errWriter&#123;w: fd&#125;</span><br><span class="line">ew.write(p0[a:b])</span><br><span class="line">ew.write(p1[c:d])</span><br><span class="line">ew.write(p2[e:f])</span><br><span class="line"><span class="comment">// and so on</span></span><br><span class="line"><span class="keyword">if</span> ew.err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ew.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​    改进方法2(<code>bufio</code>的设计)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := bufio.NewWriter(fd)</span><br><span class="line">b.Write(p0[a:b])</span><br><span class="line">b.Write(p1[c:d])</span><br><span class="line">b.Write(p2[e:f])</span><br><span class="line"><span class="comment">// and so on</span></span><br><span class="line"><span class="keyword">if</span> b.Flush() != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Error-handling-and-Go">Error handling and Go</h2>
<blockquote>
<p>合理的对错误进行包装，给错误一个模板（参考定义预期错误）</p>
</blockquote>
<h2 id="简化重复的错误处理">简化重复的错误处理</h2>
<p>​    原始程序</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/view&quot;</span>, viewRecord)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    </span><br><span class="line">    key := datastore.NewKey(c, <span class="string">&quot;Record&quot;</span>, r.FormValue(<span class="string">&quot;id&quot;</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err := viewTemplate.Execute(w, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封装函数对错误处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    </span><br><span class="line">    key := datastore.NewKey(c, <span class="string">&quot;Record&quot;</span>, r.FormValue(<span class="string">&quot;id&quot;</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> viewTemplate.Execute(w, record)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外层对重复错误的处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fn appHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="keyword">if</span> err := fn(w, r); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一个http服务的错误封装">一个<code>http</code>服务的错误封装</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> appError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Error   <span class="type">error</span></span><br><span class="line">    Message <span class="type">string</span></span><br><span class="line">    Code    <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> appHandler <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span> *appError</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fn appHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="keyword">if</span> e := fn(w, r); e != <span class="literal">nil</span> &#123; <span class="comment">// e is *appError, not os.Error.</span></span><br><span class="line">        c := appengine.NewContext(r)</span><br><span class="line">        c.Errorf(<span class="string">&quot;%v&quot;</span>, e.Error)</span><br><span class="line">        http.Error(w, e.Message, e.Code)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> *appError &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    key := datastore.NewKey(c, <span class="string">&quot;Record&quot;</span>, r.FormValue(<span class="string">&quot;id&quot;</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;appError&#123;err, <span class="string">&quot;Record not found&quot;</span>, <span class="number">404</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := viewTemplate.Execute(w, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;appError&#123;err, <span class="string">&quot;Can&#x27;t display record&quot;</span>, <span class="number">500</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="毛剑老师的课程的建议">毛剑老师的课程的建议</h2>
<h3 id="panic">panic</h3>
<ul>
<li>在程序启动的时候，如果有强依赖的服务出现故障时 <code>panic</code> 退出</li>
<li>在程序启动的时候，如果发现有配置明显不符合要求， 可以 <code>panic</code> 退出（防御编程）</li>
<li>其他情况下只要不是不可恢复的程序错误，都不应该直接 <code>panic</code> 应该返回 <code>error</code></li>
<li>在程序入口处，例如 <code>gin</code> 中间件需要使用 <code>recover</code> 预防 <code>panic</code> 程序退出</li>
<li>在程序中我们应该避免使用野生的 <code>goroutine</code>
<ul>
<li>如果是在请求中需要执行异步任务，应该使用异步 <code>worker</code> ，消息通知的方式进行处理，避免请求量大时大量 <code>goroutine</code> 创建</li>
<li>如果需要使用 <code>goroutine</code> 时，应该使用同一的 <code>Go</code> 函数进行创建，这个函数中会进行 <code>recover</code> ，避免因为野生 <code>goroutine</code> panic 导致主进程退出</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Go</span><span class="params">(f <span class="keyword">func</span>()</span></span>)&#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Printf(<span class="string">&quot;panic: %+v&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        f()</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="error">error</h3>
<ol>
<li>
<p>我们在应用程序中使用 <code>github.com/pkg/errors</code> 处理应用错误，<strong>注意在公共库当中，我们一般不使用这个</strong></p>
</li>
<li>
<p><code>error</code>应该是函数的最后一个返回值，当<code>error</code>不为<code>nil</code> 时，函数的其他返回值是不可用的状态，不应该对其他返回值做任何期待</p>
<ol>
<li><code>func f() (io.Reader, *S1, error)</code> 在这里，我们不知道 <code>io.Reader</code> 中是否有数据，可能有，也有可能有一部分</li>
</ol>
</li>
<li>
<p>错误处理的时候应该先判断错误， <code>if err != nil</code> 出现错误及时返回，使代码是一条流畅的直线，避免过多的嵌套.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// good case</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    a, err := A()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad case</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    a, err := A()</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 其他逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在<strong>应用程序</strong>中出现错误时，使用 <code>errors.New</code> 或者 <code>errors.Errorf</code> 返回错误</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *usecese)</span></span> usecase1() <span class="type">error</span> &#123;</span><br><span class="line">    money := u.repo.getMoney(uid)</span><br><span class="line">    <span class="keyword">if</span> money &lt; <span class="number">10</span> &#123;</span><br><span class="line">        errors.Errorf(<span class="string">&quot;用户余额不足, uid: %d, money: %d&quot;</span>, uid, money)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>如果是调用<strong>应用程序的</strong>其他函数出现错误，请直接返回，如果需要携带信息，请使用 <code>errors.WithMessage</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *usecese)</span></span> usecase2() <span class="type">error</span> &#123;</span><br><span class="line">    name, err := u.repo.getUserName(uid)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;其他附加信息&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>如果是调用其他库（标准库、企业公共库、开源第三方库等）获取到错误时，请使用<code>errors.Wrap</code>添加堆栈信息
<ol>
<li>切记，不要每个地方都是用 <code>errors.Wrap</code> 只需要在错误第一次出现时进行 <code>errors.Wrap</code> 即可</li>
<li>根据场景进行判断是否需要将其他库的原始错误吞掉，例如可以把 <code>repository</code> 层的数据库相关错误吞掉，返回业务错误码，避免后续我们分割微服务或者更换 <code>ORM</code> 库时需要去修改上层代码</li>
<li>注意我们在基础库，被大量引入的第三方库编写时一般不使用 <code>errors.Wrap</code> 避免堆栈信息重复</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    err := json.Unmashal(&amp;a, data)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;其他附加信息&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li><strong>禁止</strong>每个出错的地方都打日志，<strong>只需要</strong>在进程的最开始的地方使用 <code>%+v</code> 进行统一打印，例如 <code>http/rpc </code>服务的中间件</li>
<li>错误判断使用 <code>errors.Is</code> 进行比较</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    err := A()</span><br><span class="line">    <span class="keyword">if</span> errors.Is(err, io.EOF)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="9">
<li>错误类型判断，使用 <code>errors.As</code> 进行赋值</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    err := A()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> errA errorA</span><br><span class="line">    <span class="keyword">if</span> errors.As(err, &amp;errA)&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="10">
<li>如何判定错误的信息是否足够，想一想当你的代码出现问题需要排查的时候你的错误信息是否可以帮助你快速的定位问题，例如我们在请求中一般会输出参数信息，用于辅助判断错误</li>
<li>对于业务错误，推荐在一个统一的地方创建一个错误字典，错误字典里面应该包含错误的 code，并且在日志中作为独立字段打印，方便做业务告警的判断，错误必须有清晰的错误文档</li>
<li>不需要返回，<strong>被忽略的错误必须输出日志信息</strong></li>
<li>同一个地方不停的报错，最好不要不停输出错误日志，这样可能会导致被大量的错误日志信息淹没，无法排查问题，比较好的做法是打印一次错误详情，然后打印出错误出现的次数</li>
<li>对同一个类型的错误，采用相同的模式，例如参数错误，不要有的返回 404 有的返回 200</li>
<li>处理错误的时候，需要处理已分配的资源，使用 <code>defer</code> 进行清理，例如文件句柄</li>
</ol>
<h3 id="panic-or-error">panic or error</h3>
<ol>
<li>在 Go 中 panic 会导致程序直接退出，是一个致命的错误，如果使用 <code>panic</code>,<code>recover</code> 进行处理的话，会存在很多问题
<ol>
<li>性能问题，频繁 <code>panic</code>, <code>recover</code> 性能不好</li>
<li>容易导致程序异常退出，只要有一个地方没有处理到就会导致程序进程整个退出</li>
<li>不可控，一旦 panic 就将处理逻辑移交给了外部，我们并不能预设外部包一定会进行处理</li>
</ol>
</li>
<li>什么时候使用 panic 呢？
<ol>
<li>对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界、不可恢复的环境问题、栈溢出，我们才使用 panic</li>
</ol>
</li>
<li>使用 error 处理有哪些好处？
<ol>
<li>简单。</li>
<li>考虑失败，而不是成功(Plan for failure, not success)。</li>
<li>没有隐藏的控制流。</li>
<li>完全交给你来控制 error。</li>
<li>Error are values。</li>
</ol>
</li>
</ol>
<h1>参考链接</h1>
<ul>
<li>
<p><a href="https://go.dev/blog/errors-are-values">Errors are values - The Go Programming Language</a></p>
</li>
<li>
<p><a href="https://go.dev/blog/error-handling-and-go">Error handling and Go - The Go Programming Language</a></p>
</li>
<li>
<p><a href="https://lailin.xyz/post/go-training-03.html">https://lailin.xyz/post/go-training-03.html</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang并发编程最佳实践</title>
    <url>/2023/02/06/Golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1>Golang 并发编程最佳实践</h1>
<h2 id="Goroutine-定义">Goroutine 定义</h2>
<p>​    Goroutines 是与其他<a href="https://golangbot.com/functions/">函数</a>或<a href="https://golangbot.com/methods/">方法</a>同时运行的函数或方法。Goroutines 可以被认为是轻量级线程。与线程相比，创建 Goroutine 的成本很小。因此，Go 应用程序通常会同时运行数千个 Goroutine。</p>
<h2 id="Goroutines-相对于线程的优势">Goroutines 相对于线程的优势</h2>
<ul>
<li>与线程相比，Goroutines 非常便宜。它们的堆栈大小只有几 kb，堆栈可以根据应用程序的需要增长和缩小，而在线程的情况下，堆栈大小必须指定并固定。</li>
<li>Goroutine 被多路复用到更少数量的 OS 线程。一个包含数千个 Goroutine 的程序中可能只有一个线程。如果该线程中的任何 Goroutine 阻塞等待用户输入，则创建另一个 OS 线程并将剩余的 Goroutine 移动到新的 OS 线程。所有这些都由运行时处理，我们作为程序员从这些复杂的细节中抽象出来，并获得了一个干净的 API 来处理并发性。</li>
<li>Goroutines 使用通道进行通信。通道通过设计防止在使用 Goroutine 访问共享内存时发生竞争条件。通道可以被认为是 Goroutine 进行通信的管道。</li>
</ul>
<span id="more"></span>
<h2 id="三种常见使用">三种常见使用</h2>
<h4 id="通过sync-WaitGroup的三个方法-Add-Done-Wait-来实现协程的控制">通过<code>sync. WaitGroup</code>的三个方法 <code>Add()</code>, <code>Done()</code>, <code>Wait()</code> 来实现协程的控制</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">  fmt.Println(<span class="string">&quot;我是A&quot;</span>, i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    </span><br><span class="line">  fmt.Println(<span class="string">&quot;我是main&quot;</span>)</span><br><span class="line">    </span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    A(i)</span><br><span class="line">  &#125;(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">  wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;执行完了&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过带buffe的channel来控制">通过带<code>buffe</code>的<code>channel</code>来控制</h4>
<blockquote>
<p>无缓冲 channel，发送者会阻塞直到接收者接收了发送的值。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;我是A&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">    fmt.Println(<span class="string">&quot;我是main&quot;</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, chp <span class="keyword">chan</span>&lt;- <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(chp)</span><br><span class="line">    </span><br><span class="line">        A(i)</span><br><span class="line">    fmt.Println(<span class="string">&quot;finish&quot;</span>)</span><br><span class="line">        chp &lt;- <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  &#125;(<span class="number">1</span>, ch)</span><br><span class="line">    </span><br><span class="line">  fmt.Println(<span class="string">&quot;wait&quot;</span>)</span><br><span class="line">  </span><br><span class="line">    &lt;-ch</span><br><span class="line">  </span><br><span class="line">    fmt.Println(<span class="string">&quot;执行完了&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过sync-Cond">通过<code>sync.Cond</code></h4>
<blockquote>
<p><code>sync.Cond</code> <strong>条件变量用来协调想要访问共享资源的那些 goroutine</strong>，当共享资源的状态发生变化的时候，它可以用来通知被互斥锁阻塞的 <code>goroutine</code>。</p>
</blockquote>
<ul>
<li><code>cond.L.Lock()</code>和<code>cond.L.Unlock()</code>：也可以使用<code>lock.Lock()</code>和<code>lock.Unlock()</code>，完全一样，因为是指针转递</li>
<li><code>cond.Wait()</code>：Unlock()-&gt;*<strong>阻塞等待通知(即等待Signal()或Broadcast()的通知)-&gt;收到通知*</strong>-&gt;Lock()</li>
<li><code>cond.Signal()</code>：<code>Signal</code> 唤醒一个协程，若没有Wait()，也不会报错。<strong>Signal()通知的顺序是根据原来加入通知列表(Wait())的先入先出</strong></li>
<li><code>cond.Broadcast()</code>: 通知所有Wait()了的，若没有Wait()，也不会报错</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(name <span class="type">string</span>, c *sync.Cond)</span></span> &#123;</span><br><span class="line">  c.L.Lock()</span><br><span class="line">  <span class="keyword">for</span> !done &#123;</span><br><span class="line">    c.Wait()</span><br><span class="line">  &#125;</span><br><span class="line">  log.Println(name, <span class="string">&quot;starts reading&quot;</span>)</span><br><span class="line">  c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(name <span class="type">string</span>, c *sync.Cond)</span></span> &#123;</span><br><span class="line">  log.Println(name, <span class="string">&quot;starts writing&quot;</span>)</span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">  c.L.Lock()</span><br><span class="line">  done = <span class="literal">true</span></span><br><span class="line">  c.L.Unlock()</span><br><span class="line">  log.Println(name, <span class="string">&quot;wakes all&quot;</span>)</span><br><span class="line">  c.Broadcast()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  cond := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> read(<span class="string">&quot;reader1&quot;</span>, cond)</span><br><span class="line">  <span class="keyword">go</span> read(<span class="string">&quot;reader2&quot;</span>, cond)</span><br><span class="line">  <span class="keyword">go</span> read(<span class="string">&quot;reader3&quot;</span>, cond)</span><br><span class="line">  write(<span class="string">&quot;writer&quot;</span>, cond)</span><br><span class="line"></span><br><span class="line">  time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>done</code> 即互斥锁需要保护的条件变量。</li>
<li><code>read()</code> 调用 <code>Wait()</code> 等待通知，直到 done 为 true。</li>
<li><code>write()</code> 接收数据，接收完成后，将 done 置为 true，调用 <code>Broadcast()</code> 通知所有等待的协程。</li>
<li><code>write()</code> 中的暂停了 1s，一方面是模拟耗时，另一方面是确保前面的 3 个 read 协程都执行到 <code>Wait()</code>，处于等待状态。main 函数最后暂停了 3s，确保所有操作执行完毕。</li>
</ul>
<h2 id="使用案例">使用案例</h2>
<h3 id="从-Channel-发送和接收值">从 Channel 发送和接收值</h3>
<p>​    我们创建一个 <code>c int</code> 通道并从生成器函数中返回它。在匿名 <code>goroutine</code> 中运行的 <code>for</code> 循环将值写入通道 <code>c</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := generator()</span><br><span class="line">  receiver(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiver</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> v := <span class="keyword">range</span> c &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generator</span><span class="params">()</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      c &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取和写入斐波那契数列到通道">读取和写入斐波那契数列到通道</h3>
<p>​    主函数有两个无缓冲通道 <code>ch</code> 和 <code>quit</code>。在 <code>fibonacci</code> 函数内部，<code>select</code> 语句会阻塞，直到其中一个 <code>case</code> 准备好。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>, quit <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">  x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ch &lt;- x: <span class="comment">// write to channel ch</span></span><br><span class="line">      x, y = y, x+y</span><br><span class="line">    <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">      fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">  quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">  n := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">      fmt.Println(&lt;-ch) <span class="comment">// read from channel ch</span></span><br><span class="line">    &#125;</span><br><span class="line">    quit &lt;- <span class="literal">false</span></span><br><span class="line">  &#125;(n)</span><br><span class="line"></span><br><span class="line">  fibonacci(ch, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生产消费者模型">生产消费者模型</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;flag&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">  <span class="string">&quot;runtime&quot;</span></span><br><span class="line">  <span class="string">&quot;runtime/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Consumer <span class="keyword">struct</span> &#123;</span><br><span class="line">  msgs *<span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewConsumer creates a Consumer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConsumer</span><span class="params">(msgs *<span class="keyword">chan</span> <span class="type">int</span>)</span></span> *Consumer &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Consumer&#123;msgs: msgs&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// consume reads the msgs channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Consumer)</span></span> consume() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;consume: Started&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    msg := &lt;-*c.msgs</span><br><span class="line">    fmt.Println(<span class="string">&quot;consume: Received:&quot;</span>, msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Producer definition</span></span><br><span class="line"><span class="keyword">type</span> Producer <span class="keyword">struct</span> &#123;</span><br><span class="line">  msgs *<span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">  done *<span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewProducer creates a Producer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProducer</span><span class="params">(msgs *<span class="keyword">chan</span> <span class="type">int</span>, done *<span class="keyword">chan</span> <span class="type">bool</span>)</span></span> *Producer &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Producer&#123;msgs: msgs, done: done&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// produce creates and sends the message through msgs channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Producer)</span></span> produce(max <span class="type">int</span>) &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;produce: Started&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; max; i++ &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;produce: Sending &quot;</span>, i)</span><br><span class="line">    *p.msgs &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line">  *p.done &lt;- <span class="literal">true</span> <span class="comment">// signal when done</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;produce: Done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// profile flags</span></span><br><span class="line">  cpuprofile := flag.String(<span class="string">&quot;cpuprofile&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;write cpu profile to `file`&quot;</span>)</span><br><span class="line">  memprofile := flag.String(<span class="string">&quot;memprofile&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;write memory profile to `file`&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get the maximum number of messages from flags</span></span><br><span class="line">  max := flag.Int(<span class="string">&quot;n&quot;</span>, <span class="number">5</span>, <span class="string">&quot;defines the number of messages&quot;</span>)</span><br><span class="line"></span><br><span class="line">  flag.Parse()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// utilize the max num of cores available</span></span><br><span class="line">  runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CPU Profile</span></span><br><span class="line">  <span class="keyword">if</span> *cpuprofile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    f, err := os.Create(*cpuprofile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(<span class="string">&quot;could not create CPU profile: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := pprof.StartCPUProfile(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(<span class="string">&quot;could not start CPU profile: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> msgs = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)  <span class="comment">// channel to send messages</span></span><br><span class="line">  <span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>) <span class="comment">// channel to control when production is done</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start a goroutine for Produce.produce</span></span><br><span class="line">  <span class="keyword">go</span> NewProducer(&amp;msgs, &amp;done).produce(*max)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start a goroutine for Consumer.consume</span></span><br><span class="line">  <span class="keyword">go</span> NewConsumer(&amp;msgs).consume()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finish the program when the production is done</span></span><br><span class="line">  &lt;-done</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Memory Profile</span></span><br><span class="line">  <span class="keyword">if</span> *memprofile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    f, err := os.Create(*memprofile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(<span class="string">&quot;could not create memory profile: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    runtime.GC() <span class="comment">// get up-to-date statistics</span></span><br><span class="line">    <span class="keyword">if</span> err := pprof.WriteHeapProfile(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(<span class="string">&quot;could not write memory profile: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    f.Close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Generator-模式">Generator 模式</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// boring is a function that returns a channel to communicate with it.</span></span><br><span class="line"><span class="comment">// &lt;-chan string means receives-only channel of string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boring</span><span class="params">(msg <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">  <span class="comment">// we launch goroutine inside a function</span></span><br><span class="line">  <span class="comment">// that sends the data to channel</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// The for loop simulate the infinite sender.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      c &lt;- fmt.Sprintf(<span class="string">&quot;%s %d&quot;</span>, msg, i)</span><br><span class="line">      time.Sleep(time.Duration(rand.Intn(<span class="number">1e3</span>)) * time.Millisecond)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The sender should close the channel</span></span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">return</span> c <span class="comment">// return a channel to caller.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  joe := boring(<span class="string">&quot;Joe&quot;</span>)</span><br><span class="line">  ahn := boring(<span class="string">&quot;Ahn&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This loop yields 2 channels in sequence</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(&lt;-joe)</span><br><span class="line">    fmt.Println(&lt;-ahn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// or we can simply use the for range</span></span><br><span class="line">  <span class="comment">// for msg := range joe &#123;</span></span><br><span class="line">  <span class="comment">// 	fmt.Println(msg)</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;You&#x27;re both boring. I&#x27;m leaving&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="google-3-0">google 3.0</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="type">string</span></span><br><span class="line"><span class="keyword">type</span> Search <span class="function"><span class="keyword">func</span><span class="params">(query <span class="type">string</span>)</span></span> Result</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  Web1   = fakeSearch(<span class="string">&quot;web1&quot;</span>)</span><br><span class="line">  Web2   = fakeSearch(<span class="string">&quot;web2&quot;</span>)</span><br><span class="line">  Image1 = fakeSearch(<span class="string">&quot;image1&quot;</span>)</span><br><span class="line">  Image2 = fakeSearch(<span class="string">&quot;image2&quot;</span>)</span><br><span class="line">  Video1 = fakeSearch(<span class="string">&quot;video1&quot;</span>)</span><br><span class="line">  Video2 = fakeSearch(<span class="string">&quot;video2&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fakeSearch</span><span class="params">(kind <span class="type">string</span>)</span></span> Search &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(query <span class="type">string</span>)</span></span> Result &#123;</span><br><span class="line">    time.Sleep(time.Duration(rand.Intn(<span class="number">100</span>)) * time.Millisecond)</span><br><span class="line">    <span class="keyword">return</span> Result(fmt.Sprintf(<span class="string">&quot;%s result for %q\n&quot;</span>, kind, query))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// How do we avoid discarding result from the slow server.</span></span><br><span class="line"><span class="comment">// We duplicates to many instance, and perform parallel request.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">      c &lt;- replicas[idx](query)</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// the magic is here. First function always waits for 1 time after receiving the result</span></span><br><span class="line">  <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// I don&#x27;t want to wait for slow server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Google</span><span class="params">(query <span class="type">string</span>)</span></span> []Result &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// each search performs in a goroutine</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c &lt;- First(query, Web1, Web2)</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c &lt;- First(query, Image1, Image2)</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c &lt;- First(query, Video1, Video2)</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> results []Result</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the global timeout for 3 queries</span></span><br><span class="line">  <span class="comment">// it means after 50ms, it ignores the result from the server that taking response greater than 50ms</span></span><br><span class="line">  timeout := time.After(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> r := &lt;-c:</span><br><span class="line">      results = <span class="built_in">append</span>(results, r)</span><br><span class="line">    <span class="comment">// this line ignore the slow server.</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">      fmt.Println(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> results</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  rand.Seed(time.Now().UnixNano())</span><br><span class="line">  start := time.Now()</span><br><span class="line">  results := Google(<span class="string">&quot;golang&quot;</span>)</span><br><span class="line">  elapsed := time.Since(start)</span><br><span class="line">  fmt.Println(results)</span><br><span class="line">  fmt.Println(elapsed)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="work-pool">work-pool</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Credit:</span></span><br><span class="line"><span class="comment">// https://gobyexample.com/worker-pools</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker pool benefits:</span></span><br><span class="line"><span class="comment">// - Efficiency because it distributes the work across threads.</span></span><br><span class="line"><span class="comment">// - Flow control: Limit work in flight</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Disadvantage of worker:</span></span><br><span class="line"><span class="comment">// Lifetimes complexity: clean up and idle worker</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Principles:</span></span><br><span class="line"><span class="comment">// Start goroutines whenever you have the concurrent work to do.</span></span><br><span class="line"><span class="comment">// The goroutine should exit as soon as posible the work is done. This helps us</span></span><br><span class="line"><span class="comment">// to clean up the resources and manage the lifetimes correctly.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, jobs &lt;-<span class="keyword">chan</span> <span class="type">int</span>, results <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> j := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;worker&quot;</span>, id, <span class="string">&quot;started job&quot;</span>, j)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;worker&quot;</span>, id, <span class="string">&quot;fnished job&quot;</span>, j)</span><br><span class="line">    results &lt;- j * <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workerEfficient</span><span class="params">(id <span class="type">int</span>, jobs &lt;-<span class="keyword">chan</span> <span class="type">int</span>, results <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// sync.WaitGroup helps us to manage the job</span></span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  <span class="keyword">for</span> j := <span class="keyword">range</span> jobs &#123;</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// we start a goroutine to run the job</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(job <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">      <span class="comment">// start the job</span></span><br><span class="line">      fmt.Println(<span class="string">&quot;worker&quot;</span>, id, <span class="string">&quot;started job&quot;</span>, job)</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">      fmt.Println(<span class="string">&quot;worker&quot;</span>, id, <span class="string">&quot;fnished job&quot;</span>, job)</span><br><span class="line">      results &lt;- job * <span class="number">2</span></span><br><span class="line">      wg.Done()</span><br><span class="line"></span><br><span class="line">    &#125;(j)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// With a help to manage the lifetimes of goroutines</span></span><br><span class="line">  <span class="comment">// we can add more handler when a goroutine finished</span></span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">const</span> numbJobs = <span class="number">8</span></span><br><span class="line">  jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, numbJobs)</span><br><span class="line">  results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, numbJobs)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. Start the worker</span></span><br><span class="line">  <span class="comment">// it is a fixed pool of goroutines receive and perform tasks from a channel</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// In this example, we define a fixed 3 workers</span></span><br><span class="line">  <span class="comment">// they receive the `jobs` from the channel jobs</span></span><br><span class="line">  <span class="comment">// we also naming the worker name with `w` variable.</span></span><br><span class="line">  <span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= <span class="number">3</span>; w++ &#123;</span><br><span class="line">    <span class="keyword">go</span> workerEfficient(w, jobs, results)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. send the work</span></span><br><span class="line">  <span class="comment">// other goroutine sends the work to the channels</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// in this example, the `main` goroutine sends the work to the channel `jobs`</span></span><br><span class="line">  <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= numbJobs; j++ &#123;</span><br><span class="line">    jobs &lt;- j</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(jobs)</span><br><span class="line">  fmt.Println(<span class="string">&quot;Closed job&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> a := <span class="number">1</span>; a &lt;= numbJobs; a++ &#123;</span><br><span class="line">    &lt;-results</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(results)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="崩溃处理-recover">崩溃处理(recover)</h2>
<blockquote>
<p><strong>在Go语言中，如果一个协程崩溃了，则所有协程都会退出</strong>，比如数组越界，会触发panic(相当于throw exception), 这对持续可运行的应用来说，显然不是我们想要的效果．那这个时候我们需要对崩溃进行修复.</p>
</blockquote>
<p>​     在<code>Go</code>语言中提供了一个<code>defer</code>和<code>recover</code>来实现崩溃恢复，这个相当于其它语言的<code>try catch</code>的方式．在使用<code>recover</code>函数时，如果要达到能捕获异常的作用，有几点需要注意：</p>
<ul>
<li><code>recover</code>如果想起作用的话， 必须在<code>defer</code>函数前声明，因为只要<code>panic</code>，后面的函数不会被执行</li>
<li><code>recover</code>函数只有在方法内部发生<code>panic</code>时，返回值不会为<code>nil</code>，没有<code>panic</code>的情况下返回值为<code>nil</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">)我·</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;我是A&quot;</span>, i)</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;崩溃&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    </span><br><span class="line">  fmt.Println(<span class="string">&quot;我是main&quot;</span>)</span><br><span class="line">  </span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">            <span class="comment">//在调用A函数前声明defer recover,能捕获异常</span></span><br><span class="line">      <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;恢复&quot;</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line">      wg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line">    A(i)</span><br><span class="line"></span><br><span class="line">  &#125;(<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;执行完了&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>如果在协程内执行其它函数时，为了保证不崩溃，安全的做法是，提前声明defer recover函数</strong></p>
<h1>参考链接</h1>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/374464199">https://zhuanlan.zhihu.com/p/374464199</a></li>
<li><a href="https://www.golangprograms.com/goroutines-and-channels-example.html">https://www.golangprograms.com/goroutines-and-channels-example.html</a></li>
<li><a href="https://github.com/lotusirous/go-concurrency-patterns">https://github.com/lotusirous/go-concurrency-patterns</a></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Service Mesh 介绍</title>
    <url>/2023/02/06/ServiceMesh%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h1>Service Mesh 介绍</h1>
<blockquote>
<p>Service Mesh 是微服务时代的 TCP/IP 协议</p>
</blockquote>
<p>​    <strong>一种控制应用程序的不同部分如何相互共享数据的方法</strong>。与其他用于管理此通信的系统不同，服务网格是内置于应用中的专用基础结构层。这个可见的基础结构层可以记录应用的不同部分的交互程度（或交互程度），因此随着应用的增长，优化通信和避免停机变得更加容易。														– redhat</p>
<p>​    Buoyant的CEO William Morgan，也就是Service Mesh这个词的发明人，对Service Mesh的定义：</p>
<p>​    服务网格是一个<strong>基础设施层</strong>，用于处理服务间通信。云原生应用有着复杂的服务拓扑，服务网格保证<strong>请求在这些拓扑中可靠地穿梭</strong>。在实际应用当中，服务网格通常是由一系列轻量级的<strong>网络代理</strong>组成的，<strong>它们与应用程序部署在一起，但对应用程序透明。</strong></p>
<h2 id="演化进程">演化进程</h2>
<h3 id="时代0">时代0</h3>
<p>开发人员想象中，不同服务间通信的方式，抽象表示如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/v2-2a182cea5ab0f7d625776a9446cd596b_1440w.jpg" alt="img"></p>
<h3 id="时代1：原始通信时代">时代1：原始通信时代</h3>
<p>​     然而现实远比想象的复杂，在实际情况中，通信需要底层能够传输字节码和电子信号的物理层来完成，在TCP协议出现之前，服务需要自己处理网络通信所面临的丢包、乱序、重试等一系列流控问题，<strong>因此服务实现中，除了业务逻辑外，还夹杂着对网络传输问题的处理逻辑。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/v2-1443e6bebd93d5e6bb1c18197676d29b_1440w.jpg" alt="img"></p>
<span id="more"></span>
<h3 id="时代2：TCP时代">时代2：<code>TCP</code>时代</h3>
<p>​    为了避免每个服务都需要自己实现一套相似的网络传输处理逻辑，TCP协议出现了，它解决了网络传输中通用的流量控制问题，将技术栈下移，从服务的实现中抽离出来，成为操作系统网络层的一部分。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/v2-9e6c4c6b4229b947b4efdf63de86f695_1440w.jpg" alt="img"></p>
<h3 id="时代3：第一代微服务">时代3：第一代微服务</h3>
<p>​    在TCP出现之后，机器之间的网络通信不再是一个难题，以<code>GFS/BigTable/MapReduce</code>为代表的分布式系统得以蓬勃发展。这时，分布式系统特有的通信语义又出现了，如熔断策略、负载均衡、服务发现、认证和授权、quota限制、trace和监控等等，于是服务根据业务需求来实现一部分所需的通信语义。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/v2-b31cc447637c71b887ac80c0bfa680d4_1440w.jpg" alt="img"></p>
<h3 id="时代4：第二代微服务">时代4：第二代微服务</h3>
<p>​    为了避免每个服务都需要自己实现一套分布式系统通信的语义功能，随着技术的发展，一些面向微服务架构的开发框架出现了，如<code>Twitter</code>的<a href="https://link.zhihu.com/?target=https%3A//finagle.github.io/">Finagle</a>、<code>Facebook</code>的<a href="https://link.zhihu.com/?target=https%3A//code.facebook.com/posts/1503205539947302">Proxygen</a>以及<code>Spring Cloud</code>等等，这些框架实现了分布式系统通信需要的各种通用语义功能：如负载均衡和服务发现等，因此<strong>一定程度上屏蔽了这些通信细节，使得开发人员使用较少的框架代码就能开发出健壮的分布式系统。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/v2-9382bf9facb290eceed01d998ac2ef44_1440w.jpg" alt="img"></p>
<h3 id="时代5：第一代Service-Mesh">时代5：第一代Service Mesh</h3>
<blockquote>
<p>代表项目：<code>Linkerd</code> 和 <code>Envoy </code>为代表</p>
</blockquote>
<p>第二代微服务模式看似完美，但开发人员很快又发现，它也存在一些本质问题：</p>
<ul>
<li>其一，虽然框架本身屏蔽了分布式系统通信的一些通用功能实现细节，但<strong>开发者却要花更多精力去掌握和管理复杂的框架本身</strong>，在实际应用中，去追踪和解决框架出现的问题也绝非易事；</li>
<li>其二，<strong>开发框架通常只支持一种或几种特定的语言</strong>，回过头来看文章最开始对微服务的定义，一个重要的特性就是语言无关，但那些没有框架支持的语言编写的服务，很难融入面向微服务的架构体系，想因地制宜的用多种语言实现架构体系中的不同模块也很难做到；</li>
<li>其三，框架以lib库的形式和服务联编，复杂项目依赖时的库版本兼容问题非常棘手，同时，框架库的升级也无法对服务透明，<strong>服务会因为和业务无关的lib库升级而被迫升级</strong>；</li>
</ul>
<p>​    因此以<code>Linkerd</code>，<code>Envoy</code>，<code>NginxMesh</code>为代表的代理模式（边车模式）应运而生，这就是第一代<code>Service Mesh</code>，<strong>它将分布式服务的通信抽象为单独一层，在这一层中实现负载均衡、服务发现、认证授权、监控追踪、流量控制等分布式系统所需要的功能</strong>，作为一个和服务对等的代理服务，和服务部署在一起，接管服务的流量，通过代理之间的通信间接完成服务之间的通信请求，这样上边所说的三个问题也迎刃而解。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/v2-e5660d35a311467c3323f10ebf2fb9a5_1440w.jpg" alt="img"></p>
<p>如果我们从一个全局视角来看，就会得到如下部署图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/v2-8a9cc161a34d97f36ead06d0abc5b1fb_1440w.jpg" alt="img"></p>
<p>如果我们暂时略去服务，只看Service Mesh的单机组件组成的网络：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/v2-ee0bde35f9ec79bf38feda98550b8f71_1440w.jpg" alt="img"></p>
<p>相信现在，大家已经理解何所谓<code>Service Mesh</code>，也就是服务网格了。它看起来确实就像是一个由若干服务代理所组成的错综复杂的网格。</p>
<h3 id="时代6：第二代Service-Mesh">时代6：第二代Service Mesh</h3>
<blockquote>
<p>代表项目： <a href="https://istio.io/">Istio</a> 和 <a href="https://conduit.io/">Conduit</a></p>
</blockquote>
<p>​    第一代<code>Service Mesh</code>由<strong>一系列独立运行的单机代理服务构成</strong>，为了提供统一的上层运维入口，演化出了集中式的控制面板，<strong>所有的单机代理组件通过和控制面板交互进行网络拓扑策略的更新和单机数据的汇报</strong>。这就是以<code>Istio</code>为代表的第二代<code>Service Mesh</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/v2-546ed82e25d83a2cb404b0a3f526f9c6_1440w.jpg" alt="img"></p>
<p>只看单机代理组件(数据面板)和控制面板的Service Mesh全局部署视图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/v2-8686840abd3de29e5cb6e8dcfa78182f_1440w.jpg" alt="img"></p>
<h1>小结</h1>
<p>Service Mesh具有如下优点：</p>
<ul>
<li>屏蔽分布式系统通信的复杂性(负载均衡、服务发现、认证授权、监控追踪、流量控制等等)，服务只用关注业务逻辑；</li>
<li>真正的语言无关，服务可以用任何语言编写，只需和Service Mesh通信即可；</li>
<li>对应用透明，Service Mesh组件可以单独升级；</li>
</ul>
<p>当然，Service Mesh目前也面临一些挑战：</p>
<ul>
<li>Service Mesh组件以代理模式计算并转发请求，一定程度上会降低通信系统性能，并增加系统资源开销；</li>
<li>Service Mesh组件接管了网络流量，因此服务的整体稳定性依赖于Service Mesh，同时额外引入的大量Service Mesh服务实例的运维和管理也是一个挑战；</li>
</ul>
<p>​    历史总是惊人的相似。为了解决端到端的字节码通信问题，TCP协议诞生，让多机通信变得简单可靠；微服务时代，Service Mesh应运而生，屏蔽了分布式系统的诸多复杂性，让开发者可以回归业务，聚焦真正的价值。</p>
<h1>参考链接</h1>
<ul>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/61901608">什么是 Service Mesh - 知乎 (zhihu.com)</a></p>
</li>
<li>
<p><a href="https://philcalcado.com/2017/08/03/pattern_service_mesh.html">Pattern: Service Mesh (philcalcado.com)</a></p>
</li>
<li>
<p><a href="https://www.redhat.com/en/topics/microservices/what-is-a-service-mesh">What’s a service mesh? (redhat.com)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>CloudNative</category>
      </categories>
      <tags>
        <tag>Service Mesh</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊分布式事务</title>
    <url>/2023/02/06/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1>聊聊分布式事务</h1>
<h2 id="前言">前言</h2>
<p>​    随着业务的快速发展、业务复杂度越来越高，传统单体应用逐渐暴露出了一些问题，例如开发效率低、可维护性差、架构扩展性差、部署不灵活、健壮性差等等。</p>
<p>​    微服务架构是一个分布式的系统，按业务进行划分为独立的服务单元，解决单体系统的不足，同时也满足越来越复杂的业务需求。每个微服务仅关注于完成一件任务并很好地完成该任务。</p>
<h2 id="微服务架构的特点">微服务架构的特点</h2>
<p>微服务架构的优势非常明显，在近些年迅猛发展。</p>
<ul>
<li>将复杂的业务拆分成多个小的业务，能够达到更好的业务复用，有利于人员组织分工</li>
<li>服务独立部署，独立扩容，每个服务的修改和部署对其他服务没有影响</li>
<li>每个服务可以根据业务场景选取合适的编程语言和数据库</li>
</ul>
<p>微服务有以上的优势，但是微服务也带来不少的新问题，例如：</p>
<ul>
<li>服务数量众多，其测试、部署、监控等都变的更加困难。</li>
<li>单体应用拆分为分布式系统后，进程间的通讯机制和故障处理措施变的更加复杂</li>
<li>系统微服务化后，原先是一个服务内部的本地数据库事务，被拆到了多个服务，需要在分布式环境下保证事务的一致性</li>
</ul>
<p>上述的各项问题中，1、2都可以通过近几年涌现的各项微服务技术解决，例如<code>Kubernetes</code>提供了服务发现、服务治理等。</p>
<p><strong>因此分布式事务已经成为微服务落地最大的阻碍，也是最具挑战性的一个技术难题。</strong></p>
<h3 id="CAP-理论">CAP 理论</h3>
<p>一个分布式系统最多只能同时满足 <code>一致性（Consistency）</code>、<code>可用性（Availability）</code>和<code>分区容错性（Partition tolerance）</code>这三项中的两项。</p>
<h2 id="分布式事务方案">分布式事务方案</h2>
<p>分布式事务模式常见的有<code>XA</code>、<code>TCC</code>、<code>SAGA</code>、<code>可靠消息</code>。</p>
<span id="more"></span>
<h3 id="两阶段提交XA">两阶段提交<code>XA</code></h3>
<p>​    <code>XA </code>是由<code>X/Open</code>组织提出的分布式事务的规范，<code>XA</code>规范主要定义了（全局）事务管理器（TM）和（局部）资源管理器（RM）之间的接口。本地的数据库如<code>MySQL</code>在<code>XA</code>中扮演的是<code>RM</code>角色。</p>
<p>​    <code>XA</code>一共分为两阶段：</p>
<ul>
<li>
<p>第一阶段（prepare）：即所有的参与者RM准备执行事务并锁住需要的资源。参与者ready时，向TM报告已准备就绪。</p>
</li>
<li>
<p>第二阶段（commit/rollback）：当事务管理者（TM）确认所有参与者（RM）都ready后，向所有参与者发送commit命令。</p>
</li>
</ul>
<p>目前主流的数据库基本都支持<code>XA</code>事务，包括<code>MySQL</code>、<code>Oracle</code>、<code>SQLServer</code>、<code>PostgreSQL</code>。</p>
<p>一个成功完成的<code>XA</code>事务时序图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/202205201524887.jpeg" alt="img"></p>
<h3 id="TCC事务方案"><code>TCC</code>事务方案</h3>
<p>​    <code>TCC</code>方案其实是<code>XA</code>提交的一种改进。其将整个业务逻辑的每个分支显式的分成了<code>Try</code>、<code>Confirm</code>、<code>Cancel</code>三个操作。<code>Try</code>部分完成业务的准备工作，<code>confirm</code>部分完成业务的提交，<code>cancel</code>部分完成事务的回滚。</p>
<p>​    事务开始时，业务应用会向事务协调器注册启动事务。之后业务应用会调用所有服务的<code>try</code>接口，完成一阶段准备。之后事务协调器会根据<code>try</code>接口返回情况，决定调用<code>confirm接口</code>或者<code>cancel接口</code>。如果接口调用失败，会进行重试。</p>
<p>一个成功完成的<code>TCC</code>事务时序图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/202205201829792.jpeg" alt="img"></p>
<h3 id="SAGA事务方案">SAGA事务方案</h3>
<p>​    <code>Saga</code>和<code>TCC</code>一样，也是最终一致性事务、柔性事务。Saga的本质就是把一个长事务分隔成一个个小的事务，每个事务都包含一个执行模块和补偿模块。</p>
<p>​    <code>Saga</code>没有<code>try</code>，直接提交事务，可能出现脏读的情况，在某些对一致性要求较高的场景下，是不可接受的。</p>
<p>​    在启动一个<code>Saga</code>事务时，事务管理器会告诉第一个<code>Saga</code>参与者，也就是子事务，去执行本地事务。事务完成之后<code>Saga</code>的会按照执行顺序调用<code>Saga</code>的下一个参与的子事务。这个过程会一直持续到<code>Saga</code>事务执行完毕。</p>
<p>如果在执行子事务的过程中遇到子事务对应的本地事务失败，则<code>Saga</code>会按照相反的顺序执行补偿事务。</p>
<p>一个成功完成的SAGA事务时序图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/202205201828396.jpeg" alt="img"></p>
<h3 id="可靠消息">可靠消息</h3>
<p>​    消息一致性方案是通过消息中间件保证上下游应用数据操作的一致性。基本思路是将本地操作和发送消息放在一个本地事务中，保证本地操作和消息发送要么两者都成功或者都失败。下游应用向消息系统订阅该消息，收到消息后执行相应操作。</p>
<p><code>RocketMQ</code> 提供了典型的可靠消息接口，可以参考。</p>
<h3 id="分布式事务开源项目">分布式事务开源项目</h3>
<p>​    当前的分布式事务领域，有<code>java</code>语言的开源项目，以<code>seata</code>为代表。在非Java领域，Go语言的<code> DTM</code> 是代表项目。 <code>DTM </code>支持<code>XA</code>、<code>TCC</code>、<code>SAGA</code>、可靠消息，架构图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/202205201530623.jpeg" alt="img"></p>
<p>图中的各角色与<code>XA</code>模型中的角色模型一致，分别解释如下：</p>
<ul>
<li>AP应用程序（定义和提交事务，当前支持Go语言，即将支持<code>Nodejs</code>、<code>Python</code>、<code>PHP</code>、Rust等）</li>
<li>RM资源管理器（负责管理本地事务，不限语言，只要提供了<code>http</code>相关的接口即可）</li>
<li>TM事务管理器（<code>DTM</code>，协调全局事务，进行提交以及回滚）</li>
</ul>
<p>在上述的架构图中，<code>AP</code>通过<code>DTM</code>提供的分布式事务接口，与<code>RM</code>和<code>TM</code>交互，对现有的微服务，侵入很小。</p>
<p>另外在实际的业务中，AP和RM角色可能会有重叠，例如<code>TCC</code>模式下，AP可能有自己的本地事务，也会注册并调用其他事务分支。</p>
]]></content>
      <categories>
        <category>分布式事务</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Runtime:Golang 处理系统调用阻塞方式</title>
    <url>/2023/02/06/Runtime%EF%BC%9AGolang%20%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%98%BB%E5%A1%9E%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1>Runtime：Golang 处理系统调用阻塞方式</h1>
<blockquote>
<p>当一个Goroutine由于执行 <code>系统调用</code> 而阻塞时，会将M从GPM中分离出去，然后P再找一个G和M重新执行，避免浪费CPU资源。</p>
</blockquote>
<h2 id="前言">前言</h2>
<h2 id="什么是-runtime">什么是 runtime</h2>
<p>​    runtime 描述了<strong>程序运行时候</strong>执行的软件/指令， 在每种语言有着不同的实现。可大可小，在 C 中，runtime 是库代码， 等同于<code> C runtime library</code>，一系列 <code>C </code>程序运行所需的函数，在<code>Java</code>中，<code>runtime</code> 还提供了 <code>Java</code> 程序运行所需的虚拟机等。</p>
<p>​    总而言之，<strong>runtime 是一个通用抽象的术语，指的是计算机程序运行的时候所需要的一切代码库，框架，平台等</strong>。</p>
<h2 id="Go中的-runtime">Go中的 runtime</h2>
<p>在 Go 中， 有一个 runtime 库，其实现了垃圾回收，并发控制， 栈管理以及其他一些 Go 语言的关键特性。 runtime 库是每个 Go 程序的一部分，也就是说编译 Go 代码为机器代码时也会将其也编译进来。所以 Go 官方将其定位偏向类似于 C 语言中的库。Go 中的 runtime 不像 Java runtime （JRE， java runtime envirement ) 一样，jre 还会提供虚拟机， Java 程序要在 JRE 下 才能运行。</p>
<p>所以在 Go 语言中， runtime 只是提供支持语言特性的库的名称，也就是 Go 程序执行时候使用的库。</p>
<h2 id="P的状态切换">P的状态切换</h2>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/202205201526793.png" alt="P的状态切换"></p>
<p>​    从上图我们可以看出 <code>P</code> 执行系统调用时会执行 <code>entersyscall()</code> 函数（另还有一个类似的阻塞函数 <a href="https://github.com/golang/go/blob/go1.15.6/src/runtime/proc.go#L3171-L3212"><code>entersyscallblock()</code></a> ，注意两者的区别）。当系统调用执行完毕切换回去会执行 <a href="https://github.com/golang/go/blob/go1.15.6/src/runtime/proc.go#L3222-L3305"><code>exitsyscall()</code></a> 函数，下面我们看一下这两个函数的实现。</p>
<span id="more"></span>
<h1>进入系统调用</h1>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Standard syscall entry used by the go syscall library and normal cgo calls.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This is exported via linkname to assembly in the syscall package.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname entersyscall</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entersyscall</span><span class="params">()</span></span> &#123;</span><br><span class="line">  reentersyscall(getcallerpc(), getcallersp())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当通过Golang标准库 <code>syscall</code> 或者 <code>cgo</code> 调用时会执行 <code>entersyscall() </code>函数，并通过 <code>go:linkname</code> 方式导出为标准包。此函数只是对 <code>reentersyscall()</code> 函数的封装，我们看下这个函数实现了什么。</p>
<p>函数注释比较多，这里只帖子重点的一部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// The goroutine g is about to enter a system call.</span><br><span class="line"></span><br><span class="line">// Record that it&#x27;s not using the cpu anymore.</span><br><span class="line"></span><br><span class="line">// This is called only from the go syscall library and cgocall,</span><br><span class="line"></span><br><span class="line">// not from the low-level system calls used by the runtime.</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">// Entersyscall cannot split the stack: the gosave must</span><br><span class="line"></span><br><span class="line">// make g-&gt;sched refer to the caller&#x27;s stack segment, because</span><br><span class="line"></span><br><span class="line">// entersyscall is going to return immediately after.</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">// Nothing entersyscall calls can split the stack either.</span><br><span class="line"></span><br><span class="line">// We cannot safely move the stack during an active call to syscall,</span><br><span class="line"></span><br><span class="line">// because we do not know which of the uintptr arguments are</span><br><span class="line"></span><br><span class="line">// really pointers (back into the stack).</span><br><span class="line"></span><br><span class="line">// In practice, this means that we make the fast path run through</span><br><span class="line"></span><br><span class="line">// entersyscall doing no-split things, and the slow path has to use systemstack</span><br><span class="line"></span><br><span class="line">// to run bigger things on the system stack.</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">// reentersyscall is the entry point used by cgo callbacks, where explicitly</span><br><span class="line"></span><br><span class="line">// saved SP and PC are restored. This is needed when exitsyscall will be called</span><br><span class="line"></span><br><span class="line">// from a function further up in the call stack than the parent, as g-&gt;syscallsp</span><br><span class="line"></span><br><span class="line">// must always point to a valid stack frame. entersyscall below is the normal</span><br><span class="line"></span><br><span class="line">// entry point for syscalls, which obtains the SP and PC from the caller.</span><br></pre></td></tr></table></figure>
<p>从注释我们得知以下信息：</p>
<ul>
<li>调用此函数，<code>goroutine</code> 即将进入系统调用，将不会使用P。此函数只能通过标准的 <code>syscall</code> 库和 <code>cgocall</code> 调用</li>
<li><code>entersyscall()</code> 函数是<code>禁止栈分裂</code>的， <code>gosave()</code> 函数必须将 <code>g-&gt;sched</code> 指向它的调用者的栈段，这是因为 <code>entersyscall()</code> 函数返回时要使用（不清楚的话，可以点击<a href="https://studygolang.com/articles/12443">这里</a>）</li>
<li><code>reentersyscall()</code> 函数是cgo的回调执行函数，它保存了已经恢复的 <code>SP/PC</code> 。</li>
<li><code>reentersyscall()</code> 是不允许分裂的 <code>go:nosplit</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reentersyscall</span><span class="params">(pc, sp <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line">    <span class="comment">// Disable preemption because during this function g is in Gsyscall status,</span></span><br><span class="line">    <span class="comment">// but can have inconsistent g-&gt;sched, do not let GC observe it.</span></span><br><span class="line">    _g_.m.locks++</span><br><span class="line">    <span class="comment">// Entersyscall must not call any function that might split/grow the stack.</span></span><br><span class="line">    <span class="comment">// (See details in comment above.)</span></span><br><span class="line">    <span class="comment">// Catch calls that might, by replacing the stack guard with something that</span></span><br><span class="line">    <span class="comment">// will trip any stack check and leaving a flag to tell newstack to die.</span></span><br><span class="line">    _g_.stackguard0 = stackPreempt</span><br><span class="line">    _g_.throwsplit = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// Leave SP around for GC and traceback.</span></span><br><span class="line">    <span class="comment">// 更新 g.sched 相关信息，后期需要读取这些信息</span></span><br><span class="line">    save(pc, sp)</span><br><span class="line">    <span class="comment">// 记录g的系统调用SP/PC</span></span><br><span class="line">    _g_.syscallsp = sp</span><br><span class="line">    _g_.syscallpc = pc</span><br><span class="line">    <span class="comment">// 设置g的状态为 _Gsyscall</span></span><br><span class="line">    casgstatus(_g_, _Grunning, _Gsyscall)</span><br><span class="line">    <span class="keyword">if</span> _g_.syscallsp &lt; _g_.stack.lo || _g_.stack.hi &lt; _g_.syscallsp &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;entersyscall inconsistent &quot;</span>, hex(_g_.syscallsp), <span class="string">&quot; [&quot;</span>, hex(_g_.stack.lo), <span class="string">&quot;,&quot;</span>, hex(_g_.stack.hi), <span class="string">&quot;]n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;entersyscall&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        systemstack(traceGoSysCall)</span><br><span class="line">        <span class="comment">// systemstack itself clobbers g.sched.&#123;pc,sp&#125; and we might</span></span><br><span class="line">        <span class="comment">// need them later when the G is genuinely blocked in a</span></span><br><span class="line">        <span class="comment">// syscall</span></span><br><span class="line">        save(pc, sp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;sched.sysmonwait) != <span class="number">0</span> &#123;</span><br><span class="line">        systemstack(entersyscall_sysmon)</span><br><span class="line">        save(pc, sp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _g_.m.p.ptr().runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// runSafePointFn may stack split if run on this stack</span></span><br><span class="line">        systemstack(runSafePointFn)</span><br><span class="line">        save(pc, sp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新与当前g关联P的执行调用系统调用次数</span></span><br><span class="line">    _g_.m.syscalltick = _g_.m.p.ptr().syscalltick</span><br><span class="line">    _g_.sysblocktraced = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 设置当前 m 所关联的 P 为下次优先使用的P（m.oldp = p), 实现亲和性</span></span><br><span class="line">    pp := _g_.m.p.ptr()</span><br><span class="line">    pp.m = <span class="number">0</span></span><br><span class="line">    _g_.m.oldp.set(pp)</span><br><span class="line">    <span class="comment">//  解除 m 与 p 的关联</span></span><br><span class="line">    _g_.m.p = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 修改P的状态为 _Psyscall</span></span><br><span class="line">    atomic.Store(&amp;pp.status, _Psyscall)</span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">        systemstack(entersyscall_gcwait)</span><br><span class="line">        save(pc, sp)</span><br><span class="line">    &#125;</span><br><span class="line">    _g_.m.locks--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要有以下工作：</p>
<ul>
<li>在开始前需要进行 <code>_g_.m.locks++</code>, 以防止GC，函数执行结束时再减少一个锁</li>
<li>要进行禁止栈分裂</li>
<li>通过 <code>save()</code> 函数将当前调度需要的信息暂存到 <code>_g_.sched</code></li>
<li>修改 <code>G</code> 和 <code>P</code> 的状态为系统调用状态</li>
<li>将本次 <code>m</code> 绑定的 P 保存到 <code>_g_.oldp</code> 字段中，以备系统调用完毕后可以优先使用当前P继续执行</li>
</ul>
<h1>退出系统调用</h1>
<p>​    当一个<code>goroutine</code>系统调用结束后，需要再次将<code>GM</code>重新与<code>P</code>关联继续执行，<code>Golang</code> 为了亲和性，会优先与上次执行的P绑定，如果上次关联的 <code>P</code> 正在被使用，这时再考虑重新找一个新的<code>P </code>关联。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The goroutine g exited its system call.</span></span><br><span class="line"><span class="comment">// Arrange for it to run on a cpu again.</span></span><br><span class="line"><span class="comment">// This is called only from the go syscall library, not</span></span><br><span class="line"><span class="comment">// from the low-level system calls used by the runtime.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write barriers are not allowed because our P may have been stolen.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This is exported via linkname to assembly in the syscall package.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="comment">//go:linkname exitsyscall</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitsyscall</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>同 <code>reentersyscall()</code> 函数一样，<code>exitsyscall() </code>函数也是通过调用go的标准系统调用库实现的，而不是使用底层的<code>runtime</code>调用方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitsyscall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line">    _g_.m.locks++ <span class="comment">// see comment in entersyscall</span></span><br><span class="line">    <span class="keyword">if</span> getcallersp() &gt; _g_.syscallsp &#123;</span><br><span class="line">        throw(<span class="string">&quot;exitsyscall: syscall frame is no longer valid&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置g阻塞时间为0</span></span><br><span class="line">    _g_.waitsince = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 取出上次关联的P，优先使用</span></span><br><span class="line">    oldp := _g_.m.oldp.ptr()</span><br><span class="line">    _g_.m.oldp = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 与原来的P进行关联</span></span><br><span class="line">    <span class="keyword">if</span> exitsyscallfast(oldp) &#123;</span><br><span class="line">        <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">            <span class="keyword">if</span> oldp != _g_.m.p.ptr() || _g_.m.syscalltick != _g_.m.p.ptr().syscalltick &#123;</span><br><span class="line">                systemstack(traceGoStart)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// There&#x27;s a cpu for us, so we can run.</span></span><br><span class="line">        _g_.m.p.ptr().syscalltick++</span><br><span class="line">        <span class="comment">// We need to cas the status and scan before resuming...</span></span><br><span class="line">        <span class="comment">// G 的状态恢复为 _Grunning</span></span><br><span class="line">        casgstatus(_g_, _Gsyscall, _Grunning)</span><br><span class="line">        <span class="comment">// Garbage collector isn&#x27;t running (since we are),</span></span><br><span class="line">        <span class="comment">// so okay to clear syscallsp.</span></span><br><span class="line">        _g_.syscallsp = <span class="number">0</span></span><br><span class="line">        _g_.m.locks--</span><br><span class="line">        <span class="keyword">if</span> _g_.preempt &#123;</span><br><span class="line">            <span class="comment">// restore the preemption request in case we&#x27;ve cleared it in newstack</span></span><br><span class="line">            _g_.stackguard0 = stackPreempt</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// otherwise restore the real _StackGuard, we&#x27;ve spoiled it in entersyscall/entersyscallblock</span></span><br><span class="line">            _g_.stackguard0 = _g_.stack.lo + _StackGuard</span><br><span class="line">        &#125;</span><br><span class="line">        _g_.throwsplit = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(_g_) &#123;</span><br><span class="line">            <span class="comment">// Scheduling of this goroutine is disabled.</span></span><br><span class="line">            Gosched()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    _g_.sysexitticks = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        <span class="comment">// Wait till traceGoSysBlock event is emitted.</span></span><br><span class="line">        <span class="comment">// This ensures consistency of the trace (the goroutine is started after it is blocked).</span></span><br><span class="line">        <span class="keyword">for</span> oldp != <span class="literal">nil</span> &amp;&amp; oldp.syscalltick == _g_.m.syscalltick &#123;</span><br><span class="line">            osyield()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We can&#x27;t trace syscall exit right now because we don&#x27;t have a P.</span></span><br><span class="line">        <span class="comment">// Tracing code can invoke write barriers that cannot run without a P.</span></span><br><span class="line">        <span class="comment">// So instead we remember the syscall exit time and emit the event</span></span><br><span class="line">        <span class="comment">// in execute when we have a P.</span></span><br><span class="line">        _g_.sysexitticks = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    _g_.m.locks--</span><br><span class="line">    <span class="comment">// Call the scheduler.</span></span><br><span class="line">    <span class="comment">// 在g0上调用 exitsyscall0() 函数, 执行流程到这里的话，说明并没有找到空闲的P，此时需要将G和M进行解绑，分别入相应的队列等待下次执行</span></span><br><span class="line">    mcall(exitsyscall0)</span><br><span class="line">    <span class="comment">// Scheduler returned, so we&#x27;re allowed to run now.</span></span><br><span class="line">    <span class="comment">// Delete the syscallsp information that we left for</span></span><br><span class="line">    <span class="comment">// the garbage collector during the system call.</span></span><br><span class="line">    <span class="comment">// Must wait until now because until gosched returns</span></span><br><span class="line">    <span class="comment">// we don&#x27;t know for sure that the garbage collector</span></span><br><span class="line">    <span class="comment">// is not running.</span></span><br><span class="line">    <span class="comment">// 以下信息必须等待调度器返回才可以重置，gc考虑</span></span><br><span class="line">    _g_.syscallsp = <span class="number">0</span></span><br><span class="line">    _g_.m.p.ptr().syscalltick++</span><br><span class="line">    _g_.throwsplit = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当系统调用返回时，通过函数 <code>exitsyscallfast()</code> 优先与上次关联的 <code>oldp</code> 进行关联，否则重新获取一个新的<code>P</code>。如果重新获取新<code>P</code>也失败的话，这时候就需要将<code>GM</code>进行解绑，分别入等待执行队列等待下次的调度执行。</p>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/202205111736507.png" alt="img"></p>
<h2 id="有P关联">有P关联</h2>
<p>上面我们说过与P关联时会优先使用上次使用的P，这里我们先看下与<code>oldp</code> 绑定的逻辑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitsyscallfast</span><span class="params">(oldp *p)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Freezetheworld sets stopwait but does not retake P&#x27;s.</span></span><br><span class="line">    <span class="keyword">if</span> sched.stopwait == freezeStopWait &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try to re-acquire the last P.</span></span><br><span class="line">    <span class="comment">// 尝试与上次的P关联</span></span><br><span class="line">    <span class="keyword">if</span> oldp != <span class="literal">nil</span> &amp;&amp; oldp.status == _Psyscall &amp;&amp; atomic.Cas(&amp;oldp.status, _Psyscall, _Pidle) &#123;</span><br><span class="line">        <span class="comment">// There&#x27;s a cpu for us, so we can run.</span></span><br><span class="line">        wirep(oldp)</span><br><span class="line">        exitsyscallfast_reacquired()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try to get any other idle P.</span></span><br><span class="line">    <span class="keyword">if</span> sched.pidle != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> ok <span class="type">bool</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 获取另一个P</span></span><br><span class="line">            ok = exitsyscallfast_pidle()</span><br><span class="line">            <span class="keyword">if</span> ok &amp;&amp; trace.enabled &#123;</span><br><span class="line">                <span class="keyword">if</span> oldp != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="comment">// Wait till traceGoSysBlock event is emitted.</span></span><br><span class="line">                    <span class="comment">// This ensures consistency of the trace (the goroutine is started after it is blocked).</span></span><br><span class="line">                    <span class="keyword">for</span> oldp.syscalltick == _g_.m.syscalltick &#123;</span><br><span class="line">                        osyield()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                traceGoSysExit(<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里优先通过调用 <code>wirep()</code> 函数实现与上次使用的P关联。如果关联失败，再去看调度器里是否有空闲的P可以用（<code>sched.pidle != 0</code>）。如果有的话，则通过 <code>exitsyscallfast_pidle()</code> 函数里的 <code>pidleget()</code> 重新获取一个新的P进行关联。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Try get a p from _Pidle list.</span></span><br><span class="line"><span class="comment">// Sched must be locked.</span></span><br><span class="line"><span class="comment">// May run during STW, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pidleget</span><span class="params">()</span></span> *p &#123;</span><br><span class="line">    _p_ := sched.pidle.ptr()</span><br><span class="line">    <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">        sched.pidle = _p_.link</span><br><span class="line">        atomic.Xadd(&amp;sched.npidle, <span class="number">-1</span>) <span class="comment">// <span class="doctag">TODO:</span> fast atomic</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _p_</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="无P关联">无P关联</h2>
<p>如果所有的 <code>P</code> 都处于繁忙状态，可能无法获取空闲的P，这时就不得不先将GM解除关联，然后放入各自的等待队列里，等待下次的调度。实现函数为 <code>exitsyscall0()</code>, 此函数需要在系统栈上执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exitsyscall slow path on g0.</span></span><br><span class="line"><span class="comment">// Failed to acquire P, enqueue gp as runnable.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitsyscall0</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// G 状态为等待执行状态</span></span><br><span class="line">    casgstatus(gp, _Gsyscall, _Grunnable)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除m与G的关联</span></span><br><span class="line">    dropg()</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">var</span> _p_ *p</span><br><span class="line">    <span class="keyword">if</span> schedEnabled(_g_) &#123;</span><br><span class="line">        _p_ = pidleget()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 将g 放放全局运行队列</span></span><br><span class="line">        globrunqput(gp)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> atomic.Load(&amp;sched.sysmonwait) != <span class="number">0</span> &#123;</span><br><span class="line">        atomic.Store(&amp;sched.sysmonwait, <span class="number">0</span>)</span><br><span class="line">        notewakeup(&amp;sched.sysmonnote)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里再检查一次是否有p可用，有的话，正好重新再获取一个G立即执行</span></span><br><span class="line">    <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">        acquirep(_p_)</span><br><span class="line">        execute(gp, <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Wait until another thread schedules gp and so m again.</span></span><br><span class="line">        stoplockedm()</span><br><span class="line">        execute(gp, <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 停止M</span></span><br><span class="line">    stopm()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新调度</span></span><br><span class="line">    schedule() <span class="comment">// Never returns.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>stopm() </code>函数会停止当前<code>m</code>执行，直到有新的G需要执行。m停止后被调用 <code>mput()</code> 函数将当前<code>m</code>放在一下 <code>sched.midle</code> 空闲列表里。</p>
<h1>总结</h1>
<ul>
<li>当进入系统调用时，先记录下当前 G 的调度信息，包括当前使用的 P</li>
<li>退出系统调用时，优先使用上次使用的P；如果原来的P已被使用，则重新找一个新的P；如果无P可用，则先当前的GM关系先解除，放入各自的待执行队列，等待下次调度再执行。这里的执行队列为全局 <code>sched</code> 。</li>
</ul>
<h1>参考链接</h1>
<ul>
<li><a href="https://blog.haohtml.com/archives/23551">https://blog.haohtml.com/archives/23551</a></li>
<li><a href="https://studygolang.com/articles/28812#:~:text=Go%E4%B8%AD%E7%9A%84runtime,C%20%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%BA%93%E3%80%82">https://studygolang.com/articles/28812#:~:text=Go中的runtime,C 语言中的库。</a></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>GPM调度器</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX 环境高级编程 - 文件和目录</title>
    <url>/2023/02/06/Unix%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h1>Unix高级编程之文件和目录</h1>
<h2 id="文件类型">文件类型</h2>
<h3 id="普通文件（regular-file）">普通文件（regular file）</h3>
<ul>
<li>这是最常用的文件类型，这种文件包含了某种形式的数据。例如文本文件、二进制可执行文件等等。</li>
<li>不管文件是何种格式，其用途如何，对于 Unix 文件系统对此类文件的管理是完全一致的。</li>
<li>对普通文件内容的解释由处理该文件的应用程序进行。</li>
</ul>
<h3 id="目录文件（directory-file）">目录文件（directory file）</h3>
<ul>
<li>这种文件包含了其他文件的名字以及指向与这些文件有关信息的指针。</li>
<li>对于一个目录文件具有读权限的任一进程都可以读取该目录的内容，但只有内核可以直接写目录文件。</li>
</ul>
<h3 id="块特殊文件（block-special-file）">块特殊文件（block special file）</h3>
<ul>
<li>这种类型的文件提供对设备（如磁盘）带缓冲的访问，每次访问以固定长度为单位进行。</li>
</ul>
<h3 id="字符特殊文件-（character-special-file）">字符特殊文件 （character special file）</h3>
<ul>
<li>这种类型的文件提供对设备不带缓冲的访问，每次访问的长度可变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件。</li>
</ul>
<h3 id="FIFO">FIFO</h3>
<ul>
<li>这种类型的文件用于进程间的通信，有时也称为命名管道（named pipe）</li>
</ul>
<h3 id="套接字（socket）">套接字（socket）</h3>
<ul>
<li>这种类型的文件用于进程间的网络通信。</li>
<li>也可用于在一台宿主机上进程之间的非网络通信。</li>
</ul>
<h3 id="符号链接（symbolic-link）">符号链接（symbolic link）</h3>
<ul>
<li>这种类型的文件指向另一个文件。</li>
</ul>
]]></content>
      <categories>
        <category>UNIX</category>
      </categories>
      <tags>
        <tag>Unix高级编程</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX 系统体系结构</title>
    <url>/2023/02/06/Unix%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1>Unix 体系结构</h1>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/202203291146103.webp" alt="img"></p>
<ul>
<li>内核：从严格意义来说，可将操作系统（内核）定义为一种软件，它控制计算机硬件资源，提供程序运行环境。</li>
<li>shell: 是一个命令行解释器，它读取用户输入，然后执行命令。</li>
</ul>
<h3 id="函数">函数</h3>
<blockquote>
<p>系统调用通常提供一种最小的接口，而库函数通常提供比较复杂的功能。</p>
</blockquote>
<ul>
<li>系统调用：内核的接口。各种版本的Unix实现都提供良好定义、数量有限、直接进入内核的入口点，这些入口点称为<code>系统调用</code></li>
<li>公用库函数：封装一些功能，库函数可能会包含很多的系统调用</li>
</ul>
<h2 id="登录">登录</h2>
<ul>
<li><code>/etc/passwd</code>口令文件中保存这用户的登录相关信息。</li>
<li>由七个以冒号分隔的字段组成：登录名、加密口令、数字用户ID、数字组ID、注释字段、起始目录（<code>/home/sar</code>）、shell程序（<code>/bin/ksh</code>）。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">登录名 加密口令  数字用户ID  数字组ID   注释字段   起始目录    shell程序</span><br><span class="line">root    x        0         0        root     /root      /bin/bash</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="文件和目录">文件和目录</h2>
<h3 id="文件系统">文件系统</h3>
<ul>
<li>UNIX 文件系统是目录和文件的一种层次结构，所有东西的起点是称为根（root）的目录，这个目录名称是一个字符 <code>&quot;/&quot;</code>。</li>
<li>目录（directory）是一个包含目录项的文件。</li>
</ul>
<h3 id="文件名">文件名</h3>
<ul>
<li>目录中的各个名字称为文件名（filename）。只有斜线（<code>/</code>）和空字符不能出现在文件名中。
<ul>
<li><code>/</code>：用来分隔构成路径名的各文件名。</li>
<li>空字符：用来终止一个路径名。</li>
</ul>
</li>
<li>创建新目录的时候会自动创建两个文件名：<code>.</code>(点)和<code>..</code>（点点）。在最高层次的根目录中，点点和点相同
<ul>
<li><code>.</code>(点)：指向当前目录</li>
<li><code>..</code>（点点）：指向父目录</li>
</ul>
</li>
</ul>
<h3 id="路径名">路径名</h3>
<p>由斜线分隔的一个或多个文件名组成的序列（也可以斜线开头）构成路径名（pathname），以斜线开头的路径名称称为绝对路径名（absolute pathname），否则称为相对路径名（relative pathname）。</p>
<ul>
<li>文件系统根的名字（<code>/</code>）是一个特殊的绝对路径名，它不含文件名。</li>
</ul>
<h3 id="工作目录">工作目录</h3>
<p>每个进程都有一个工作目录（working directory），有时称其为当前工作目录（current working directory）。<strong>所有的相对路径都从工作目录开始解释</strong></p>
<h3 id="起始目录">起始目录</h3>
<p>登录时，工作目录设置为起始目录（home directory），该其实目录从口令文件中相应的用户的登录项中取得。</p>
<h2 id="输入和输出">输入和输出</h2>
<h3 id="文件描述符">文件描述符</h3>
<p>文件描述符（file descriptor）通常是一个<strong>小的非负整数</strong>，内核用以标识一个特定进程正在访问的文件。当内核打开一个现有文件或创建一个新文件时，它都返回一个文件描述符。在读、写文件时，可以使用这个文件描述符。</p>
<h3 id="标准输入、标准输出和标准错误">标准输入、标准输出和标准错误</h3>
<p>按照惯例，每当运行一个新程序时，所有的shell都为其打开3个文件描述符，即标准输入（standard input）、标准输出（standard output）、以及标准错误（standard error）。</p>
<h3 id="不带缓冲的I-O">不带缓冲的I/O</h3>
<p>函数 open、read、write、lseek以及close提供了不带缓冲的I/O。</p>
<h3 id="标准I-O">标准I/O</h3>
<p>标准I/O函数为那些不带缓冲的I/O函数提供了一个带缓冲的接口。使用标准I/O函数无须担心选取最佳的缓冲区大小。</p>
<h2 id="程序和进程">程序和进程</h2>
<h3 id="程序">程序</h3>
<p>程序（program）是一个存储在磁盘上某个目录中的可执行文件。内核使用<code>exec</code>函数（7个<code>exec</code>函数之一），将程序读入内存，并执行程序。</p>
<h3 id="进程和进程ID">进程和进程ID</h3>
<p>程序被执行的实例被称为进程（process）。Unix系统确保每个进程都有一个唯一的数字标识符，称为进程ID（process ID）。进程ID总是一个非负整数</p>
<h3 id="进程控制">进程控制</h3>
<p>有3个用于进程控制的主要函数：<code>fork</code>、<code>exec</code>、<code>waitpid</code>。(<code>exec</code>函数有七种变体，但经常把它们统称为<code>exec</code>函数。)</p>
<ul>
<li><code>fork</code>：调用fork用于创建一个新进程。</li>
<li><code>waitpid</code>: 函数返回子进程的终止状态（status变量）。</li>
</ul>
<h3 id="线程和线程ID">线程和线程ID</h3>
<p>通常，一个进程只有一个控制线程（thread）——某一时刻执行的一组机器指令。</p>
<ul>
<li>一个线程内的所有线程共享同一地址空间、文件描述符、栈以及与进程相关的属性。因为它们能访问同一存储区，所有各线程在访问共享数据时需要采用同步措施避免不一致性。</li>
<li>与进程相同，线程也用ID标识。但是，<strong>线程ID只在它所属的进程内起作用</strong>。一个进程中的线程ID在另一个进程中没有意义。当在一进程中对某个特定线程进行处理时，我们可以使用该线程的ID引用它。</li>
</ul>
<h3 id="出错处理">出错处理</h3>
<p>​    当Unix系统函数出错时候，通常会返回一个负值，而且整形变量<code>errno</code>通常被设置为具有特定信息的值。</p>
<h2 id="用户标识">用户标识</h2>
<h3 id="用户ID">用户ID</h3>
<p>​    口令文件登录项中的用户ID（user ID）是一个数值，它向系统标识各个不用的用户</p>
<ul>
<li>用户ID为0的用户为根用户（root）或者超级用户（superuser）。
<ul>
<li>如果一个进程具有超级用户特权，则大多数文件名权限的检查都不再进行。</li>
</ul>
</li>
</ul>
<h3 id="组ID">组ID</h3>
<blockquote>
<p>组被用于将若干用户集合到项目或部门中去。这种机制允许同组的各个成员之间共享资源（如文件）</p>
<p>这个组管理可以按照（rbac）角色资源管理去理解</p>
</blockquote>
<p>口令文件登录项也包含用户的组ID（group ID），它是一个数值。</p>
<ul>
<li>组ID是由系统管理员在指定用户登录名时分配的。</li>
<li>在口令文件中有多个登录项具有相同的组ID。</li>
</ul>
<h3 id="附属组ID">附属组ID</h3>
<p>​    除了在口令文件中对一个登录名指定一个组ID外，大多数UNIX系统版本还允许一个用户属于另外一些组。</p>
<h2 id="信号">信号</h2>
<p>​    信号用于通知进程发生了某种情况。进程有以下三种信号处理方式。</p>
<ul>
<li>忽略信号</li>
<li>按系统默认的方式处理。一般是终止该进程</li>
<li>提供一个函数，信号发生时调用该函数，这种称为捕捉信号。</li>
</ul>
]]></content>
      <categories>
        <category>UNIX</category>
      </categories>
      <tags>
        <tag>Unix高级编程</tag>
      </tags>
  </entry>
  <entry>
    <title>关于登录认证这件事</title>
    <url>/2023/02/06/%E8%81%8A%E8%81%8A%E7%99%BB%E5%BD%95%E8%AE%A4%E7%9C%9F%E8%BF%99%E4%BB%B6%E4%BA%8B/</url>
    <content><![CDATA[<h1>聊聊登录认证这件事</h1>
<p>这里介绍的是减少登录页面的编写的方法，比如一个公司中有A，B, C 三个系统，对于用户来说希望是我只需要登录（认证）一次就可以访问A，B，C三个系统，而不是进到A系统在A中登录（认证）一次，进到B系统又要在B中登录（认证）一次，进到C系统还要在C中登录（认证）一次，这样一方面会有重复的编码（A，B，C系统的登录页面逻辑），另一方面对用户来说也是非常不友好。</p>
<p><strong>请区别于对系统中的资源的权限校验</strong></p>
<h2 id="关于LDAP">关于LDAP</h2>
<blockquote>
<p>轻量级目录访问协议 (LDAP) 是一种使应用程序可以快速查询用户信息的协议。</p>
</blockquote>
<h3 id="“什么是目录服务？”"><strong>“什么是目录服务？</strong>”</h3>
<ul>
<li>目录服务是一个特殊的数据库，用来保存描述性的、基于属性的详细信息，支持过滤功能。</li>
<li>是动态的，灵活的，易扩展的。</li>
</ul>
<p>如：人员组织管理，电话簿，地址簿。</p>
<h3 id="LDAP介绍">LDAP介绍</h3>
<ul>
<li>LDAP（Light Directory Access Portocol），它是基于 X.500 标准的轻量级目录访问协议。</li>
<li>目录是一个为查询、浏览和搜索而优化的数据库，它成树状结构组织数据，类似文件目录一样。</li>
<li>目录数据库和关系数据库不同，它有优异的读性能，但写性能差，并且没有事务处理、回滚等复杂功能，不适于存储修改频繁的数据。所以目录天生是用来查询的，就好象它的名字一样。</li>
</ul>
<p>LDAP目录服务是由目录数据库和一套访问协议组成的系统。</p>
<h3 id="LDAP-登录流程">LDAP 登录流程</h3>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/202203131307287.png" alt="image-20220313130546204"></p>
<span id="more"></span>
<h2 id="单点登录-SingleSign-On，SSO">单点登录(SingleSign-On，<em>SSO</em>)</h2>
<blockquote>
<p>单点登录 (SSO) 是一种身份验证方法，可让用户仅使用一组凭据即可安全地对多个应用程序和网站进行身份验证</p>
</blockquote>
<p>SSO的想法就是将<strong>身份提供者（Identity provider，IDP）</strong>，**服务提供者（Service provider，SP）**彻底分离，用户用IDP提供的身份就可以在Web世界畅通无阻。</p>
<p>这里面最让人头疼的其实是安全问题。如何保证用户的身份在逻辑上不能被冒充，才是最难的题目。数据加密，**数字签名（Digital Signature）**等各种密码学知识刚好解决了这个问题。</p>
<p>在2001年由OASIS组织安全服务技术委员会(Security Services Technical Committee)推出了**SAML（安全主张标记语言，Security Assertion Markup Language），**就是提出了对SSO实现的整体技术和安全规范。</p>
<p>SAML是以XML为基础，不用JSON的原因，大概是因为JSON一直在1999年才发明，2004年以后才流行起来逐渐取代了XML。在这之前，XML一直是作为网络通讯的标准格式。</p>
<p>在SAML协议中，实际上也包含了可以发送账号属性等登陆外的扩展部分。SAML协议实际内容很多，就不一一介绍，这里只围绕单点登录来说明。</p>
<p>SAML协议里，约定了参与SSO的三方：浏览器，身份提供者（IDP），服务提供者（SP），以及这三方相互的通讯次序，加密方法，传输数据格式。</p>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/202203131308877.png" alt="image-20220313130627731"></p>
<h2 id="LDAP-和-SSO-对比">LDAP 和 SSO 对比</h2>
<ul>
<li>LDAP协议里只负责用户身份的认证，不包含授权过程。在SAML协议中，不仅包含身份认证，还包含是否允许用户访问当前网站内容的授权部分。</li>
<li>LDAP服务与应用之间是毫无条件的充分信任，LDAP几乎是作为应用的远程数据库一般的存在。而在SAML中，SP与IDP不仅需要在事前互相信任（互换签名公钥与IP地址），还要在认证过程中防止他人伪造而进行数据校验。因为SAML定义的SP与IDP是在互联网上相互独立的站点。</li>
<li>同时能注意到SAML协议非常依赖浏览器重定向功能，而LDAP协议都是应用与LDAP服务间的直接通讯。
<ul>
<li>浏览器重定向，其实就是指当前你访问的页面主动跳转到另外一个网站的网页上去，在跳转的过程中可以给这次访问网页的请求上附加上一些数据用来完成数据传输。</li>
</ul>
</li>
</ul>
<h2 id="OpenID诞生">OpenID诞生</h2>
<p>一个叫布莱德的程序员在1999年的时候，开发了一个类似博客一样的社区网站。运营的还不错，有了好几百万用户。你看，互联网公司，几百万用户，感觉可以开始做自己的SSO登录了。可这次布莱德不想做一个跟巨头们一样的东西，毕竟就算做出来估计也打不过。那要不要尝试去中心化的路子？</p>
<h3 id="中心化">中心化</h3>
<p>去中心化这个概念随着比特币流行而火爆了起来，其实去中心化这个概念很早就有了。</p>
<ul>
<li>中心化的意思就是用户在使用某项服务时，所有的访问请求都需要向同一个主体的服务器地址发送。比如每个微信用户的客户端，都是在跟腾讯公司的服务端交流，A发送给B一条消息，都是A先发送给腾讯服务端，再由腾讯服务端转发给B。A是不能通过其它公司或个人的服务端发送给B消息的。</li>
</ul>
<p>类似这样，所有用户都围着中间一个服务端，就管这种叫中心化的服务。</p>
<h3 id="去中心化">去中心化</h3>
<ul>
<li>就是并没有固定的一个服务商提供服务，任何人只要他愿意的话，都可以作为服务端来给用户服务，用户也可以自由的切换服务端。这种方式显然是不符合已经拥有大量用户的互联网公司的利益，但却迎合了用户和中小企业抱团取暖的需求。</li>
</ul>
<p>于是布莱德在2005开始了一个叫OpenID的项目开发，这个项目在软件社区中得到了响应，越来越多的人参与进来，之后越来越多的人开始使用。OpenID的目的就是建立一个统一的SSO的方式，而不用在意IDP服务的提供方。用户完全可以自己启动一个IDP的服务，或者选择一个用户信任的IDP服务提供方，在这个IDP服务上完成注册。那么只要SP站点能使用OpenID的方式，用户就可以完成登录了。</p>
<h2 id="OpenID登录流程">OpenID登录流程</h2>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/202203131307694.png" alt="image-20220313130724620"></p>
<h1>常见的两种登录框架</h1>
<blockquote>
<p>OAuth 2.0 定义了一个协议，即规定了token 的传输方式，JWT 定义了一种token 格式</p>
</blockquote>
<h2 id="CAS（Central-Authentication-Service）">CAS（Central Authentication Service）</h2>
<p><strong>CAS框架</strong>：CAS（Central Authentication Service，即：统一认证服务）是实现SSO单点登录的框架。</p>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/202203131412131.webp" alt="img"></p>
<h2 id="OAuth-2-0"><strong>OAuth 2.0</strong></h2>
<blockquote>
<p>OAuth2是当前授权的行业标准，其重点在于为Web应用程序、桌面应用程序、移动设备以及室内设备的授权流程提供简单的客户端开发方式。它为第三方应用提供对HTTP服务的有限访问，既可以是资源拥有者通过授权允许第三方应用获取HTTP服务，也可以是第三方以自己的名义获取访问权限。</p>
</blockquote>
<h3 id="角色"><strong>角色</strong></h3>
<p>OAuth2 中主要分为了4种角色</p>
<ul>
<li>resource owner 资源所有者，是能够对受保护的资源授予访问权限的实体，可以是一个用户，这时会被称为end-user。</li>
<li>resource server 资源服务器，持有受保护的资源，允许持有访问令牌(access token)的请求访问受保护资源。</li>
<li>client 客户端，持有资源所有者的授权，代表资源所有者对受保护资源进行访问。</li>
<li>authorization server 授权服务器，对资源所有者的授权进行认证，成功后向客户端发送访问令牌。</li>
</ul>
<p><strong>协议流程</strong></p>
<p>首先看一张来自官方提供的流程图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------+                               +---------------+</span><br><span class="line">|        |--(1)- Authorization Request -&gt;|   Resource    |</span><br><span class="line">|        |                               |     Owner     |</span><br><span class="line">|        |&lt;-(2)-- Authorization Grant ---|               |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |--(3)-- Authorization Grant --&gt;| Authorization |</span><br><span class="line">| Client |                               |     Server    |</span><br><span class="line">|        |&lt;-(4)----- Access Token -------|               |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |--(5)----- Access Token ------&gt;|    Resource   |</span><br><span class="line">|        |                               |     Server    |</span><br><span class="line">|        |&lt;-(6)--- Protected Resource ---|               |</span><br><span class="line">+--------+                               +---------------+</span><br></pre></td></tr></table></figure>
<p>这是一张关于 OAuth2 角色的抽象交互流程图，主要包含以下的6个步骤：</p>
<ol>
<li>客户端请求资源所有者的授权；</li>
<li>资源所有者同意授权，返回授权许可(Authorization Grant)，这代表了资源所有者的授权凭证；</li>
<li>客户端携带授权许可要求授权服务器进行认证，请求访问令牌；</li>
<li>授权服务器对客户端进行身份验证，并认证授权许可，如果有效，返回访问令牌；</li>
<li>客户端携带访问许可向资源服务器请求受保护资源的访问；</li>
<li>资源服务器验证访问令牌，如果有效，接受访问请求，返回受保护资源。 <strong>客户端授权类型</strong></li>
</ol>
<h1>参考文章</h1>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/105674989">https://zhuanlan.zhihu.com/p/105674989</a></li>
<li><a href="https://www.jianshu.com/p/6ba65cc8e399">https://www.jianshu.com/p/6ba65cc8e399</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html</a></li>
</ul>
]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>登录认证</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 并发模型 &amp; Goroutine 详解</title>
    <url>/2023/02/06/Golang%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%92%8CGoroutine%20%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1><code>Golang</code> 并发模型 &amp; Goroutine 详解</h1>
<p>💡 <strong>并发不是并行，并发关乎结构，并行关乎执行</strong></p>
<blockquote>
<p>操作系统的基本调度与执行单元是进程(process)</p>
</blockquote>
<blockquote>
<p><strong>操作系统</strong>的<strong>最小调度</strong>单位是线程-<code>线程可作为执行单元可被独立调度到处理器上运行</code></p>
</blockquote>
<h2 id="CSP-Communicationing-Sequential-Processes，通信顺序进程-并发模型">**<code>CSP</code>( Communicationing Sequential Processes，通信顺序进程)**并发模型</h2>
<p>Tony Hoare 的 <code>CSP</code> 模型旨在简化并发程序的编写，让并发程序的编写与编写顺序程序一样简单。Tony Hoare 认为输入输出应该是基本的编程原语，数据处理逻辑(也就是 <code>CSP</code>中的 P)只需调用输入原语获取数据，顺序地处理数据，并将结果数据通过输出原语输出就可以了。因此，在 Tony Hoare 眼中，<strong>一个符合 <code>CSP</code> 模型的并发程序应该是一组通过输入输出原语连接起来的 P 的集合</strong>。</p>
<p>从这个角度来看，<code>CSP</code>理论不仅是一个并发参考模型，也是一种并发程序的程序组织方法。它的组合思想与 Go 的设计哲学不谋而合。</p>
<p>Tony Hoare 的 <code>CSP</code> 理论中的 P，也就是“Process(进程)”，是一个抽象概念，它代表任何顺序处理逻辑的封装，它获取输入数据(或从其他 P 的输出获取)，并生产出可以被其他 P 消费的输出数据。这里我们可以简单看下 <code>CSP</code> 通信模型的示意图:</p>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/202202112129599.png" alt="image-20220211212946539"></p>
<p>注意了，这里的 P 并不一定与操作系统的进程或线程划等号。在 Go 中，与“Process”对 应的是 <code>goroutine</code>。</p>
<p>为了实现 <code>CSP</code> 并发模型中的输入和输出原语，Go 还引入了 <code>goroutine</code>§之间的通信原语channel。goroutine 可以从 channel 获取输入数据， 再将处理后得到的结果数据通过 channel 输出。通过 channel 将 goroutine§组合连 接在一起，让设计和编写大型并发系统变得更加简单和清晰，我们再也不用为那些传统共 享内存并发模型中的问题而伤脑筋了。</p>
<h2 id="Goroutine-的优势"><code>Goroutine</code> 的优势</h2>
<ul>
<li>资源占用小，每个 goroutine 的初始栈大小仅为 2k;</li>
<li>由 Go 运行时而不是操作系统调度，goroutine 上下文切换在用户层完成，开销更小;</li>
<li>在语言层面而不是通过标准库提供。goroutine 由go关键字创建，一退出就会被回收或 销毁，开发体验更佳</li>
<li>语言内置 channel 作为 goroutine 间通信原语，为并发设计提供了强大支撑。</li>
</ul>
<h2 id="Goroutine-调度器"><strong><code>Goroutine</code> 调度器</strong></h2>
<p>一个 Go 程序对于操作系统来说只是一个<strong>用户层程序</strong>，操作系统眼中只有线程，它甚至不知道有一种叫 <strong>Goroutine</strong> 的事物存在。所以，Goroutine 的调度全要靠 Go 自己完成。那么，实现 Go 程序内 Goroutine 之间“公平”竞争“CPU”资源的任务，就落到了Go 运行时(runtime)头上了。要知道在一个 Go 程序中，除了用户层代码，剩下的就是Go 运行时了。</p>
<p>于是，Goroutine 的调度问题就演变为，Go 运行时如何将程序内的众多 Goroutine，按照一定算法调度到“CPU”资源上运行的问题了。</p>
<p>💡 <strong>可是，在操作系统层面，线程竞争的“CPU”资源是真实的物理 CPU，但在 Go 程序层 面，各个 Goroutine 要竞争的“CPU”资源又是什么呢?</strong></p>
<ul>
<li>Go 程序是用户层程序，它本身就是整体运行在一个或多个操作系统线程上的。所以这个答案就出来了: <strong>Goroutine 们要竞争的“CPU”资源就是操作系统线程</strong>。这样，Goroutine调度器的任务也就明确了: <strong>将 Goroutine 按照一定算法放到不同的操作系统线程中去执行</strong>。</li>
</ul>
<span id="more"></span>
<h2 id="Goroutine-调度器模型与演化过程"><strong>Goroutine 调度器模型与演化过程</strong></h2>
<p>Goroutine 调度器的实现不是一蹴而就的，它的调度模型与算法也是几经演化，从最初的 G-M 模型、到 G-P-M 模型，从不支持抢占，到支持协作式抢占，再到支持基于信号的异步抢占。 Goroutine 调度器经历了不断地优化与打磨。</p>
<h3 id="G-M-模型"><strong>G-M 模型</strong></h3>
<p>在这个调度器中，每个 Goroutine 对应于运行时中的一个抽象结构: G(<code>Goroutine</code>) ，而被视作“物理 CPU”的操作系统线程，则被抽象为另外一个结构:M(machine)。</p>
<p>调度器的工作就是将 G 调度到 M 上去运行。为了更好地控制程序中活跃的 M 的数量，调度器引入了 <code>GOMAXPROCS</code> 变量来表示 Go 调度器可见的“处理器”的最大数量。</p>
<p><strong>G-M 模型</strong>的一个重要不足:限制了 Go 并发程序的伸缩性，尤其是对那些有高吞吐或并行计算需求的服务程序。这个问题主要体现在这几个方面:</p>
<ul>
<li>单一全局互斥锁(<code>Sched.Lock</code>) 和集中状态存储的存在，导致所有 Goroutine 相关操作，比如创建、重新调度等，都要上锁;</li>
<li>Goroutine 传递问题: M 经常在 M 之间传递“可运行”的 Goroutine，这导致调度延迟增大，也增加了额外的性能损耗;</li>
<li>每个 M 都做内存缓存，导致内存占用过高，数据局部性较差;</li>
<li>由于系统调用(<code>syscall</code>)而形成的频繁的工作线程阻塞和解除阻塞，导致额外的性能损耗。</li>
</ul>
<p>为了解决这些问题德米特里 - 维尤科夫又亲自操刀改进了 Go 调度器，在 Go 1.1 版本中实现了 <strong>G-P-M 调度模型。</strong></p>
<h2 id="G-P-M-调度模型"><strong>G-P-M 调度模型</strong></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/202205201527275.png" alt="img"></p>
<p>P 是一个“逻辑 <code>Proccessor</code>”，每个 G(Goroutine)要想真正运行起来，首先需要被分配一个 P，也就是进入到 P 的本地运行队列(<code>local runq</code>)中。</p>
<p>对于 G 来说，P 就是运行它的“CPU”，可以说:<strong>在 G 的眼里只有 P</strong>。但从 Go 调度器的视角来看，真正的“CPU”是 M，只有将 P 和 M 绑定，才能让 P 的 <code>runq</code>中的 G 真正运行起来。</p>
<p>G-P-M 模型的实现算是Go调度器的一大进步，但调度器仍然有一个令人头疼的问题，那就是<strong>不支持抢占式调度</strong>，这导致一旦某个 G 中出现死循环的代码逻辑，那么 G 将永久占用分配给它的 P 和 M，而位于同一个 P 中的其他 G 将得不到调度，出现“<strong>饿死</strong>”的情况。</p>
<p>更为严重的是，当只有一个 P(<code>GOMAXPROCS=1</code>)时，整个 Go 程序中的其他 G 都 将“饿死”。</p>
<h2 id="基于协作的“抢占式”调度"><strong>基于协作的“抢占式”调度</strong></h2>
<p>Go 编译器在每个函数或方法的入口处加上了一段额外的代码 (<code>runtime.morestack_noctxt</code>)，让运行时有机会在这段代码中检查是否需要执行抢占调度。</p>
<p>这种解决方案只能说局部解决了“饿死”问题，只在有函数调用的地方才能插入“抢 占”代码(埋点)，对于没有函数调用而是纯算法循环计算的 G，Go 调度器依然无法抢占。</p>
<p>比如，死循环等并没有给编译器插入抢占代码的机会，这就会导致 <code>GC</code> 在等待所有 Goroutine 停止时的等待时间过长，从而导致 <code>GC</code> 延迟，内存占用瞬间冲高;甚至在一 些特殊情况下，导致在<code>STW(stop the world)</code>时死锁。</p>
<h2 id="非协作的抢占式调度"><strong>非协作的抢占式调度</strong></h2>
<p>这种抢占式调度是基于系统信号的，也就是通过向线程发送信号的方式来抢占正在运行Goroutine。</p>
<h2 id="小结">小结</h2>
<p>除了这些大的迭代外，Goroutine 的调度器还有一些小的优化改动，比如<strong>通过文件 I/O poller 减少 M 的阻塞等</strong>。</p>
<p>Go 运行时已经实现了<code>netpoller</code>，这使得即便 G 发起网络 I/O 操作，也不会导致 M 被阻塞(仅阻塞 G)，也就不会导致大量线程(M)被创建出来。但是对于文件 I/O 操作来说，一旦阻塞，那么线程(M)将进入挂起状态，等待 I/O 返回后被唤醒。这种情况下 P 将与挂起的 M 分离，再选择一个处于空闲状态(idle)的 M。如果此时没有空闲的 M，就会新创建一个 M(线程)，所以，这种情况下，大量 I/O 操作仍然会导致大量线程被创建。</p>
<p>为了解决这个问题，Go 开发团队的伊恩 - 兰斯 - 泰勒(Ian Lance Taylor)在 Go 1.9 中 增加了一个针对文件 I/O 的 Poller的功能，这个功能可以像 <code>netpoller</code> 那样，在 G 操作 那些支持监听(<code>pollable</code>)的文件描述符时，仅会阻塞 G，而不会阻塞 M。不过这个功能 依然不能对常规文件有效，常规文件是不支持监听的(<code>pollable</code>)。但对于 Go 调度器而 言，这也算是一个不小的进步了。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Goroutine模型</tag>
      </tags>
  </entry>
  <entry>
    <title>defer的妙用之跟踪函数调用链</title>
    <url>/2023/02/06/%E8%B7%9F%E8%B8%AA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E9%93%BE/</url>
    <content><![CDATA[<h1>defer的妙用之跟踪函数调用链</h1>
<blockquote>
<p>本文参考：Tony Bai 老师的极客时间 <a href="https://time.geekbang.org/column/intro/100093501?code=cQ4ugiP4uzDdDVD1T-HXXlTv9Fdl-SpdsPnSfxf0%2FuU%3D">《Tony Bai · Go语言第一课》</a> 课程</p>
</blockquote>
<blockquote>
<p>使用 defer 可以跟踪函数的 执行过程</p>
<p>defer 会预计算参数(表达式进行求值): 详情见 <a href="https://luenci.me/2021/08/28/defer&amp;goroutine%E8%BF%AD%E4%BB%A3/#more">https://luenci.me/2021/08/28/defer&amp;goroutine迭代/#more</a></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// trace.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trace</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;enter:&quot;</span>, name)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;exit:&quot;</span>, name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> Trace(<span class="string">&quot;foo&quot;</span>)()</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> Trace(<span class="string">&quot;bar&quot;</span>)()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> Trace(<span class="string">&quot;main&quot;</span>)() </span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    enter: main</span><br><span class="line">    enter: foo</span><br><span class="line">    enter: bar</span><br><span class="line">    exit: bar</span><br><span class="line">    exit: foo</span><br><span class="line">    exit: main</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序的函数调用的全过程一目了然地展现在了我们面前：程序按 <code>main</code> -&gt; <code>foo</code> -&gt; <code>bar</code>的函数调用次序执行，代码在函数的入口与出口处分别输出了跟踪日志。</p>
<ul>
<li>Go 会对 <code>defer</code> 后面的表达式<code>Trace(&quot;foo&quot;)()</code>进行求值。由于这个表达式包含一个函数调用<code>Trace(&quot;foo&quot;)</code>，所以这个函数会被执行。</li>
</ul>
<p>程序存在的问题</p>
<ul>
<li>调用 Trace 时需手动显式传入要跟踪的函数名；</li>
<li>如果是并发应用，不同 Goroutine 中函数链跟踪混在一起无法分辨；</li>
<li>输出的跟踪结果缺少层次感，调用关系不易识别；</li>
<li>对要跟踪的函数，需手动调用 Trace 函数</li>
</ul>
<p>接下来我们一步一步的解决这些问题，来完善我们的函数调用链。</p>
<span id="more"></span>
<h2 id="自动获取所跟踪函数的函数名">自动获取所跟踪函数的函数名</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trace</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  pc, _, _, ok := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not found caller&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  fn := runtime.FuncForPC(pc)</span><br><span class="line">    name := fn.Name()</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;enter:&quot;</span>, name)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">&quot;exit:&quot;</span>, name) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>改进后的<code>Trace()</code>函数，通过 <code>runtime.Caller</code> 函数获得当前 <code>Goroutine</code> 的函数调用 栈上的信息，<code>runtime.Caller</code> 的参数标识的是要获取的是哪一个栈帧的信息。当参数为 0 时，返回的是 Caller 函数的调用者的函数信息，在这里就是 <code>Trace</code> 函数。但我们需要的是 <code>Trace</code> 函数的调用者的信息，于是我们传入 1。</p>
<p><code>Caller</code> 函数有四个返回值：</p>
<ul>
<li>
<p>第一个返回值代表的是程序计数（<code>pc</code>）；</p>
</li>
<li>
<p>第二个 和 第三个参数 代表对应函数所在的源文件名以及所在行数，这里我们暂时不需要</p>
</li>
<li>
<p>最后一个参数代表是 否能成功获取这些信息</p>
</li>
</ul>
<p>如果获取失败，我们抛出 panic。 然后，我们通过 <code>runtime.FuncForPC</code> 函数和程序计数器（<code>PC</code>）得到被跟踪函数的函数名称。<code>runtime.FuncForPC</code> 返回的名称中不仅仅包含函数名，还包含了被跟踪函数所在的包名</p>
<h2 id="增加-Goroutine-标识">增加 Goroutine 标识</h2>
<blockquote>
<p>注意：Go 核心团队为了避免 Goroutine ID 的滥用，故意没有将 Goroutine ID 暴露给开发者。但是在 Go 标准库的 <code>h2_bundle.go</code> 中发现了一个官方的获取 Goroutine ID的用法。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// curGoroutineID 获取当前goroutine的id</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">curGoroutineID</span><span class="params">()</span></span> <span class="type">uint64</span> &#123;</span><br><span class="line">  b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">64</span>)</span><br><span class="line">  b = b[:runtime.Stack(b, <span class="literal">false</span>)]</span><br><span class="line">  <span class="comment">// Parse the 4707 out of &quot;goroutine 4707 [&quot;</span></span><br><span class="line">  b = bytes.TrimPrefix(b, goroutineSpace)</span><br><span class="line">  i := bytes.IndexByte(b, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> i &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;No space found in %q&quot;</span>, b))</span><br><span class="line">  &#125;</span><br><span class="line">  b = b[:i]</span><br><span class="line">  n, err := strconv.ParseUint(<span class="type">string</span>(b), <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;Failed to parse goroutine ID out of %q: %v&quot;</span>, b, err))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trace</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  pc, _, _, ok := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not found caller&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  fn := runtime.FuncForPC(pc)</span><br><span class="line">  name = fn.Name()</span><br><span class="line">  gid := curGoroutineID()</span><br><span class="line">  fmt.Printf(<span class="string">&quot;g[%05d]: enter: [%s]\n&quot;</span>, gid, name)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">&quot;g[%05d]: exit: [%s]\n&quot;</span>, gid, name) &#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    g[<span class="number">00001</span>]: enter: [main.main]</span><br><span class="line">    g[<span class="number">00001</span>]: enter: [main.foo]</span><br><span class="line">    g[<span class="number">00001</span>]: enter: [main.bar]</span><br><span class="line">    g[<span class="number">00001</span>]: exit: [main.bar]</span><br><span class="line">    g[<span class="number">00001</span>]: exit: [main.foo]</span><br><span class="line">    g[<span class="number">00001</span>]: exit: [main.main]</span><br></pre></td></tr></table></figure>
<p>改进后的代码在出入口输出的跟踪信息中加入了 Goroutine ID 信息，我们输出的 Goroutine ID 为 5 位数字，如果 ID 值不足 5 位，则左补零，这一切都是 <code>Printf </code>函数的格 式控制字符串<code>%05d</code>帮助我们实现的。这样对齐 Goroutine ID 的位数，为的是输出信 息格式的一致性更好。如果你的 Go 程序中 Goroutine 的数量超过了 5 位数可以表示的数值范围，也可以自行调整控制字符串。</p>
<p>多Goroutine 测试</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// trace.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;bytes&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;runtime&quot;</span></span><br><span class="line">  <span class="string">&quot;strconv&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> goroutineSpace = []<span class="type">byte</span>(<span class="string">&quot;goroutine &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// curGoroutineID 获取当前goroutine的id</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">curGoroutineID</span><span class="params">()</span></span> <span class="type">uint64</span> &#123;</span><br><span class="line">  b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">64</span>)</span><br><span class="line">  b = b[:runtime.Stack(b, <span class="literal">false</span>)]</span><br><span class="line">  <span class="comment">// Parse the 4707 out of &quot;goroutine 4707 [&quot;</span></span><br><span class="line">  b = bytes.TrimPrefix(b, goroutineSpace)</span><br><span class="line">  i := bytes.IndexByte(b, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> i &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;No space found in %q&quot;</span>, b))</span><br><span class="line">  &#125;</span><br><span class="line">  b = b[:i]</span><br><span class="line">  n, err := strconv.ParseUint(<span class="type">string</span>(b), <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;Failed to parse goroutine ID out of %q: %v&quot;</span>, b, err))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trace</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  pc, _, _, ok := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not found caller&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  fn := runtime.FuncForPC(pc)</span><br><span class="line">  name := fn.Name()</span><br><span class="line">  gid := curGoroutineID()</span><br><span class="line">  fmt.Printf(<span class="string">&quot;g[%05d]: enter: [%s]\n&quot;</span>, gid, name)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">&quot;g[%05d]: exit: [%s]\n&quot;</span>, gid, name) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> Trace()()</span><br><span class="line">  B1()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B1</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> Trace()()</span><br><span class="line">  C1()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C1</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> Trace()()</span><br><span class="line">  D()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">D</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> Trace()()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> Trace()()</span><br><span class="line">  B2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B2</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> Trace()()</span><br><span class="line">  C2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C2</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> Trace()()</span><br><span class="line">  D()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    A2()</span><br><span class="line">    wg.Done()</span><br><span class="line">  &#125;()</span><br><span class="line">  A1()</span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  g[<span class="number">00001</span>]: enter: [main.A1]</span><br><span class="line">    g[<span class="number">00001</span>]: enter: [main.B1]</span><br><span class="line">    g[<span class="number">00001</span>]: enter: [main.C1]</span><br><span class="line">    g[<span class="number">00001</span>]: enter: [main.D]</span><br><span class="line">    g[<span class="number">00001</span>]: exit: [main.D]</span><br><span class="line">    g[<span class="number">00001</span>]: exit: [main.C1]</span><br><span class="line">    g[<span class="number">00001</span>]: exit: [main.B1]</span><br><span class="line">    g[<span class="number">00001</span>]: exit: [main.A1]</span><br><span class="line">    g[<span class="number">00006</span>]: enter: [main.A2]</span><br><span class="line">    g[<span class="number">00006</span>]: enter: [main.B2]</span><br><span class="line">    g[<span class="number">00006</span>]: enter: [main.C2]</span><br><span class="line">    g[<span class="number">00006</span>]: enter: [main.D]</span><br><span class="line">    g[<span class="number">00006</span>]: exit: [main.D]</span><br><span class="line">    g[<span class="number">00006</span>]: exit: [main.C2]</span><br><span class="line">    g[<span class="number">00006</span>]: exit: [main.B2]</span><br><span class="line">    g[<span class="number">00006</span>]: exit: [main.A2]</span><br></pre></td></tr></table></figure>
<p>由于 Go 运行时对 Goroutine 调度顺序的不确定性，各个 Goroutine 的输出还是会存 在交织在一起的问题，这会给你查看某个 Goroutine 的函数调用链跟踪信息带来阻碍。这里提供一个小技巧：你可以将程序的输出重定向到一个本地文件中，然后通过 Goroutine ID 过滤出（可使用 <code>grep</code> 工具）你想查看的 <code>groutine</code> 的全部函数跟踪信息。</p>
<h2 id="优化输出的跟踪信息">优化输出的跟踪信息</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> goroutineSpace = []<span class="type">byte</span>(<span class="string">&quot;goroutine &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint64</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// printTrace 层次输出追踪栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printTrace</span><span class="params">(id <span class="type">uint64</span>, name, arrow <span class="type">string</span>, indent <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  indents := <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; indent; i++ &#123;</span><br><span class="line">    indents += <span class="string">&quot; &quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;g[%05d]:%s%s%s\n&quot;</span>, id, indents, arrow, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// curGoroutineID 获取当前goroutine的id</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">curGoroutineID</span><span class="params">()</span></span> <span class="type">uint64</span> &#123;</span><br><span class="line">  b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">64</span>)</span><br><span class="line">  b = b[:runtime.Stack(b, <span class="literal">false</span>)]</span><br><span class="line">  <span class="comment">// Parse the 4707 out of &quot;goroutine 4707 [&quot;</span></span><br><span class="line">  b = bytes.TrimPrefix(b, goroutineSpace)</span><br><span class="line">  i := bytes.IndexByte(b, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> i &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;No space found in %q&quot;</span>, b))</span><br><span class="line">  &#125;</span><br><span class="line">  b = b[:i]</span><br><span class="line">  n, err := strconv.ParseUint(<span class="type">string</span>(b), <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;Failed to parse goroutine ID out of %q: %v&quot;</span>, b, err))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trace</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  pc, _, _, ok := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not found caller&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  fn := runtime.FuncForPC(pc)</span><br><span class="line">  name := fn.Name()</span><br><span class="line">  gid := curGoroutineID()</span><br><span class="line"></span><br><span class="line">  mu.Lock()</span><br><span class="line">  indents := m[gid]    <span class="comment">// 获取当前gid对应的缩进层次</span></span><br><span class="line">  m[gid] = indents + <span class="number">1</span> <span class="comment">// 缩进层次+1后存入map</span></span><br><span class="line">  mu.Unlock()</span><br><span class="line">  printTrace(gid, name, <span class="string">&quot;-&gt;&quot;</span>, indents+<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    indents := m[gid]    <span class="comment">// 获取当前gid对应的缩进层次</span></span><br><span class="line">    m[gid] = indents - <span class="number">1</span> <span class="comment">// 缩进层次-1后存入map</span></span><br><span class="line">    mu.Unlock()</span><br><span class="line">    printTrace(gid, name, <span class="string">&quot;&lt;-&quot;</span>, indents)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  g[<span class="number">00001</span>]: -&gt;main.A1</span><br><span class="line">    g[<span class="number">00001</span>]:  -&gt;main.B1</span><br><span class="line">    g[<span class="number">00001</span>]:   -&gt;main.C1</span><br><span class="line">    g[<span class="number">00001</span>]:    -&gt;main.D</span><br><span class="line">    g[<span class="number">00001</span>]:    &lt;-main.D</span><br><span class="line">    g[<span class="number">00001</span>]:   &lt;-main.C1</span><br><span class="line">    g[<span class="number">00001</span>]:  &lt;-main.B1</span><br><span class="line">    g[<span class="number">00001</span>]: &lt;-main.A1</span><br><span class="line">    g[<span class="number">00006</span>]: -&gt;main.A2</span><br><span class="line">    g[<span class="number">00006</span>]:  -&gt;main.B2</span><br><span class="line">    g[<span class="number">00006</span>]:   -&gt;main.C2</span><br><span class="line">    g[<span class="number">00006</span>]:    -&gt;main.D</span><br><span class="line">    g[<span class="number">00006</span>]:    &lt;-main.D</span><br><span class="line">    g[<span class="number">00006</span>]:   &lt;-main.C2</span><br><span class="line">    g[<span class="number">00006</span>]:  &lt;-main.B2</span><br><span class="line">    g[<span class="number">00006</span>]: &lt;-main.A2</span><br></pre></td></tr></table></figure>
<p>为了格式化输出我们使用了一个 <code>map</code> 类型变量 m 来保存每个 Goroutine 当前的缩进信息：</p>
<ul>
<li>m 的 key 为 Goroutine 的 ID，值为缩进的层次。</li>
</ul>
<p>然后，考虑到 Trace 函数可能在 并发环境中运行，因为的“<strong>map 不支持并发写</strong>”的，我 们增加了一个 <code>sync.Mutex</code> 实例 <code>mu </code>用于同步对 <code>m </code>的写操作。 这样，对于一个 Goroutine 来说，每次刚进入一个函数调用，我们就在输出入口跟踪信息 之前，将缩进层次加一，并输出入口跟踪信息，加一后的缩进层次值也保存到 map 中。然 后，在函数退出前，我们取出当前缩进层次值并输出出口跟踪信息，之后再将缩进层次减 一后保存到<code> map</code>中。</p>
<p>除了增加缩进层次信息外，在这一版的 Trace 函数实现中，我们也把输出出入口跟踪信息 的操作提取到了一个独立的函数 <code>printTrace </code>中，这个函数会根据传入的<code> Goroutine ID</code>、 函数名、箭头类型与缩进层次值，按预定的格式拼接跟踪信息并输出。</p>
<h2 id="利用代码生成自动注入-Trace-函数">利用代码生成自动注入 Trace 函数</h2>
<p>将一些核心的逻辑封装程一个 module （完整代码在地址在 [trace](<a href="https://github.com/luenci/trace">luenci/trace: 一个跟踪函数调用链的工具库 (github.com)</a>) ）</p>
<h2 id="扩展：函数调用可视化">扩展：函数调用可视化</h2>
<p>推荐一个三方库：<a href="https://github.com/ofabry/go-callvis">https://github.com/ofabry/go-callvis</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊 Wire 依赖注入</title>
    <url>/2023/02/06/%E8%81%8A%E8%81%8AWire%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<blockquote>
<p>Wire 等依赖注入工具旨在简化初始化代码的管理</p>
</blockquote>
<p>💡 <a href="https://en.wikipedia.org/wiki/Dependency_injection">依赖注入</a> 是一种标准技术，用于生成灵活且松散耦合的代码，通过显式地为组件提供它们工作所需的所有依赖项。</p>
<h1>Wire 介绍</h1>
<blockquote>
<p>参考文章：<a href="https://blog.csdn.net/uisoul/article/details/108776073">Golang依赖注入框架wire使用详解_魂影魔宅-CSDN博客_golang wire</a></p>
</blockquote>
<p>Wire 有两个基本概念：提供者(<strong>provider</strong>)和注入器(<strong>Injector</strong>)。</p>
<p>官方的定义：</p>
<blockquote>
<p>provider:  a function that can produce a value. These functions are ordinary Go code.</p>
<p>injector:  a function that calls providers in dependency order.</p>
<p>With Wire, you write the injector’s signature, then Wire generates the function’s body.</p>
</blockquote>
<ul>
<li>提供者(<strong>provider</strong>)：一个可以产生值的函数（通常是构造函数)。这些函数都是普通的 Go 代码</li>
<li>注入器(<strong>Injector</strong>)：一个按依赖顺序调用提供者的函数。</li>
</ul>
<p>使用 Wire，您编写注入器(<strong>Injector</strong>)的签名，然后 Wire 生成函数的主体。</p>
<span id="more"></span>
<h3 id="provider"><strong>provider</strong></h3>
<p><code>provider</code>就是普通的Go函数，可以把它看作是某对象的构造函数，我们通过<code>provider</code>告诉<code>wire</code>该对象的依赖情况：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewUserStore是*UserStore的provider，表明*UserStore依赖于*Config和 *mysql.DB.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserStore</span><span class="params">(cfg *Config, db *mysql.DB)</span></span> (*UserStore, <span class="type">error</span>) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewDefaultConfig是*Config的provider，没有依赖</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDefaultConfig</span><span class="params">()</span></span> *Config &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewDB是*mysql.DB的provider，依赖于ConnectionInfo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDB</span><span class="params">(info ConnectionInfo)</span></span> (*mysql.DB, <span class="type">error</span>) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserStoreSet 可选项，可以使用wire.NewSet将通常会一起使用的依赖组合起来。</span></span><br><span class="line"><span class="keyword">var</span> UserStoreSet = wire.NewSet(NewUserStore, NewDefaultConfig) </span><br></pre></td></tr></table></figure>
<h3 id="injector"><strong>injector</strong></h3>
<p><code>injector</code>是<code>wire</code>生成的函数，我们通过调用<code>injector</code>来获取我们所需的对象或值，injector会按照依赖关系，按顺序调用<code>provider</code>函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File: wire_gen.go// Code generated by Wire. DO NOT EDIT.</span></span><br><span class="line"><span class="comment">//go:generate wire</span></span><br><span class="line"><span class="comment">//+build !wireinject</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// initUserStore是由wire生成的injector</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initUserStore</span><span class="params">(info ConnectionInfo)</span></span> (*UserStore, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// *Config的provider函数</span></span><br><span class="line">    defaultConfig := NewDefaultConfig()</span><br><span class="line">    <span class="comment">// *mysql.DB的provider函数</span></span><br><span class="line">    db, err := NewDB(info)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// *UserStore的provider函数</span></span><br><span class="line">    userStore, err := NewUserStore(defaultConfig, db)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userStore, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>injector</code>帮我们把按顺序初始化依赖的步骤给做了，我们在<code>main.go</code>中只需要调用<code>initUserStore</code>方法就能得到我们想要的对象了。</p>
<p>那么<code>wire</code>是怎么知道如何生成<code>injector</code>的呢？我们需要写一个函数来告诉它：</p>
<ul>
<li>定义<code>injector</code>的函数签名</li>
<li>在函数中使用<code>wire.Build</code>方法列举生成<code>injector</code>所需的<code>provider</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="comment">// initUserStore用于声明injector的函数签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initUserStore</span><span class="params">(info ConnectionInfo)</span></span> (*UserStore, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// wire.Build声明要获取一个UserStore需要调用到哪些provider函数</span></span><br><span class="line">    wire.Build(UserStoreSet, NewDB)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span> <span class="comment">// 这些返回值wire并不关心。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了上面的函数，<code>wire</code>就可以得知如何生成<code>injector</code>了。<code>wire</code>生成<code>injector</code>的步骤描述如下：</p>
<ol>
<li>确定所生成<code>injector</code>函数的函数签名：<code>func initUserStore(info ConnectionInfo) (*UserStore, error)</code></li>
<li>感知返回值第一个参数是<code>UserStore</code></li>
<li>检查<code>wire.Build</code>列表，找到<code>UserStore</code>的<code>provider：NewUserStore</code></li>
<li>由函数签名<code>func NewUserStore(cfg *Config, db *mysql.DB)</code>得知<code>NewUserStore</code>依赖于<code>Config</code>, 和<code>mysql.DB</code></li>
<li>检查<code>wire.Build</code>列表，找到<code>Config</code>和<code>mysql.DB</code>的<code>provider：NewDefaultConfig</code>和<code>NewDB</code></li>
<li>由函数签名<code>func NewDefaultConfig() *Config</code>得知<code>Config</code>没有其他依赖了。</li>
<li>由函数签名<code>func NewDB(info *ConnectionInfo) (*mysql.DB, error)</code>得知<code>mysql.DB</code>依赖于<code>ConnectionInfo</code>。</li>
<li>检查<code>wire.Build</code>列表，找不到<code>ConnectionInfo</code>的<code>provider</code>，但在injector函数签名中发现匹配的入参类型，直接使用该参数作为<code>NewDB</code>的入参。</li>
<li>感知返回值第二个参数是<code>error</code></li>
<li>按依赖关系，按顺序调用<code>provider</code>函数，拼装<code>injector</code>函数。</li>
</ol>
<h2 id="接口绑定"><strong>接口绑定</strong></h2>
<blockquote>
<p>💡 根据依赖倒置原则（Dependence Inversion Principle），对象应当依赖于接口，而不是直接依赖于具体实现。</p>
</blockquote>
<p><code>wire</code>中如何处理接口依赖：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UserService</span></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> &#123;</span><br><span class="line">  userRepo UserRepository<span class="comment">// &lt;-- UserService依赖UserRepository接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">int</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserRepository 存放User对象的数据仓库接口,比如可以是mysql,restful api.</span></span><br><span class="line"><span class="keyword">type</span> UserRepository <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// GetUserByID 根据ID获取User, 如果找不到User返回对应错误信息</span></span><br><span class="line">  GetUserByID(id <span class="type">int</span>) (*User, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewUserService *UserService构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserService</span><span class="params">(userRepo UserRepository)</span></span> *UserService &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;UserService&#123;</span><br><span class="line">    userRepo:userRepo,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mockUserRepo 模拟一个UserRepository实现</span></span><br><span class="line"><span class="keyword">type</span> mockUserRepo <span class="keyword">struct</span> &#123;</span><br><span class="line">  foo <span class="type">string</span></span><br><span class="line">  bar <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetUserByID UserRepository接口实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *mockUserRepo)</span></span> GetUserByID(id <span class="type">int</span>) (*User,<span class="type">error</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;User&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NewMockUserRepo *mockUserRepo构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMockUserRepo</span><span class="params">(foo <span class="type">string</span>,bar <span class="type">int</span>)</span></span> *mockUserRepo &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;mockUserRepo&#123;</span><br><span class="line">    foo:foo,</span><br><span class="line">    bar:bar,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MockUserRepoSet 将 *mockUserRepo与UserRepository绑定</span></span><br><span class="line"><span class="keyword">var</span> MockUserRepoSet = wire.NewSet(NewMockUserRepo,wire.Bind(<span class="built_in">new</span>(UserRepository), <span class="built_in">new</span>(*mockUserRepo)))</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个例子中，<code>UserService</code>依赖<code>UserRepository</code>接口，其中<code>mockUserRepo</code>是<code>UserRepository</code>的一个实现，由于在Go的最佳实践中，更推荐返回具体实现而不是接口。所以<code>mockUserRepo</code>的<code>provider</code>函数返回的是<code>*mockUserRepo</code>这一具体类型。<code>wire</code>无法自动将具体实现与接口进行关联，我们需要显示声明它们之间的关联关系。通过<code>wire.NewSet</code>和<code>wire.Bind</code>将<code>*mockUserRepo</code>与<code>UserRepository</code>进行绑定：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MockUserRepoSet 将 *mockUserRepo与UserRepository绑定</span></span><br><span class="line"><span class="keyword">var</span> MockUserRepoSet = wire.NewSet(NewMockUserRepo,wire.Bind(<span class="built_in">new</span>(UserRepository), <span class="built_in">new</span>(*mockUserRepo)))</span><br></pre></td></tr></table></figure>
<p>定义injector函数签名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeUserService</span><span class="params">(foo <span class="type">string</span>, bar <span class="type">int</span>)</span></span> *UserService&#123;</span><br><span class="line">  wire.Build(NewUserService,MockUserRepoSet)<span class="comment">// 使用MockUserRepoSetreturn nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>wire</code>对<code>provider</code>的返回值个数和顺序有所规定：</p>
<ul>
<li>第一个参数是需要生成的依赖对象</li>
<li>如果返回2个返回值，第二个参数必须是<code>func()</code>或者<code>error</code></li>
<li>如果返回3个返回值，第二个参数必须是<code>func()</code>，第三个参数则必须是<code>error</code></li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Context 正确使用姿势（推荐）</title>
    <url>/2023/02/06/Context%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/</url>
    <content><![CDATA[<h1>Context 正确使用姿势</h1>
<blockquote>
<p>原文参考：<a href="https://juejin.cn/post/6844903929340231694">https://juejin.cn/post/6844903929340231694</a></p>
</blockquote>
<blockquote>
<p>Context 是 immutable（不可变的）</p>
</blockquote>
<h2 id="context-Context-API">context.Context API</h2>
<p>基本上是两类操作：</p>
<ul>
<li>3个函数用于<strong>限定什么时候你的子节点退出</strong>；</li>
<li>1个函数用于<strong>设置请求范畴的变量</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">//  啥时候退出</span></span><br><span class="line">  Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">  Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  Err() <span class="type">error</span></span><br><span class="line">  <span class="comment">//  设置变量</span></span><br><span class="line">  Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何创建-Context？">如何创建 Context？</h2>
<ul>
<li>在 RPC 开始的时候，使用 context.Background()
<ul>
<li>有些人把在 main() 里记录一个 context.Background()，然后把这个放到服务器的某个变量里，然后请求来了后从这个变量里继承 context。这么做是<strong>不对的</strong>。直接每个请求，源自自己的 context.Background() 即可。</li>
</ul>
</li>
<li>如果你没有 context，却需要调用一个 context 的函数的话，用 context.TODO()</li>
<li>如果某步操作需要自己的超时设置的话，给它一个独立的 sub-context（如前面的例子）</li>
</ul>
<h2 id="Context-放哪？">Context 放哪？</h2>
<ul>
<li>把 Context 想象为一条河流流过你的程序</li>
<li>理想情况下，Context 存在于调用栈（Call Stack） 中</li>
<li>不要把 Context 存储到一个 struct 里
<ul>
<li>除非你使用的是像 http.Request 中的 request 结构体的方式</li>
</ul>
</li>
<li>request 结构体应该以 Request 结束为生命终止</li>
<li>当 RPC 请求处理结束后，应该去掉对 Context 变量的引用（Unreference）</li>
<li>Request 结束，Context 就应该结束。</li>
</ul>
<h2 id="Context-包的注意事项">Context 包的注意事项</h2>
<ul>
<li>要养成关闭 Context 的习惯
<ul>
<li><strong>特别是</strong> 超时的 Contexts</li>
</ul>
</li>
<li>如果一个 context 被 GC 而不是 cancel 了，那一般是你做错了</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(parentCtx, time.Second * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">defer</span> cancel()、</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 Timeout 会导致内部使用 time.AfterFunc，从而会导致 context 在计时器到时之前都不会被垃圾回收。</li>
<li>在建立之后，立即 defer cancel() 是一个好习惯。</li>
</ul>
<span id="more"></span>
<h2 id="终止请求-Request-Cancellation">终止请求 (Request Cancellation)</h2>
<p>当你不再关心接下来获取的结果的时候，有可能会 Cancel 一个 Context？</p>
<p>以 <a href="http://golang.org/x/sync/errgroup">golang.org/x/sync/errgroup</a> 为例，errgroup 使用 Context 来提供 RPC 的终止行为。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">  cancel  <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">  wg      sync.WaitGroup</span><br><span class="line">  errOnce sync.Once</span><br><span class="line">  err     <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个 group 和 context：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithContext</span><span class="params">(ctx context.Context)</span></span> (*Group, context.Context) &#123;</span><br><span class="line">  ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">  <span class="keyword">return</span> &amp;Group&#123;cancel: cancel&#125;, ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就返回了一个可以被提前 cancel 的 group。</p>
<p>而调用的时候，并不是直接调用 go func()，而是调用 Go()，将函数作为参数传进去，用高阶函数的形式来调用，其内部才是 go func() 开启 goroutine。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Go(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span>) &#123;</span><br><span class="line">  g.wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> g.wg.Done()</span><br><span class="line">    <span class="keyword">if</span> err := f(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      g.errOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        g.err = err</span><br><span class="line">        <span class="keyword">if</span> g.cancel != <span class="literal">nil</span> &#123;</span><br><span class="line">          g.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当给入函数 f 返回错误，则使用 sync.Once 来 cancel context，而错误被保存于 g.err 之中，在随后的 Wait() 函数中返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Wait() <span class="type">error</span> &#123;</span><br><span class="line">  g.wg.Wait()</span><br><span class="line">  <span class="keyword">if</span> g.cancel != <span class="literal">nil</span> &#123;</span><br><span class="line">    g.cancel()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> g.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：这里在 Wait() 结束后，调用了一次 cancel()。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoTwoRequestsAtOnce</span><span class="params">(ctx context.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  eg, egCtx := errgroup.WithContext(ctx)</span><br><span class="line">  <span class="keyword">var</span> resp1, resp2 *http.Response</span><br><span class="line">  f := <span class="function"><span class="keyword">func</span><span class="params">(loc <span class="type">string</span>, respIn **http.Response)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">      reqCtx, cancel := context.WithTimeout(egCtx, time.Second)</span><br><span class="line">      <span class="keyword">defer</span> cancel()</span><br><span class="line">      req, _ := http.NewRequest(<span class="string">&quot;GET&quot;</span>, loc, <span class="literal">nil</span>)</span><br><span class="line">      <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">      *respIn, err = http.DefaultClient.Do(req.WithContext(reqCtx))</span><br><span class="line">      <span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; (*respIn).StatusCode &gt;= <span class="number">500</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;unexpected!&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  eg.Go(f(<span class="string">&quot;&lt;http://localhost:8080/fast_request&gt;&quot;</span>, &amp;resp1))</span><br><span class="line">  eg.Go(f(<span class="string">&quot;&lt;http://localhost:8080/slow_request&gt;&quot;</span>, &amp;resp2))</span><br><span class="line">  <span class="keyword">return</span> eg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，同时发起了两个 RPC 调用，当任何一个调用超时或者出错后，会终止另一个 RPC 调用。这里就是利用前面讲到的 errgroup 来实现的，应对有很多并非请求，并需要集中处理超时、出错终止其它并发任务的时候，这个 pattern 使用起来很方便。</p>
<h2 id="Context-Value-Request-范畴的值">Context.Value - Request 范畴的值</h2>
<h3 id="context-Value-API-的万金油（duct-tape">context.Value API 的万金油（duct tape)</h3>
<p>胶带（duct tape) 几乎可以修任何东西，从破箱子，到人的伤口，到汽车引擎，甚至到NASA登月任务中的阿波罗13号飞船（Yeah! True Story)。所以在西方文化里，胶带是个“万能”的东西。在中文里，恐怕万金油是更合适的对应词汇，从头疼、脑热，感冒发烧，到跌打损伤几乎无所不治。</p>
<p>当然，<strong>治标不治本</strong>，这点东西方文化中的潜台词都是一样的。这里提及的 context.Value 对于 API 而言，就是这类性质的东西，啥都可以干，但是治标不治本。</p>
<ul>
<li>value 节点是 Context 链中的一个节点</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> context</span><br><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">  Context</span><br><span class="line">  key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context &#123;</span><br><span class="line">  <span class="comment">//  ...</span></span><br><span class="line">  <span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">  <span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">    <span class="keyword">return</span> c.val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，WithValue() 实际上就是在 Context 树形结构中，增加一个节点罢了。</p>
<h3 id="约束-key-的空间">约束 key 的空间</h3>
<p>为了防止树形结构中出现重复的键，建议约束键的空间。比如使用私有类型，然后用 GetXxx() 和 WithXxxx() 来操作私有实体。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> privateCtxType <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  reqID = privateCtxType(<span class="string">&quot;req-id&quot;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetRequestID</span><span class="params">(ctx context.Context)</span></span> (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">  id, exists := ctx.Value(reqID).(<span class="type">int</span>)</span><br><span class="line">  <span class="keyword">return</span> id, exists</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithRequestID</span><span class="params">(ctx context.Context, reqid <span class="type">int</span>)</span></span> context.Context &#123;</span><br><span class="line">  <span class="keyword">return</span> context.WithValue(ctx, reqID, reqid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用 WithXxx 而不是 SetXxx 也是因为 Context 实际上是 immutable 的，所以不是修改 Context 里某个值，而是产生新的 Context <strong>带某个值</strong>。</p>
<h3 id="Context-Value-是-immutable-的">Context.Value 是 immutable 的</h3>
<p><strong>再多次的强调 Context.Value 是 immutable 的也不过分。</strong></p>
<ul>
<li>context.Context 从设计上就是按照 immutable （不可变的）模式设计的</li>
<li>同样，Context.Value 也是 immutable 的</li>
<li>不要试图在 Context.Value 里存某个可变更的值，然后改变，期望别的 Context 可以看到这个改变
<ul>
<li>更别指望着在 Context.Value 里存可变的值，最后多个 goroutine 并发访问没竞争冒险啥的，因为自始至终，就是按照不可变来设计的</li>
<li>比如设置了超时，就别以为可以改变这个设置的超时值</li>
</ul>
</li>
<li>在使用 Context.Value 的时候，一定要记住这一点</li>
</ul>
<h3 id="应该把什么放到-Context-Value-里？">应该把什么放到 Context.Value 里？</h3>
<ul>
<li>应该保存 Request 范畴的值
<ul>
<li>任何关于 Context 自身的都是 Request 范畴的（这俩同生共死）</li>
<li>从 Request 数据衍生出来，并且随着 Request 的结束而终结</li>
</ul>
</li>
</ul>
<h3 id="什么东西不属于-Request-范畴？">什么东西不属于 Request 范畴？</h3>
<ul>
<li>在 Request 以外建立的，并且不随着 Request 改变而变化
<ul>
<li>比如你 func main() 里建立的东西显然不属于 Request 范畴</li>
</ul>
</li>
<li>数据库连接
<ul>
<li>如果 User ID 在连接里呢？(稍后会提及)</li>
</ul>
</li>
<li>全局 logger
<ul>
<li>如果 logger 里需要有 User ID 呢？（稍后会提及）</li>
</ul>
</li>
</ul>
<h3 id="那么用-Context-Value-有什么问题？">那么用 Context.Value 有什么问题？</h3>
<ul>
<li>不幸的是，好像所有东西都是由请求衍生出来的</li>
<li>那么我们为什么还需要函数参数？然后干脆只来一个 Context 就完了？</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(ctx context.Context)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ctx.Value(<span class="string">&quot;first&quot;</span>).(<span class="type">int</span>) + ctx.Value(<span class="string">&quot;second&quot;</span>).(<span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>曾经看到过一个 API，就是这种形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsAdminUser</span><span class="params">(ctx context.Context)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  userID := GetUser(ctx)</span><br><span class="line">  <span class="keyword">return</span> authSingleton.IsAdmin(userID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里API实现内部从 context 中取得 UserID，然后再进行权限判断。但是从函数签名看，则完全无法理解这个函数具体需要什么、以及做什么。</p>
<blockquote>
<p>代码要以可读性为优先设计考虑。</p>
</blockquote>
<p>别人拿到一个代码，一般不是掉进函数实现细节里去一行行的读代码，而是会先浏览一下函数接口。所以清晰的函数接口设计，会更加利于别人（<strong>或者是几个月后的你自己</strong>）理解这段代码。</p>
<p>一个良好的 API 设计，应该从函数签名就清晰的理解函数的逻辑。如果我们将上面的接口改为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsAdminUser</span><span class="params">(ctx context.Context, userID <span class="type">string</span>, authenticator auth.Service)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure>
<p>我们从这个函数签名就可以清楚的知道：</p>
<ul>
<li>这个函数很可能可以提前被 cancel</li>
<li>这个函数需要 User ID</li>
<li>这个函数需要一个authenticator来</li>
<li>而且由于 authenticator 是传入参数，而不是依赖于隐式的某个东西，我们知道，测试的时候就很容易传入一个模拟认证函数来做测试</li>
<li>userID 是传入值，因此我们可以修改它，不用担心影响别的东西</li>
</ul>
<p>所有这些信息，都是从函数签名得到的，而无需打开函数实现一行行去看。</p>
<h3 id="那什么可以放到-Context-Value-里去？">那什么可以放到 Context.Value 里去？</h3>
<p>现在知道 Context.Value 会让接口定义更加模糊，似乎不应该使用。那么又回到了原来的问题，到底什么可以放到 Context.Value 里去？换个角度去想，什么不是衍生于 Request？</p>
<ul>
<li>Context.Value 应该是告知性质的东西，而不是控制性质的东西</li>
<li>应该永远都不需要写进文档作为必须存在的输入数据</li>
<li>如果你发现你的函数在某些 Context.Value 下无法正确工作，那就说明这个 Context.Value 里的信息不应该放在里面，而应该放在接口上。因为已经让接口太模糊了。</li>
</ul>
<h3 id="什么东西不是控制性质的东西？">什么东西不是控制性质的东西？</h3>
<ul>
<li>Request ID
<ul>
<li>只是给每个 RPC 调用一个 ID，而没有实际意义</li>
<li>这就是个数字/字符串，反正你也不会用其作为逻辑判断</li>
<li>一般也就是日志的时候需要记录一下
<ul>
<li>而 logger 本身不是 Request 范畴，所以 logger 不应该在 Context 里</li>
<li>非 Request 范畴的 logger 应该只是利用 Context 信息来修饰日志</li>
</ul>
</li>
</ul>
</li>
<li>User ID （如果仅仅是作为日志用）</li>
<li>Incoming Request ID</li>
</ul>
<h3 id="什么显然是控制性质的东西？">什么显然是控制性质的东西？</h3>
<ul>
<li>数据库连接
<ul>
<li>显然会非常严重的影响逻辑</li>
<li>因此这应该在函数参数里，明确表示出来</li>
</ul>
</li>
<li>认证服务(Authentication)
<ul>
<li>显然不同的认证服务导致的逻辑不同</li>
<li>也应该放到函数参数里，明确表示出来</li>
</ul>
</li>
</ul>
<h2 id="Context-WithValue的常见使用场景">Context WithValue的常见使用场景</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;context&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">case1:</span></span><br><span class="line"><span class="comment">首先，我们创建一个空上下文并将其分配给ctx变量。</span></span><br><span class="line"><span class="comment">  1.ctx使用其键和值创建 3 个上下文作为父值。</span></span><br><span class="line"><span class="comment">  2.然后我们创建另一个ctx1作为父级的上下文并给它一个键和值。</span></span><br><span class="line"><span class="comment">  3.我们将尝试从中提取价值ctx1，ctx2，ctx3用正确的密钥。它将根据键返回给我们值。</span></span><br><span class="line"><span class="comment">  4.如果我们尝试从具有错误键的上下文中提取值，它将返回nil值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">case2:</span></span><br><span class="line"><span class="comment">  在http上下文中插入固值(中间件的方式)，如 userID，Token等。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//case1()</span></span><br><span class="line">  http.Handle(<span class="string">&quot;/&quot;</span>, middleware1(http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// After Insert Claim into Context</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\\n&quot;</span>, CtxClaim(r.Context()))</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;%+v\\n&quot;</span>, CtxClaim(r.Context()))</span><br><span class="line">  &#125;)))</span><br><span class="line"></span><br><span class="line">  http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Claims <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID <span class="type">int</span> <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> contextKey = <span class="string">&quot;ctx-key&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleware1</span><span class="params">(next http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">  <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Example: Get UserID From Token</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Insert Claim into Context&quot;</span>)</span><br><span class="line">    newCtx := context.WithValue(r.Context(), contextKey, &amp;Claims&#123;</span><br><span class="line">      ID: <span class="number">1</span>, <span class="comment">// example User ID: 1</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r = r.WithContext(newCtx)</span><br><span class="line"></span><br><span class="line">    next.ServeHTTP(w, r)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CtxClaim</span><span class="params">(ctx context.Context)</span></span> *Claims &#123;</span><br><span class="line">  raw, _ := ctx.Value(contextKey).(*Claims)</span><br><span class="line">  <span class="keyword">return</span> raw</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">case1</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ctx := context.Background() <span class="comment">// Empty Context</span></span><br><span class="line"></span><br><span class="line">  ctx1 := context.WithValue(ctx, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>) <span class="comment">// parent: ctx</span></span><br><span class="line">  ctx2 := context.WithValue(ctx, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>) <span class="comment">// parent: ctx</span></span><br><span class="line">  ctx3 := context.WithValue(ctx, <span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>) <span class="comment">// parent: ctx</span></span><br><span class="line"></span><br><span class="line">  ctx4 := context.WithValue(ctx1, <span class="string">&quot;key4&quot;</span>, <span class="string">&quot;value4&quot;</span>) <span class="comment">// parent: ctx1</span></span><br><span class="line"></span><br><span class="line">  fmt.Println(ctx1.Value(<span class="string">&quot;key1&quot;</span>)) <span class="comment">// value1</span></span><br><span class="line">  fmt.Println(ctx2.Value(<span class="string">&quot;key2&quot;</span>)) <span class="comment">// value2</span></span><br><span class="line">  fmt.Println(ctx3.Value(<span class="string">&quot;key3&quot;</span>)) <span class="comment">// value3</span></span><br><span class="line"></span><br><span class="line">  fmt.Println(ctx4.Value(<span class="string">&quot;key4&quot;</span>)) <span class="comment">// value4</span></span><br><span class="line">  fmt.Println(ctx4.Value(<span class="string">&quot;key1&quot;</span>)) <span class="comment">// value1</span></span><br><span class="line"></span><br><span class="line">  fmt.Println(ctx3.Value(<span class="string">&quot;key1&quot;</span>)) <span class="comment">// nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结">小结</h2>
<p>个人不推荐在 context 中封装太多的东西向下传递是非常的不 “simple”，时刻记住context设计初衷从API就可以看出：1.超时控制。2.固值传递（如UserID等）。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang的组合和嵌套（面向接口编程）</title>
    <url>/2023/02/06/golang%E7%9A%84%E7%BB%84%E5%90%88%E5%92%8C%E5%B5%8C%E5%A5%97/</url>
    <content><![CDATA[<h2 id="官方关于golang的继承和重载的FAQ">官方关于golang的继承和重载的FAQ</h2>
<blockquote>
<p>原文部分来自：<a href="https://segmentfault.com/a/1190000022429780">https://segmentfault.com/a/1190000022429780</a></p>
</blockquote>
<ul>
<li>关于类型继承</li>
</ul>
<blockquote>
<p>面向对象的编程，至少在最著名的语言中，涉及对类型之间关系的过多讨论，这些关系通常可以自动派生。Go 采取了不同的方法。</p>
<p>与其要求程序员提前声明两种类型是相关的，在 Go 中，类型会自动满足任何指定其方法子集的接口。除了减少簿记之外，这种方法还有真正的优势。类型可以同时满足多个接口，没有传统多重继承的复杂性。接口可以是非常轻量级的——具有一个甚至零个方法的接口可以表达一个有用的概念。如果出现新想法或用于测试，可以事后添加接口——无需注释原始类型。因为类型和接口之间没有明确的关系，所以没有要管理或讨论的类型层次结构。</p>
<p>可以使用这些想法来构建类似于类型安全的 Unix 管道的东西。例如，了解如何<code>fmt.Fprintf</code> 为任何输出启用格式化打印，而不仅仅是文件，或者<code>bufio</code>包如何与 文件 I/O 完全分离，或者<code>image</code>包如何生成压缩图像文件。所有这些想法都源于<code>io.Writer</code>表示单个方法 ( <code>Write</code>)的单个接口( )。而这只是皮毛。Go 的接口对程序的结构有着深远的影响。</p>
<p>这需要一些时间来适应，但这种隐式的类型依赖是 Go 最高效的事情之一。</p>
<p>​																								    --faq: <a href="https://golang.org/doc/faq#inheritance">https://golang.org/doc/faq#inheritance</a></p>
</blockquote>
<ul>
<li>关于重载的定义</li>
</ul>
<blockquote>
<p>如果不需要进行类型匹配，则方法分派会得到简化。使用其他语言的经验告诉我们，拥有多种名称相同但签名不同的方法有时很有用，但在实践中也可能会令人困惑和脆弱。仅按名称匹配并要求类型的一致性是 Go 类型系统中一个主要的简化决定。</p>
<p>关于运算符重载，它似乎更方便而不是绝对要求。同样，没有它，事情会更简单。</p>
<p>​																									– faq:<a href="https://golang.org/doc/faq#overloading">https://golang.org/doc/faq#overloading</a></p>
</blockquote>
<h2 id="从一个案例引入">从一个案例引入</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ShapeInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">  Area() <span class="type">float64</span></span><br><span class="line">  GetName() <span class="type">string</span></span><br><span class="line">  PrintArea()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shape <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Shape)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Shape)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Shape)</span></span> PrintArea() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s : Area %v\r\n&quot;</span>, s.GetName(), s.Area())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rectangle 矩形求面积</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">  Shape</span><br><span class="line">  w, h <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> r.w * r.h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle 圆形  : 重新定义 Area 和PrintArea 方法</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">  Shape</span><br><span class="line">  r <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Circle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> c.r * c.r * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Circle)</span></span> PrintArea() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s : Area %v\r\n&quot;</span>, c.GetName(), c.Area())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  s := Shape&#123;name: <span class="string">&quot;Shape&quot;</span>&#125;</span><br><span class="line">  c := Circle&#123;Shape: Shape&#123;name: <span class="string">&quot;Circle&quot;</span>&#125;, r: <span class="number">10</span>&#125;</span><br><span class="line">  r := Rectangle&#123;Shape: Shape&#123;name: <span class="string">&quot;Rectangle&quot;</span>&#125;, w: <span class="number">5</span>, h: <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">  listshape := []ShapeInterface&#123;&amp;s, &amp;c, &amp;r&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, si := <span class="keyword">range</span> listshape &#123;</span><br><span class="line">    si.PrintArea() <span class="comment">//!! 猜猜哪个Area()方法会被调用 !!</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">out: </span><br><span class="line">Shape : Area <span class="number">0</span></span><br><span class="line">Circle : Area <span class="number">314.1592653589793</span></span><br><span class="line">Rectangle : Area <span class="number">0</span>    <span class="comment">// 为啥这里没有调用 5 * 4</span></span><br></pre></td></tr></table></figure>
<p>原因分析：<code>Rectangle</code>通过组合<code>Shape</code>获得的<code>PrintArea()</code>方法并没有去调用<code>Rectangle</code>实现的<code>Area()</code>方法，而是去调用了<code>Shape</code>的<code>Area()</code>方法。<code>Circle</code>是因为自己重写了<code>PrintArea()</code>所以在方法里调用到了自身的<code>Area()</code>。</p>
<span id="more"></span>
<h1>解决方案</h1>
<h3 id="1-将要使用的值抽取成一个方法，在初始化中进行赋值。">1.将要使用的值抽取成一个方法，在初始化中进行赋值。</h3>
<p>定义了一个类似<code>InitShape</code>的方法来完成初始化流程，这里我把<code>ShapeInterface</code>接口和<code>Shape</code>类型做一些调整会更好理解一些。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ShapeInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Area() <span class="type">float64</span></span><br><span class="line">    GetName() <span class="type">string</span></span><br><span class="line">    SetArea(<span class="type">float64</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Shape <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    area <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Shape)</span></span> SetArea(area <span class="type">float64</span>) &#123;</span><br><span class="line">    s.area = area</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Shape)</span></span> PrintArea() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s : Area %v\r\n&quot;</span>, s.name, s.area)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitShape</span><span class="params">(s ShapeInterface)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  area, err := s.Area()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  s.SetArea(area)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>Rectangle</code>和<code>Circle</code>这样的组合<code>Shape</code>的类型，只需要按照自己的计算面积的公式实现<code>Area()</code>，<code>SetArea()</code>会把<code>Area()</code>计算出的面积存储在<code>area</code>字段供后面的程序使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Shape</span><br><span class="line">    w, h <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.w * r.h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r := &amp;Rectangle &#123;</span><br><span class="line">    Shape: Shape&#123;name: <span class="string">&quot;Rectangle&quot;</span>&#125;,</span><br><span class="line">    w: <span class="number">5</span>, <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InitShape(r)</span><br><span class="line">r.PrintArea()</span><br></pre></td></tr></table></figure>
<h3 id="2-按照接口的定义，实现所有相关联的方法">2.按照接口的定义，实现所有相关联的方法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Rectangle 矩形求面积 : 重新定义了 Area 方法</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">  Shape</span><br><span class="line">  w, h <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> r.w * r.h</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现 PrintArea 方法，</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span></span> PrintArea() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s : Area %v\r\n&quot;</span>, r.GetName(), r.Area())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-用组合的方式去减少代码量（推荐）">3.用组合的方式去减少代码量（推荐）</h3>
<p>面向接口编程</p>
<ul>
<li>接口里面的方法之间不应该存在相互依赖，应该用单一的方法组合去完成你的功能</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ShapeInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">  GetName() <span class="type">string</span></span><br><span class="line">  GetArea() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shape <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Shape)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Shape)</span></span> GetArea() <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rectangle 矩形求面积 : 重新定义了 Area 方法</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">  Shape</span><br><span class="line">  w, h <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span></span> GetArea() <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> r.w * r.h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle 圆形  : 重新定义 Area 和PrintArea 方法</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">  Shape</span><br><span class="line">  r <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Circle)</span></span> GetArea() <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> c.r * c.r * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PrintAreaInterface 抽象出一个输出面积的接口</span></span><br><span class="line"><span class="keyword">type</span> PrintAreaInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">  PrintArea(ShapeInterface)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PrintAreas <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PrintAreas)</span></span> PrintArea(shape ShapeInterface) &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s : Area %v\r\n&quot;</span>, shape.GetName(), shape.GetArea())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPrintAreas</span><span class="params">()</span></span> PrintAreaInterface &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;PrintAreas&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  s := Shape&#123;name: <span class="string">&quot;Shape&quot;</span>&#125;</span><br><span class="line">  c := Circle&#123;Shape: Shape&#123;name: <span class="string">&quot;Circle&quot;</span>&#125;, r: <span class="number">10</span>&#125;</span><br><span class="line">  r := Rectangle&#123;Shape: Shape&#123;name: <span class="string">&quot;Rectangle&quot;</span>&#125;, w: <span class="number">5</span>, h: <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">  listshape := []ShapeInterface&#123;&amp;s, &amp;c, &amp;r&#125;</span><br><span class="line"></span><br><span class="line">  areas := NewPrintAreas()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, si := <span class="keyword">range</span> listshape &#123;</span><br><span class="line">    areas.PrintArea(si)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="方案一">方案一</h4>
<p>优点</p>
<ul>
<li>重复代码量少，可复用重复逻辑方法</li>
</ul>
<p>缺点</p>
<ul>
<li>接口抽象不太优雅</li>
<li>容易留坑</li>
</ul>
<h4 id="方案二">方案二</h4>
<p>优点</p>
<ul>
<li>接口职责单一，抽象优雅</li>
<li>不容易留坑，代码可读性好</li>
</ul>
<p>缺点</p>
<ul>
<li>重复代码量多</li>
</ul>
<h4 id="方案三（推荐）">方案三（推荐）</h4>
<p>优点</p>
<ul>
<li>符合golang的面向接口编程哲学</li>
</ul>
<p>缺点</p>
<ul>
<li>暂无:dog:</li>
</ul>
<h2 id="小结">小结</h2>
<p>由于本人之前是Python转到golang，对于面向对象的理解和golang的设计不太相符，应该是golang不是纯面向对象的语言，文章开头的几个FAQ也阐述了golang对面向对象支持的问题，所以在代码设计和抽象的时候不能完全的按照面向对象的方式去思考，golang应该是组合，而不是继承。和朋友探讨下来最终实现了方案三（推荐），面向接口编程的哲学。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang指针详解</title>
    <url>/2023/02/06/Go%20%E6%99%AE%E9%80%9A%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E3%80%81unsafe.Pointer%E3%80%81uintptr%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h1>Golang指针</h1>
<blockquote>
<p>原文来自:<a href="https://www.cnblogs.com/-wenli/p/12682477.html">https://www.cnblogs.com/-wenli/p/12682477.html</a></p>
</blockquote>
<ul>
<li><code>*</code>类型:普通指针类型，用于传递对象地址，不能进行指针运算。</li>
<li><code>unsafe.Pointer</code>:通用指针类型，用于转换不同类型的指针，不能进行指针运算，不能读取内存存储的值（必须转换到某一类型的普通指针）。</li>
<li><code>uintptr</code>:用于指针运算，GC 不把 uintptr 当指针，uintptr 无法持有对象。uintptr 类型的目标会被回收。</li>
</ul>
<p><strong><code>unsafe.Pointer</code> 是桥梁，可以让任意类型的指针实现相互转换，也可以将任意类型的指针转换为 uintptr 进行指针运算。</strong><br>
<strong>unsafe.Pointer 不能参与指针运算</strong>，比如你要在某个指针地址上加上一个偏移量，Pointer是不能做这个运算的，那么谁可以呢?</p>
<ul>
<li>就是uintptr类型了，只要将Pointer类型转换成uintptr类型，做完加减法后，转换成Pointer，通过*操作，取值，修改值，随意。</li>
</ul>
<h2 id="小结">小结</h2>
<p><code>unsafe.Pointer</code> 可以让你的变量在不同的普通指针类型转来转去，也就是表示为任意可寻址的指针类型。而 <code>uintptr</code> 常用于与 <code>unsafe.Pointer</code> 打配合，用于做指针运算。</p>
<h2 id="unsafe-Pointer">unsafe.Pointer</h2>
<blockquote>
<p>unsafe 是关注 Go 程序操作类型安全的包。</p>
</blockquote>
<p><code>unsafe.Pointer</code> 可以让你无视 Go 的类型系统，完成任何类型与内建的 uintptr 类型之间的转化。</p>
<p><code>unsafe.Pointer</code>称为通用指针，官方文档对该类型有四个重要描述：</p>
<ul>
<li>
<p>（1）任何类型的指针都可以被转化为Pointer</p>
</li>
<li>
<p>（2）Pointer可以被转化为任何类型的指针</p>
</li>
<li>
<p>（3）uintptr可以被转化为Pointer</p>
</li>
<li>
<p>（4）Pointer可以被转化为uintptr</p>
<p><code>unsafe.Pointer</code>是特别定义的一种指针类型（译注：类似C语言中的void类型的指针），<strong>在golang中是用于各种指针相互转换的桥梁</strong>，它可以包含任意类型变量的地址。<br>
当然，我们不可以直接通过*p来获取unsafe.Pointer指针指向的真实变量的值，因为我们并不知道变量的具体类型。<br>
和普通指针一样，unsafe.Pointer指针也是可以比较的，并且支持和nil常量比较判断是否为空指针。</p>
</li>
</ul>
<h2 id="uintptr">uintptr</h2>
<p>uintptr是一个整数类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// uintptr is an integer type that is large enough to hold the bit pattern of</span></span><br><span class="line"><span class="comment">// any pointer.</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">uintptr</span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure>
<p>即使uintptr变量仍然有效，由uintptr变量表示的地址处的数据也可能被GC回收，这个需要注意！</p>
<h2 id="unsafe包">unsafe包</h2>
<p>unsafe包只有两个类型，三个函数，但是功能很强大。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ArbitraryType <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Offsetof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ArbitraryType是int的一个别名，在Go中对ArbitraryType赋予特殊的意义。代表一个任意Go表达式类型。</li>
<li>Pointer是int指针类型的一个别名，在Go中可以把Pointer类型，理解成任何指针的父类型。</li>
</ul>
<p>三个函数的参数均是ArbitraryType类型，就是接受任何类型的变量。</p>
<ul>
<li>unsafe.Sizeof 接受任意类型的值(表达式)，返回其占用的字节数,这和c语言里面不同，c语言里面sizeof函数的参数是类型，而这里是一个表达式，比如一个变量。</li>
<li>unsafe.Offsetof：返回结构体中元素所在内存的偏移量。</li>
<li>Alignof 返回变量对齐字节数量Offsetof返回变量指定属性的偏移量，这个函数虽然接收的是任何类型的变量，但是有一个前提，就是变量要是一个struct类型，且还不能直接将这个struct类型的变量当作参数，只能将这个struct类型变量的属性当作参数。</li>
</ul>
<span id="more"></span>
<h3 id="巧妙用法">巧妙用法</h3>
<p>在$GOPATH/src下建立poit包，并在poit下建立子包p，目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">GOPATH/src</span></span><br><span class="line"></span><br><span class="line">----poit</span><br><span class="line"></span><br><span class="line">--------p</span><br><span class="line"></span><br><span class="line">------------v.go</span><br><span class="line"></span><br><span class="line">--------main.go</span><br></pre></td></tr></table></figure>
<p>以下是v.go的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> p</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> V <span class="keyword">struct</span> &#123;</span><br><span class="line">    i <span class="type">int32</span></span><br><span class="line">    j <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this V)</span></span> PutI() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;i=%d\n&quot;</span>, this.i)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this V)</span></span> PutJ() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;j=%d\n&quot;</span>, this.j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>意图很明显，我是想通过unsafe包来实现对V的成员i和j赋值，然后通过PutI()和PutJ()来打印观察输出结果。</p>
<p>以下是main.go源代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;poit/p&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> v *p.V = <span class="built_in">new</span>(p.V)</span><br><span class="line">    <span class="keyword">var</span> i *<span class="type">int32</span> = (*<span class="type">int32</span>)(unsafe.Pointer(v))</span><br><span class="line">    *i = <span class="type">int32</span>(<span class="number">98</span>)</span><br><span class="line">    <span class="keyword">var</span> j *<span class="type">int64</span> = (*<span class="type">int64</span>)(unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(v)) + <span class="type">uintptr</span>(unsafe.Sizeof(<span class="type">int32</span>(<span class="number">0</span>)))))</span><br><span class="line">    *j = <span class="type">int64</span>(<span class="number">763</span>)</span><br><span class="line">    v.PutI()</span><br><span class="line">    v.PutJ()</span><br><span class="line">&#125;　</span><br></pre></td></tr></table></figure>
<p>当然会有些限制，比如需要知道结构体V的成员布局，要修改的成员大小以及成员的偏移量。我们的核心思想就是：结构体的成员在内存中的分配是一段连续的内存，结构体中第一个成员的地址就是这个结构体的地址，您也可以认为是相对于这个结构体偏移了0。相同的，这个结构体中的任一成员都可以相对于这个结构体的偏移来计算出它在内存中的绝对地址。</p>
<p>具体来讲解下main方法的实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v *p.V = <span class="built_in">new</span>(p.V)</span><br></pre></td></tr></table></figure>
<p>new是golang的内置方法，用来分配一段内存(会按类型的零值来清零)，并返回一个指针。所以v就是类型为p.V的一个指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i *<span class="type">int32</span> = (*<span class="type">int32</span>)(unsafe.Pointer(v))</span><br></pre></td></tr></table></figure>
<p>将指针v转成通用指针，再转成int32指针。这里就看到了unsafe.Pointer的作用了，您不能直接将v转成int32类型的指针，那样将会panic。刚才说了v的地址其实就是它的第一个成员的地址，所以这个i就很显然指向了v的成员i，通过给i赋值就相当于给v.i赋值了，但是别忘了i只是个指针，要赋值得解引用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">*i = <span class="type">int32</span>(<span class="number">98</span>)　</span><br></pre></td></tr></table></figure>
<p>现在已经成功的改变了v的私有成员i的值，好开心^_^</p>
<p>但是对于v.j来说，怎么来得到它在内存中的地址呢？其实我们可以获取它相对于v的偏移量(unsafe.Sizeof可以为我们做这个事)，但我上面的代码并没有这样去实现。各位别急，一步步来。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> j *<span class="type">int64</span> = (*<span class="type">int64</span>)(unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(v)) + <span class="type">uintptr</span>(unsafe.Sizeof(<span class="type">int32</span>(<span class="number">0</span>)))))</span><br></pre></td></tr></table></figure>
<p>其实我们已经知道v是有两个成员的，包括i和j，并且在定义中，i位于j的前面，而i是int32类型，也就是说i占4个字节。所以j是相对于v偏移了4个字节。您可以用uintptr(4)或uintptr(unsafe.Sizeof(int32(0)))来做这个事。unsafe.Sizeof方法用来得到一个值应该占用多少个字节空间。注意这里跟C的用法不一样，C是直接传入类型，而golang是传入值。之所以转成uintptr类型是因为需要做指针运算。v的地址加上j相对于v的偏移地址，也就得到了v.j在内存中的绝对地址，别忘了j的类型是int64，所以现在的j就是一个指向v.j的指针，接下来给它赋值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">*j = <span class="type">int64</span>(<span class="number">763</span>)</span><br></pre></td></tr></table></figure>
<p>好吧，现在貌视一切就绪了，来打印下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v.PutI()</span><br><span class="line">v.PutJ()</span><br></pre></td></tr></table></figure>
<p>如果您看到了正确的输出，那就成功了！！！</p>
<h3 id="内存对齐">内存对齐</h3>
<p>但是，别忘了上面的代码其实是有一些问题的，您发现了吗？</p>
<p>在p目录下新建w.go文件，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> p</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> W <span class="keyword">struct</span> &#123;</span><br><span class="line">    b <span class="type">byte</span></span><br><span class="line">    i <span class="type">int32</span></span><br><span class="line">    j <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> w *W = <span class="built_in">new</span>(W)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;size=%d\n&quot;</span>, unsafe.Sizeof(*w))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要修改main.go的代码吗？不需要，我们只是来测试一下。w.go里定义了一个特殊方法init，它会在导入p包时自动执行，别忘了我们有在main.go里导入p包。每个包都可定义多个init方法，它们会在包被导入时自动执行(在执行main方法前被执行，通常用于初始化工作)，但是，最好在一个包中只定义一个init方法，否则您或许会很难预期它的行为)。我们来看下它的输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">size=<span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>等等，好像跟我们想像的不一致。来手动计算一下：b是byte类型，占1个字节；i是int32类型，占4个字节；j是int64类型，占8个字节，1+4+8=13。这是怎么回事呢？这是因为发生了对齐。在struct中，它的对齐值是它的成员中的最大对齐值。每个成员类型都有它的对齐值，可以用unsafe.Alignof方法来计算，比如unsafe.Alignof(w.b)就可以得到b在w中的对齐值。同理，我们可以计算出w.b的对齐值是1，w.i的对齐值是4，w.j的对齐值也是4。如果您认为w.j的对齐值是8那就错了，所以我们前面的代码能正确执行(试想一下，如果w.j的对齐值是8，那前面的赋值代码就有问题了。也就是说前面的赋值中，如果v.j的对齐值是8，那么v.i跟v.j之间应该有4个字节的填充。所以得到正确的对齐值是很重要的)。对齐值最小是1，这是因为存储单元是以字节为单位。所以b就在w的首地址，而i的对齐值是4，它的存储地址必须是4的倍数，因此，在b和i的中间有3个填充，同理j也需要对齐，但因为i和j之间不需要填充，所以w的Sizeof值应该是13+3=16。如果要通过unsafe来对w的三个私有成员赋值，b的赋值同前，而i的赋值则需要跳过3个字节，也就是计算偏移量的时候多跳过3个字节，同理j的偏移可以通过简单的数学运算就能得到。<br>
比如也可以通过unsafe来灵活取值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b []<span class="type">byte</span> = []<span class="type">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> c *<span class="type">byte</span> = &amp;b[<span class="number">0</span>]</span><br><span class="line">    fmt.Println(*(*<span class="type">byte</span>)(unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(c)) + <span class="type">uintptr</span>(<span class="number">1</span>))))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误案例">错误案例</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> subtly incorrect!</span></span><br><span class="line">tmp := <span class="type">uintptr</span>(unsafe.Pointer(&amp;x)) + unsafe.Offsetof(x.b)</span><br><span class="line">pb := (*<span class="type">int16</span>)(unsafe.Pointer(tmp))</span><br><span class="line">*pb = <span class="number">42</span></span><br></pre></td></tr></table></figure>
<p>产生错误的原因很微妙。<strong>有时候垃圾回收器会移动一些变量以降低内存碎片等问题。这类垃圾回收器被称为移动GC。</strong></p>
<p>​    当一个变量被移动，所有的保存改变量旧地址的指针必须同时被更新为变量移动后的新地址。</p>
<p>​    从垃圾收集器的视角来看，一个unsafe.Pointer是一个指向变量的指针，因此当变量被移动是对应的指针也必须被更新；但是uintptr类型的临时变量只是一个普通的数字，所以其值不应该被改变。</p>
<p>上面错误的代码因为引入一个非指针的临时变量tmp，导致垃圾收集器无法正确识别这个是一个指向变量x的指针。当第二个语句执行时，变量x可能已经被转移，这时候临时变量tmp也就不再是现在的&amp;x.b地址。**第三个向之前无效地址空间的赋值语句将彻底摧毁整个程序！</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算和云原生概念浅析</title>
    <url>/2023/02/06/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%92%8C%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1>云计算定义</h1>
<blockquote>
<p>一种能够跨网络、按需提供基础架构、服务、平台和应用的交付方式，正在快速取代原本通过硬布线连接进行资源共享的方式。          –  redhat</p>
</blockquote>
<ul>
<li>云计算解决的问题主要是<strong>物理资源上云，通过虚拟化技术来将底层资源池化，达到弹性、可控等目的</strong>。然而大多数传统应用并不是面向云环境来构建的，这里面包含了大量开发需求（开发框架、类库、后段服务等），就导致了云端的强大能力没有被完全发挥出来。因此，摒弃传统的应用技术架构，基于云的特点重新构建云原生应用，成为企业上云的下一个阶段。</li>
</ul>
<h2 id="特点">特点</h2>
<p>云计算是指在云中<strong>运行工作负载</strong>，而云是一种能够抽象、汇集和共享整个网络中的可扩展资源的 IT 环境。云计算和云本身都不属于技术的范畴。</p>
<ul>
<li>云计算是指在云中运行工作负载的功能。</li>
<li>而云是一种环境，是运行应用的地方。</li>
<li>技术则是指用于构建和使用云的软件和硬件</li>
</ul>
<p>云计算为云原生提供了物理基础，做个不太精确的比喻:“云计算是电脑硬件，云原生是应用”.</p>
<h1>云原生</h1>
<h2 id="公有云，私有云和混和云">公有云，私有云和混和云</h2>
<ul>
<li>根据服务模式对云计算的分类包括：基础设施作为服务（iaas），平台作为服务（paas），软件作为服务（saas）。</li>
</ul>
<p>根据云计算的资源归属对象，它可以分为公共云和私有云两大类。</p>
<ul>
<li>公共云（公共云）是一种向公众提供计算资源的服务。一般通过互联网使用，成本低，公共云的核心属性是<strong>共享资源服务</strong>。公共云的优点是低成本和良好的可扩展性。缺点是用户对云资源、数据安全、网络性能和匹配等问题缺乏控制。</li>
<li>私有云是为拥有基础设施并控制如何在其上部署应用程序的单个客户而构建的。用户可以在企业数据中心防火墙或安全托管站点中部署私有云。<strong>私有云的核心属性是专有资源</strong>。</li>
<li>混合云不是一个独立的概念。它是一种混合云服务模式，通过标准化手段或专有技术将公共和私人云结合起来。简单地说，混合云是一种云服务模式，既有公共云，也有私人云。</li>
</ul>
<span id="more"></span>
<h2 id="服务网格（Service-mesh）">服务网格（Service mesh）</h2>
<blockquote>
<p>服务网格是用于处理服务间通信的专用基础设施层。它负责通过包含现代云原生应用程序的复杂服务拓扑来可靠地传递请求。实际上，服务网格通常通过一组轻量级网络代理来实现，这些代理与应用程序代码一起部署，而不需要感知应用程序本身。 —— Willian Morgan Buoyant CEO</p>
</blockquote>
<p>服务网格有如下几个特点：</p>
<ul>
<li>应用程序间通讯的中间层</li>
<li>轻量级网络代理</li>
<li>应用程序无感知</li>
<li>解耦应用程序的重试/超时、监控、追踪和服务发现</li>
</ul>
<p>目前两款流行的服务网格开源软件 <code>Linkerd</code> 和 <code>Istio</code> 都可以直接在 kubernetes`中集成，其中 Linkerd 已经成为 CNCF 成员，Istio 在 2018年7月31日宣布 1.0。</p>
<h2 id="理解服务网格"><strong>理解服务网格</strong></h2>
<p>如果用一句话来解释什么是服务网格，可以将它比作是应用程序或者说微服务间的 TCP/IP，负责服务之间的网络调用、限流、熔断和监控。</p>
<p>对于编写应用程序来说一般无须关心 TCP/IP 这一层（比如通过 HTTP 协议的 RESTful 应用），同样使用服务网格也就无须关系服务之间的那些原来是通过应用程序或者其他框架实现的事情，比如 Spring Cloud、OSS，现在只要交给服务网格就可以了。</p>
<p><a href="http://philcalcado.com/">Phil Calçado</a> 在他的这篇博客 <a href="http://philcalcado.com/2017/08/03/pattern_service_mesh.html">Pattern: Service Mesh</a> 中详细解释了服务网格的来龙去脉：</p>
<ol>
<li>从最原始的主机之间直接使用网线相连</li>
<li>网络层的出现</li>
<li>集成到应用程序内部的控制流</li>
<li>分解到应用程序外部的控制流</li>
<li>应用程序的中集成服务发现和断路器</li>
<li>出现了专门用于服务发现和断路器的软件包/库，如 <a href="https://finagle.github.io/">Twitter 的 Finagle</a> 和 <a href="https://code.fb.com/networking-traffic/introducing-proxygen-facebook-s-c-http-framework/">Facebook 的 Proxygen</a>，这时候还是集成在应用程序内部</li>
<li>出现了专门用于服务发现和断路器的开源软件，如 <a href="https://netflix.github.io/">Netflix OSS</a>、Airbnb 的 <a href="https://github.com/airbnb/synapse">synapse</a> 和 <a href="https://github.com/airbnb/nerve">nerve</a></li>
<li>最后作为微服务的中间层服务网格出现</li>
</ol>
<p>服务网格的架构如下图所示：</p>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/202111012122133.png" alt="image-20211101212200081"></p>
<p>下面以 Istio 为例讲解服务网格如何在 Kubernetes 中工作。</p>
<ul>
<li>Istio 将服务请求路由到目的地址，根据中的参数判断是到生产环境、测试环境还是 staging 环境中的服务（服务可能同时部署在这三个环境中），是路由到本地环境还是公有云环境？所有的这些路由信息可以动态配置，可以是全局配置也可以为某些服务单独配置。</li>
<li>当 Istio 确认了目的地址后，将流量发送到相应服务发现端点，在 Kubernetes 中是 service，然后 service 会将服务转发给后端的实例。</li>
<li>Istio 根据它观测到最近请求的延迟时间，选择出所有应用程序的实例中响应最快的实例。</li>
<li>Istio 将请求发送给该实例，同时记录响应类型和延迟数据。</li>
<li>如果该实例挂了、不响应了或者进程不工作了，Istio 将把请求发送到其他实例上重试。</li>
<li>如果该实例持续返回 error，Istio 会将该实例从负载均衡池中移除，稍后再周期性得重试。</li>
<li>如果请求的截止时间已过，Istio 主动失败该请求，而不是再次尝试添加负载。</li>
<li>Istio 以 metric 和分布式追踪的形式捕获上述行为的各个方面，这些追踪信息将发送到集中 metric 系统。</li>
</ul>
<h2 id="概念篇">概念篇</h2>
<p>云原生</p>
<blockquote>
<p>云原生计算基金会（CNCF）：云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。</p>
</blockquote>
<p>容器：Kubernetes 的底层计算引擎，提供容器化的计算资源。</p>
<p>微服务：一种软件架构思想，用来构建云原生应用。服务网格：建立在 Kubernetes 之上，作为服务间通信的底座，提供强大的服务治理功能。</p>
<p>声明式 API ：一种新的软件开发模式，通过描述期望的应用状态，来使系统更加健壮。</p>
<ul>
<li>声明式 API 是指我们通过工具描述期望的应用状态，并由工具保障应用一直处在我们期望的状态。</li>
<li>Kubernetes 的 API 设计，就是一种典型的声明式 API。例如，我们在创建 Deployment 时，在 Kubernetes YAML 文件中声明应用的副本数为2，即设置replicas: 2，Deployment Controller 就会确保应用的副本数一直为2。也就是说，如果当前副本数大于2，Deployment Controller 会删除多余的副本；如果当前副本数小于2，会创建新的副本。</li>
<li>声明式设计是一种设计理念，同时也是一种工作模式，它使得你的系统更加健壮。分布式系统环境可能会出现各种不确定的故障，面对这些组件故障，如果使用声明式 API ，你只需要查看对应组件的 API 服务器状态，再确定需要执行的操作即可。</li>
</ul>
<p>不可变基础设施：一种新的软件部署模式，应用实例一旦被创建，便只能重建不能更新，是现代运维的基础。</p>
<ul>
<li>不可变基础设施（Immutable Infrastructure）的构想，是由 Chad Fowler 于 2013 年提出的。具体来说就是：一个应用程序的实例，一旦被创建，就会进入只读的状态，后面如果想变更这个应用程序的实例，只能重新创建一个新的实例。通过这种模式，可以<strong>确保应用程序实例的一致性</strong>，这使得落地 DevOps 更加容易，并可以有效减少运维人员管理配置的负担。</li>
</ul>
<blockquote>
<p>云原生是一种构建和运行应用程序的方法</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Cloud表示应用程序位于云中，而不是传统的数据中心；</span><br><span class="line">Native表示应用程序从设计之初即考虑到云的环境，原生为云而设计，在云上以最佳姿势运行，</span><br><span class="line">充分利用和发挥云平台的弹性+分布式优势。</span><br></pre></td></tr></table></figure>
<p>DevOps+持续交付+微服务+容器</p>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/202111012122173.png" alt="image-20211101212245096"></p>
<ul>
<li>符合云原生架构的应用程序应该是：采用开源堆栈（K8S+Docker）进行容器化，基于微服务架构提高灵活性和可维护性，借助敏捷方法、DevOps支持持续迭代和运维自动化，利用云平台设施实现弹性伸缩、动态调度、优化资源利用率。</li>
</ul>
<h2 id="云元生素的四要素">云元生素的四要素</h2>
<ul>
<li><strong>微服务</strong>：几乎每个云原生的定义都包含微服务，跟微服务相对的是单体应用，微服务有理论基础，那就是康威定律，指导服务怎么切分，很玄乎，凡是能称为理论定律的都简单明白不了，不然就忒没b格，大概意思是组织架构决定产品形态，不知道跟马克思的生产关系影响生产力有无关系。</li>
</ul>
<p>微服务架构的好处就是按 function 切了之后，服务解耦，内聚更强，变更更易；另一个划分服务的技巧据说是依据DDD来搞。</p>
<ul>
<li><strong>容器化</strong>：Docker是应用最为广泛的容器引擎，在思科谷歌等公司的基础设施中大量使用，是基于LXC技术搞的，容器化为微服务提供实施保障，起到应用隔离作用，K8S是容器编排系统，用于容器管理，容器间的负载均衡，谷歌搞的，Docker和K8S都采用Go编写，都是好东西。</li>
<li><strong>DevOps</strong>：这是个组合词，Dev+Ops，就是开发和运维合体，不像开发和产品，经常刀刃相见，实际上DevOps应该还包括测试，DevOps是一个敏捷思维，是一个沟通文化，也是组织形式，为云原生提供持续交付能力。</li>
<li><strong>持续交付</strong>：持续交付是不误时开发，不停机更新，小步快跑，反传统瀑布式开发模型，这要求开发版本和稳定版本并存，其实需要很多流程和工具支撑。</li>
</ul>
<h2 id="云原生的设计理念"><strong>云原生的设计理念</strong></h2>
<p>云原生系统的设计理念如下:</p>
<ul>
<li>面向分布式设计（Distribution）：容器、微服务、API 驱动的开发；</li>
<li>面向配置设计（Configuration）：一个镜像，多个环境配置；</li>
<li>面向韧性设计（Resistancy）：故障容忍和自愈；</li>
<li>面向弹性设计（Elasticity）：弹性扩展和对环境变化（负载）做出响应；</li>
<li>面向交付设计（Delivery）：自动拉起，缩短交付时间；</li>
<li>面向性能设计（Performance）：响应式，并发和资源高效利用；</li>
<li>面向自动化设计（Automation）：自动化的 DevOps；</li>
<li>面向诊断性设计（Diagnosability）：集群级别的日志、metric 和追踪；</li>
<li>面向安全性设计（Security）：安全端点、API Gateway、端到端加密；</li>
</ul>
<p>以上的设计理念很多都是继承自分布式应用的设计理念。虽然有如此多的理念但是我们仍然无法辨认什么样的设施才是云原生基础设施，不过可以先用排除法，我将解释什么不是云原生基础设施。</p>
<h1>云原生应用</h1>
<p>整体来看，云原生应用是指生而为云的应用，应用程序从设计之初就考虑到了云的环境，可以在云上以最佳姿势运行，充分利用和发挥云平台提供的各种能力。具体来看，云原生应用具有以下三大特点：</p>
<ul>
<li>从应用生命周期管理维度来看，使用 DevOps 和 CI/CD 的方式，进行开发和交付。</li>
<li>从应用维度来看，以微服务原则进行划分设计。</li>
<li>从系统资源维度来看，采用 Docker + Kubernetes 的方式来部署。</li>
</ul>
<p>对于云原生架构的部署，通常我们需要关注以下两点：</p>
<ul>
<li>容灾能力：容灾能力是指应用程序遇到故障时的恢复能力。在互联网时代，对应用的容灾能力有比较高的要求。理想情况是系统在出现故障时，能够无缝切换到另外一个可用的实例上，继续提供服务，并做到用户无感知。但在实际开发中，无缝切换在技术上比较难以实现，所以也可以退而求其次，允许系统在一定时间内不可用。通常这个时间需要控制在秒级，例如 5s。容灾能力可以通过负载均衡、健康检查来实现。</li>
<li>扩缩容能力：扩缩容能力指的是系统能够根据需要扩缩容，可以手动扩缩容，也可以自动扩缩容。互联网时代对扩缩容能力的要求也比较高，需要实现自动扩缩容。我们可以基于一些自定义指标，例如 CPU 使用率、内存使用率等来自动扩缩容。扩容也意味着能够承载更多的请求，提高系统的吞吐量；缩容，意味着能够节省成本。扩缩容能力的实现，需要借助于负载均衡和监控告警能力。</li>
</ul>
]]></content>
      <categories>
        <category>CloudNative</category>
      </categories>
      <tags>
        <tag>云原生概念</tag>
      </tags>
  </entry>
  <entry>
    <title>golang中的nil</title>
    <url>/2023/02/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3golang%E4%B8%AD%E7%9A%84nil/</url>
    <content><![CDATA[<h1>深入理解golang中的<code>nil</code></h1>
<blockquote>
<p>nil is (a) zero</p>
</blockquote>
<h2 id="什么是零值（zero-value）">什么是零值（zero value）</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go中的零值</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span>        -&gt; <span class="literal">false</span></span><br><span class="line">numbers     -&gt; <span class="number">0</span></span><br><span class="line"><span class="type">string</span>      -&gt; <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">pointers    -&gt; <span class="literal">nil</span>      <span class="comment">// point to nothing</span></span><br><span class="line">slices      -&gt; <span class="literal">nil</span>			<span class="comment">// have no backing array</span></span><br><span class="line">maps        -&gt; <span class="literal">nil</span>			<span class="comment">// are not initialized</span></span><br><span class="line">channels    -&gt; <span class="literal">nil</span>			<span class="comment">// are not initialized</span></span><br><span class="line">functions    -&gt; <span class="literal">nil</span>			<span class="comment">// are not initialized</span></span><br><span class="line">interfaces  -&gt; <span class="literal">nil</span>			<span class="comment">// have no value assigned, not even a  nil pointer</span></span><br></pre></td></tr></table></figure>
<h3 id="struct中的零值（zero-values）">struct中的零值（zero values）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">  Age     <span class="type">int</span></span><br><span class="line">  Name     <span class="type">string</span></span><br><span class="line">  Friend  []Person	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p Person <span class="comment">// Person&#123;0,&quot;&quot;,nil&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="nil-是什么类型（type）">nil 是什么类型（type）</h3>
<blockquote>
<p>“nil is a predeclared identifier in Go that <strong>represents zero values for pointers, interfaces, channels</strong>, maps, slices and function types.”</p>
<p>nil 是 Go 中预先声明的标识符，表示指针、接口、通道、映射、切片和函数类型的零值。</p>
</blockquote>
<h3 id="一些关于nil的实践">一些关于<code>nil</code>的实践</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//nil == nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s fmt.Stringer      <span class="comment">// Stringer (nil,nil)</span></span><br><span class="line">fmt.Println(s == <span class="literal">nil</span>)    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *Person            <span class="comment">// nil of type *Person</span></span><br><span class="line"><span class="keyword">var</span> s fmt.Stringer = p  <span class="comment">// Stringer(*Person,nil)</span></span><br><span class="line">fmt.Println(s == <span class="literal">nil</span>)    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h5 id="nil-not-nil">nil not nil ?</h5>
<ul>
<li>Do not declare concrete error vars (不要声名错误变量)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">type</span> NameEmtpyError <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NameEmtpyError实现了 Error() 方法的对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *NameEmtpyError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;name 不能为空&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> err *NameEmtpyError</span><br><span class="line">  <span class="keyword">return</span> err								<span class="comment">// nil of type *NameEmtpyError</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  err := do()                <span class="comment">// error(*NameEmtpyError,nil)</span></span><br><span class="line">  fmt.Println(err == <span class="literal">nil</span>)   <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不要返回具体的错误类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span></span> *NameEmtpyError &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span>								<span class="comment">// nil of type *NameEmtpyError</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wrapDo</span><span class="params">()</span></span> <span class="type">error</span> &#123;        <span class="comment">// error(*NameEmtpyError, nil)</span></span><br><span class="line">  <span class="keyword">return</span> do()								<span class="comment">// nil of type *NameEmtpyError</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  err := wrapDo()            <span class="comment">// error(*NameEmtpyError,nil)</span></span><br><span class="line">  fmt.Println(err == <span class="literal">nil</span>)		<span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="nil-is-useful">nil is useful</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pointers       <span class="comment">// methods can be callend on nil receivers 方法可以在 nil 接收器上调用</span></span><br><span class="line">slices         <span class="comment">// perfectly valid zero values							完全有效的零值映射</span></span><br><span class="line">maps           <span class="comment">// perfect as read-only values							完美的只读值</span></span><br><span class="line">channels       <span class="comment">// essential for some concurrency patterns 对于某些并发模式必不可少</span></span><br><span class="line">functions      <span class="comment">// needed for completeness									完整性所需</span></span><br><span class="line">interfaces      <span class="comment">// the most userd signal in Go(err != nil) Go中使用次数最多的信号(err != nil)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang并发编程</title>
    <url>/2023/02/06/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1>预备知识</h1>
<h2 id="unsafe-Pointer">unsafe.Pointer</h2>
<blockquote>
<p>unsafe.Pointer 是一种特殊意义的指针，它可以包含任意类型的地址，有点类似于 C 语言里的 void* 指针，全能型的。</p>
</blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/137060307">对unsafe.Pointer 又爱又恨，你会有效使用它吗？</a></p>
<blockquote>
<p>unsafe 是关注 Go 程序操作类型安全的包。</p>
</blockquote>
<p><code>unsafe.Pointer</code> 可以让你无视 Go 的类型系统，完成任何类型与内建的 uintptr 类型之间的转化。根据文档，unsafe.Pointer 可以实现四种其他类型不能的操作：</p>
<ul>
<li>任何类型的指针都可以转化为一个 unsafe.Pointer</li>
<li>一个 unsafe.Pointer 可以转化成任何类型的指针</li>
<li>一个 uintptr 可以转化成一个 unsafe.Pointer</li>
<li>一个 unsafe.Pointer 可以转化成一个 uintptr</li>
</ul>
<p>两种只能借助 unsafe 包才能完成的操作：</p>
<ul>
<li>使用 unsafe.Pointer 实现两种类型间转换</li>
<li>使用 unsafe.Pointer 处理系统调用。</li>
</ul>
<h2 id="CAS比较并交换-Compare-And-Swap">CAS比较并交换----Compare And Swap</h2>
<p><a href="https://studygolang.com/articles/23289">Go 的一个 CAS 操作使用场景</a></p>
<ul>
<li>在并发执行的多个 routine R1,R2…Rn 的中，同一时间只允许唯一一个 routine 执行某一个操作，并且其他 routine 需要非阻塞的知道自己无权操作并返回的时候，可以使用 CAS 操作。</li>
</ul>
<blockquote>
<p>大方向：任务编排用 <code>Channel</code>，共享资源保护用传统<code>并发原语</code></p>
</blockquote>
<h1>互斥锁实现机制</h1>
<blockquote>
<p>使用互斥锁，限定临界区只能同时由一个线程持有。</p>
</blockquote>
<ul>
<li>临界区
<ul>
<li>在并发编程中，如果程序中的一部分会被并发访问或修改，那么，为了避免并发访问导致的意想不到的结果，这部分程序需要被保护起来，这部分被保护起来的程序，就叫做临界区。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/202108281355882.png" alt="image-20210828135504575"></p>
<p>在 Go 标准库中，它提供了 Mutex 来实现互斥锁这个功能。</p>
<ul>
<li>共享资源。并发地读写共享资源，会出现数据竞争（data race）的问题，所以需要 Mutex、RWMutex 这样的并发原语来保护。</li>
<li>任务编排。需要 goroutine 按照一定的规律执行，而 goroutine 之间有相互等待或者依赖的顺序关系，我们常常使用 WaitGroup 或者 Channel 来实现。</li>
<li>消息传递。信息交流以及不同的 goroutine 之间的线程安全的数据交流，常常使用 Channel 来实现。</li>
</ul>
<span id="more"></span>
<h2 id="简单的计数器例子-Counter">简单的计数器例子 Counter</h2>
<p>方法一：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">   <span class="comment">// 互斥锁保护计数器</span></span><br><span class="line">   <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">   wg.Add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++&#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="comment">// 对变量 count 进行加法操作</span></span><br><span class="line">         <span class="comment">// count++ 不是一个原子操作，它至少包含几个步骤，</span></span><br><span class="line">         <span class="comment">// 比如读取变量 count 的当前值，</span></span><br><span class="line">         <span class="comment">// 对这个值加 1，把结果再保存到 count 中。</span></span><br><span class="line">         <span class="comment">// 因为不是原子操作，就可能有并发的问题。</span></span><br><span class="line">         <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++&#123;</span><br><span class="line">mu.Lock()</span><br><span class="line">count++</span><br><span class="line">            mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待 10 个 goroutine 完成</span></span><br><span class="line">   wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;结果为&quot;</span>, count)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二（推荐）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span>&#123;</span><br><span class="line">   id    <span class="type">int</span></span><br><span class="line">   name  <span class="type">string</span></span><br><span class="line">   mu    sync.Mutex</span><br><span class="line">   count <span class="type">uint</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(c *Counter)</span></span>Inc() &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line">c.count++</span><br><span class="line">   c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(c *Counter)</span></span>Count()<span class="type">uint</span>&#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main2</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> counter Counter</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">   wg.Add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++&#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++&#123;</span><br><span class="line">counter.Inc()<span class="comment">// 受到 mutex 保护的方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;结果为&quot;</span>, counter.count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等待的goroutine们是以FIFO排队的</p>
<ul>
<li>
<p>1）当Mutex处于正常模式时，若此时没有新goroutine与队头goroutine竞争，则队头goroutine获得。若有新goroutine竞争大概率新goroutine获得。</p>
</li>
<li>
<p>2）当队头goroutine竞争锁失败1ms后，它会将Mutex调整为饥饿模式。进入饥饿模式后，锁的所有权会直接从解锁goroutine移交给队头goroutine，此时新来的goroutine直接放入队尾。</p>
</li>
<li>
<p>3）当一个goroutine获取锁后，如果发现自己满足下列条件中的任何一个</p>
<ul>
<li>它是队列中最后一个</li>
<li>它等待锁的时间少于1ms</li>
</ul>
<p>将锁切换回正常模式</p>
</li>
</ul>
<h2 id="mutex-注意点">mutex 注意点</h2>
<ul>
<li>Unlock 方法可以被任意的 goroutine 调用释放锁，即使是没持有这个互斥锁的 goroutine，也可以进行这个操作。这是因为，Mutex 本身并没有包含持有这把锁的 goroutine 的信息，所以，Unlock 也不会对此进行检查。Mutex 的这个设计一直保持至今。</li>
</ul>
<h2 id="Mutex常见错误">Mutex常见错误</h2>
<blockquote>
<p>Mutex 常见的错误场景有 4 类，分别是 Lock/Unlock 不是成对出现、Copy 已使用的 Mutex、重入和死锁。</p>
</blockquote>
<p>可重入的概念</p>
<ul>
<li>当一个线程获取锁时，如果没有其它线程拥有这个锁，那么，这个线程就成功获取到这个锁。之后，如果其它线程再请求这个锁，就会处于阻塞等待的状态。但是，如果拥有这把锁的线程再请求这把锁的话，不会阻塞，而是成功返回，所以叫可重入锁（有时候也叫做递归锁）。只要你拥有这把锁，你可以可着劲儿地调用，比如通过递归实现一些算法，调用者不会阻塞或者死锁。</li>
</ul>
<p>死锁</p>
<ul>
<li>两个或两个以上的进程（或线程，goroutine）在执行过程中，因争夺共享资源而处于一种互相等待的状态，如果没有外部干涉，它们都将无法推进下去，此时，我们称系统处于死锁状态或系统产生了死锁。</li>
</ul>
<p>避免死锁，只要破坏这四个条件中的一个或者几个，就可以了。</p>
<ul>
<li>互斥： 至少一个资源是被排他性独享的，其他线程必须处于等待状态，直到资源被释放。</li>
<li>持有和等待：goroutine 持有一个资源，并且还在请求其它 goroutine 持有的资源，也就是咱们常说的“吃着碗里，看着锅里”的意思。</li>
<li>不可剥夺：资源只能由持有它的 goroutine 来释放。</li>
<li>环路等待：一般来说，存在一组等待进程，P={P1，P2，…，PN}，P1 等待 P2 持有的资源，P2 等待 P3 持有的资源，依此类推，最后是 PN 等待 P1 持有的资源，这就形成了一个环路等待的死结。</li>
</ul>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/202108281347706.png" alt="image-20210828135540673"></p>
<h2 id="Mutex小结">Mutex小结</h2>
<h2 id="RWMutex-—-读写锁">RWMutex — 读写锁</h2>
<p>标准库中的 RWMutex 是一个 <code>reader/writer</code> 互斥锁。RWMutex在某一时刻只能由任意数量的 reader 持有，或者是只被单个的 writer 持有。RWMutex 的方法也很少，总共有 5 个。</p>
<ul>
<li>
<p>Lock/Unlock：写操作时调用的方法。如果锁已经被 reader 或者 writer 持有，那么，Lock 方法会一直阻塞，直到能获取到锁；Unlock 则是配对的释放锁的方法。</p>
</li>
<li>
<p>RLock/RUnlock：读操作时调用的方法。如果锁已经被 writer 持有的话，RLock 方法会一直阻塞，直到能获取到锁，否则就直接返回；而 RUnlock 是 reader 释放锁的方法。</p>
</li>
<li>
<p>RLocker：这个方法的作用是为读操作返回一个 Locker 接口的对象。它的 Lock 方法会调用 RWMutex 的 RLock 方法，它的 Unlock 方法会调用 RWMutex 的 RUnlock 方法。</p>
<p>RWMutex 的零值是未加锁的状态，所以，当你使用 RWMutex 的时候，无论是声明变量，还是嵌入到其它 struct 中，都不必显式地初始化。</p>
</li>
</ul>
<blockquote>
<p>如果你遇到可以明确区分 reader 和 writer goroutine 的场景，且有大量的并发读、少量的并发写，并且有强烈的性能需求，你就可以考虑使用读写锁 RWMutex 替换 Mutex。</p>
</blockquote>
<h2 id="RWMutex-的实现原理">RWMutex 的实现原理</h2>
<p>RWMutex 是很常见的并发原语，很多编程语言的库都提供了类似的并发类型。RWMutex 一般都是基于互斥锁、条件变量（condition variables）或者信号量（semaphores）等并发原语来实现。Go 标准库中的 RWMutex 是基于 Mutex 实现的。</p>
<ul>
<li>readers-writers 问题一般有三类，基于对读和写操作的优先级，读写锁的设计和实现也分成三类。Read-preferring：读优先的设计可以提供很高的并发性，但是，在竞争激烈的情况下可能会导致写饥饿。这是因为，如果有大量的读，这种设计会导致只有所有的读都释放了锁之后，写才可能获取到锁。</li>
<li>Write-preferring：写优先的设计意味着，如果已经有一个 writer 在等待请求锁的话，它会阻止新来的请求锁的 reader 获取到锁，所以优先保障 writer。当然，如果有一些 reader 已经请求了锁的话，新请求的 writer 也会等待已经存在的 reader 都释放锁之后才能获取。所以，写优先级设计中的优先权是针对新来的请求而言的。这种设计主要避免了 writer 的饥饿问题。</li>
<li>不指定优先级：这种设计比较简单，不区分 reader 和 writer 优先级，某些场景下这种不指定优先级的设计反而更有效，因为第一类优先级会导致写饥饿，第二类优先级可能会导致读饥饿，这种不指定优先级的访问不再区分读写，大家都是同一个优先级，解决了饥饿的问题。</li>
</ul>
<p>Go 标准库中的 RWMutex 设计是 Write-preferring 方案。一个正在阻塞的 Lock 调用会排除新的 reader 请求到锁。</p>
<h2 id="RWMutex的锁">RWMutex的锁</h2>
<p>RWMutex 是⼀个多 writer 多 reader 的读写锁，所以同时可能有多个 writer 和 reader。那 么，为了避免 writer 之间的竞争，RWMutex 就会使用⼀个 Mutex 来保证 writer 的互斥。</p>
<ul>
<li>在 Lock 方法中，是先获取内部互斥锁，才会修改的其他字段；</li>
<li>在 Unlock 方法中，是先修改的其他字段，才会释放内部互斥锁，这样才能保证字段的修改也受到互斥锁的保护。</li>
</ul>
<blockquote>
<p>使用读写锁最需要注意的⼀点就是尽量避免重入，重入带来的死锁⾮常隐蔽，⽽且难以 诊断。</p>
</blockquote>
<h1>WaitGroup：协同等待，任务编排利器</h1>
<h2 id="WaitGroup基本用法">WaitGroup基本用法</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Add(delta <span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Done()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait()</span><br></pre></td></tr></table></figure>
<ul>
<li>Add，用来设置 WaitGroup 的计数值；</li>
<li>Done，用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1)；</li>
<li>Wait，调用这个方法的 goroutine 会⼀直阻塞，直到 WaitGroup 的计数值变为 0。</li>
</ul>
<h2 id="WaitGroup数据结构">WaitGroup数据结构</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 避免复制使用的⼀个技巧，可以告诉vet⼯具违反了复制使用的规则</span></span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 64bit(8bytes)的值分成两段，⾼32bit是计数值，低32bit是waiter的计数</span></span><br><span class="line">    <span class="comment">// 另外32bit是用作信号量的</span></span><br><span class="line">    <span class="comment">// 因为64bit值的原子操作需要64bit对⻬，但是32bit编译器不⽀持，所以数组中的元素在不同的架构</span></span><br><span class="line">    <span class="comment">// 总之，会找到对⻬的那64bit作为state，其余的32bit做信号量</span></span><br><span class="line">    state1 [<span class="number">3</span>]<span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到state的地址和信号量的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> state() (statep *<span class="type">uint64</span>, semap *<span class="type">uint32</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="type">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 如果地址是64bit对⻬的，数组前两个元素做state，后⼀个元素做信号量</span></span><br><span class="line"><span class="keyword">return</span> (*<span class="type">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class="number">2</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果地址是32bit对⻬的，数组后两个元素用来做state，它可以用来做64bit的原子操作，第</span></span><br><span class="line"><span class="keyword">return</span> (*<span class="type">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class="number">1</span>])), &amp;wg.state1[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>WaitGroup 是可以重用的。只要 WaitGroup 的计数值恢复到零值的状态，那么它就可以被看作是新创建的 WaitGroup，被重复使用</p>
</blockquote>
<h2 id="小结">小结</h2>
<ul>
<li>不重用 WaitGroup。新建⼀个 WaitGroup 不会带来多⼤的资源开销，重用反⽽更容易出 错。</li>
<li>保证所有的 Add 方法调用都在 Wait 之前。</li>
<li>不传递负数给 Add 方法，只通过 Done 来给计数值减 1。</li>
<li>不做多余的 Done 方法调用，保证 Add 的计数值和 Done 方法调用的数量是⼀样的。</li>
<li>不遗漏 Done 方法的调用，否则会导致 Wait hang 住⽆法返回。</li>
</ul>
<h1>Cond</h1>
<p>Go 标准库提供 Cond 原语的目的是，为等待 / 通知场景下的并发问题提供⽀持。</p>
<h2 id="Cond-的基本用法">Cond 的基本用法</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NeWCond</span><span class="params">(l Locker)</span></span> *Cond</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait()</span><br></pre></td></tr></table></figure>
<ul>
<li>⾸先，Cond 关联的 Locker 实例可以通过 c.L 访问，它内部维护着⼀个先入先出的等待队 列。</li>
<li>Signal 方法，允许调用者 Caller 唤醒⼀个等待此 Cond 的 goroutine。如果此时没有等待的goroutine，显然⽆需通知 waiter；如果 Cond 等待队列中有⼀个或者多个等待的goroutine，则需要从等待队列中移除第⼀个 goroutine 并把它唤醒。在其他编程语言中，⽐如 Java 语⾔中，Signal 方法也被叫做 notify 方法。
<ul>
<li>调用 Signal 方法时，不强求你⼀定要持有 c.L 的锁。</li>
</ul>
</li>
<li>Broadcast 方法，允许调用者 Caller 唤醒所有等待此 Cond 的 goroutine。如果此时没有等待的 goroutine，显然⽆需通知 waiter；如果 Cond 等待队列中有⼀个或者多个等待的goroutine，则清空所有等待的 goroutine，并全部唤醒。在其他编程语⾔中，⽐如 Java 语⾔中，Broadcast 方法也被叫做 notifyAll 方法。
<ul>
<li>同样地，调用 Broadcast 方法时，也不强求你⼀定持有 c.L 的锁。</li>
</ul>
</li>
<li>Wait 方法，会把调用者 Caller 放入 Cond 的等待队列中并阻塞，直到被 Signal 或者Broadcast 的方法从等待队列中移除并唤醒。
<ul>
<li>调用 Wait 方法时必须要持有 c.L 的锁。</li>
</ul>
</li>
</ul>
<h2 id="案例">案例</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">  <span class="keyword">var</span> ready <span class="type">int</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++ &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">      time.Sleep(time.Duration(rand.Int63n(<span class="number">10</span>)) * time.Second)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加锁更改等待条件</span></span><br><span class="line">      c.L.Lock()</span><br><span class="line">      ready++</span><br><span class="line">      c.L.Unlock()</span><br><span class="line">      log.Printf(<span class="string">&quot;运动员#%d 准备就绪\\n&quot;</span>, i)</span><br><span class="line">      <span class="comment">// 广播唤醒所有的等待着</span></span><br><span class="line">      c.Broadcast()</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c.L.Lock()</span><br><span class="line">  <span class="keyword">for</span> ready!= <span class="number">10</span>&#123;</span><br><span class="line">    c.Wait()</span><br><span class="line">    log.Printf(<span class="string">&quot;裁判员被唤醒一次&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  c.L.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有运动员是否准备就绪</span></span><br><span class="line">  log.Println(<span class="string">&quot;所有运动员准备就绪，比赛开始！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结-2">小结</h2>
<ul>
<li>Cond 是为等待 / 通知场景下的并发问题提供⽀持的。它提供了条件变量的三个基本方法Signal、Broadcast 和 Wait，为并发的 goroutine 提供等待 / 通知机制。</li>
<li>使用 Cond 之所以容易出错，就是 Wait 调用需要加锁，以及被唤醒后⼀定要检查条件是否真 的已经满⾜。你需要牢记这两点。</li>
<li>WaitGroup和 Cond 的区别：WaitGroup 是主 goroutine 等待确定数量的子 goroutine 完成任务；⽽ Cond 是等待某个条件满⾜，这个条件的修改可以被任意多的 goroutine 更新，⽽且 Cond的 Wait 不关⼼也不知道其他 goroutine 的数量，只关⼼等待条件。⽽且 Cond 还有单个通知的机制，也就是 Signal 方法。</li>
</ul>
<h1>Once</h1>
<p>Once可以用来执行且仅仅执行⼀次动作，常常用于单例对象的初始化场景。</p>
<h2 id="使用场景">使用场景</h2>
<p>sync.Once 只暴露了⼀个方法 Do，你可以多次调用 Do 方法，但是只有第⼀次调用 Do 方法 时 f 参数才会执行，这⾥的 f 是⼀个⽆参数⽆返回值的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Once 常常用来初始化单例资源，或者并发访问只需初始化⼀次的共享资源，或者在测试的时候初始化⼀次测试资源。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> once sync.Once</span><br><span class="line">  </span><br><span class="line">  f1:=<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;f1 exce！&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  once.Do(f1)</span><br><span class="line">  </span><br><span class="line">  f2 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;f2 exce&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  once.Do(f2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结-3">小结</h2>
<blockquote>
<p>⼀旦你遇到只需要初始化⼀次的场景，⾸先想到的就应该是 Once 并发原语。</p>
</blockquote>
<h1>Pool</h1>
<p>Go 标准库中提供了⼀个通用的 Pool 数据结构，也就是 sync.Pool，我们使用它可以创建池化的对象。但是它池化的对象可能会被垃圾回收掉。</p>
<ul>
<li>sync.Pool 数据类型用来保存⼀组可独立访问的临时对象。
<ul>
<li>也就是说，它池化的对象会在未来的某个时候被毫无预兆地移除掉。而且，如果没有别的对象引用这个被移除的对象的话，这个被移除的对象就会被垃圾回收掉。</li>
</ul>
</li>
</ul>
<h3 id="注意点">注意点</h3>
<ul>
<li>
<ol>
<li>sync.Pool 本身就是线程安全的，多个 goroutine 可以并发地调用它的方法存取对象；</li>
</ol>
</li>
<li>
<ol>
<li>sync.Pool 不可在使用之后再复制使用。</li>
</ol>
</li>
</ul>
<h2 id="方法介绍">方法介绍</h2>
<p>1.New</p>
<ul>
<li>Pool struct 包含⼀个 New 字段，这个字段的类型是函数 func() interface{}。当调用 Pool 的 Get 方法从池中获取元素，没有更多的空闲元素可返回时，就会调用这个 New 方法来创建新 的元素。如果你没有设置 New 字段，没有更多的空闲元素可返回时，Get 方法将返回 nil，表 明当前没有可用的元素。 有趣的是，New 是可变的字段。这就意味着，你可以在程序运行的时候改变创建元素的方 法。当然，很少有⼈会这么做，因为⼀般我们创建元素的逻辑都是⼀致的，要创建的也是同⼀ 类的元素，所以你在使用 Pool 的时候也没必要玩⼀些“花活”，在程序运行时更改 New 的 值。</li>
</ul>
<p>2.Get</p>
<ul>
<li>如果调用这个方法，就会从 Pool取⾛⼀个元素，这也就意味着，这个元素会从 Pool 中移除， 返回给调用者。不过，除了返回值是正常实例化的元素，Get 方法的返回值还可能会是⼀个 nil（Pool.New 字段没有设置，⼜没有空闲元素可以返回），所以你在使用的时候，可能需要 判断。</li>
</ul>
<p>3.Put</p>
<ul>
<li>这个方法用于将⼀个元素返还给 Pool，Pool 会把这个元素保存到池中，并且可以复用。但如 果 Put ⼀个 nil 值，Pool 就会忽略这个值。</li>
</ul>
<h2 id="推荐的三方pool">推荐的三方pool</h2>
<ul>
<li><code>gammazero/workerpool</code>：gammazero/workerpool 可以⽆限制地提交任务，提供了更便利的 Submit 和 SubmitWait 方法提交任务，还可以提供当前的 worker 数和任务数以及关闭 Pool 的功能。</li>
<li><code>ivpusic/grpool</code>：grpool 创建 Pool 的时候需要提供 Worker 的数量和等待执行的任务的 最⼤数量，任务的提交是直接往 Channel 放入任务。</li>
<li><code>dpaks/goworkers</code>：dpaks/goworkers 提供了更便利的 Submit 方法提交任务以及Worker 数、任务数等查询方法、关闭 Pool 的方法。它的任务的执行结果需要在ResultChan 和 ErrChan 中去获取，没有提供阻塞的方法，但是它可以在初始化的时候设置 Worker 的数量和任务数。</li>
</ul>
<h2 id="pool可能造成的问题">pool可能造成的问题</h2>
<ul>
<li>内存泄漏
<ul>
<li>在使用 sync.Pool 回收 buffer 的时候，⼀定要检查回收的对象的⼤⼩。如果 buffer 太⼤，就 不要回收了，否则就太浪费了</li>
</ul>
</li>
<li>内存浪费
<ul>
<li>要做到物尽其用，尽可能不浪费的话，我们可以将 buffer 池分成⼏层</li>
<li>⼩于 512 byte的元素的 buffer 占⼀个池子；其次，⼩于 1K byte ⼤⼩的元素占⼀个池子；再次，⼩于 4Kbyte ⼤⼩的元素占⼀个池子。这样分成⼏个池子以后，就可以根据需要，到所需⼤⼩的池子中获取 buffer 了。</li>
</ul>
</li>
</ul>
<h2 id="小结-4">小结</h2>
<ul>
<li>Pool 是⼀个通用的概念，也是解决对象重用和预先分配的⼀个常用的优化⼿段。即使你⾃⼰ 没在项目中直接使用过，但肯定在使用其它库的时候，就享受到应用 Pool 的好处了，⽐如数 据库的访问、http API 的请求等等。</li>
<li>我们⼀般不会在程序⼀开始的时候就开始考虑优化，⽽是等项目开发到⼀个阶段，或者快结束 的时候，才全⾯地考虑程序中的优化点，⽽ Pool 就是常用的⼀个优化⼿段。如果你发现程序 中有⼀种 GC 耗时特别⾼，有⼤量的相同类型的临时对象，不断地被创建销毁，这时，你就可 以考虑看看，是不是可以通过池化的⼿段重用这些对象。</li>
<li>另外，在分布式系统或者微服务框架中，可能会有⼤量的并发 Client 请求，如果 Client 的耗 时占⽐很⼤，你也可以考虑池化 Client，以便重用。</li>
<li>如果你发现系统中的 goroutine 数量⾮常多，程序的内存资源占用⽐较⼤，⽽且整体系统的耗 时和 GC 也⽐较⾼，我建议你看看，是否能够通过 Worker Pool 解决⼤量 goroutine 的问 题，从⽽降低这些指标。</li>
</ul>
<h1>Context：信息穿透上下文</h1>
<p>在 API之间或者方法调用之间，所传递的除了业务参数之外的额外信息。</p>
<h2 id="context使用场景">context使用场景</h2>
<ul>
<li>上下⽂信息传递 （request-scoped），⽐如处理 http 请求、在请求处理链路上传递信 息；</li>
<li>控制子 goroutine 的运行；</li>
<li>超时控制的方法调用；</li>
<li>可以取消的方法调用。</li>
</ul>
<h2 id="context-接口函数">context 接口函数</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Deadline 方法会返回这个 Context 被取消的截⽌⽇期。如果没有设置截⽌⽇期，ok 的值是 false。后续每次调用这个对象的 Deadline 方法时，都会返回和第⼀次调用相同的结果。</li>
<li>Done 方法返回⼀个 Channel 对象。在 Context 被取消时，此 Channel 会被 close，如果没 被取消，可能会返回 nil。后续的 Done 调用总是返回相同的结果。当 Done 被 close 的时 候，你可以通过 ctx.Err 获取错误信息。Done 这个方法名其实起得并不好，因为名字太过笼 统，不能明确反映 Done 被 close 的原因，因为 cancel、timeout、deadline 都可能导致</li>
<li>Done 被 close，不过，目前还没有⼀个更合适的方法名称。
<ul>
<li>如果 Done 没有被 close，Err 方法返回 nil；如果 Done 被 close，Err 方法会返回 Done 被 close 的原因。</li>
</ul>
</li>
<li>Value 返回此 ctx 中和指定的 key 相关联的 value。</li>
</ul>
<p>Context 中实现了 2 个常用的生成顶层 Context 的方法。</p>
<ul>
<li><code>context.Background()</code>：返回⼀个⾮ nil 的、空的 Context，没有任何值，不会被 cancel，不会超时，没有截⽌⽇期。⼀般用在主函数、初始化、测试以及创建根 Context 的时候</li>
<li><code>context.TODO()</code>：返回⼀个⾮ nil 的、空的 Context，没有任何值，不会被 cancel，不会超时，没有截⽌⽇期。当你不清楚是否该用 Context，或者目前还不知道要传递⼀些什么上下⽂信息的时候，就可以使用这个方法。</li>
</ul>
<h2 id="关于Context的一些约定规定">关于Context的一些约定规定</h2>
<ul>
<li>
<ol>
<li>⼀般函数使用 Context 的时候，会把这个参数放在第⼀个参数的位置。从来不把 nil 当Context 类型的参数值，可以使用 context.Background() 创建⼀个空的上下⽂对象，也不要使用 nil。</li>
</ol>
</li>
<li>2.Context 只用来临时做函数之间的上下⽂透传，不能持久化 Context 或者把 Context ⻓久存。<strong>把 Context 持久化到数据库、本地⽂件或者全局变量、缓存中都是错误的用法</strong>。</li>
<li>3.key 的类型不应该是字符串类型或者其它内建类型，否则容易在包之间使用 Context 时候产生冲突。使用 WithValue 时，key 的类型应该是⾃⼰定义的类型。</li>
<li>4.常常使用 struct{}作为底层类型定义 key 的类型。对于 exported key 的静态类型，常常是接⼝或者指针。这样可以尽量减少内存分配。</li>
</ul>
<h2 id="应用场景">应用场景</h2>
<p>main函数返回时，所有的goroutine都会被直接打断，程序退出。除此之外如果想通过编程的方法让一个goroutine中断其他goroutine的执行，只能是通过在多个goroutine间通过context上下文对象同步取消信号的方式来实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">      ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;goroutine exit&quot;</span>)</span><br><span class="line">      &#125;()</span><br><span class="line">      <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;()</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">      cancel()</span><br><span class="line">      time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1>atomic 原子操作</h1>
<p>原子操作，是因为⼀个原子在执行的时候，其它线程不会看到执行⼀半的操作结果。在其它线程看来，原子操作要么执行完了，要么还没有执行，就像⼀个最⼩的粒子 - 原子⼀样，不可分割</p>
<h2 id="atomic-提供的方法">atomic 提供的方法</h2>
<ul>
<li>atomic 操作的对象是⼀个地址，你需要把可寻址的变量的地址作为参数传递给方法，⽽不是把变量的值传递给方法。</li>
</ul>
<h2 id="Add">Add</h2>
<p>Add 方法就是给第⼀个参数地址中的值增加⼀个 delta 值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AddInt32 atomically adds delta to *addr and returns the new value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt32</span><span class="params">(addr *<span class="type">int32</span>, delta <span class="type">int32</span>)</span></span> (<span class="built_in">new</span> <span class="type">int32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddUint32 atomically adds delta to *addr and returns the new value.</span></span><br><span class="line"><span class="comment">// To subtract a signed positive constant value c from x, do AddUint32(&amp;x, ^uint32(c-1)).</span></span><br><span class="line"><span class="comment">// In particular, to decrement x, do AddUint32(&amp;x, ^uint32(0)).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint32</span><span class="params">(addr *<span class="type">uint32</span>, delta <span class="type">uint32</span>)</span></span> (<span class="built_in">new</span> <span class="type">uint32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddInt64 atomically adds delta to *addr and returns the new value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt64</span><span class="params">(addr *<span class="type">int64</span>, delta <span class="type">int64</span>)</span></span> (<span class="built_in">new</span> <span class="type">int64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddUint64 atomically adds delta to *addr and returns the new value.</span></span><br><span class="line"><span class="comment">// To subtract a signed positive constant value c from x, do AddUint64(&amp;x, ^uint64(c-1)).</span></span><br><span class="line"><span class="comment">// In particular, to decrement x, do AddUint64(&amp;x, ^uint64(0)).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint64</span><span class="params">(addr *<span class="type">uint64</span>, delta <span class="type">uint64</span>)</span></span> (<span class="built_in">new</span> <span class="type">uint64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddUintptr atomically adds delta to *addr and returns the new value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, delta <span class="type">uintptr</span>)</span></span> (<span class="built_in">new</span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure>
<p>CAS （CompareAndSwap）</p>
<p>这个方法会⽐较当前 addr 地址⾥的值是不是 old，如果不等于 old，就返回 false；如果等于old，就把此地址的值替换成 new 值，返回 true。这就相当于“判断相等才替换”。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt32</span><span class="params">(addr *<span class="type">int32</span>, old, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt64</span><span class="params">(addr *<span class="type">int64</span>, old, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint32</span><span class="params">(addr *<span class="type">uint32</span>, old, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint64</span><span class="params">(addr *<span class="type">uint64</span>, old, <span class="built_in">new</span> <span class="type">uint64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, old, <span class="built_in">new</span> <span class="type">uintptr</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapPointer</span><span class="params">(addr *unsafe.Pointer, old, <span class="built_in">new</span> unsafe.Pointer)</span></span> (swapped <span class="type">bool</span>)</span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> *addr == old &#123;</span><br><span class="line">  *addr = <span class="built_in">new</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="Swap">Swap</h2>
<p>如果不需要⽐较旧值，只是⽐较粗暴地替换的话，就可以使用 Swap 方法，它替换后还可以 返回旧值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SwapInt32 atomically stores new into *addr and returns the previous *addr value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt32</span><span class="params">(addr *<span class="type">int32</span>, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> (old <span class="type">int32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SwapInt64 atomically stores new into *addr and returns the previous *addr value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt64</span><span class="params">(addr *<span class="type">int64</span>, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (old <span class="type">int64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SwapUint32 atomically stores new into *addr and returns the previous *addr value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUint32</span><span class="params">(addr *<span class="type">uint32</span>, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> (old <span class="type">uint32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SwapUint64 atomically stores new into *addr and returns the previous *addr value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUint64</span><span class="params">(addr *<span class="type">uint64</span>, <span class="built_in">new</span> <span class="type">uint64</span>)</span></span> (old <span class="type">uint64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SwapUintptr atomically stores new into *addr and returns the previous *addr value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, <span class="built_in">new</span> <span class="type">uintptr</span>)</span></span> (old <span class="type">uintptr</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SwapPointer atomically stores new into *addr and returns the previous *addr value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapPointer</span><span class="params">(addr *unsafe.Pointer, <span class="built_in">new</span> unsafe.Pointer)</span></span> (old unsafe.Pointer)</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">old = *addr</span><br><span class="line">*addr = <span class="built_in">new</span></span><br><span class="line"><span class="keyword">return</span> old</span><br></pre></td></tr></table></figure>
<h2 id="Load">Load</h2>
<p>Load 方法会取出 addr 地址中的值，即使在多处理器、多核、有 CPU cache 的情况下，这个操作也能保证 Load 是⼀个原子操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LoadInt32 atomically loads *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt32</span><span class="params">(addr *<span class="type">int32</span>)</span></span> (val <span class="type">int32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadInt64 atomically loads *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt64</span><span class="params">(addr *<span class="type">int64</span>)</span></span> (val <span class="type">int64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadUint32 atomically loads *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint32</span><span class="params">(addr *<span class="type">uint32</span>)</span></span> (val <span class="type">uint32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadUint64 atomically loads *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint64</span><span class="params">(addr *<span class="type">uint64</span>)</span></span> (val <span class="type">uint64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadUintptr atomically loads *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUintptr</span><span class="params">(addr *<span class="type">uintptr</span>)</span></span> (val <span class="type">uintptr</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadPointer atomically loads *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadPointer</span><span class="params">(addr *unsafe.Pointer)</span></span> (val unsafe.Pointer)</span><br></pre></td></tr></table></figure>
<h2 id="Store">Store</h2>
<p>Store 方法会把⼀个值存入到指定的 addr 地址中，即使在多处理器、多核、有 CPU cache的情况下，这个操作也能保证 Store 是⼀个原子操作。别的 goroutine 通过 Load 读取出来，不会看到存取了⼀半的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StoreInt32 atomically stores val into *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt32</span><span class="params">(addr *<span class="type">int32</span>, val <span class="type">int32</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StoreInt64 atomically stores val into *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt64</span><span class="params">(addr *<span class="type">int64</span>, val <span class="type">int64</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StoreUint32 atomically stores val into *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint32</span><span class="params">(addr *<span class="type">uint32</span>, val <span class="type">uint32</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StoreUint64 atomically stores val into *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint64</span><span class="params">(addr *<span class="type">uint64</span>, val <span class="type">uint64</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StoreUintptr atomically stores val into *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, val <span class="type">uintptr</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StorePointer atomically stores val into *addr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StorePointer</span><span class="params">(addr *unsafe.Pointer, val unsafe.Pointer</span></span></span><br></pre></td></tr></table></figure>
<h2 id="Value-类型">Value 类型</h2>
<p>它可以原子地存取对象类型，但也只能存取，不能 CAS 和 Swap，常常用在配置变更等场景中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Value must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">  v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Load() (x <span class="keyword">interface</span>&#123;&#125;) &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Store(x <span class="keyword">interface</span>&#123;&#125;) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<h1>Channel：解决并发问题</h1>
<p>CSP允许使用进程组件来描述系统，它们独⽴运行，并且只通过消息传递的方式通信。</p>
<h2 id="Channel-的应用场景">Channel 的应用场景</h2>
<blockquote>
<p>执行业务处理的 goroutine 不要通过共享内存的方式通信，⽽是要通过 Channel 通信的方式分享数据</p>
</blockquote>
<ul>
<li>“communicate by sharing memory”是传统的并发编程处理方式，就是指，共享的数据需要用锁进行保护，goroutine 需要获取到锁，才能并发访问数据。</li>
<li>“share memory by communicating”则是类似于 CSP 模型的方式，通过通信的方式，⼀个goroutine 可以把数据的“所有权”交给另外⼀个 goroutine（虽然 Go 中没有“所有权”的概念，但是从逻辑上说，你可以把它理解为是所有权的转移）。</li>
</ul>
<p>五大应用场景</p>
<ul>
<li><code>数据交流</code>：当作并发的 buffer 或者 queue，解决生产者 - 消费者问题。多个 goroutine 可以并发当作生产者（Producer）和消费者（Consumer）。</li>
<li><code>数据传递</code>：⼀个 goroutine 将数据交给另⼀个 goroutine，相当于把数据的拥有权 (引用)托付出去。</li>
<li><code>信号通知</code>：⼀个 goroutine 可以将信号 (closing、closed、data ready 等) 传递给另⼀个或者另⼀组 goroutine 。</li>
<li><code>任务编排</code>：可以让⼀组 goroutine 按照⼀定的顺序并发或者串行的执行，这就是编排的功能。</li>
<li><code>锁</code>：利用 Channel 也可以实现互斥锁的机制。</li>
</ul>
<h2 id="channel-基本用法">channel 基本用法</h2>
<blockquote>
<p><code>&lt;-</code> v有个规则，总是尽量和左边的 chan 结合（The &lt;- operator associates with the leftmost chan possible:</p>
</blockquote>
<ul>
<li>nil 是 chan 的零值，是⼀种特殊的 chan，对值是 nil 的 chan 的发送接收调用者总是会阻塞</li>
</ul>
<h2 id="关于channel的选择">关于channel的选择</h2>
<ul>
<li>
<ol>
<li>共享资源的并发访问使用传统并发原语；</li>
</ol>
</li>
<li>
<ol>
<li>复杂的任务编排和消息传递使用 Channel；</li>
</ol>
</li>
<li>
<ol>
<li>消息通知机制使用 Channel，除非只想 signal ⼀个 goroutine，才使用 Cond；</li>
</ol>
</li>
<li>
<ol>
<li>简单等待所有任务的完成用 WaitGroup，也有 Channel 的推崇者用 Channel，都可以；</li>
</ol>
</li>
<li>
<ol>
<li>需要和 Select 语句结合，使用 Channel；</li>
</ol>
</li>
<li>
<ol>
<li>需要和超时配合时，使用 Channel 和 Context。</li>
</ol>
</li>
</ul>
<h2 id="chan-的编排方式">chan 的编排方式</h2>
<p>Or-Done 模式、扇入模式、扇出模式、Stream 和 map-reduce</p>
<h3 id="Or-Done-模式">Or-Done 模式</h3>
<p>Or-Done 模式是信号通知模式中更宽泛的⼀种模式</p>
<p>我们会使用“信号通知”实现某个任务执行完成后的通知机制，在实现时，我们为这个任务定义 ⼀个类型为 chan struct{}类型的 done 变量，等任务结束后，我们就可以 close 这个变量， 然后，其它 receiver 就会收到这个通知。 这是有⼀个任务的情况，如果有多个任务，只要有任意⼀个任务执行完，我们就想获得这个信 号，这就是 Or-Done 模式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or or-done 模式 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">or</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">  <span class="comment">// 特殊情况，只有零个,1个或2个 chan</span></span><br><span class="line">  <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line">    <span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line">    <span class="comment">// fmt.Println(&quot;执行&quot;)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(channels) &gt; <span class="number">2</span> &#123;</span><br><span class="line">      m := <span class="built_in">len</span>(channels) / <span class="number">2</span></span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-or(channels[:m]...):</span><br><span class="line">      <span class="keyword">case</span> &lt;-or(channels[m:]...):</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">return</span> orDone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sig</span><span class="params">(after time.Duration)</span></span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">    time.Sleep(after)</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// orSelect 反射⽅式 实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">orSelect</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">  <span class="comment">// 特殊情况，只有零个,1个或2个 chan</span></span><br><span class="line">  <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line">    <span class="comment">// 利用反射构建SelectCase</span></span><br><span class="line">    <span class="keyword">var</span> cases []reflect.SelectCase</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> channels &#123;</span><br><span class="line">      cases = <span class="built_in">append</span>(cases, reflect.SelectCase&#123;</span><br><span class="line">        Dir:  reflect.SelectRecv,</span><br><span class="line">        Chan: reflect.ValueOf(c),</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 随机选取一个可用 case</span></span><br><span class="line">    reflect.Select(cases)</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> orDone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  start := time.Now()</span><br><span class="line"></span><br><span class="line">  &lt;-orSelect(</span><br><span class="line">    sig(<span class="number">10</span>*time.Second),</span><br><span class="line">    sig(<span class="number">20</span>*time.Second),</span><br><span class="line">    sig(<span class="number">30</span>*time.Second),</span><br><span class="line">    sig(<span class="number">40</span>*time.Second),</span><br><span class="line">    sig(<span class="number">50</span>*time.Second),</span><br><span class="line">    sig(<span class="number">01</span>*time.Second),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">&quot;done after %v&quot;</span>, time.Since(start))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="扇入模式">扇入模式</h3>
<p>扇入借鉴了数字电路的概念，它定义了单个逻辑们能够接受的数字信号输入最⼤量的术语。⼀ 个逻辑们可以有多个输入，⼀个输出。</p>
<ul>
<li>在软件⼯程中，<strong>模块的扇入是指有多少个上级模块调用它</strong>。</li>
<li>而对于我们这里的 <code>Channel</code> 扇入模式来说，就是指有多个源 <code>Channel</code> 输入、⼀个目的<code> Channel</code> 输出的情况。</li>
</ul>
<p>扇入比就是源 Channel 数量比1。</p>
<ul>
<li>每个源 Channel 的元素都会发送给目标 Channel，相当于目标 Channel 的 receiver 只需要 监听目标 Channel，就可以接收所有发送给源 Channel 的数据。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扇入模式 反射实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanInReflect</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">  out:= <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">    <span class="comment">// 构造 SelectCases slice</span></span><br><span class="line">    <span class="keyword">var</span> cases []reflect.SelectCase</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> channels&#123;</span><br><span class="line">      cases = <span class="built_in">append</span>(cases, reflect.SelectCase&#123;</span><br><span class="line">        Dir:  reflect.SelectRecv,</span><br><span class="line">        Chan: reflect.ValueOf(c),</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 循环，从 cases 中选择一个可用的</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(cases)&gt;<span class="number">0</span>&#123;</span><br><span class="line">      i,v,ok:=reflect.Select(cases)</span><br><span class="line">      <span class="keyword">if</span> !ok&#123; <span class="comment">// chan 关闭</span></span><br><span class="line">        cases = <span class="built_in">append</span>(cases[:i],cases[i+<span class="number">1</span>:]...)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      out &lt;-v.Interface()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanInRec</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  <span class="keyword">switch</span> <span class="built_in">len</span>(channels)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    c:= <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> mergeTow(channels[<span class="number">0</span>], channels[<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    m:=<span class="built_in">len</span>(channels)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> mergeTow(</span><br><span class="line">      fanInRec(channels[:m]...),</span><br><span class="line">      fanInRec(channels[m:]...))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个 chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTow</span><span class="params">(a,b &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">    <span class="keyword">for</span> a!= <span class="literal">nil</span> || b !=<span class="literal">nil</span>&#123;</span><br><span class="line">      <span class="keyword">select</span>&#123;</span><br><span class="line">      <span class="keyword">case</span> v,ok := &lt;-a:</span><br><span class="line">        <span class="keyword">if</span> !ok &#123; <span class="comment">// a 已关闭，设置为nil</span></span><br><span class="line">          a=<span class="literal">nil</span></span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        c &lt;- v</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">case</span> v,ok := &lt;-b:</span><br><span class="line">        <span class="keyword">if</span> !ok &#123; <span class="comment">// b已关闭，设置为nil</span></span><br><span class="line">        b=<span class="literal">nil</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        c &lt;- v</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sigs</span><span class="params">(after time.Duration)</span></span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">    time.Sleep(after)</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  start := time.Now()</span><br><span class="line"></span><br><span class="line">  &lt;-fanInReflect(</span><br><span class="line">    sigs(<span class="number">10</span>*time.Second),</span><br><span class="line">    sigs(<span class="number">02</span>*time.Second),</span><br><span class="line">    sigs(<span class="number">03</span>*time.Second),</span><br><span class="line">    sigs(<span class="number">04</span>*time.Second),</span><br><span class="line">    sigs(<span class="number">05</span>*time.Second),</span><br><span class="line">    sigs(<span class="number">01</span>*time.Second),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">&quot;done after %v&quot;</span>, time.Since(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扇出模式">扇出模式</h3>
<p>扇出模式是和扇入模式相反的。</p>
<p>扇出模式只有⼀个输入源 <code>Channel</code>，有多个目标 <code>Channel</code>，扇出比就是 1比目标 <code>Channel </code>数 的值，经常用在设计模式中的观察者模式中（观察者设计模式定义了对象间的⼀种⼀对多的 组合关系。这样⼀来，⼀个对象的状态发⽣变化时，所有依赖于它的对象都会得到通知并⾃动 刷新）。在观察者模式中，数据变动后，多个观察者都会收到这个变更信号。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang常见错误之defer和迭代</title>
    <url>/2023/02/06/defer&amp;goroutine%E8%BF%AD%E4%BB%A3/</url>
    <content><![CDATA[<h1>defer 解析</h1>
<h2 id="作用域">作用域</h2>
<p>向 <code>defer</code> 关键字传入的函数会在函数返回之前运行。假设我们在 <code>for</code> 循环中多次调用 <code>defer</code> 关键字：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>运行上述代码会倒序执行传入 <code>defer</code> 关键字的所有表达式，因为最后一次调用 <code>defer</code> 时传入了 <code>fmt.Println(4)</code>，所以这段代码会优先打印 4。我们可以通过下面这个简单例子强化对 <code>defer</code> 执行时机的理解：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer runs&quot;</span>)</span><br><span class="line">        fmt.Println(<span class="string">&quot;block ends&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;main ends&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">block ends</span><br><span class="line">main ends</span><br><span class="line"><span class="keyword">defer</span> runs</span><br></pre></td></tr></table></figure>
<p>从上述代码的输出我们会发现，<code>defer</code> 传入的函数不是在退出代码块的作用域时执行的，它只会在当前函数和方法返回之前被调用。</p>
<h2 id="预计算参数">预计算参数</h2>
<p>Go 语言中所有的函数调用都是传值的，虽然 <code>defer</code> 是关键字，但是也继承了这个特性。假设我们想要计算 <code>main</code> 函数运行的时间，可能会写出以下的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  startedAt := time.Now()</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(time.Since(startedAt))</span><br><span class="line"></span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">0</span>s</span><br></pre></td></tr></table></figure>
<p>然而上述代码的运行结果并不符合我们的预期，这个现象背后的原因是什么呢？</p>
<ul>
<li>经过分析，我们会发现调用 <code>defer</code> 关键字会立刻拷贝函数中引用的外部参数，所以 <code>time.Since(startedAt)</code> 的结果不是在 <code>main</code> 函数退出之前计算的，而是在 <code>defer</code> 关键字调用时计算的，最终导致上述代码输出 0s。</li>
</ul>
<p>想要解决这个问题的方法非常简单，我们只需要向 <code>defer</code> 关键字传入匿名函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  startedAt := time.Now()</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(time.Since(startedAt)) &#125;()</span><br><span class="line"></span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">1</span>s</span><br></pre></td></tr></table></figure>
<p>虽然调用 <code>defer</code> 关键字时也使用值传递，但是因为拷贝的是函数指针，所以 <code>time.Since(startedAt)</code> 会在 <code>main</code> 函数返回前调用并打印出符合预期的结果。</p>
<span id="more"></span>
<h1>使用对循环迭代器变量的引用</h1>
<p>在 Go 中，循环迭代器变量是一个在每次循环迭代中采用不同值的单个变量。这是非常有效的，但如果使用不当可能会导致意外行为。例如，请参阅以下程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> out []*<span class="type">int</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">    out = <span class="built_in">append</span>(out, &amp;i)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Values:&quot;</span>, *out[<span class="number">0</span>], *out[<span class="number">1</span>], *out[<span class="number">2</span>])</span><br><span class="line">  fmt.Println(<span class="string">&quot;Addresses:&quot;</span>, out[<span class="number">0</span>], out[<span class="number">1</span>], out[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它会输出意想不到的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Values: 3 3 3</span><br><span class="line">Addresses: 0x40e020 0x40e020 0x40e020</span><br></pre></td></tr></table></figure>
<p>解释：在每次迭代中，我们将 i 的地址附加<code>i</code>到<code>out</code>切片，但由于它是相同的变量，因此我们附加了相同的地址，该地址最终包含分配给 的最后一个值<code>i</code>。解决方案之一是将循环变量复制到新变量中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">i := i <span class="comment">// Copy i into a new variable.</span></span><br><span class="line">  out = <span class="built_in">append</span>(out, &amp;i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该程序的新输出是预期的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Values: 0 1 2</span><br><span class="line">Addresses: 0x40e020 0x40e024 0x40e028</span><br></pre></td></tr></table></figure>
<p>说明：该行将<code>i := i</code>循环变量复制<code>i</code>到作用域为 for 循环体块的新变量中，也称为<code>i</code>. 新变量的地址是附加到数组的地址，这使得它比 for 循环体块更有效。在每次循环迭代中，都会创建一个新变量。</p>
<p>虽然这个例子可能看起来有点明显，但在其他一些情况下，同样的意外行为可能更隐蔽。例如，循环变量可以是一个数组，而引用可以是一个切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> out [][]<span class="type">int</span></span><br><span class="line">  <span class="keyword">for</span> _, i := <span class="keyword">range</span> [][<span class="number">1</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;&#125; &#123;</span><br><span class="line">    out = <span class="built_in">append</span>(out, i[:])</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Values:&quot;</span>, out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Values: [[3] [3] [3]]</span><br></pre></td></tr></table></figure>
<p>当在 Goroutine 中使用循环变量时，也可以证明同样的问题（见下一节）。</p>
<h1>在循环迭代器变量上使用 <code>goroutines</code></h1>
<p>在 Go 中进行迭代时，可能会尝试使用 <code>goroutines</code> 并行处理数据。例如，您可以使用闭包编写如下内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(val)</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 for 循环可能不会像你期望的那样做，因为它们的<code>val</code>变量实际上是一个单一的变量，它接受每个切片元素的值。因为闭包都只绑定到那个变量，所以当你运行这段代码时，很有可能你会看到每次迭代打印的最后一个元素而不是按顺序打印的每个值，因为 <code>goroutines</code> 可能不会开始执行，直到循环后。</p>
<p>编写该闭环的正确方法是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Println(val)</span><br><span class="line">  &#125;(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过将 val 作为参数添加到闭包中，<code>val</code>在每次迭代时评估并放置在 goroutine 的堆栈中，因此每个切片元素在最终执行时对 goroutine 可用。</p>
<p>同样重要的是要注意，在循环体中声明的变量在迭代之间不共享，因此可以在闭包中单独使用。下面的代码使用一个公共索引变量<code>i</code>来创建单独的<code>val</code>s，这会导致预期的行为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> valslice &#123;</span><br><span class="line">  val := valslice[i]</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(val)</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，如果没有将这个闭包作为 goroutine 执行，代码会按预期运行。以下示例打印出 1 到 10 之间的整数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使闭包仍然关闭同一个变量（在这种情况下，<code>i</code>），它们在变量更改之前执行，从而导致所需的行为。 <a href="http://golang.org/doc/go_faq.html#closures_and_goroutines">http://golang.org/doc/go_faq.html#closures_and_goroutines</a></p>
<p>您可能会发现另一种类似的情况，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">  <span class="keyword">go</span> val.MyMethod()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *val)</span></span> MyMethod() &#123;</span><br><span class="line">  fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子也将打印值的最后一个元素，原因与闭包相同。要解决此问题，请在循环内声明另一个变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">  newVal := val</span><br><span class="line">  <span class="keyword">go</span> newVal.MyMethod()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *val)</span></span> MyMethod() &#123;</span><br><span class="line">  fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>初探架构设计</title>
    <url>/2023/02/06/%E5%88%9D%E6%8E%A2%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<blockquote>
<p>架构设计的主要目的是为了解决软件系统复杂度带来的问题</p>
</blockquote>
<h2 id="架构、框架、组件、模块、系统">架构、框架、组件、模块、系统</h2>
<p>OLAP（Online Analytical Processing）在线分析处理</p>
<p>架构是顶层设计；框架是面向编程或配置的半成品；组件是从技术维度上的复用；模块是从业务维度上职责的划分；系统是相互协同可运行的实体。</p>
<h1>架构设计的目的</h1>
<h2 id="明确“架构设计是为了解决软件复杂度”原则后">明确“架构设计是为了解决软件复杂度”原则后</h2>
<ul>
<li>“这么多需求，从哪里开始下手进行架构设计呢？”
<ul>
<li>— 通过熟悉和理解需求，识别系统复杂性所在的地方，然后针对这些复杂点进行架构设计。</li>
</ul>
</li>
<li>“架构设计要考虑高性能、高可用、高扩展……这么多高 XX，全部设计完成估计要 1 个月，但老大只给了 1 周时间”
<ul>
<li>—架构设计并不是要面面俱到，不需要每个架构都具备高性能、高可用、高扩展等特点，而是要识别出复杂点然后有针对性地解决问题。</li>
</ul>
</li>
<li>“业界 A 公司的架构是 X，B 公司的方案是 Y，两个差别比较大，该参考哪一个呢？”
<ul>
<li>—理解每个架构方案背后所需要解决的复杂点，然后才能对比自己的业务复杂点，参考复杂点相似的方案。</li>
</ul>
</li>
</ul>
<p>其次，遵循这条准则能够让“老鸟”架构师有的放矢，而不是贪大求全。技术人员往往都希望自己能够做出最牛的东西，架构师也不例外，尤其是一些“老鸟”架构师，为了证明自己的技术牛，可能会陷入贪大求全的焦油坑而无法自拔。</p>
<p>例如：“我们的系统一定要做到每秒 TPS 10 万”。</p>
<p>“淘宝的架构是这么做的，我们也要这么做”。</p>
<p>“Docker 现在很流行，我们的架构应该将 Docker 应用进来”。</p>
<p>以上这些想法，如果拿“架构设计是为了解决软件复杂度”这个原则来衡量，就很容易判断。</p>
<ul>
<li>“我们的系统一定要做到每秒 TPS 10 万”
<ul>
<li>—如果系统的复杂度不是在性能这部分，TPS 做到 10 万并没有什么用。</li>
</ul>
</li>
<li>“淘宝的架构是这么做的，我们也要这么做”
<ul>
<li>—淘宝的架构是为了解决淘宝业务的复杂度而设计的，淘宝的业务复杂度并不就是我们的业务复杂度，绝大多数业务的用户量都不可能有淘宝那么大。</li>
</ul>
</li>
<li>“Docker 现在很流行，我们的架构应该将 Docker 应用进来
<ul>
<li>—Docker 不是万能的，只是为了解决资源重用和动态分配而设计的，如果我们的系统复杂度根本不是在这方面，引入 Docker 没有什么意义。</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h2 id="简单的复杂度分析案例我来分析一个简单的案例">简单的复杂度分析案例我来分析一个简单的案例</h2>
<p>一起来看看如何将“架构设计的真正目的是为了解决软件系统复杂度带来的问题”这个指导思想应用到实践中。假设我们需要设计一个大学的学生管理系统，其基本功能包括登录、注册、成绩管理、课程管理等。当我们对这样一个系统进行架构设计的时候，首先应识别其复杂度到底体现在哪里。</p>
<ul>
<li>性能：一个学校的学生大约 1 ~ 2 万人，学生管理系统的访问频率并不高，平均每天单个学生的访问次数平均不到 1 次，因此性能这部分并不复杂，存储用 MySQL 完全能够胜任，缓存都可以不用，Web 服务器用 Nginx 绰绰有余。</li>
<li>可扩展性：学生管理系统的功能比较稳定，可扩展的空间并不大，因此可扩展性也不复杂。</li>
<li>高可用：学生管理系统即使宕机 2 小时，对学生管理工作影响并不大，因此可以不做负载均衡，更不用考虑异地多活这类复杂的方案了。但是，如果学生的数据全部丢失，修复是非常麻烦的，只能靠人工逐条修复，这个很难接受，因此需要考虑存储高可靠，这里就有点复杂了。我们需要考虑多种异常情况：机器故障、机房故障，针对机器故障，我们需要设计 MySQL 同机房主备方案；针对机房故障，我们需要设计 MySQL 跨机房同步方案。</li>
<li>安全性：学生管理系统存储的信息有一定的隐私性，例如学生的家庭情况，但并不是和金融相关的，也不包含强隐私（例如玉照、情感）的信息，因此安全性方面只要做 3 个事情就基本满足要求了：Nginx 提供 ACL 控制、用户账号密码管理、数据库访问权限控制。</li>
<li>成本：由于系统很简单，基本上几台服务器就能够搞定，对于一所大学来说完全不是问题，可以无需太多关注。还有其他方面，如果有兴趣，你可以自行尝试去分析。通过我上面的分析，可以看到这个方案的主要复杂性体现在存储可靠性上，需要保证异常的时候，不要丢失所有数据即可（丢失几个或者几十个学生的信息问题不大），对应的架构如下：</li>
</ul>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/202108091404716.png" alt="image-20210809140457406"></p>
<h1>高性能</h1>
<h2 id="1-任务分配">1. 任务分配</h2>
<p>任务分配的意思是指每台机器都可以处理完整的业务任务，不同的任务分配到不同的机器上执行。</p>
<h2 id="2-任务分解">2.任务分解</h2>
<p>虽然系统拆分可能在某种程度上能提升业务处理性能，但提升性能也是有限的，不可能系统不拆分的时候业务处理耗时为 50ms，系统拆分后业务处理耗时只要 1ms，**因为最终决定业务处理性能的还是业务逻辑本身，业务逻辑本身没有发生大的变化下，理论上的性能是有一个上限的，系统拆分能够让性能逼近这个极限，但无法突破这个极限。**因此，任务分解带来的性能收益是有一个度的，并不是任务分解越细越好，而对于架构设计来说，如何把握这个粒度就非常关键了。</p>
<h1>高可用</h1>
<blockquote>
<p>系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。</p>
</blockquote>
<p>高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元。</p>
<h2 id="计算高可用">计算高可用</h2>
<p>计算有一个特点就是无论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都是一样的，所以将计算从一台机器迁移到另外一台机器，对业务并没有什么影响。</p>
<p>你可能会发现，这个双机的架构图和上期“高性能”讲到的双机架构图是一样的，因此复杂度也是类似的，具体表现为：</p>
<p>需要增加一个任务分配器，选择合适的任务分配器也是一件复杂的事情，需要综合考虑性能、成本、可维护性、可用性等各方面因素。</p>
<p>任务分配器和真正的业务服务器之间有连接和交互，需要选择合适的连接方式，并且对连接进行管理。例如，连接建立、连接检测、连接中断后如何处理等。</p>
<p>任务分配器需要增加分配算法。例如，常见的双机算法有主备、主主，主备方案又可以细分为冷备、温备、热备。</p>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/202108091404259.png" alt="image-20210809140416757"></p>
<h2 id="存储高可用">存储高可用</h2>
<p>综合分析，无论是正常情况下的传输延迟，还是异常情况下的传输中断，都会导致系统的数据在某个时间点或者时间段是不一致的，而数据的不一致又会导致业务问题；但如果完全不做冗余，系统的整体高可用又无法保证，所以存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响。</p>
<p>计算机内部复杂度最关键的地方就是操作系统。计算机性能的发展本质上是由硬件发展驱动的，尤其是 CPU 的性能发展。著名的“摩尔定律”表明了 CPU 的处理能力每隔 18 个月就翻一番；而将硬件性能充分发挥出来的关键就是操作系统，所以操作系统本身其实也是跟随硬件的发展而发展的，操作系统是软件系统的运行环境，操作系统的复杂度直接决定了软件系统的复杂度。</p>
<h2 id="高性能方案">高性能方案</h2>
<p>数据库读写分离（主从集群）</p>
<ul>
<li>主从复制延迟和分配机制。</li>
</ul>
<p>读写分离分散了数据库读写操作的压力，但没有分散存储压力，当数据量达到千万甚至上亿条的时候，单台数据库服务器的存储能力会成为系统的瓶颈，主要体现在这几个方面：</p>
<ul>
<li>数据量太大，读写的性能会下降，即使有索引，索引也会变得很大，性能同样会下降。</li>
<li>数据文件会变得很大，数据库备份和恢复需要耗费很长时间。</li>
<li>数据文件越大，极端情况下丢失数据的风险越高（例如，机房火灾导致数据库主备机都发生故障）。</li>
</ul>
<h2 id="分库分表">分库分表</h2>
<p>业务分库</p>
<ul>
<li>业务分库指的是按照业务模块将数据分散到不同的数据库服务器。</li>
</ul>
<h2 id="分表">分表</h2>
<p>将不同业务数据分散存储到不同的数据库服务器，能够支撑百万甚至千万用户规模的业务，但如果业务继续发展，同一业务的单表数据也会达到单台数据库服务器的处理瓶颈。例如，淘宝的几亿用户数据，如果全部存放在一台数据库服务器的一张表中，肯定是无法满足性能要求的，此时就需要对单表数据进行拆分。</p>
<h3 id="垂直分表">垂直分表</h3>
<ul>
<li>垂直分表适合将表中某些不常用且占了大量空间的列拆分出去。</li>
</ul>
<h2 id="水平分表">水平分表</h2>
<ul>
<li>当看到表的数据量达到千万级别时，作为架构师就要警觉起来，因为这很可能是架构的性能瓶颈或者隐患。</li>
</ul>
<h2 id="小结">小结</h2>
<p>这些操作依次尝试</p>
<p>1.做硬件优化，例如从机械硬盘改成使用固态硬盘，当然固态硬盘不适合服务器使用，只是举个例子</p>
<p>2.先做数据库服务器的调优操作，例如增加索引，oracle有很多的参数调整;</p>
<p>3.引入缓存技术，例如Redis，减少数据库压力</p>
<p>4.程序与数据库表优化，重构，例如根据业务逻辑对程序逻辑做优化，减少不必要的查询;</p>
<p>5.在这些操作都不能大幅度优化性能的情况下，不能满足将来的发展，再考虑分库分表，也要有预估性</p>
<h1>高性能NoSQL</h1>
<p>常见的 NoSQL 方案分为 4 类。</p>
<ul>
<li>K-V 存储：解决关系数据库无法存储数据结构的问题，以 Redis 为代表。</li>
<li>文档数据库：解决关系数据库强 schema 约束的问题，以 MongoDB 为代表。</li>
<li>列式数据库：解决关系数据库大数据场景下的 I/O 问题，以 HBase 为代表。</li>
<li>全文搜索引擎：解决关系数据库的全文搜索性能问题，以 Elasticsearch 为代表。</li>
</ul>
<h1>缓存</h1>
<h2 id="缓存穿透">缓存穿透</h2>
<p>缓存穿透是指缓存没有发挥作用，业务系统虽然去缓存查询数据，但缓存中没有数据，业务系统需要再次去存储系统查询数据。通常情况下有两种情况：</p>
<ol>
<li>存储数据不存在</li>
<li>缓存数据生成耗费大量时间或者资源</li>
</ol>
<h2 id="缓存雪崩">缓存雪崩</h2>
<p>缓存雪崩是指当缓存失效（过期）后引起系统性能急剧下降的情况。当缓存过期被清除后，业务系统需要重新生成缓存，因此需要再次访问存储系统，再次进行运算，这个处理步骤耗时几十毫秒甚至上百毫秒。而对于一个高并发的业务系统来说，几百毫秒内可能会接到几百上千个请求。由于旧的缓存已经被清除，新的缓存还未生成，并且处理这些请求的线程都不知道另外有一个线程正在生成缓存，因此所有的请求都会去重新生成缓存，都会去访问存储系统，从而对存储系统造成巨大的性能压力。这些压力又会拖慢整个系统，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。</p>
]]></content>
      <categories>
        <category>从0开始学架构</category>
      </categories>
      <tags>
        <tag>入门知识</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发,高可用,高性能</title>
    <url>/2023/02/06/%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%8C%E9%AB%98%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<blockquote>
<p>原文链接：<a href="https://juejin.cn/post/6844903944955625479">https://juejin.cn/post/6844903944955625479</a></p>
</blockquote>
<h1>一、高并发</h1>
<h2 id="简介">简介</h2>
<p>高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证<strong>系统能够同时并行处理很多请求</strong>。 高并发相关常用的一些指标有<strong>响应时间</strong>（Response Time），<strong>吞吐量</strong>（Throughput），<strong>每秒查询率</strong>QPS（Query Per Second），<strong>并发用户数</strong>等。</p>
<ul>
<li><strong>响应时间</strong>：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。</li>
<li><strong>吞吐量</strong>：单位时间内处理的请求数量。</li>
<li><strong>QPS</strong>：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。</li>
<li><strong>并发用户数</strong>：同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。</li>
</ul>
<h2 id="如何提高并发能力">如何提高并发能力</h2>
<ul>
<li>
<p>垂直扩展</p>
<p>（Scale Up）</p>
<ol>
<li><strong>增强单机硬件性能</strong>（优先）：例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T，扩充系统内存如128G。</li>
<li><strong>提升单机架构性能</strong>：例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间。</li>
<li>总结：管是提升单机硬件性能，还是提升单机架构性能，都有一个致命的不足：单机性能总是有极限的。所以互联网分布式架构设计高并发终极解决方案还是<strong>水平扩展</strong>。</li>
</ol>
</li>
<li>
<p>水平扩展</p>
<p>（Scale Out）</p>
<ol>
<li>只要增加服务器数量，就能线性扩充系统性能。水平扩展对系统架构设计是有要求的，难点在于：如何在架构各层进行可水平扩展的设计。</li>
</ol>
</li>
</ul>
<h1>二、高性能</h1>
<h2 id="简介-2">简介</h2>
<ol>
<li>简单的说，高性能（High Performance）就是指<strong>程序处理速度快，所占内存少，cpu占用率低</strong>。</li>
<li>高并发和高性能是紧密相关的，提高应用的性能，是肯定可以提高系统的并发能力的。</li>
<li>应用性能优化的时候，对于<strong>计算密集型</strong>和<strong>IO密集型</strong>还是有很大差别，需要分开来考虑。</li>
<li>增加服务器资源（CPU、内存、服务器数量），绝大部分时候是可以提高应用的并发能力和性能 （前提是应用能够支持多任务并行计算，多服务器分布式计算才行），但也是要避免其中的一些问题，才可以更好的更有效率的利用服务器资源。</li>
</ol>
<h2 id="提高性能的注意事项">提高性能的注意事项</h2>
<ol>
<li>避免因为<strong>IO阻塞</strong>让CPU闲置，导致CPU的浪费。</li>
<li>避免<strong>多线程间增加锁</strong>来保证同步，导致并行系统串行化。</li>
<li>免创建、销毁、维护太多进程、线程，导致操作系统浪费资源在调度上。</li>
<li>避免分布式系统中多服务器的关联，比如：依赖同一个mysql，程序逻辑中使用<strong>分布式锁</strong>，导致瓶颈在mysql，分布式又变成串行化运算。</li>
</ol>
<span id="more"></span>
<h1>三、高可用</h1>
<h2 id="简介-3">简介</h2>
<p>高可用性（High Availability）通常来描述一个系统经过<strong>专门</strong>的设计，从而<strong>减少停工时间</strong>，而保持其服务的高度可用性(一直都能用)。</p>
<ul>
<li>全年停机不能超过<strong>31.5秒</strong>，</li>
<li><strong>6个9的性能</strong>：一直能用的概率为99.9999%</li>
</ul>
<h2 id="高可用注意事项">高可用注意事项</h2>
<ol>
<li><strong>避免单点</strong>：使用单个服务器，一旦该服务器意外宕机，将导致服务不可用</li>
<li><strong>使用“集群”</strong>：一台服务器挂了，还有其他后备服务器能够顶上</li>
<li><strong>心跳机制</strong>：用于<strong>监控</strong>服务器状态，挂了就进行<strong>故障修复</strong></li>
</ol>
<h1>四、 举例</h1>
<h2 id="Redis的主从复制">Redis的主从复制</h2>
<h3 id="1-应用场景">1. 应用场景</h3>
<p>电子商务网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p>
<h3 id="2-实现原理">2. 实现原理</h3>
<p>一个Redis服务可以有多个该服务的复制品，这个Redis服务称为Master，其它复制称为Slaves。</p>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/202108091405615.png" alt="image-20210809140552374"></p>
<p>如图中所示，我们将一台Redis服务器作主库(Matser)，其他三台作为从库(Slave)，主库只负责写数据，每次有数据更新都将更新的数据同步到它所有的从库，而从库只负责读数据。这样一来，就有了两个好处：</p>
<ol>
<li><strong>读写分离</strong>：不仅可以提高服务器的负载能力，并且可以根据读请求的规模自由增加或者减少从库的数量。</li>
<li>数据被复制成了了好几份，就算有一台机器出现故障，也可以使用其他机器的数据快速恢复。</li>
</ol>
<p><strong>注意事项</strong>：在Redis主从模式中，一台主库可以拥有多个从库，但是一个从库只能隶属于一个主库。</p>
]]></content>
      <categories>
        <category>从0开始学架构</category>
      </categories>
      <tags>
        <tag>三高解释</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang的goroutine模型概述和调度</title>
    <url>/2023/02/06/Golang%E7%9A%84GPM%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0%E5%92%8C%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h1>G-P-M 模型概述</h1>
<ul>
<li>每一个OS线程都有一个固定大小的内存块(一般会是<code>2MB</code>)来做栈，这个栈会用来存储当前正在被调用或挂起(指在调用其它函数时)的函数的内部变量。</li>
<li>这个固定大小的栈同时很大又很小。因为<code>2MB</code>的栈对于一个小小的<code>Goroutine</code>来说是很大的内存浪费，而对于一些复杂的任务（如深度嵌套的递归）来说又显得太小。因此，Go语言做了它自己的『线程』。</li>
<li>在Go语言中，每一个Goroutine是一个独立的执行单元，相较于每个OS线程固定分配<code>2M</code>内存的模式，Goroutine的栈采取了动态扩容方式， <strong>初始时仅为<code>2KB</code></strong>，随着任务执行按需增长，最大可达<code>1GB</code>（64位机器最大是<code>1G</code>，32位机器最大是<code>256M</code>），且完全由Golang自己的调度器 Go Scheduler 来调度。</li>
<li>此外，<code>GC</code>还会周期性地将不再使用的内存回收，收缩栈空间。 因此，Go程序可以同时并发成千上万个Goroutine是得益于它<strong>强劲的调度器和高效的内存模型</strong>。</li>
</ul>
<blockquote>
<p><strong>任何用户线程最终肯定都是要交由OS线程来执行</strong></p>
</blockquote>
<p>​    Goroutine（称为G）也不例外，但是G并不直接绑定OS线程运行，而是由Goroutine Scheduler中的 <code>P - Logical Processor </code>（逻辑处理器）来作为两者的<code>『中介』</code>。</p>
<p>P 可以看作是一个抽象的资源或者一个上下文，一个P绑定一个OS线程，在Golang的实现里把OS线程抽象成一个数据结构。</p>
<p><strong>M，G实际上是由M通过P来进行调度运行的</strong>，但是在G的层面来看，<strong>P提供了G运行所需的一切资源和环境</strong>，因此在G看来P就是运行它的 “CPU”，由 G、P、M 这三种由Go抽象出来的实现，最终形成了Go调度器的基本结构：</p>
<h2 id="G-Goroutine">G: Goroutine</h2>
<ul>
<li>
<p>G有以下状态</p>
<ul>
<li>
<p>非<code>GC</code>状态</p>
<ul>
<li><code>idle</code>:<code>_Gidle for idle</code>，意思是这个goroutine刚被创建出来，还未被进行初始化。</li>
<li><code>runnable</code>: <code>_Grunnable for runnable</code>意思是这个goroutine已经在运行队列，在这种情况下，goroutine还未执行用户代码，M的执行栈还不是goroutine自己的</li>
<li><code>running</code>: <code>_Grunning for running</code>，意思是goroutine可能正在执行用户代码，M的执行栈已经由该goroutine所拥有，此时对象g不在运行队列中。这个状态值要待分配给M和P之后，交由M和P来设定</li>
<li><code>syscall</code>, <code>waiting</code>, <code>dead</code>, <code>copystack</code></li>
</ul>
</li>
<li>
<p>对应的<code>GC</code>状态</p>
<ul>
<li><code>scan</code>, <code>scanrunnable</code>, <code>scan running</code>, <code>scansyscall</code>, <code>scanwaiting</code></li>
<li><code>_Gscan</code>系列，用于标记正在被<code>GC</code>扫描的状态，这些状态是由<code>_Gscan=0x1000</code>再加上<code>_GRunnable</code>, <code>_Grunning</code>, <code>_Gsyscall</code>和<code>_Gwaiting</code>的枚举值所产生的，这么做的好处是直接通过简单的运算即可知道被Scan之前的状态。当被标记为这系列的状态时，这些<code>goroutine</code>都不会执行用户代码，并且它们的执行栈都是被做该<code>GC</code>的<code>goroutine</code>所拥有。不过<code>_Gscanrunning</code>状态有点特别，这个标记是为了阻止正在运行的<code>goroutine</code>切换成其它状态，并告诉这个G自己扫描自己的堆栈。正是这种巧妙的方式，使得<code>Go</code>语言的<code>GC</code>十分高效。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>每个Goroutine对应一个G结构体，G 存储 Goroutine的运行堆栈、状态以及任务函数，可重用。</p>
</li>
<li>
<p>G并非执行体，每个G需要绑定到P才能被调度执行。</p>
</li>
</ul>
<h2 id="P-Processor">P: Processor</h2>
<ul>
<li>表示逻辑处理器， 对G来说，P相当于CPU核，G只有绑定到P(<code>在P的local run中</code>)才能被调度。对M来说，<code>P</code>提供了相关的执行环境(<code>Context</code>)，如内存分配状态(<code>mcache</code>)，任务队列(<code>G</code>)等，<strong>P的数量决定了系统内最大可并行的G的数量（前提：物理CPU核数 &gt;= P的数量），P的数量由用户设置的<code>GoMAXPROCS</code>决定，但是不论<code>GoMAXPROCS</code>设置为多大，P的数量最大为256</strong>。</li>
<li><code>golang runtime</code>是有个<code>sysmon</code>的协程，他会轮询的检测所有的<code>P上下文队列</code>，**只要 G-M 的线程长时间在阻塞状态，那么就重新创建一个线程去从runtime P队列里获取任务。先前的阻塞的线程会被游离出去了，当他完成阻塞操作后会触发相关的callback回调，并加入回线程组里。**简单说，如果你没有特意配置<code>runtime.SetMaxThreads</code>，那么在没有可复用的线程的情况下，会一直创建新线程。</li>
</ul>
<h2 id="M-Machine">M: Machine</h2>
<p>​    OS线程抽象，<strong>代表着真正执行计算的资源</strong>。</p>
<ul>
<li>
<p>在绑定有效的P后，进入schedule循环；而schedule循环的机制大致是从Global队列、P的Local队列以及wait队列中获取G，切换到G的执行栈上并执行G的函数，调用<code>Goexit</code>做清理工作并回到M，如此反复。</p>
</li>
<li>
<p>M并不保留G状态，这是G可以跨M调度的基础，M的数量是不定的，由Go Runtime调整，为了防止创建过多OS线程导致系统调度不过来，目前默认最大限制为10000个。</p>
</li>
<li>
<p>在绝大多数时候，其实<code>P</code>的数量和<code>M</code>的数量是相等。 每创建一个<code>p</code>, 就会创建一个对应的<code>M</code>只有少数情况下，<code>M</code>的数量会大于<code>P</code></p>
</li>
</ul>
<h1><em><a href="https://supertech.csail.mit.edu/papers/steal.pdf">work-stealing</a></em> 的调度算法</h1>
<ul>
<li>每个P维护一个G的本地队列；</li>
<li>当一个G被创建出来，或者变为可执行状态时，就把他放到P的可执行队列中；</li>
<li>当一个G在M里执行结束后，P会从队列中把该G取出；如果此时P的队列为空，即没有其他G可以执行， M就随机选择另外一个P，从其可执行的G队列中取走一半。</li>
</ul>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/202108091238404.png" alt="image-20210809113044316"></p>
<span id="more"></span>
<h1>G-P-M 模型调度</h1>
<p>​    Go调度器工作时会维护两种用来保存G的任务队列：</p>
<ul>
<li>一种是一个Global任务队列</li>
<li>一种是每个P维护的Local任务队列</li>
</ul>
<p>当通过Go关键字创建一个新的Goroutine的时候，它会优先被放入P的本地队列。</p>
<p>​    为了运Goroutine，M需要持有（绑定）一个P，接着M会启动一个OS线程，循环从P的本地队列里取出一个Goroutine并执行。</p>
<p>当然还有上文提及的 work-stealing调度算法:</p>
<p>​    当M执行完了当前P的Local队列里的所有G后，P也不会就这么在那躺尸啥都不干，它会<strong>先尝试从Global队列寻找G</strong>来执行，如果Global队列为空，它会随机挑选另外一个P，从它的队列里中拿走一半的G到自己的队列中执行。</p>
<h2 id="用户态阻塞-唤醒"><strong>用户态阻塞/唤醒</strong></h2>
<p>​    当<code>Goroutine</code>因为<code>channel</code>操作或者<code>network I/O</code>而阻塞时（实际上<code>Golang</code>已经用<code>netpoller</code>实现了<code>Goroutine</code>网络<code>I/O</code>阻塞不会导致<code>M</code>被阻塞，仅阻塞<code>G</code>，这里仅仅是举个栗子），对应的<code>G</code>会被放置到某个<code>wait</code>队列(如<code>channel</code>的<code>waitq</code>)，该G的状态由<code>_Gruning</code>变为<code>_Gwaitting</code>，而M会跳过该G尝试获取并执行下一个G，如果此时没有<code>runnable</code>的<code>G</code>供<code>M</code>运行，那么M将解绑P，并进入<code>sleep</code>状态；</p>
<p>当阻塞的<code>G</code>被另一端的<code>G2</code>唤醒时（比如<code>channel</code>的可读/写通知），G被标记为<code>runnable</code>，尝试加入<code>G2</code>所在P的<code>runnext</code>，然后再是P的<code>Local</code>队列和<code>Global</code>队列。</p>
<h2 id="系统调用阻塞">系统调用阻塞</h2>
<p>​    当G被阻塞在某个系统调用上时，此时G会阻塞在<code>_Gsyscall</code>状态，M也处于 <code>block on syscall</code> 状态，此时的M可被抢占调度：执行该G的M会与P解绑，而<code>P</code>则尝试与其它<code>idle</code>的M绑定，继续执行其它<code>G</code>。</p>
<p>​    如果没有其它<code>idle</code>的M，但<code>P</code>的<code>Local</code>队列中仍然有<code>G</code>需要执行，则创建一个新的M；当系统调用完成后，<code>G</code>会重新尝试获取一个<code>idle</code>的<code>P</code>进入它的<code>Local</code>队列恢复执行，如果没有<code>idle</code>的<code>P</code>，<code>G</code>会被标记为<code>runnable</code>加入到<code>Global</code>队列。</p>
<h2 id="管理协程">管理协程</h2>
<p>​    上面说到go语言自己定义一个结构体，叫协程。自己在用户态控制多个协程（结构体）的调度和执行，那它是怎么实现的呢？</p>
<ul>
<li>
<p>go引入了P(Processor)的概念。一个P表示一个逻辑处理器，用于调度G。称之为逻辑处理器，一般与物理处理器对应</p>
</li>
<li>
<p>M(Machine)，可以理解成一个线程，真正执行P的线程。</p>
</li>
</ul>
<p>G、P、M之间的关系如下图：</p>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/202108091238161.png" alt="image-20210809113107322"></p>
<p>每一个P都有一个对应的G队列，P绑定了线程<code>M0</code>正在执行协程<code>G0</code>，当遇到阻塞事件的时候，runtime会为P绑定一个新的线程<code>M1</code>，执行新的新的线程</p>
<h1>参考链接</h1>
<blockquote>
<p><a href="https://juejin.cn/post/6927264515193045000#heading-10">Go协程管理</a></p>
<p><a href="https://segmentfault.com/a/1190000022871460">Go 调度模型 GPM</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>GPM调度器</tag>
      </tags>
  </entry>
  <entry>
    <title>goroutine VS python 协程</title>
    <url>/2023/02/06/goroutineVspython%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<h1>协程概念</h1>
<p><strong>协程</strong>，其实可以理解为一种特殊的程序调用。特殊的是在执行过程中，在子程序（或者说函数）内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<p><strong>它有两个特征：</strong></p>
<ul>
<li><strong>可中断，这里的中断不是普通的函数调用，而是类似CPU的中断，CPU在这里直接释放转到其他程序断点继续执行。</strong></li>
<li><strong>可恢复，等到合适的时候，可以恢复到中断的地方继续执行。</strong></li>
</ul>
<h2 id="和进程线程的区别"><strong>和进程线程的区别</strong></h2>
<p>上面两个特点就导致了它相对于线程和进程切换来说极高的执行效率，为什么这么说呢？我们先老生常谈地说一下进程和线程。</p>
<ul>
<li><strong>进程是操作系统资源分配的基本单位，线程是操作系统调度和执行的最小单位</strong>。</li>
</ul>
<p>这两句应该是我们最常听到的两句话，拆开来说，</p>
<ul>
<li>进程是程序的启动实例，拥有代码和打开的文件资源、数据资源、独立的内存空间。</li>
<li>线程从属于进程，是程序的实际执行者，一个进程至少包含一个主线程，也可以有更多的子线程，线程拥有自己的栈空间。无论是进程还是线程，都是由操作系统所管理和切换的。</li>
</ul>
<p>我们再来看协程，它又叫做微<strong>线程，但其实它和进程还有线程完全不是一个维度上的概念</strong>。</p>
<ul>
<li>进程和线程的切换完全是用户无感，由操作系统控制，<strong>从用户态到内核态再到用户态</strong>。</li>
<li>而协程的切换完全是程序代码控制的，在<strong>用户态</strong>的切换，就像函数回调的消耗一样，在线程的栈内即可完成。</li>
</ul>
<span id="more"></span>
<h2 id="python协程的特点">python协程的特点</h2>
<ul>
<li><strong>单线程内切换，适用于IO密集型程序中，可以最大化IO多路复用的效果。</strong></li>
<li><strong>无法利用多核。</strong></li>
<li><strong>协程间完全同步，不会并行。不需要考虑数据安全。</strong></li>
<li><strong>用法多样，可以用在web服务中，也可用在pipeline数据/任务消费中</strong></li>
</ul>
<h2 id="go协程的特点"><strong>go协程的特点</strong></h2>
<ul>
<li><strong>协程间需要保证数据安全，比如通过channel或锁。</strong></li>
<li><strong>可以利用多核并行执行。</strong></li>
<li><strong>协程间不完全同步，可以并行运行，具体要看channel的设计。</strong></li>
<li><strong>抢占式调度，可能无法实现公平。</strong></li>
</ul>
<h2 id="coroutine（python）和goroutine（go）的区别">coroutine（python）和goroutine（go）的区别</h2>
<p>coroutine 与 goroutine 在名字上类似，都是可中断可恢复的协程，它们之间最大的不同是，</p>
<ul>
<li>goroutine 可能在多核上发生并行执行，但 coroutine 始终是顺序执行。</li>
</ul>
<p>也基于此，我们应该清楚coroutine适用于IO密集程序中，而goroutine在 IO密集和CPU密集 中都有很好的表现。不过话说回来，go就一定比python快么，假如在完全IO并发密集的程序中，python的表现反而更好，因为<strong>单线程内的协程切换效率更高</strong>。</p>
<p>从运行机制上来说，coroutine 的运行机制属于协作式任务处理， 程序需要主动交出控制权，宿主才能获得控制权并将控制权交给其他 coroutine。</p>
<ul>
<li>如果开发者无意间或者故意让应用程序长时间占用 CPU，操作系统也无能为力，表现出来的效果就是计算机很容易失去响应或者死机。goroutine 属于抢占式任务处理，已经和现有的多线程和多进程任务处理非常类似， 虽然无法控制自己获取高优先度支持。但如果发现一个应用程序长时间大量地占用 CPU，那么用户有权终止这个任务。</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解堆、栈、CPU密集型 和 I/O 密集型任务</title>
    <url>/2023/02/06/%E5%85%B3%E4%BA%8E%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81CPU%E5%AF%86%E9%9B%86%E5%9E%8B%20%E5%92%8C%20IO%20%E5%AF%86%E9%9B%86%E5%9E%8B%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1>关于堆、栈、CPU密集型 和 I/O 密集型知识</h1>
<h2 id="程序中的内存分配方式（c-c-）">程序中的内存分配方式（c/c++）</h2>
<ul>
<li>1、栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其<br>
操作方式类似于数据结构中的栈。</li>
<li>2、堆区（heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回<br>
收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链。</li>
<li>3、全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的<br>
全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另<br>
一块区域。 - 程序结束后由系统释放。</li>
<li>4、文字常量区：常量字符串就是放在这里的。 程序结束后由系统释放</li>
<li>5、程序代码区：存放函数体的二进制代码。</li>
</ul>
<h2 id="python的堆栈解析">python的堆栈解析</h2>
<p>因为是动态语言**，python中的所有变量内容都存在堆（heap）中**，而<strong>变量名只是堆中内容的引用，存放在栈（stack）中</strong>，便于用户去间接操作堆中的数据。</p>
<p>堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：</p>
<ul>
<li>（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；</li>
<li>（2）空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；</li>
<li>（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。</li>
<li>（4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由<code>malloc</code>函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。</li>
<li>（5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。</li>
<li>（6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。</li>
</ul>
<span id="more"></span>
<h2 id="函数入栈和出栈">函数入栈和出栈</h2>
<ul>
<li>
<p>当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等。一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。</p>
</li>
<li>
<p>出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。</p>
<p>从以上可以看到，堆和栈相比，由于大量<code>malloc()/free()</code>或<code>new/delete</code>的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。</p>
</li>
</ul>
<h3 id="小结">小结</h3>
<ul>
<li>栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。</li>
</ul>
<p>无论是堆还是栈，在内存使用时都要防止非法越界，越界导致的非法内存访问可能会摧毁程序的堆、栈数据，轻则导致程序运行处于不确定状态，获取不到预期结果，重则导致程序异常崩溃，这些都是我们编程时与内存打交道时应该注意的问题。</p>
<h1>CPU 密集型 和I / O 密集型</h1>
<h2 id="CPU密集型（CPU-bound）"><strong>CPU密集型（CPU-bound）</strong></h2>
<ul>
<li>CPU密集型也叫计算密集型，指的是<strong>系统的硬盘、内存性能相对CPU要好很多</strong>，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读/写I/O(硬盘/内存)，<strong>I/O在很短的时间就可以完成</strong>，而CPU还有许多运算要处理，CPU Loading很高。</li>
<li>在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。</li>
</ul>
<p>CPU bound的程序一般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I/O设备，也可能是因为程序是多线程实现因此屏蔽掉了等待I/O的时间。</p>
<h2 id="IO密集型（I-O-bound）"><strong>IO密集型（I/O bound）</strong></h2>
<ul>
<li>I/O密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，<strong>大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作</strong>，此时CPU Loading并不高。</li>
<li>I/O bound的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I/O操作，而pipeline做得不是很好，没有充分利用处理器能力。</li>
</ul>
<h2 id="CPU密集型-vs-IO密集型"><strong>CPU密集型 vs IO密集型</strong></h2>
<p>我们可以把任务分为计算密集型和IO密集型。</p>
<p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p>
<ul>
<li>
<p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p>
<p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p>
</li>
<li>
<p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p>
</li>
</ul>
<blockquote>
<p><strong>总之，计算密集型程序适合C语言多线程，I/O密集型适合脚本语言开发的多线程。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>程序堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title>json、结构体标签和rpc入门</title>
    <url>/2023/02/06/json%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E6%A0%87%E7%AD%BE%E5%92%8Crpc%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1>json、结构体标签和rpc入门</h1>
<h2 id="json使用">json使用</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 结构体 --&gt; 字符串  编码</span></span><br><span class="line"><span class="comment">// 将 字符串 --&gt; 结构体  解码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体的成员须大写，不然不参与编码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name  <span class="type">string</span></span><br><span class="line">   Sex   <span class="type">string</span></span><br><span class="line">   Age   <span class="type">int</span></span><br><span class="line">   Score <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   st1 := Student&#123;</span><br><span class="line">      Name:  <span class="string">&quot;luenci&quot;</span>,</span><br><span class="line">      Sex:   <span class="string">&quot;man&quot;</span>,</span><br><span class="line">      Age:   <span class="number">22</span>,</span><br><span class="line">      Score: <span class="number">99</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 编码 序列化</span></span><br><span class="line">   encodeInfo, err := json.Marshal(st1)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;序列化发生错误,error&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(reflect.TypeOf(encodeInfo))</span><br><span class="line">   fmt.Println(<span class="type">string</span>(encodeInfo))</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解码 反序列化</span></span><br><span class="line">   <span class="keyword">var</span> st2 Student</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err := json.Unmarshal([]<span class="type">byte</span>(encodeInfo), &amp;st2); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;反序列化发生错误,&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(st2.Name)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="结构体标签">结构体标签</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体标签由一个或多个键值对组成。</span></span><br><span class="line"><span class="comment">// 键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name    <span class="type">string</span> <span class="string">`json:&quot;-&quot;`</span>                 <span class="comment">// 在使用json编码时候，这个字段不参与编码</span></span><br><span class="line">   Subject <span class="type">string</span> <span class="string">`json:&quot;subject_name&quot;`</span>      <span class="comment">// 在使用json编码时候，这个字段会编码成 subject_name</span></span><br><span class="line">   Age     <span class="type">int</span>    <span class="string">`json:&quot;age,string&quot;`</span>        <span class="comment">// 在使用json编码时候，这个字段类型会变成age and 类型会变为 string</span></span><br><span class="line">   Address <span class="type">string</span> <span class="string">`json:&quot;address,omitempty&quot;`</span> <span class="comment">// 在使用json编码时候，如果这个字段是空的,就会忽略掉不编码</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 小写的结构体成员在json编码时候会被忽略掉</span></span><br><span class="line">   gender <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   t1 := Teacher&#123;</span><br><span class="line">      Name:    <span class="string">&quot;lynn&quot;</span>,</span><br><span class="line">      Subject: <span class="string">&quot;math&quot;</span>,</span><br><span class="line">      Age:     <span class="number">0</span>,</span><br><span class="line">      Address: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">      gender:  <span class="string">&quot;girl&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   marshal, err := json.Marshal(t1)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;编码后结果为:&quot;</span>, <span class="type">string</span>(marshal))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rpc封装设计">rpc封装设计</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">   HelloWorld(<span class="type">string</span>, *<span class="type">string</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端注册函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterName</span><span class="params">(i MyInterface)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">   err := rpc.RegisterName(<span class="string">&quot;Hello&quot;</span>, i)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyClient <span class="keyword">struct</span> &#123;</span><br><span class="line">   c *rpc.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitClient</span><span class="params">(addr <span class="type">string</span>)</span></span> MyClient &#123;</span><br><span class="line">   conn, _ := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">   <span class="keyword">return</span> MyClient&#123;c: conn&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现函数参照interface实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyClient)</span></span> HelloWorld(name <span class="type">string</span>, resp *<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> this.c.Call(<span class="string">&quot;Hello.HelloWorld&quot;</span>, name, resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rpc-server">rpc-server</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;net&quot;</span></span><br><span class="line">   <span class="string">&quot;net/rpc/jsonrpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Hello <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Hello)</span></span> HelloWorld(name <span class="type">string</span>, resp *<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">   *resp = name + <span class="string">&quot; 你好！&quot;</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 1.注册服务</span></span><br><span class="line">   <span class="comment">//if err := rpc.RegisterName(&quot;luenci&quot;, new(Hello)); err != nil &#123;</span></span><br><span class="line">   <span class="comment">// fmt.Println(&quot;注册服务失败:&quot;, err)</span></span><br><span class="line">   <span class="comment">// return</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line">   <span class="keyword">if</span> err := RegisterName(<span class="built_in">new</span>(Hello)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;服务注册失败,error&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.设置监听着</span></span><br><span class="line">   listenner, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8800&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;设置监听者失败:&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> listenner.Close()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3.建立链接</span></span><br><span class="line">   conn, err := listenner.Accept()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;建立链接失败:&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4.绑定服务 jsonrpc</span></span><br><span class="line">   <span class="comment">//rpc.ServeConn(conn)</span></span><br><span class="line">   jsonrpc.ServeConn(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rpc-client（go）">rpc-client（go）</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* --------------------- 方式一 ------------------*/</span></span><br><span class="line">   <span class="comment">// 通用的序列化和反序列化 -- json、protobuf</span></span><br><span class="line">   <span class="comment">// 使用 Dail 链接服务器 -- Dail()</span></span><br><span class="line">   <span class="comment">//conn, err := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:8800&quot;)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//conn, err := jsonrpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:8800&quot;)</span></span><br><span class="line">   <span class="comment">//if err != nil &#123;</span></span><br><span class="line">   <span class="comment">// fmt.Println(&quot;Dail error:&quot;, err)</span></span><br><span class="line">   <span class="comment">// return</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line">   <span class="comment">//defer conn.Close()</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">//// 调用远程函数</span></span><br><span class="line">   <span class="comment">//var response string // 接收返回值 -- 传出参数</span></span><br><span class="line">   <span class="comment">//if err := conn.Call(&quot;luenci.HelloWorld&quot;, &quot;lynn&quot;, &amp;response); err != nil &#123;</span></span><br><span class="line">   <span class="comment">// fmt.Println(&quot;Call error&quot;, err)</span></span><br><span class="line">   <span class="comment">// return</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line">   <span class="comment">//fmt.Println(&quot;response&quot;, response)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* --------------------- 方式二 ------------------*/</span></span><br><span class="line"></span><br><span class="line">   MyClient := InitClient(<span class="string">&quot;127.0.0.1:8800&quot;</span>)</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(c *rpc.Client)</span></span> &#123;</span><br><span class="line">      err := c.Close()</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;关闭链接出错.error&quot;</span>, err)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;(MyClient.c)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> resp <span class="type">string</span></span><br><span class="line">   err := MyClient.HelloWorld(<span class="string">&quot;luenci&quot;</span>, &amp;resp)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;出错了,error&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rpc-client（python）">rpc-client（python）</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> socket               <span class="comment"># 导入 socket 模块</span></span><br><span class="line"></span><br><span class="line">s = socket.socket()         <span class="comment"># 创建 socket 对象</span></span><br><span class="line">host = <span class="string">&quot;127.0.0.1&quot;</span> <span class="comment"># 获取本地主机名</span></span><br><span class="line">port = <span class="number">8800</span>                <span class="comment"># 设置端口号</span></span><br><span class="line"></span><br><span class="line">s.connect((host, port))</span><br><span class="line">data = json.dumps(&#123;<span class="string">&quot;method&quot;</span>:<span class="string">&quot;luenci.HelloWorld&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;lynn&quot;</span>],<span class="string">&quot;id&quot;</span>:<span class="number">0</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">s.send(data)</span><br><span class="line">res = s.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(res))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>consul服务发现</title>
    <url>/2023/02/06/consul%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<h1>consul服务发现</h1>
<blockquote>
<p>Consul是由HashiCorp开发的一个支持多数据中心的分布式服务发现和键值对存储服务的开源软件，被大量应用于基于微服务的软件架构当中。</p>
</blockquote>
<h2 id="服务发现流程图">服务发现流程图</h2>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/20210607214102.png" alt="image-20210607214102612"></p>
<ul>
<li>服务发现，也可以看做一个“服务”，是给“服务”提供服务的</li>
</ul>
<h2 id="服务发现种类">服务发现种类</h2>
<ul>
<li>consul：常用于go-micro中</li>
<li>mdns：go-micro中默认的服务发现</li>
<li>etcd：k8s内嵌的服务发现</li>
<li>zookeeper：java中常用</li>
</ul>
<h2 id="Consul关键特性">Consul关键特性</h2>
<ul>
<li>服务发现：consul提供服务，服务端主动向consul发起注册。</li>
<li>健康检查：定时发送消息，类似于“心跳包”，保证客户端获取到的一定是健康的服务。</li>
<li>键值存储：consul提供，但常用于redis。</li>
<li>多数据中心：可以轻松加入集群。</li>
</ul>
<h2 id="Consul-参数">Consul 参数</h2>
<ul>
<li>安装好 Consul 后，在启动程序之前，需要掌握一些配置参数，通过掌握这些参数，可以一次性的成功运行 Consul 服务器集群，常用的参数如下：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">参数名称</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-server</td>
<td style="text-align:center">此标志用于控制代理是运行于服务器/客户端模式，每个 Consul 集群至少有一个服务器，正常情况下不超过5个，使用此标记的服务器参与 Raft一致性算法、选举等事务性工作</td>
</tr>
<tr>
<td style="text-align:center">-http-port=8500</td>
<td style="text-align:center">consul自带的一个web访问端口，默认为8500</td>
</tr>
<tr>
<td style="text-align:center">-client</td>
<td style="text-align:center">表示 Consul 绑定客户端接口的IP地址，默认值为：127.0.0.1，当你有多块网卡的时候，最好指定IP地址，不要使用默认值</td>
</tr>
<tr>
<td style="text-align:center">-bootstrap-expect</td>
<td style="text-align:center">预期的服务器集群的数量，整数，如 -bootstrap-expect=3，表示集群服务器数量为3台，设置该参数后，Consul将等待指定数量的服务器全部加入集群可用后，才开始引导集群正式开始工作，此参数必须与 -server 一起使用</td>
</tr>
<tr>
<td style="text-align:center">-data-dir</td>
<td style="text-align:center">存储数据的目录，该目录在 Consul 程序重启后数据不会丢失，指定此目录时，应确保运行 Consul 程序的用户对该目录具有读写权限</td>
</tr>
<tr>
<td style="text-align:center">-config-dir=XX</td>
<td style="text-align:center">所有服务主动注册的配置文件</td>
</tr>
<tr>
<td style="text-align:center">- node</td>
<td style="text-align:center">当前服务器在集群中的名称，该值在整个 Consul 集群中必须唯一，默认值为当前主机名称</td>
</tr>
<tr>
<td style="text-align:center">- bind</td>
<td style="text-align:center">Consul 在当前服务器侦听的地址，如果您有多块网卡，请务必指定一个IP地址（IPv4/IPv6)，默认值为：0.0.0.0，也可用使用[::]</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h2 id="启动consul">启动consul</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=consul1 -<span class="built_in">bind</span>=172.16.249.181 -ui -rejoin -config-dir /etc/consul.d/ -client 0.0.0.0</span><br></pre></td></tr></table></figure>
<ul>
<li>如果第一次启动 请先创建 <code>/etc/consul.d/</code> 文件夹</li>
<li>consul leave — 优雅退出consul</li>
<li>consul members  — 查看consul成员</li>
<li>consul info — 查看consul信息</li>
</ul>
<h2 id="注册服务到consul">注册服务到consul</h2>
<ul>
<li>增加配置在 <code>/etc/consul.d/demo.json</code></li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;service&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;luenci&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;study&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span><span class="number">8880</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>curl 命令查看注册的服务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Luenci:~<span class="comment"># curl -s 127.0.0.1:8500/v1/catalog/service/luenci | python -m json.tool</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Address&quot;</span>: <span class="string">&quot;172.16.249.181&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CreateIndex&quot;</span>: 44,</span><br><span class="line">        <span class="string">&quot;Datacenter&quot;</span>: <span class="string">&quot;dc1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ID&quot;</span>: <span class="string">&quot;c3908dfa-4fdf-4a57-686f-a3fc620fc5b7&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ModifyIndex&quot;</span>: 44,</span><br><span class="line">        <span class="string">&quot;Node&quot;</span>: <span class="string">&quot;consul1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;NodeMeta&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;consul-network-segment&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;ServiceAddress&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ServiceConnect&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;ServiceEnableTagOverride&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;ServiceID&quot;</span>: <span class="string">&quot;luenci&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ServiceKind&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ServiceMeta&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;ServiceName&quot;</span>: <span class="string">&quot;luenci&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ServicePort&quot;</span>: 8880,</span><br><span class="line">        <span class="string">&quot;ServiceProxy&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;ServiceProxyDestination&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ServiceTags&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;study&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;ServiceWeights&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Passing&quot;</span>: 1,</span><br><span class="line">            <span class="string">&quot;Warning&quot;</span>: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;TaggedAddresses&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;lan&quot;</span>: <span class="string">&quot;172.16.249.181&quot;</span>,</span><br><span class="line">            <span class="string">&quot;wan&quot;</span>: <span class="string">&quot;172.16.249.181&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="健康检查">健康检查</h2>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">root@Luenci<span class="punctuation">:</span>~# cat /etc/consul.d/sweetie.json | python -m json.tool</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;service&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;check&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;http://172.16.249.181:8001&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;api&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;interval&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10s&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;check sweetie api&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2s&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sweetie&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">8001</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;fast-api&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>consul 健康检查必须是<code>Script</code>, <code>HTTP</code> ,  <code>TCP</code> , <code>TTL</code> 中的一种</li>
</ul>
<h2 id="使用go注册服务，python做服务发现">使用go注册服务，python做服务发现</h2>
<p><strong>服务注册</strong>，就是将提供某个服务的模块信息(通常是这个服务的ip和端口)注册到1个公共的组件上去。</p>
<p><strong>服务发现</strong>，就是新注册的这个服务模块能够及时的被其他调用者发现。不管是服务新增和服务删减都能实现自动发现。</p>
<h3 id="protoc文件">protoc文件</h3>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line">// 指定所在包名</span><br><span class="line">package study.consul;</span><br><span class="line"></span><br><span class="line">option go_package = <span class="string">&quot;./proto&quot;</span>;</span><br><span class="line"></span><br><span class="line">message <span class="symbol">Human</span> &#123;</span><br><span class="line">  string name = <span class="number">1</span>;</span><br><span class="line">  int32 age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service <span class="symbol">SayName</span>&#123;</span><br><span class="line">  rpc <span class="symbol">Hello</span> (<span class="symbol">Human</span>) returns (<span class="symbol">Human</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="server-consul（go实现）">server-consul（go实现）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;context&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/hashicorp/consul/api&quot;</span></span><br><span class="line">   <span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;net&quot;</span></span><br><span class="line">   <span class="string">&quot;study.consul/proto&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">   proto.UnimplementedSayNameServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> Hello(ctx context.Context, args *proto.Human) (*proto.Human, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">// 通过编译出来的rpc.pb.go解析String类型数据</span></span><br><span class="line">   args.Name += <span class="string">&quot; is coding!&quot;</span></span><br><span class="line">   args.Age += <span class="number">3</span></span><br><span class="line">   <span class="keyword">return</span> args, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* ------------------- 注册服务到consul ---------------------*/</span></span><br><span class="line">   <span class="comment">// 初始化consul配置</span></span><br><span class="line">   consulConfig := api.DefaultConfig()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建consul对象</span></span><br><span class="line">   consulClient, err := api.NewClient(consulConfig)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;api NewClient err&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注册服务，服务的常规信息</span></span><br><span class="line">   regInfo := api.AgentServiceRegistration&#123;</span><br><span class="line">      ID:      <span class="string">&quot;go grpc&quot;</span>,</span><br><span class="line">      Tags:    []<span class="type">string</span>&#123;<span class="string">&quot;grpc&quot;</span>, <span class="string">&quot;consul&quot;</span>&#125;,</span><br><span class="line">      Name:    <span class="string">&quot;go grpc server&quot;</span>,</span><br><span class="line">      Address: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">      Port:    <span class="number">5001</span>,</span><br><span class="line">      Check: &amp;api.AgentServiceCheck&#123;</span><br><span class="line">         CheckID:  <span class="string">&quot;consul check grpc test&quot;</span>,</span><br><span class="line">         TCP:      <span class="string">&quot;127.0.0.1:5001&quot;</span>,</span><br><span class="line">         Timeout:  <span class="string">&quot;2s&quot;</span>,</span><br><span class="line">         Interval: <span class="string">&quot;3s&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注册 grpc 服务到 consul 上</span></span><br><span class="line">   consulClient.Agent().ServiceRegister(&amp;regInfo)</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;注册成功...&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* ------------------- grpc 远程调用 ---------------------*/</span></span><br><span class="line">   <span class="comment">// 初始化框架</span></span><br><span class="line">   grpcServer := grpc.NewServer()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注册服务</span></span><br><span class="line">   proto.RegisterSayNameServer(grpcServer, <span class="built_in">new</span>(Person))</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定义端口监听服务</span></span><br><span class="line">   lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:5001&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> lis.Close()</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;服务启动...&quot;</span>)</span><br><span class="line">   <span class="comment">// 开启监听</span></span><br><span class="line">   grpcServer.Serve(lis)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="clien-consul-python实现">clien-consul(python实现)</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pip install python-consul</span></span><br><span class="line"><span class="comment"># python 编译 protoc</span></span><br><span class="line"><span class="comment"># python -m grpc_tools.protoc --python_out=. --grpc_python_out=. -I. rpc.proto</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> consul</span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test_pb2</span><br><span class="line"><span class="keyword">import</span> test_pb2_grpc</span><br><span class="line"></span><br><span class="line">c = consul.Consul(<span class="string">&quot;XX.XX.XX.XX&quot;</span>, <span class="string">&quot;port&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(c.catalog.service(&quot;go grpc server&quot;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 consul 中拿到健康的服务</span></span><br><span class="line">service = c.health.service(<span class="string">&quot;go grpc server&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(type(service))</span></span><br><span class="line">addr = service[<span class="number">1</span>][<span class="number">0</span>][<span class="string">&quot;Service&quot;</span>][<span class="string">&quot;Address&quot;</span>]</span><br><span class="line">port = service[<span class="number">1</span>][<span class="number">0</span>][<span class="string">&quot;Service&quot;</span>][<span class="string">&quot;Port&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取健康的服务 ip + port</span></span><br><span class="line">health_service = <span class="built_in">str</span>(addr) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(port)</span><br><span class="line"><span class="built_in">print</span>(health_service)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接 rpc 服务器</span></span><br><span class="line"></span><br><span class="line">channel = grpc.insecure_channel(health_service)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用rpc服务,通过编译出来的rpc_pb2_grpc的HelloService接口定义HelloServiceStub接口,接收来自channel的数据</span></span><br><span class="line">stub = test_pb2_grpc.SayNameStub(channel)</span><br><span class="line"><span class="built_in">print</span>(stub)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过接口的rpc获取String类型数据，并获取值</span></span><br><span class="line">response = stub.Hello(test_pb2.Human(name=<span class="string">&#x27;luenci&#x27;</span>, age=<span class="number">19</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Greeter client received: &quot;</span> + response.name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Greeter client received: &quot;</span>, response.age)</span><br></pre></td></tr></table></figure>
<p>扩展阅读：<a href="https://my.oschina.net/daba0007/blog/3189858">python与golang通过grpc进行通信</a></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>consul</tag>
      </tags>
  </entry>
  <entry>
    <title>管道和go程</title>
    <url>/2023/02/06/%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95(%E7%AE%A1%E9%81%93%E5%92%8Cgo%E7%A8%8B)/</url>
    <content><![CDATA[<h1>管道和go程</h1>
<h2 id="goroutine（go程）">goroutine（go程）</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">(num <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   count := <span class="number">1</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;============&gt; 这是子go程：&quot;</span>, num, <span class="string">&quot;当前count值&quot;</span>, count)</span><br><span class="line">      count++</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 启动子go程</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">go</span> display(i)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 主go程</span></span><br><span class="line">   count := <span class="number">1</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;============&gt; 这是主go程：&quot;</span>, count)</span><br><span class="line">      count++</span><br><span class="line">      time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="提前退出go程">提前退出go程</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;runtime&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GOEXIT ===&gt; 提前退出go程</span></span><br><span class="line"><span class="comment">// return ===&gt; 返回当前函数</span></span><br><span class="line"><span class="comment">// exit ===&gt; 退出当前进程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;子go程内部的函数!&quot;</span>)</span><br><span class="line">         <span class="comment">//return // 退出当前函数</span></span><br><span class="line">         <span class="comment">//os.Exit(-1) // 退出进程</span></span><br><span class="line">         runtime.Goexit() <span class="comment">// 退出当前go程</span></span><br><span class="line">      &#125;()</span><br><span class="line"></span><br><span class="line">      fmt.Println(<span class="string">&quot;子go程结束！&quot;</span>)</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 主go程需要等待子go程退出</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;主go程~&quot;</span>)</span><br><span class="line">   time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">   fmt.Println(<span class="string">&quot;OVER!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="无缓冲管道">无缓冲管道</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当通道在多个协程之间传输的是指向数据的指针是，且读写操作是由不同的协程操作，则需要提供额外的同步动作。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 当涉及到多go程时，c语言使用互斥量，上锁来保持资源同步，避免资源竞争问题</span></span><br><span class="line">   <span class="comment">// go语言更好的解决方案是管道、通道</span></span><br><span class="line">   <span class="comment">// 使用通道不需要手动进行加锁</span></span><br><span class="line">   <span class="comment">//sync.RWMutex&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建管道 关键字 chan</span></span><br><span class="line">   numChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// 装数字的管道，无缓冲通道，未声明空间</span></span><br><span class="line">   <span class="comment">//numChan := make(chan int, 10) // 有缓冲通道</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建两个go程，父写，子读</span></span><br><span class="line">   <span class="comment">// 发现子go程没有发生资源抢夺</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 子go程1</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">25</span>; i++ &#123;</span><br><span class="line">         <span class="comment">// 只能 &lt;- 数据流向</span></span><br><span class="line">         data := &lt;-numChan</span><br><span class="line">         fmt.Println(<span class="string">&quot;子go程1 读取data&quot;</span>, data)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="comment">// 子go程2</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">25</span>; i++ &#123;</span><br><span class="line">         data := &lt;-numChan</span><br><span class="line">         fmt.Println(<span class="string">&quot;子go程2 读取data&quot;</span>, data)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 父go程</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">      <span class="comment">// 向管道中写入数据</span></span><br><span class="line">      numChan &lt;- i</span><br><span class="line">      fmt.Println(<span class="string">&quot;====&gt; 主go程，写入数据&quot;</span>, i)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="有缓冲管道">有缓冲管道</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当管道的读写次数不一致的时候</span></span><br><span class="line"><span class="comment">1.如果阻塞在主go程，程序会崩溃</span></span><br><span class="line"><span class="comment">2.如果阻塞在子go程，会发生内存泄露</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 当缓冲写满的时候，写阻塞，被读取后，在恢复写入</span></span><br><span class="line">   <span class="comment">// 当缓冲区读取完毕，读阻塞，开始写入</span></span><br><span class="line">   <span class="comment">// 如果没有使用make分配空间，那么管道默认nil的，读取，写入都会阻塞</span></span><br><span class="line">   numChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>) <span class="comment">// 有缓冲通道</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 子go程1</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">25</span>; i++ &#123;</span><br><span class="line">         <span class="comment">// 只能 &lt;- 数据流向</span></span><br><span class="line">         data := &lt;-numChan</span><br><span class="line">         fmt.Println(<span class="string">&quot;子go程1 读取data&quot;</span>, data)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 父go程</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">      <span class="comment">// 向管道中写入数据</span></span><br><span class="line">      numChan &lt;- i</span><br><span class="line">      fmt.Println(<span class="string">&quot;====&gt; 主go程，写入数据&quot;</span>, i)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> names <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">   <span class="comment">// 因为names是nil的，写操作会一直阻塞在这里</span></span><br><span class="line">   <span class="comment">// 并发生 deadlock 的 error</span></span><br><span class="line">   names &lt;- <span class="string">&quot;luenci&quot;</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;names&quot;</span>, &lt;-names)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for-range读取管道">for range读取管道</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   numChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">         numChan &lt;- i</span><br><span class="line">         fmt.Println(<span class="string">&quot;写入数据&lt;&lt;&quot;</span>, i)</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(<span class="string">&quot;数据写入完成,关闭管道&quot;</span>)</span><br><span class="line">      <span class="comment">// 从一个close的管道中读取数据时，会返回零值（不会崩溃）</span></span><br><span class="line">      <span class="built_in">close</span>(numChan)</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 遍历一个管道时，只会返回一个值</span></span><br><span class="line">   <span class="keyword">for</span> v := <span class="keyword">range</span> numChan &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;读取数据&gt;&gt;&quot;</span>, v)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断管道是否关闭">判断管道是否关闭</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   numChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">         numChan &lt;- i</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">close</span>(numChan)</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">// ok-idom 模式判断</span></span><br><span class="line">      <span class="keyword">if</span> v, ok := &lt;-numChan; ok &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;读取数据&quot;</span>, v)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;管道已经关闭！&quot;</span>)</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单向管道">单向管道</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 单向通道：为了明确语义,一般用于函数参数</span></span><br><span class="line">   <span class="comment">// 单向读通道：</span></span><br><span class="line">   <span class="comment">//var numChanReadOnly &lt;-chan int</span></span><br><span class="line">   <span class="comment">// 单向写通道:</span></span><br><span class="line">   <span class="comment">//var numChanWriteOnly chan&lt;- int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//numChanReadOnly = make(chan int, 10)</span></span><br><span class="line">   <span class="comment">//numChanWriteOnly = make(chan int, 10)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 双向管道可以赋值给单向管道，单向不能转双向</span></span><br><span class="line">   numChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>) <span class="comment">// 双向管道</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 生产者消费者模型</span></span><br><span class="line">   wg.Add(<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">go</span> producer(numChan, &amp;wg)</span><br><span class="line">   wg.Add(<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">go</span> consumer(numChan, &amp;wg)</span><br><span class="line"></span><br><span class="line">   wg.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// producer :生产者  ===&gt; 提供一个只写通道</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(in <span class="keyword">chan</span>&lt;- <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      in &lt;- i</span><br><span class="line">      <span class="comment">//data:= &lt;-out 写通道不允许读操作</span></span><br><span class="line">      fmt.Println(<span class="string">&quot;======&gt; 向管道中写入数据:&quot;</span>, i)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">close</span>(in)</span><br><span class="line">   wg.Done()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// consumer :消费者  ===&gt; 只提供一个只读通道</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(out &lt;-<span class="keyword">chan</span> <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//out &lt;-10 读通道不允许有写入数据</span></span><br><span class="line">   <span class="keyword">for</span> v := <span class="keyword">range</span> out &#123;</span><br><span class="line">      fmt.Println(v, <span class="string">&quot;&lt;======= 从管道中读取数据&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="利用管道控制go程">利用管道控制go程</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">100</span>)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">         fmt.Println(i)</span><br><span class="line">         c &lt;- <span class="literal">true</span></span><br><span class="line">      &#125;(i)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">      &lt;-c</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="select用法">select用法</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 当程序中有多个channel协同工作，ch1，ch2，某一时刻，ch1或者ch2触发了，程序要做响应处理</span></span><br><span class="line"><span class="comment">   1.使用 select 来监听多个管道，当管道被触发时（写入数据，读取数据，关闭管道）</span></span><br><span class="line"><span class="comment">   2.select 语法于 switch case 很像，但是所有的分支条件必须是通道I/O</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">var</span> ch1, ch2 <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">   ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">   ch2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">   wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">   wg.Add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 启动一个go程，负责监听两个channel</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;开始监听....&quot;</span>)</span><br><span class="line">      <span class="keyword">for</span> &#123;</span><br><span class="line">         <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> data1 := &lt;-ch1:</span><br><span class="line">            fmt.Println(<span class="string">&quot;从ch1中读取数据: &quot;</span>, data1)</span><br><span class="line">         <span class="keyword">case</span> data2 := &lt;-ch2:</span><br><span class="line">            fmt.Println(<span class="string">&quot;从ch2中读取数据: &quot;</span>, data2)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      wg.Done()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">         ch1 &lt;- i</span><br><span class="line">      &#125;</span><br><span class="line">      wg.Done()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">         ch2 &lt;- i</span><br><span class="line">      &#125;</span><br><span class="line">      wg.Done()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go面向对象相关知识</title>
    <url>/2023/02/06/Go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1>Go面向对象相关知识</h1>
<h2 id="类的封装和绑定方法">类的封装和绑定方法</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// go语言没有class关键字生成类</span></span><br><span class="line"><span class="comment">// 使用struct声明类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// 成员属性</span></span><br><span class="line">   name   <span class="type">string</span></span><br><span class="line">   age    <span class="type">int</span></span><br><span class="line">   gender <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外边绑定方法</span></span><br><span class="line"><span class="comment">// 类的方法，可以使用自己的成员</span></span><br><span class="line"><span class="comment">// 使用指针可以修改类的成员变量等</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> Eat() &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;使用 *Person 指针 修改前&quot;</span>)</span><br><span class="line">   fmt.Println(p.name + <span class="string">&quot; is eating&quot;</span>)</span><br><span class="line">   p.name = <span class="string">&quot;luenci&quot;</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;使用 *Person 指针 修改后&quot;</span>)</span><br><span class="line">   fmt.Println(p.name + <span class="string">&quot; is eating&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Eat2() &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;使用 Person 不是指针 修改前&quot;</span>)</span><br><span class="line">   fmt.Println(p.name + <span class="string">&quot; is eating&quot;</span>)</span><br><span class="line">   p.name = <span class="string">&quot;luenci&quot;</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;使用 Person 不是指针 修改后&quot;</span>)</span><br><span class="line">   fmt.Println(p.name + <span class="string">&quot; is eating&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   lynn := Person&#123;</span><br><span class="line">      name:   <span class="string">&quot;lynn&quot;</span>,</span><br><span class="line">      age:    <span class="number">20</span>,</span><br><span class="line">      gender: <span class="string">&quot;girl&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   lynn.Eat()</span><br><span class="line">   lynn.Eat2()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的继承">类的继承</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="type">string</span></span><br><span class="line">   sex  <span class="type">string</span></span><br><span class="line">   age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">   hum    Human <span class="comment">// 包含 Human类型的变量 是嵌套类</span></span><br><span class="line">   school <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">   Human  <span class="comment">// 直接声明Human类型，没有定义变量 类继承</span></span><br><span class="line">   school <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外面绑定方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> Eat() &#123;</span><br><span class="line">   fmt.Println(h.name + <span class="string">&quot; is eating&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   st1 := Student&#123;</span><br><span class="line">      hum: Human&#123;</span><br><span class="line">         name: <span class="string">&quot;lynn&quot;</span>,</span><br><span class="line">         sex:  <span class="string">&quot;girl&quot;</span>,</span><br><span class="line">         age:  <span class="number">20</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      school: <span class="string">&quot;一中&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;st1&quot;</span>, st1)</span><br><span class="line">   fmt.Println(<span class="string">&quot;st1 name&quot;</span>, st1.hum.name)</span><br><span class="line"></span><br><span class="line">   t1 := Teacher&#123;&#125;</span><br><span class="line">   t1.school = <span class="string">&quot;一中&quot;</span></span><br><span class="line">   t1.name = <span class="string">&quot;lynn&quot;</span></span><br><span class="line">   t1.sex = <span class="string">&quot;girl&quot;</span></span><br><span class="line">   t1.age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;t1&quot;</span>, t1)</span><br><span class="line">   fmt.Println(<span class="string">&quot;t1 name&quot;</span>, t1.name)</span><br><span class="line">   <span class="comment">// 继承的时候虽然我们没有声明变量名称，但是默认自动会给类型创建一个同名字段</span></span><br><span class="line">   <span class="comment">// 这是为了能在子类中操作父类，因为：子类父类可能出现同名字段</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;t1 age&quot;</span>, t1.Human.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类成员访问权限（字段大小写）">类成员访问权限（字段大小写）</h2>
<span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> src</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外面绑定方法</span></span><br><span class="line"><span class="comment">// 即使在类的定义前也没关系，go应该不是逐行运行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> Eat() &#123;</span><br><span class="line">   fmt.Println(h.Name + <span class="string">&quot; is eating&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name <span class="type">string</span></span><br><span class="line">   Sex  <span class="type">string</span></span><br><span class="line">   Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">   Hum    Human <span class="comment">// 包含 Human类型的变量 是嵌套类</span></span><br><span class="line">   School <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">   Human  <span class="comment">// 直接声明Human类型，没有定义变量 类继承</span></span><br><span class="line">   School <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;luenci/github.com/day03/3.类成员访问权限/src&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// go语言中，权限都是通过首字母大小写来控制的</span></span><br><span class="line"><span class="comment">// import XX 如果package名称不同，那么只有大写字母开头的才是 Public</span></span><br><span class="line"><span class="comment">// 对于类里面的成员、函数等，只有大写字母开头的才能在其他的包中使用</span></span><br><span class="line"><span class="comment">// 如果在用一个package（文件下）下则无以上限制</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   st1 := src.Student&#123;</span><br><span class="line">      Hum: src.Human&#123;</span><br><span class="line">         Name: <span class="string">&quot;lynn&quot;</span>,</span><br><span class="line">         Sex:  <span class="string">&quot;girl&quot;</span>,</span><br><span class="line">         Age:  <span class="number">20</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      School: <span class="string">&quot;一中&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;st1&quot;</span>, st1)</span><br><span class="line">   fmt.Println(<span class="string">&quot;st1 name&quot;</span>, st1.Hum.Name)</span><br><span class="line"></span><br><span class="line">   t1 := src.Teacher&#123;&#125;</span><br><span class="line">   t1.School = <span class="string">&quot;一中&quot;</span></span><br><span class="line">   t1.Name = <span class="string">&quot;lynn&quot;</span></span><br><span class="line">   t1.Sex = <span class="string">&quot;girl&quot;</span></span><br><span class="line">   t1.Age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;t1&quot;</span>, t1)</span><br><span class="line">   fmt.Println(<span class="string">&quot;t1 name&quot;</span>, t1.Name)</span><br><span class="line">   fmt.Println(<span class="string">&quot;t1 age&quot;</span>, t1.Human.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口">接口</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// go语言中,interface代表接口</span></span><br><span class="line"><span class="comment">// interface 不仅仅是用来处理多态，它可以接收任意的数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// func Println(a ...interface&#123;&#125;) (n int, err error) &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定义三个接口类型</span></span><br><span class="line">   <span class="keyword">var</span> i, j, k <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   i = []<span class="type">string</span>&#123;<span class="string">&quot;lynn&quot;</span>, <span class="string">&quot;luenci&quot;</span>&#125;</span><br><span class="line">   j = <span class="number">98</span></span><br><span class="line">   k = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 快速判断接口的类型</span></span><br><span class="line">   <span class="comment">//jType := reflect.TypeOf(j) 反射</span></span><br><span class="line">   jType, ok := j.(<span class="type">int</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;ok&quot;</span>, ok)</span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;j不是int类型&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;jType&quot;</span>, jType)</span><br><span class="line">   fmt.Println(i, j, k)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 最常用的场景：把interface当成一个函数的参数，（类似于上面的 Println函数） ，使用switch来判断用户输入的不同类型</span></span><br><span class="line">   <span class="comment">// 根据不同类型，做相关的逻辑处理</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建一个具有三个接口类型的切片</span></span><br><span class="line">   array := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">3</span>)</span><br><span class="line">   array[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">   array[<span class="number">1</span>] = <span class="string">&quot;luenci&quot;</span></span><br><span class="line">   array[<span class="number">2</span>] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, value := <span class="keyword">range</span> array &#123;</span><br><span class="line">      <span class="comment">// 获取接口中真正的数据类型</span></span><br><span class="line">      <span class="keyword">switch</span> v := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;当前数据类型为int，内容为:&quot;</span>, v)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;当前数据类型为string，内容为:&quot;</span>, v)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;当前数据类型为bool，内容为:&quot;</span>, v)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;不是合理的数据类型&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多态">多态</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// go语言多态，需要实现定义接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个接口，类型是interface</span></span><br><span class="line"><span class="keyword">type</span> IAttack <span class="keyword">interface</span> &#123;</span><br><span class="line">   <span class="comment">// 如果定义了多个接口函数，那么实现的类必须全部实现这些接口，才可以赋值</span></span><br><span class="line">   Attack() <span class="comment">// 接口函数可以有多个，但是只能有函数原型，不可以有实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 低等级玩家</span></span><br><span class="line"><span class="keyword">type</span> HumanLowLevel <span class="keyword">struct</span> &#123;</span><br><span class="line">   name  <span class="type">string</span></span><br><span class="line">   level <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *HumanLowLevel)</span></span> Attack() &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;我是&quot;</span>, a.name, <span class="string">&quot;等级为&quot;</span>, a.level, <span class="string">&quot;造成伤害1000&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高等级玩家</span></span><br><span class="line"><span class="keyword">type</span> HumanHighLevel <span class="keyword">struct</span> &#123;</span><br><span class="line">   name  <span class="type">string</span></span><br><span class="line">   level <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *HumanHighLevel)</span></span> Attack() &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;我是&quot;</span>, a.name, <span class="string">&quot;等级为&quot;</span>, a.level, <span class="string">&quot;造成伤害50000&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个多态的通用接口，传入不同的对象，调用相同的函数，实现不同的效果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoAttack</span><span class="params">(a IAttack)</span></span> &#123;</span><br><span class="line">   a.Attack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//var player IAttack // 定义一个包含Attack的接口变量</span></span><br><span class="line"></span><br><span class="line">   lowLevel1 := HumanLowLevel&#123;</span><br><span class="line">      name:  <span class="string">&quot;luenci&quot;</span>,</span><br><span class="line">      level: <span class="number">0</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   HighLevel1 := HumanHighLevel&#123;</span><br><span class="line">      name:  <span class="string">&quot;lynn&quot;</span>,</span><br><span class="line">      level: <span class="number">1000</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 两个不同对象调用相同方法</span></span><br><span class="line">   DoAttack(&amp;HighLevel1)</span><br><span class="line">   DoAttack(&amp;lowLevel1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//lowLevel1.Attack()</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对player赋值为lowLevel1，接口需要使用指针类型来赋值</span></span><br><span class="line">   <span class="comment">//player = &amp;lowLevel1</span></span><br><span class="line">   <span class="comment">//player.Attack()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言基础知识和语法</title>
    <url>/2023/02/06/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1>Go语言特点</h1>
<ul>
<li>没有头文件概念，<code>.go</code>后缀</li>
<li>强类型语言，编译型语言</li>
<li>一个go语言的应用程序，在运行的时候是不需要依赖外部库的
<ul>
<li>把执行时需要的库都打包到程序中</li>
<li>go程序比较大</li>
<li>如果import的包没有使用，那么程序不允许编译</li>
</ul>
</li>
<li>go语法不区分平台的，在windos下面编译的一个程序，可以在Linux上运行，需要配置环境变量来控制
<ul>
<li>GOOS：设定运行平台
<ul>
<li>mac：darwin</li>
<li>linux：linux</li>
<li>windos：windos</li>
</ul>
</li>
<li>GOARCH：目标平台的体系架构
<ul>
<li>386</li>
<li>amd64</li>
<li>arm</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Go命令">Go命令</h2>
<ul>
<li>
<p>go build -o 生成文件名.exe 编译文件名.go</p>
</li>
<li>
<p>go run *.go</p>
<ul>
<li>直接运行程序不会编译成exe文件</li>
</ul>
</li>
<li>
<p>安装程序</p>
<ul>
<li>./configure</li>
<li>make</li>
<li>make install —&gt;将编译好的程序安装到指定目录</li>
</ul>
</li>
<li>
<p>go install</p>
<ul>
<li>将编译后的可执行文件安装到 GOBIN 目录下</li>
</ul>
</li>
<li>
<p>go mod</p>
<p><a href="https://www.notion.so/6b079c18f2fa42d9bccd79f84eaa0578">参数</a></p>
<ul>
<li>go mod 资料连接</li>
</ul>
<p><a href="https://juejin.cn/post/6844903798658301960">go mod 使用</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/59687626">开始使用 Go Module</a></p>
</li>
</ul>
<h3 id="依赖包存储位置">依赖包存储位置</h3>
<ul>
<li>使用go get获取的包放在<code>$GOPATH/src/</code>目录下</li>
<li>使用go mod下载的依赖包放在<code>$GOPATH/pkg/mod/</code>目录下，所有项目共享</li>
</ul>
<h2 id="Go目录结构">Go目录结构</h2>
<h3 id="一般的，一个Go项目在GOPATH下，会有如下三个目录：">一般的，一个Go项目在GOPATH下，会有如下三个目录：</h3>
<p>一般，bin和pkg目录可以不创建，go命令会自动创建（如 go install），只需要创建src目录即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">|--bin</span><br><span class="line">|--pkg</span><br><span class="line">|--src</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>bin</code>存放编译后的可执行文件</p>
</li>
<li>
<pre><code>pkg
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  存放编译后的包文件</span><br><span class="line"></span><br><span class="line">  - `pkg`中的文件是Go编译生成的，而不是手动放进去的</span><br><span class="line"></span><br><span class="line">- `src`存放项目源文件</span><br><span class="line"></span><br><span class="line">## Go数据类型</span><br><span class="line"></span><br><span class="line">- go语言不支持隐式类型转换</span><br><span class="line">  - 比如从int 转为 int 64就会发生编译错误</span><br><span class="line"></span><br><span class="line">### 显示类型转换和隐式类型转换</span><br><span class="line"></span><br><span class="line">- 当两种或多种数据类型进行某种操作时，不需要干预，系统会自动进行隐式转换。</span><br><span class="line">- 但你需要把一个 long 类型的数据转成 int 时，又或者让 string 与 int 互转，当数据小数点太多时，这时候就必须使用 显式转型</span><br><span class="line"></span><br><span class="line">## Golang的零值</span><br><span class="line"></span><br><span class="line">- Go语言中的零值是变量没有做初始化时系统默认设置的值。 所有其他数值型的类型（包括complex64/128）零值都是0，可以用常量表达式代表数值0的任何形式表示出来。 但是类型不能混用，变量类型和零值类型必须匹配。</span><br><span class="line">- 布尔类型的零值（初始值）为 false，数值类型的零值为 0，字符串类型的零值为空字符串&quot;&quot;，而指针、切片、映射、通道、函数和接口的零值则是 nil。</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">## Go基础语法</span><br><span class="line"></span><br><span class="line">### 变量</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  // 变量定义: var</span><br><span class="line">  // 常量定义: const</span><br><span class="line"></span><br><span class="line">  // 1.先定义变量，var 变量名 类型 ；再赋值 变量=XX</span><br><span class="line">  var name string</span><br><span class="line">  name = &quot;Luenci&quot;</span><br><span class="line"></span><br><span class="line">  var age int</span><br><span class="line">  age = 22</span><br><span class="line"></span><br><span class="line">  fmt.Println(&quot;name:&quot;, name)</span><br><span class="line"></span><br><span class="line">  // 2.定义时直接赋值</span><br><span class="line">  var sex = &quot;man&quot;</span><br><span class="line"></span><br><span class="line">  fmt.Printf(&quot;sex is %s \\n&quot;, sex)</span><br><span class="line"></span><br><span class="line">  fmt.Printf(&quot;name is %s age is %d \\n&quot;, name, age)</span><br><span class="line"></span><br><span class="line">  // 3.定义时直接赋值，使用时自动推导类型（常用）</span><br><span class="line">  hobby := &quot;篮球&quot;</span><br><span class="line"></span><br><span class="line">  fmt.Println(&quot;my hobby is &quot;, hobby)</span><br><span class="line"></span><br><span class="line">  // 灰色部分表示形参</span><br><span class="line">  test(10, &quot;ll&quot;)</span><br><span class="line"></span><br><span class="line">  // 4. 平行赋值</span><br><span class="line">  i, j := 10, 22</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">  fmt.Println(j)</span><br><span class="line">  i, j = j, i</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">  fmt.Println(j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test(a int, b string) &#123;</span><br><span class="line">  fmt.Println(a)</span><br><span class="line">  fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h3 id="自增-自减-语法">自增/自减 语法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   i := <span class="number">11</span></span><br><span class="line">   <span class="built_in">println</span>(<span class="string">&quot;i 自增前&quot;</span>, i)</span><br><span class="line">   i++</span><br><span class="line">   <span class="built_in">println</span>(<span class="string">&quot;i 自增后&quot;</span>, i)</span><br><span class="line">   i--</span><br><span class="line">   <span class="built_in">println</span>(<span class="string">&quot;i 自减后&quot;</span>, i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针">指针</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// go语言在使用指针时，会使用内部的垃圾回收机制（garbage collector），开发人员不需要手动释放内存</span></span><br><span class="line">  <span class="comment">// go语言可以返回栈上指针,程序在编译的时候就确定了变量的分配位置</span></span><br><span class="line">  <span class="comment">// 在编译的时候，如果发现有必要的话，就将变量分配到堆上</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义指针，方式一</span></span><br><span class="line">  name := <span class="string">&quot;luenci&quot;</span></span><br><span class="line">  namePtr := &amp;name</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;指针地址是&quot;</span>, namePtr)</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;指针内容是&quot;</span>, *namePtr)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义指针关键字 new，方式二</span></span><br><span class="line">  name2Ptr := <span class="built_in">new</span>(<span class="type">string</span>)</span><br><span class="line">  *name2Ptr = <span class="string">&quot;luenci&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;指针地址是&quot;</span>, name2Ptr)</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;指针内容是&quot;</span>, *name2Ptr)</span><br><span class="line"></span><br><span class="line">  res := testPtr()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> res == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;指针为空&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;指针值为&quot;</span>, *res)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数,返回一个string类型的指针,go语言返回值写在参数列表后面</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testPtr</span><span class="params">()</span></span> *<span class="type">string</span> &#123;</span><br><span class="line">  city := <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">  cityPtr := &amp;city</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cityPtr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="string">string</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   name := <span class="string">&quot;Lynn&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 换行，原生字符串输出时候，使用反引号 ``</span></span><br><span class="line">   usage := <span class="string">`./a.out &lt;option&gt;</span></span><br><span class="line"><span class="string">         -h help</span></span><br><span class="line"><span class="string">         -a xxx`</span></span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;name:&quot;</span>, name)</span><br><span class="line">   fmt.Println(<span class="string">&quot;usage:&quot;</span>, usage)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 长度 自由函数 len()</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;name len&quot;</span>, <span class="built_in">len</span>(name))</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 基本循环</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(name); i++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;name[%d] %c \\n&quot;</span>, i, name[i])</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 拼接</span></span><br><span class="line">   i, j := <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;i+j&quot;</span>, i+j)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用const 修饰为常量不能修改</span></span><br><span class="line">   constip= <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;const 常量:&quot;</span>,ip)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定长数组">定长数组</h3>
<blockquote>
<p>在不考虑逃逸分析的情况下，如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上，这些转换后的代码才会继续进入中间代码生成和机器码生成两个阶段，最后生成可以执行的二进制文件</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定义数组 建议使用自动推导</span></span><br><span class="line">   <span class="comment">//var num = [10] int &#123;1,2,3&#125;</span></span><br><span class="line">   <span class="comment">//var num [10] int = [10]int&#123;1,2,3&#125;</span></span><br><span class="line">   num := [<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// make 创建</span></span><br><span class="line">   <span class="comment">//var nums[]int</span></span><br><span class="line">   <span class="comment">//nums = make([]int,10)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 遍历方式一</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(num); i++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;num[%d] %d \\n&quot;</span>, i, num[i])</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 遍历方式二</span></span><br><span class="line">   <span class="comment">// key 是数组下标, value是数组值（副本）</span></span><br><span class="line">   <span class="comment">// 如果想忽略某个值 可使用 _</span></span><br><span class="line">   <span class="comment">// for _, value := range num &#123;...&#125;</span></span><br><span class="line">   <span class="keyword">for</span> key, value := <span class="keyword">range</span> num &#123;</span><br><span class="line">      <span class="comment">// value是一个临时变量，不断的被重新赋值，修改value并不会更改原来num的值</span></span><br><span class="line">      fmt.Printf(<span class="string">&quot;key %d value %d \\n&quot;</span>, key, value)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切片">切片</h3>
<p>扩容是为切片分配新的内存空间并拷贝原切片中元素的过程</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// slice 切片 底层也是数组，可以动态改变长度</span></span><br><span class="line">   names := []<span class="type">string</span>&#123;<span class="string">&quot;lynn&quot;</span>, <span class="string">&quot;luenci&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对于一个切片不仅仅只有长度概念，还有&#x27;容量&#x27;概念</span></span><br><span class="line">   <span class="comment">// 追加元素前 长度是 2 容量是 2</span></span><br><span class="line">   <span class="comment">// 追加元素前 长度是 3 容量是 4</span></span><br><span class="line">   <span class="comment">// 在一定量级的时候,动态追加元素, 容量一般是2倍增长</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;追加元素前 长度是 %d 容量是 %d \\n&quot;</span>, <span class="built_in">len</span>(names), <span class="built_in">cap</span>(names))</span><br><span class="line"></span><br><span class="line">   <span class="comment">// append 追加元素</span></span><br><span class="line">   names = <span class="built_in">append</span>(names, <span class="string">&quot;kk&quot;</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;追加元素前 长度是 %d 容量是 %d \\n&quot;</span>, <span class="built_in">len</span>(names), <span class="built_in">cap</span>(names))</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在一定量级的时候,动态追加元素, 容量一般是2倍增长</span></span><br><span class="line">   num1 := [] <span class="type">int</span> &#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">      num1 = <span class="built_in">append</span>(num1, i)</span><br><span class="line">      fmt.Printf(<span class="string">&quot;长度 %d 容量 %d \\n&quot;</span>, <span class="built_in">len</span>(num1), <span class="built_in">cap</span>(num1))</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用make创建数组</span></span><br><span class="line">   <span class="comment">//mnu2 := make([]int, 10)</span></span><br><span class="line">   <span class="comment">//mnu2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切片2">切片2</h3>
<p>在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：</p>
<ol>
<li>如果期望容量大于当前容量的两倍就会使用期望容量；</li>
<li>如果当前切片的长度小于 1024 就会将容量翻倍；</li>
<li>如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  citys := [<span class="number">6</span>]<span class="type">string</span>&#123;<span class="string">&quot;shanghai&quot;</span>, <span class="string">&quot;beijing&quot;</span>, <span class="string">&quot;wuhan&quot;</span>, <span class="string">&quot;hangzhou&quot;</span>, <span class="string">&quot;nanjing&quot;</span>, <span class="string">&quot;shenzhen&quot;</span>&#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;city 源地址 %p \\n&quot;</span>, &amp;citys[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用索引切片访问 前开后闭 浅拷贝（副本）</span></span><br><span class="line">  loveCity := citys[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">  <span class="comment">//fmt.Println(&quot;my love city&quot;, loveCity)</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;切片地址 %p \\n&quot;</span>, &amp;loveCity[<span class="number">0</span>])</span><br><span class="line">  loveCity[<span class="number">0</span>] = <span class="string">&quot;kk&quot;</span></span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;修改元素&quot;</span>,loveCity)</span><br><span class="line">  fmt.Println(<span class="string">&quot;citys&quot;</span>,citys[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果想拷贝一份独立与源数组的 使用自由函数 copy()</span></span><br><span class="line">  loveCitys := <span class="built_in">copy</span>(loveCity, citys[:])</span><br><span class="line">  fmt.Printf(<span class="string">&quot;copy 地址 %p \\n&quot;</span>, &amp;loveCitys)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>切片的很多功能都是由运行时实现的，无论是初始化切片，还是对切片进行追加或扩容都需要运行时的支持，需要注意的是在遇到大切片扩容或者复制时可能会发生大规模的内存拷贝，一定要减少类似操作避免影响程序的性能。</p>
</blockquote>
<h2 id="map-字典">map 字典</h2>
<p>$$当桶的数量小于2^4时，由于数据较少、使用溢出桶的可能性较低，会省略创建的过程以减少额外开销；$$</p>
<p>$$当桶的数量多于 2^4 时，会额外创建 2^(B−4）个溢出桶；$$</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// key -&gt; value key是经过hash运算，是无顺序的</span></span><br><span class="line">   <span class="comment">// 使用map之前一定要分配空间</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> idName <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line"></span><br><span class="line">   idName = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">   idName[<span class="number">0</span>] = <span class="string">&quot;luenci&quot;</span></span><br><span class="line">   idName[<span class="number">1</span>] = <span class="string">&quot;lynn&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//遍历map</span></span><br><span class="line">   <span class="keyword">for</span> key, value := <span class="keyword">range</span> idName &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;id为&quot;</span>, key, <span class="string">&quot;value为&quot;</span>, value)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 确定key是否在map中</span></span><br><span class="line">   <span class="comment">// 在map中不存在访问越界，访问一个不存在的key，map不会崩溃，会返回零值</span></span><br><span class="line">   <span class="comment">// 零值: bool-》true/false string-》空 int-》0</span></span><br><span class="line">   name := idName[<span class="number">9</span>]</span><br><span class="line">   fmt.Println(<span class="string">&quot;name值为&quot;</span>, name)</span><br><span class="line"></span><br><span class="line">   idScore := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;int零值&quot;</span>, idScore[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">   idFalse := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>, <span class="number">10</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;bool零值&quot;</span>, idFalse[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">// map无法通过获取value来判断这个对应的key是否存在</span></span><br><span class="line">   <span class="comment">// 可用过下面方法来确定是否存在key  ok -》 bool值</span></span><br><span class="line">   value, ok := idName[<span class="number">99</span>]</span><br><span class="line">   fmt.Println(<span class="string">&quot;ok值为&quot;</span>,ok)</span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;idname[99]存在,值为&quot;</span>, value)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;key不存在&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 删除map中的元素</span></span><br><span class="line">   <span class="comment">// 删除不存在的key也不会报错</span></span><br><span class="line">   <span class="built_in">delete</span>(idName,<span class="number">0</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;删除后的map为&quot;</span>,idName)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 并发处理时需要对map进行上锁TODO</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="func-函数">func 函数</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>, c <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">string</span>, <span class="type">bool</span>) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> a + b, c, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(a, b <span class="type">int</span>, c <span class="type">string</span>)</span></span> (res <span class="type">int</span>, str <span class="type">string</span>, bl <span class="type">bool</span>) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 直接使用返回值变量名参与运算</span></span><br><span class="line">   res = a + b</span><br><span class="line">   str = c</span><br><span class="line">   bl = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 当返回值有名称时候，可以直接return</span></span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b, c := test1(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;luenci&quot;</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;test1函数返回值为&quot;</span>, a, b, c)</span><br><span class="line"></span><br><span class="line">   res, str, bl := test2(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;luenci&quot;</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;test2函数返回值为&quot;</span>, res, str, bl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存逃逸">内存逃逸</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   resPtr := test3()</span><br><span class="line">   fmt.Println(<span class="string">&quot;rePtr:&quot;</span>, *resPtr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test3</span><span class="params">()</span></span> *<span class="type">string</span> &#123;</span><br><span class="line">   <span class="comment">// 没有被返回，没有逃逸</span></span><br><span class="line">   name := <span class="string">&quot;lynn&quot;</span></span><br><span class="line">   p0 := &amp;name</span><br><span class="line">   fmt.Println(<span class="string">&quot;p0&quot;</span>, *p0)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 地址返回 内存逃逸</span></span><br><span class="line">   city := <span class="string">&quot;上海&quot;</span></span><br><span class="line">   ptr := &amp;city</span><br><span class="line">   fmt.Println(<span class="string">&quot;地址为:&quot;</span>, ptr)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Switch选择分支">Switch选择分支</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   cmds := os.Args</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;cmds 类型为&quot;</span>, reflect.TypeOf(cmds))</span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> cmds[<span class="number">1</span>] &#123;</span><br><span class="line">   <span class="comment">// case 中默认加了 break 不需要手动break</span></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&quot;luenci&quot;</span>:</span><br><span class="line">      <span class="comment">// 如果想向下穿透（执行下一个条件中的代码）,使用 fallthrough 关键字</span></span><br><span class="line">      fmt.Println(<span class="string">&quot;i am luenci&quot;</span>)</span><br><span class="line">      <span class="comment">//fallthrough</span></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&quot;Lynn&quot;</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;i am Lynn&quot;</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&quot;kk&quot;</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;i am kk&quot;</span>)</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;默认值&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> key, value := <span class="keyword">range</span> cmds &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;key&quot;</span>, key, <span class="string">&quot;value&quot;</span>, value)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="标签LABEL">标签LABEL</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 标签 LABLE1</span></span><br><span class="line">   <span class="comment">// goto LABEL1 &gt;&gt; 下次进入循环时,i 不会保存之前状态，i=0,重新向下运行</span></span><br><span class="line">   <span class="comment">// break LABEL1 &gt;&gt; 直接跳出指定位置的循环</span></span><br><span class="line">   <span class="comment">// continue LABEL1 &gt;&gt; 跳到指定位置，会记录之前的状态，向下执行</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 标签名称可以自定义命名</span></span><br><span class="line">LABEL1:</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">         <span class="keyword">if</span> j == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> LABEL1</span><br><span class="line">         &#125;</span><br><span class="line">         fmt.Println(<span class="string">&quot;i&quot;</span>, i, <span class="string">&quot;,j&quot;</span>, j)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举iota">枚举iota</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// iota 是常量组计数器</span></span><br><span class="line"><span class="comment">// iota从0开始，每换行递增1,从第一次出现iota开始计算</span></span><br><span class="line"><span class="comment">// 常量组如果不赋值，默认上一行表达式相同</span></span><br><span class="line"><span class="comment">// iota是以行为单位递增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个常量组的iota是独立的，都是从零开始递增</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span></span><br><span class="line">(</span><br><span class="line">MONDAY= <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">TUESDAY</span><br><span class="line">   WEDNESDAY</span><br><span class="line">   THURSDAY</span><br><span class="line">   FRIDAY</span><br><span class="line">   SATURDAY</span><br><span class="line">   M,N= <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">// const 属于预编译，所以不需要 := 自动推导</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// go语言中没有枚举类型，但是可以使用 const + iota（常量累加器）来进行模拟</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 变量组统一命名变量</span></span><br><span class="line">   <span class="keyword">var</span></span><br><span class="line">   (</span><br><span class="line">      number <span class="type">int</span></span><br><span class="line">      name   <span class="type">string</span></span><br><span class="line">      flag   <span class="type">bool</span></span><br><span class="line">   )</span><br><span class="line">   fmt.Println(number, name, flag)</span><br><span class="line"></span><br><span class="line">   fmt.Println(MONDAY)</span><br><span class="line">   fmt.Println(TUESDAY)</span><br><span class="line">   fmt.Println(WEDNESDAY)</span><br><span class="line">   fmt.Println(THURSDAY)</span><br><span class="line">   fmt.Println(FRIDAY)</span><br><span class="line">   fmt.Println(SATURDAY)</span><br><span class="line">   fmt.Println(M,N)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体">结构体</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体声明 type + 别名 + struct</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">   name  <span class="type">string</span></span><br><span class="line">   age   <span class="type">int</span></span><br><span class="line">   sex   <span class="type">string</span></span><br><span class="line">   score <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   lynn := Student&#123;</span><br><span class="line">      name:  <span class="string">&quot;lynn&quot;</span>,</span><br><span class="line">      age:   <span class="number">20</span>,</span><br><span class="line">      sex:   <span class="string">&quot;girl&quot;</span>,</span><br><span class="line">      score: <span class="number">100</span>, <span class="comment">// 最后换一个变量后必须加`,`, 或者以`&#125;`结尾</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;lynn&quot;</span>, lynn)</span><br><span class="line"></span><br><span class="line">   s1 := &amp;lynn</span><br><span class="line">   fmt.Println(<span class="string">&quot;s1&quot;</span>, s1.name, s1.age, s1.sex, s1.score)</span><br><span class="line">   fmt.Println(<span class="string">&quot;s1&quot;</span>, (*s1).name, (*s1).age, (*s1).sex, (*s1).score)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果只对结构体部分变量赋值，name应该指定变量名称</span></span><br><span class="line">   luenci := Student&#123;</span><br><span class="line">      name: <span class="string">&quot;luenci&quot;</span>,</span><br><span class="line">      age:  <span class="number">21</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;leunci&quot;</span>, luenci)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="defer函数-匿名函数">defer函数 &amp; 匿名函数</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   readFile(<span class="string">&quot;4.结构体.go&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(filename <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="comment">// os.Open 打开文件，会返回一个文件指针和err信息，如果无错误 err 是 nil</span></span><br><span class="line">   <span class="comment">// defer 当你的堆栈退出的时候会调用 （必须函数调用结束）</span></span><br><span class="line">   <span class="comment">// func ()&#123;...&#125;() 不声明函数名表示匿名函数 后面加括号() 调用</span></span><br><span class="line"></span><br><span class="line">   fp, err := os.Open(filename)</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;文件关闭！&quot;</span>)</span><br><span class="line">      _ = fp.Close()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;00000&quot;</span>)</span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;00001&quot;</span>)</span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;00002&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;文件读取错误,error:&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">   n, _ := fp.Read(buf)</span><br><span class="line">   fmt.Println(<span class="type">string</span>(buf))</span><br><span class="line">   fmt.Println(<span class="string">&quot;读取文件长度为&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="init函数">init函数</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sub</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在go语言同一层级目录，不允许出现多个 package 名称</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;sub库下的init函数&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sub</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   test5()</span><br><span class="line">   <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// sub 是文件夹名，也是package名</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   _ <span class="string">&quot;luenci/github.com/day02/5.init函数/sub&quot;</span> <span class="comment">// 只会调用sub中的init函数</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// init 函数没有参数和返回值,使用如下</span></span><br><span class="line"><span class="comment">// 同一个包中包含多个init函数时候,调用顺序是不确定的（同一个package下的多个文件都可以有init）</span></span><br><span class="line"><span class="comment">// init 函数是不允许调用(显示调用)的</span></span><br><span class="line"><span class="comment">// 如果只想调用一个package中的 init函数,只需在导包前加上 _</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//res := sub.Sub(10, 5)</span></span><br><span class="line">   <span class="comment">//fmt.Println(&quot;sub res&quot;, res)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python元类学习</title>
    <url>/2023/02/06/python%E5%85%83%E7%B1%BB/</url>
    <content><![CDATA[<blockquote>
<p>你想通过改变实例创建方式来实现单例、缓存或其他类似的特性。</p>
</blockquote>
<h1>类的创建过程</h1>
<blockquote>
<p><a href="https://docs.python.org/3/reference/datamodel.html#metaclasses">https://docs.python.org/3/reference/datamodel.html#metaclasses</a></p>
</blockquote>
<p><a href="https://gitee.com/luenci/RepoImg/raw/master/img/20210424180140.svg"><img src="https://gitee.com/luenci/RepoImg/raw/master/img/20210424180140.svg" alt="class-creation"></a></p>
<ol>
<li>当 Python 见到 <code>class</code> 关键字时，会首先解析 <code>class ...</code> 中的内容。例如解析基类信息，最重要的是找到对应的元类信息（默认是 <code>type</code>)。</li>
<li>元类找到后，Python 需要准备 namespace （也可以认为是上节中 <code>type</code> 的 <code>dict</code> 参数）。如果元类实现了 <code>__prepare__</code> 函数，则会调用它来得到默认的 namespace 。</li>
<li>之后是调用 <code>exec</code> 来执行类的 body，包括属性和方法的定义，最后这些定义会被保存进 namespace。</li>
<li>上述步骤结束后，就得到了创建类需要的所有信息，这时 Python 会调用元类的构造函数来真正创建类。</li>
</ol>
<p>如果你想在类的创建过程中做一些定制(customization)的话，创建过程中任何用到了元类的地方，我们都能通过覆盖元类的默认方法来实现定制。这也是元类“无所不能”的所在，它深深地嵌入了类的创建过程。</p>
<h1>type动态创建类</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 常规方法创建类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&quot;luenci&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">666</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于type创建类</span></span><br><span class="line"><span class="comment"># - 类名</span></span><br><span class="line"><span class="comment"># - 继承的类</span></span><br><span class="line"><span class="comment"># - 类属性</span></span><br><span class="line"><span class="comment"># - 类方法</span></span><br><span class="line"></span><br><span class="line">foo1 = <span class="built_in">type</span>(<span class="string">&quot;Foo&quot;</span>, (<span class="built_in">object</span>,), &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;luenci&quot;</span>, <span class="string">&quot;func&quot;</span>: <span class="keyword">lambda</span> self: <span class="string">&quot;hi&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1>元类声明</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MateFoo</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,*args,**kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">        <span class="comment"># super().__init__(*args, **kwargs)</span></span><br><span class="line">        <span class="built_in">type</span>.__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 创建类</span></span><br><span class="line">    <span class="comment"># new_cls = super().__new__(cls, *args, **kwargs)</span></span><br><span class="line">        new_cls = <span class="built_in">type</span>.__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;new &quot;</span>, new_cls)</span><br><span class="line">        <span class="keyword">return</span> new_cls</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 1.调用自己类的 __new__ 方法去创建对象</span></span><br><span class="line">        empty_obj = self.__new__(self)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2.调用自己类的 __init__ 方法去初始化</span></span><br><span class="line">        self.__init__(empty_obj, *args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call&quot;</span>, empty_obj)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> empty_obj</span><br><span class="line"></span><br><span class="line"><span class="comment"># Foo1 类就是MateFoo的对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo1</span>(<span class="built_in">object</span>, metaclass=MateFoo):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Foo1(<span class="string">&quot;hi&quot;</span>))</span><br></pre></td></tr></table></figure>
<h1>元类实现单例模式</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    单例元类.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line">        <span class="comment"># 可以设置子类继承的字段</span></span><br><span class="line">        self.author = <span class="string">&quot;luenci&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 对象实例化的时候调用</span></span><br><span class="line">        <span class="comment"># 判断是否已经实例化对象</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._instance:</span><br><span class="line">            self._instance = self.__new__(self)</span><br><span class="line">        self.__init__(self._instance, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBclient</span>(<span class="built_in">object</span>, metaclass=Singleton):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;数据库单例连接.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, url, port, user, pwd</span>):</span><br><span class="line">        self.url = url</span><br><span class="line">        self.port = port</span><br><span class="line">        self.url = user</span><br><span class="line">        self.pwd = pwd</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>底层元类</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1>设计模式</h1>
<ul>
<li>
<p>设计模式设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。大部分设计模式要解决的都是代码的可扩展性问题。设计模式相对于设计原则来说，没有那么抽象，而且大部分都不难理解，代码实现也并不复杂。这一块的学习难点是了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用。</p>
</li>
<li>
<p>经典的设计模式有 23 种。随着编程语言的演进，一些设计模式（比如 Singleton）也随之过时，甚至成了反模式，一些则被内置在编程语言中（比如 Iterator），另外还有一些新的模式诞生（比如 Monostate）。</p>
</li>
<li>
<p>创建型常用的有：</p>
<ul>
<li>单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。</li>
<li>不常用的有：原型模式。</li>
</ul>
</li>
<li>
<p>结构型常用的有：</p>
<ul>
<li>代理模式、桥接模式、装饰者模式、适配器模式。</li>
<li>不常用的有：门面模式、组合模式、享元模式。</li>
</ul>
</li>
<li>
<p>行为型常用的有：</p>
<ul>
<li>观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。</li>
<li>不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</li>
</ul>
</li>
</ul>
<h1>面向对象</h1>
<ul>
<li>面向对象编程因为其具有丰富的特性（<code>封装</code>、<code>抽象</code>、<code>继承</code>、<code>多态</code>），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。</li>
</ul>
<h2 id="面向对象编程和面向对象编程语言">面向对象编程和面向对象编程语言</h2>
<ul>
<li>面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</li>
<li>面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</li>
</ul>
<blockquote>
<p>面向对象编程从字面上，按照最简单、最原始的方式来理解，就是将对象或类作为代码组织的基本单元，</p>
</blockquote>
<h2 id="面向对象分析和面向对象设计">面向对象分析和面向对象设计</h2>
<h3 id="统一建模语言-UML">统一建模语言(UML)</h3>
<p>UML 是一种非常复杂的东西。它不仅仅包含我们常提到类图，还有用例图、顺序图、活动图、状态图、组件图等。在我看来，即便仅仅使用类图，学习成本也是很高的。就单说类之间的关系，UML 就定义了很多种，比如泛化、实现、关联、聚合、组合、依赖等。</p>
<h1>设计原则</h1>
<ul>
<li>SOLID 原则 -SRP 单一职责原则</li>
<li>SOLID 原则 -OCP 开闭原则</li>
<li>SOLID 原则 -LSP 里式替换原则</li>
<li>SOLID 原则 -ISP 接口隔离原则</li>
<li>SOLID 原则 -DIP 依赖倒置原则</li>
<li>DRY 原则、KISS 原则、YAGNI 原则、LOD 法则</li>
</ul>
<h1>编程规范</h1>
<ul>
<li>编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节。即便你可能对设计原则不熟悉、对设计模式不了解，但你最起码要掌握基本的编码规范，比如，如何给变量、类、函数命名，如何写代码注释，函数不宜过长、参数不能过多等等。</li>
</ul>
<h1>代码重构</h1>
<ul>
<li>重构的工具就是我们前面罗列的那些面向对象设计思想、设计原则、设计模式、编码规范。实际上，设计思想、设计原则、设计模式一个最重要的应用场景就是在重构的时候。我们前面讲过，虽然使用设计模式可以提高代码的可扩展性，但过度不恰当地使用，也会增加代码的复杂度，影响代码的可读性。在开发初期，除非特别必须，我们一定不要过度设计，应用复杂的设计模式。而是当代码出现问题的时候，我们再针对问题，应用原则和模式进行重构。这样就能有效避免前期的过度设计。</li>
</ul>
<h2 id="重构把握的点">重构把握的点</h2>
<ul>
<li>重构的目的（why）、对象（what）、时机（when）、方法（how）；</li>
<li>保证重构不出错的技术手段：单元测试和代码的可测试性；</li>
<li>两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）</li>
</ul>
<h1>五者之间的联系</h1>
<ul>
<li>面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。</li>
<li>设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。</li>
<li>设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。</li>
<li>编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。</li>
<li>重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。</li>
</ul>
<h1>小结</h1>
<p><img src="https://gitee.com/luenci/mac-img/raw/master/image-20200831140642836-20200928103742372.png" alt="image-20200831140642836"></p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型模式</title>
    <url>/2023/02/06/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1>预备知识</h1>
<blockquote>
<p>@abstractmethod：抽象方法，含abstractmethod方法的类不能实例化，继承了含abstractmethod方法的子类必须复写所有abstractmethod装饰的方法，未被装饰的可以不重写</p>
<p>@ property：方法伪装属性，方法返回值及属性值，被装饰方法不能有参数，必须实例化后调用，类不能调用</p>
<p>@ classmethod：类方法，可以通过实例对象和类对象调用，被该函数修饰的方法第一个参数代表类本身常用cls，被修饰函数内可调用类属性，不能调用实例属性</p>
<p>@staticmethod：静态方法，可以通过实例对象和类对象调用，被装饰函数可无参数，被装饰函数内部通过类名.属性引用类属性或类方法，不能引用实例属性</p>
</blockquote>
<h2 id="创建型模式">创建型模式</h2>
<p>创建型模式的工作原理是基于对象的创建机制的。由于这些模式隔离了对象的创建细节。所以使得代码能够与要创建的对象的类型互相独立。</p>
<ul>
<li>它们的运行机制基于对象的创建方式</li>
<li>它们将对象创建的细节隔离开来</li>
<li>代码与所创建的对象的类型无关</li>
</ul>
<h3 id="单例模式">单例模式</h3>
<p>单例模式提供了这样一种机制，即确保类有且只有一个特定类型的对象，并提供全局访问点</p>
<h4 id="UML图">UML图</h4>
<p><a href="https://gitee.com/luenci/RepoImg/raw/master/img/20210216171624.png"><img src="https://gitee.com/luenci/RepoImg/raw/master/img/20210216171624.png" alt="img"></a></p>
<h4 id="代码实现">代码实现</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">class</span> <span class="title class_">Singleton</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot; 单例模式 &quot;&quot;&quot;</span></span><br><span class="line">   ...:     <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls</span>):</span><br><span class="line">   ...:         <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;instance&quot;</span>):</span><br><span class="line">   ...:             cls.instance = <span class="built_in">super</span>(Singleton, cls).__new__(cls)</span><br><span class="line">   ...:         <span class="keyword">return</span> cls.instance</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: s = Singleton()</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: s</span><br><span class="line">Out[<span class="number">3</span>]: &lt;__main__.Singleton at <span class="number">0x7fc32793ed90</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: s2 = Singleton()</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: s2</span><br><span class="line">Out[<span class="number">5</span>]: &lt;__main__.Singleton at <span class="number">0x7fc32793ed90</span>&gt;</span><br><span class="line">In [<span class="number">21</span>]: <span class="keyword">class</span> <span class="title class_">Singletons</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot; 懒汉式加载 &quot;&quot;&quot;</span></span><br><span class="line">    ...:     __instance = <span class="literal">None</span></span><br><span class="line">    ...:     <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    ...:         <span class="keyword">if</span> <span class="keyword">not</span> Singletons.__instance:</span><br><span class="line">    ...:             <span class="built_in">print</span>(<span class="string">&quot;__init__ method called..&quot;</span>)</span><br><span class="line">    ...:         <span class="keyword">else</span>:</span><br><span class="line">    ...:             <span class="built_in">print</span>(<span class="string">&quot;Instance alreadly created:&quot;</span>,self.getInstance())</span><br><span class="line">    ...:     @<span class="built_in">classmethod</span></span><br><span class="line">    ...:     <span class="keyword">def</span> <span class="title function_">getInstance</span>(<span class="params">cls</span>):</span><br><span class="line">    ...:         <span class="keyword">if</span> <span class="keyword">not</span> cls.__instance:</span><br><span class="line">    ...:             cls.__instance = Singletons()</span><br><span class="line">    ...:         <span class="keyword">return</span> cls.__instance</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: a = Singletons()</span><br><span class="line">__init__ method called..</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: a1 = Singletons()</span><br><span class="line">__init__ method called..</span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: a2 = Singletons()</span><br><span class="line">__init__ method called..</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: a.getInstance()</span><br><span class="line">__init__ method called..</span><br><span class="line">Out[<span class="number">25</span>]: &lt;__main__.Singletons at <span class="number">0x7fc327b020d0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: a</span><br><span class="line">Out[<span class="number">26</span>]: &lt;__main__.Singletons at <span class="number">0x7fc327e48ca0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: a1</span><br><span class="line">Out[<span class="number">27</span>]: &lt;__main__.Singletons at <span class="number">0x7fc32763a250</span>&gt;</span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">class</span> <span class="title class_">MyMetaClass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 元类实现单例模式 &quot;&quot;&quot;</span></span><br><span class="line">   ...:     _instances = &#123;&#125;</span><br><span class="line">   ...:     <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls,*args,**kwargs</span>):</span><br><span class="line">   ...:         <span class="built_in">print</span>(<span class="string">&quot;**** Here`s my MetaClass ****&quot;</span>)</span><br><span class="line">   ...:         <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">   ...:             cls._instances[cls] = <span class="built_in">super</span>(MyMetaClass,cls).__call__(*args,**kwargs)</span><br><span class="line">   ...:         <span class="keyword">return</span> cls._instances[cls]</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="keyword">class</span> <span class="title class_">test</span>(metaclass=MyMetaClass):</span><br><span class="line">   ...:     <span class="keyword">pass</span></span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: a = test()</span><br><span class="line">**** Here`s my MetaClass ****</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: a2 = test()</span><br><span class="line">**** Here`s my MetaClass ****</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: <span class="built_in">id</span>(a)</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">139837183079520</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: <span class="built_in">id</span>(a2)</span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">139837183079520</span></span><br></pre></td></tr></table></figure>
<p>虽然单例模式在许多情况下效果很好，但是由于单例模式具有全局访问权限，可能会存在一些问题</p>
<ul>
<li>全局变量可能在某处已经被更改，但是开发人员仍然认为它们没有发生变化，而改变量还在应用程序的其他位置被使用</li>
<li>可能会对同一个对象创建多个应用（此单例类被多次实例化，实际只实例化一次就可以）</li>
<li>所有依赖于全局变量的类都会由于一个类的改变而紧密耦合为全局数据，从而可能在无意中影响另一个类</li>
</ul>
<span id="more"></span>
<h3 id="工厂模式">工厂模式</h3>
<p>工厂可以帮助开发人员创建不同类型的对象，而不是直接将对象实例化</p>
<p>优点如下：</p>
<ul>
<li>松耦合：即对象的创建可以独立于类的实现</li>
<li>客户端无需了解创建对象的类，但是照样可以使用它来创建对象，它只需要知道需要传递的接口，方法和参数，就能够创建所需类型的对象了。这简化了客户端的实现。</li>
<li>可以轻松地在工厂中添加其他类来创建其他类型的对象，而这里无需更改客户端代码。最简单的情况下，客户端只需要传递另一个参数就可以。</li>
<li>工厂还可以重用现有对象。但是，如果客户端直接创建对象的话，总是创建一条新的对象</li>
</ul>
<h4 id="简单工厂模式">简单工厂模式</h4>
<h5 id="UML图-2">UML图</h5>
<p><a href="https://gitee.com/luenci/RepoImg/raw/master/img/20210216171700.png"><img src="https://gitee.com/luenci/RepoImg/raw/master/img/20210216171700.png" alt="image-20210216171700815"></a></p>
<h5 id="代码实现-2">代码实现</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> adc</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta</span><br><span class="line">In [<span class="number">10</span>]: <span class="keyword">class</span> <span class="title class_">Animal</span>(metaclass=ABCMeta):</span><br><span class="line">    ...:     @abc.abstractmethod</span><br><span class="line">            <span class="comment"># 抽象方法，子类必须实现（重写）此方法，不然子类实例化的时候会报错</span></span><br><span class="line">    ...:     <span class="keyword">def</span> <span class="title function_">do_say</span>(<span class="params">self</span>):</span><br><span class="line">    ...:         <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: <span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    ...:     <span class="keyword">def</span> <span class="title function_">do_say</span>():</span><br><span class="line">    ...:         <span class="built_in">print</span>(<span class="string">&quot;喵喵喵&quot;</span>)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: <span class="keyword">class</span> <span class="title class_">ForrestFactory</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    ...:     <span class="keyword">def</span> <span class="title function_">make_sound</span>(<span class="params">self,object_type</span>):</span><br><span class="line">    ...:         <span class="keyword">return</span> <span class="built_in">eval</span>(object_type)().do_say()</span><br><span class="line">    ...:</span><br></pre></td></tr></table></figure>
<h4 id="工厂方法模式">工厂方法模式</h4>
<ul>
<li>我们定义一个接口来创建对象，但是工厂本身并不负责创建对象，而是将这一人物交由子类来完成，即子类决定了要实例化那些类</li>
<li>Factory方法的创建是通过集成而不是通过实例化来完成的</li>
<li>工厂方法使设计更加具有可定制性。它可以返回相同的实例或子类，而不是某种类型的对象</li>
</ul>
<h5 id="UML图-3">UML图</h5>
<p><a href="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/860f9022-e7dd-47de-84ec-3026f3377222/Untitled.png"><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/860f9022-e7dd-47de-84ec-3026f3377222/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/860f9022-e7dd-47de-84ec-3026f3377222/Untitled.png"></a></p>
<h5 id="代码示例">代码示例</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta</span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Section</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">describe</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonalSection</span>(<span class="title class_ inherited__">Section</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">describe</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Personal Section&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlbumSection</span>(<span class="title class_ inherited__">Section</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">describe</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Album Section&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PatentSection</span>(<span class="title class_ inherited__">Section</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">describe</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Patent Section&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PublicationSection</span>(<span class="title class_ inherited__">Section</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">describe</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Publication Section&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Profile</span>(metaclass=ABCMeta):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.sections = []</span><br><span class="line">        self.createProfile()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createProfile</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getSection</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.sections</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addSection</span>(<span class="params">self, section</span>):</span><br><span class="line">        self.sections.append(section)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Linkedin</span>(<span class="title class_ inherited__">Profile</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createProfile</span>(<span class="params">self</span>):</span><br><span class="line">        self.addSection(PersonalSection)</span><br><span class="line">        self.addSection(PatentSection)</span><br><span class="line">        self.addSection(PublicationSection)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FaceBook</span>(<span class="title class_ inherited__">Profile</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createProfile</span>(<span class="params">self</span>):</span><br><span class="line">        self.addSection(PersonalSection)</span><br><span class="line">        self.addSection(AlbumSection)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    profie_type = <span class="built_in">input</span>(<span class="string">&quot;Which Profile you choice ?&quot;</span>)</span><br><span class="line">    profie = <span class="built_in">eval</span>(profie_type.lower().capitalize())()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Create Profile&quot;</span>, <span class="built_in">type</span>(profie).__name__)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Profile has Sections&quot;</span>, profie.getSection())</span><br><span class="line"></span><br><span class="line">out：</span><br><span class="line">Which Profile you choice ?Create Profile Linkedin</span><br><span class="line">Profile has Sections [&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.PersonalSection&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.PatentSection&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.PublicationSection&#x27;</span>&gt;]</span><br></pre></td></tr></table></figure>
<h5 id="工厂方法的优点">工厂方法的优点</h5>
<ul>
<li>具有更大的灵活性，使代码更加通用，因为它不仅仅是单独的实例化某个类。这样实现哪些类取决于接口（Product），而不是 ConcreteProduct类</li>
<li>它们之间是松耦合的，因为创建对象的代码与使用它的代码是分开的。客户端完全不需要关心要传递哪些参数以及需要实例化哪些类。由于添加新类更加容易，所以降低了维护成本。</li>
</ul>
<h4 id="抽象工厂模式">抽象工厂模式</h4>
<p>抽象工厂模式的主要目的是提供一个接口来创建一系列相关对象，而无需指定具体类</p>
<h5 id="UML图-4">UML图</h5>
<p><a href="https://gitee.com/luenci/RepoImg/raw/master/img/20210216171806.png"><img src="https://gitee.com/luenci/RepoImg/raw/master/img/20210216171806.png" alt="image-20210216171806106"></a></p>
<h5 id="代码实现-3">代码实现</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PizzaFactory</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createVegPizza</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createNonVegPizza</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VegPizza</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prepare</span>(<span class="params">self, VegPizza</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonVegPizza</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">server</span>(<span class="params">self, VegPizza</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeluxVeggiePizza</span>(<span class="title class_ inherited__">VegPizza</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prepare</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;perpare <span class="subst">&#123;<span class="built_in">type</span>(self).__name__&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChickenPizza</span>(<span class="title class_ inherited__">NonVegPizza</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">server</span>(<span class="params">self, VegPizza</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">type</span>(self).__name__&#125;</span> is served with Chicken on <span class="subst">&#123;<span class="built_in">type</span>(VegPizza).__name__&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MexicanVegPizza</span>(<span class="title class_ inherited__">VegPizza</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prepare</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;perpare <span class="subst">&#123;<span class="built_in">type</span>(self).__name__&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HamPizza</span>(<span class="title class_ inherited__">NonVegPizza</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">server</span>(<span class="params">self, VegPizza</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">type</span>(self).__name__&#125;</span> is served with Chicken on <span class="subst">&#123;<span class="built_in">type</span>(VegPizza).__name__&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IndianPizzaFactory</span>(<span class="title class_ inherited__">PizzaFactory</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createVegPizza</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> DeluxVeggiePizza()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createNonVegPizza</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> ChickenPizza()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USPizzaFactory</span>(<span class="title class_ inherited__">PizzaFactory</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createVegPizza</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> MexicanVegPizza()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createNonVegPizza</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> HamPizza()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PizzaStore</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">makePizzas</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> factory <span class="keyword">in</span> [IndianPizzaFactory(), USPizzaFactory()]:</span><br><span class="line">            self.factory = factory</span><br><span class="line">            self.NonVegPizza = self.factory.createNonVegPizza()</span><br><span class="line">            self.VegPizza = self.factory.createVegPizza()</span><br><span class="line">            self.VegPizza.prepare()</span><br><span class="line">            self.NonVegPizza.server(self.VegPizza)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pizza = PizzaStore()</span><br><span class="line">    pizza.makePizzas()</span><br><span class="line"></span><br><span class="line">out：</span><br><span class="line">perpare DeluxVeggiePizza</span><br><span class="line">ChickenPizza <span class="keyword">is</span> served <span class="keyword">with</span> Chicken on DeluxVeggiePizza</span><br><span class="line">perpare MexicanVegPizza</span><br><span class="line">HamPizza <span class="keyword">is</span> served <span class="keyword">with</span> Chicken on MexicanVegPizza</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>结构型模式</title>
    <url>/2023/02/06/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1>结构型模式</h1>
<p>结构型模式用于设计对象和类的结构，从而使它们之间可以互相协作以获取更大的结构。</p>
<ul>
<li>结构型模式描述如何将对象和类组合成更大的结构</li>
<li>结构型模式是一种能够简化设计工作的模式，因为它能够找出更简单的方法来认识或表示实体之间的关系。在面向对象世界中，实体指的是对象或类</li>
<li>类模式可以通过继承来描述对象，从而提供更有用的程序接口，而对象模式则描述了如何将对象联系起来从而组合成更大的对象。结构型模式是类和对象模式的综合体</li>
</ul>
<h2 id="门面设计模式">门面设计模式</h2>
<ul>
<li>它为子系统的一组接口提供一个统一的接口，并定义一个高级接口来帮助客户端通过更加简单的方式使用子系统</li>
<li>门面模式解决的问题是，如何用的单个接口对象来表示复杂的子系统。实际上它并不是封装子系统，而是对底层子系统进行组合</li>
<li>它促进了实现与多个客户端的解耦</li>
</ul>
<h3 id="UML图">UML图</h3>
<p><a href="https://gitee.com/luenci/RepoImg/raw/master/img/20210225222333.png"><img src="https://gitee.com/luenci/RepoImg/raw/master/img/20210225222333.png" alt="image-20210225222333048"></a></p>
<h3 id="代码实现">代码实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventManager</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Event Manager:: Let me talk to the folks\\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">arrange</span>(<span class="params">self</span>):</span><br><span class="line">        self.hotelier = Hotelier()</span><br><span class="line">        self.hotelier.bookHotel()</span><br><span class="line"></span><br><span class="line">        self.florist = Florist()</span><br><span class="line">        self.florist.setFlowerRequirements()</span><br><span class="line"></span><br><span class="line">        self.caterer = Caterer()</span><br><span class="line">        self.caterer.setCuisine()</span><br><span class="line"></span><br><span class="line">        self.musiccian = Musician()</span><br><span class="line">        self.musiccian.setMusicType()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hotelier</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Arranging the hotel for Marriage ?&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__isAvailable</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Is the Hotel free for the event on given day?&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bookHotel</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.__isAvailable():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Register the Booking \\n\\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Florist</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Flower Decorations for the Event ? --&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setFlowerRequirements</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Carnations, Rose and Lilies would be used for Decorations\\n\\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caterer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Food Arrangements for the Event --&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setCuisine</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Chinese &amp; Continental Cuisine to be served \\n\\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Musician</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Musical Arrangements for the Marriage --&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setMusicType</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">You</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;you::whoa Marriage Arrangements !&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">askEventManager</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;you:: Let is Contact the Event Manager\\n\\n&quot;</span>)</span><br><span class="line">        em = EventManager()</span><br><span class="line">        em.arrange()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;All preparations done!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    you = You()</span><br><span class="line">    you.askEventManager()</span><br><span class="line"></span><br><span class="line">out：</span><br><span class="line">you::whoa Marriage Arrangements !</span><br><span class="line">you:: Let <span class="keyword">is</span> Contact the Event Manager</span><br><span class="line"></span><br><span class="line">Event Manager:: Let me talk to the folks</span><br><span class="line"></span><br><span class="line">Arranging the hotel <span class="keyword">for</span> Marriage ?</span><br><span class="line">Is the Hotel free <span class="keyword">for</span> the event on given day?</span><br><span class="line">Register the Booking </span><br><span class="line"></span><br><span class="line">Flower Decorations <span class="keyword">for</span> the Event ? --</span><br><span class="line">Carnations, Rose <span class="keyword">and</span> Lilies would be used <span class="keyword">for</span> Decorations</span><br><span class="line"></span><br><span class="line">Food Arrangements <span class="keyword">for</span> the Event --</span><br><span class="line">Chinese &amp; Continental Cuisine to be served </span><br><span class="line"></span><br><span class="line">Musical Arrangements <span class="keyword">for</span> the Marriage --</span><br><span class="line"></span><br><span class="line">All preparations done!</span><br></pre></td></tr></table></figure>
<h3 id="小结">小结</h3>
<ul>
<li><code>EventManager</code>类是简化接口的门面</li>
<li><code>EventManager </code>通过组合创建子系统对象，如Hotelier，Florist等。</li>
</ul>
<span id="more"></span>
<h3 id="补充：（最少知识原则）">补充：（最少知识原则）</h3>
<p>最少知识原则指导我们减少对象之间的交互，就像跟你亲近的只有某几个朋友那样。</p>
<ul>
<li>在设计系统时，对于创建的每个对象，都应该考察与之交互的类的数量，以及交互的方式</li>
<li>遵循这个原则，就能够避免创建许多彼此紧密耦合的类的情况</li>
<li>如果类之间存在大量的依赖关系，那么系统就会变得难以维护。如果对系统中的任何一部分进行修改，都可能导致系统的其他部分被无意改变，这意味着系统会退化，是应该坚决避免的</li>
</ul>
<h2 id="代理模式—控制对象的访问">代理模式—控制对象的访问</h2>
<p>代理通常就是一个介于寻求方和提供方之间的中介系统</p>
<h3 id="代理模式优势">代理模式优势</h3>
<p>在设计模式中，代理是充当实际对象接口的类</p>
<ul>
<li>它能够以更简单的方式表示一个复杂的接口</li>
<li>它提高了现有对象的安全性。</li>
<li>它为不同服务器上的远程对象提供了本地接口</li>
<li>它为消耗大量内存的对象提供了一个轻量级的句柄</li>
</ul>
<h3 id="UML图-2">UML图</h3>
<p><a href="https://gitee.com/luenci/RepoImg/raw/master/img/20210225222800.png"><img src="https://gitee.com/luenci/RepoImg/raw/master/img/20210225222800.png" alt="image-20210225222800147"></a></p>
<ul>
<li>代理：它是一个控制对RealSubject类访问的类。它处理客户端的请求，负责创建或删除RealSubject</li>
<li>主题/真实主题：主题是定义真实主题(RealSubject）和代理（Proxy）相类似的接口。RealSubject是Subject接口的实际实现。它提供了真正的功能，然后由客户端使用。</li>
<li>客户端：它访问要完成工作的Proxy类。Proxy类在内部控制对RealSubject的访问，并引导客户端（Client）所请求的工作</li>
</ul>
<h3 id="代码实现-2">代码实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Actor</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.isBusy = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">occupied</span>(<span class="params">self</span>):</span><br><span class="line">        self.isBusy = <span class="literal">True</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">type</span>(self).__name__&#125;</span> is occupied with current movie&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">available</span>(<span class="params">self</span>):</span><br><span class="line">        self.isBusy = <span class="literal">False</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">type</span>(self).__name__&#125;</span> is free for the movie&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getStatus</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.isBusy</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Agent</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.principal = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self</span>):</span><br><span class="line">        self.actor = Actor()</span><br><span class="line">        <span class="keyword">if</span> self.actor.getStatus():</span><br><span class="line">            self.actor.occupied()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.actor.available()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    r = Agent()</span><br><span class="line">    r.work()</span><br></pre></td></tr></table></figure>
<h3 id="虚拟代理">虚拟代理</h3>
<blockquote>
<p>帮助我们控制访问创建开销大的资源</p>
</blockquote>
<p>如果一个对象实例化后会占用大量内存的话，可以先利用占位符来表示，这就是所谓的虚拟代理。例如，假设你想在网站上加载大型图片，而这个请求需要很长时间才能加载完成。通常，开发人员将在网页上创建一个占位符图标，以提示这里有图像。但是，只有当用户实际点击图标时才会加载图像，从而节省了向存储器中加载大型图像的开销。因此，在虚拟代理中，当客户端请求或访间对象时，才会创建实际对象。</p>
<h3 id="远程代理">远程代理</h3>
<p>远程代理可表述如下：它给位于远程服务器或不同地址空间上的实际对象提供了一个本地表示。例如，你希望为应用程序建立一个监控系统，而该应用涉及多个Web服务器、数据库服务器、芹菜（cery）任务服务器、缓存服务器，等等。如果我们要监视这些服务器的CPU和磁盘利用率，就需要建立一个对象，该对象能够用于监视应用程序运行的上下文中，同时还可以执行远程命令以获取实际的参数值。在这种情况下，建立一个作为远程对象的本地表示的远程代理对象将可以帮助我们实现这个目标。</p>
<h3 id="保护代理">保护代理</h3>
<p>你可以通过以下几点加深对保护代理的理解。这种代理能够控制 Realsubject的敏感对象的访问。例如，在当今分布式系统的世界中，Web应用会提供多个服务，这些服务相互协作来提供各种功能。现在，在这样的系统中，认证服务充当负责认证和授权的保护性代理服务器。在这种情况下，代理自然有助于保护网站的核心功能，防止无法识别或未授权的代理访间它们。因此，代理对象会检查调用者是否具有转发请求所需的访间权限。</p>
<h3 id="智能代理">智能代理</h3>
<p>智能代理在访问对象时插入其他操作。例如，假设在系统中有一个核心组件，它将状态信息集中保存在一个地点。通常情况下，这样的组件需要被多个不同的服务调用以完成它们的任务，并且可能导致共享资源的问题。与让服务直接调用核心组件不同，智能代理是内置的，并且会在访问之前检查实际对象是否被锁定，以确保没有其他对象可以更改它。</p>
<h2 id="现实世界代理模式">现实世界代理模式</h2>
<blockquote>
<p>下面通过现实世界的付款案例来展示代理模式的现实应用场景</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta</span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">You</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;you: buy the Denim shift&quot;</span>)</span><br><span class="line">        self.debitCard = DebitCard()</span><br><span class="line">        self.isPurchased = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_payment</span>(<span class="params">self</span>):</span><br><span class="line">        self.isPurchased = self.debitCard.do_pay()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.isPurchased:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;I buy it!!!&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;I have no money&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Payment</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_pay</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>(<span class="title class_ inherited__">Payment</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.card = <span class="literal">None</span></span><br><span class="line">        self.account = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getAccount</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 假设card人员是账户成员</span></span><br><span class="line">        self.account = self.card</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.account</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hasFunds</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Bank: checking if Account <span class="subst">&#123;self.__getAccount()&#125;</span> has enough funds&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setCard</span>(<span class="params">self, card</span>):</span><br><span class="line">        self.card = card</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_pay</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.__hasFunds():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Bank: Paying the merchant&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Bank: Sorry, not enough funds&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DebitCard</span>(<span class="title class_ inherited__">Payment</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.bank = Bank()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_pay</span>(<span class="params">self</span>):</span><br><span class="line">        card = <span class="built_in">input</span>(<span class="string">&quot;punch in card number:\\n&quot;</span>)</span><br><span class="line">        self.bank.setCard(card)</span><br><span class="line">        <span class="keyword">return</span> self.bank.do_pay()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    you = You()</span><br><span class="line">    you.make_payment()</span><br><span class="line"></span><br><span class="line">out：</span><br><span class="line">you: buy the Denim shift</span><br><span class="line">punch <span class="keyword">in</span> card number:</span><br><span class="line"><span class="number">231468498</span></span><br><span class="line">Bank: checking <span class="keyword">if</span> Account <span class="number">231468498</span> has enough funds</span><br><span class="line">Bank: Paying the merchant</span><br><span class="line">I buy it!!!</span><br></pre></td></tr></table></figure>
<p>注解：</p>
<h3 id="class-You：">class You：</h3>
<blockquote>
<p>客户端</p>
</blockquote>
<ul>
<li>你的行为由类You（即客户端）来表示</li>
<li>为了购买衬衫，该类提供了**make_payment（）**方法</li>
<li><strong>make_payment（）方法会在内部调用代理的方法进行付款</strong></li>
<li>如果付款成功最后会执行<strong>del</strong>（）方法</li>
</ul>
<h3 id="class-Payment：">class Payment：</h3>
<blockquote>
<p>主题是由代理和真实主题实现的接口</p>
</blockquote>
<ul>
<li>在本例中，主题是Payment类。它是一个抽象基类，代表一个接口</li>
<li>付款具有一个 do_pay() 方法，该方法需要借助代理和真实主题来实现</li>
</ul>
<h3 id="class-Bank-Payment">class Bank(Payment):</h3>
<blockquote>
<p>真实主题</p>
</blockquote>
<ul>
<li>Bank 实际完成从你账户向商家账户划账的功能</li>
<li>Bank 提供了多个方法来处理付款。代理使用setCard（）方法将借记卡详细信息发送给银行</li>
<li>__getAccount（）方法是Bank的私有方法，用于获取借记卡持有人的账户详细信息。为了简单起见，我们强制使用与账号相同的借记卡号。</li>
<li>Bank还有__hasFunds()方法，它用来查看账户持有人在账户中是否有足够的资金来为衬衫付款。</li>
<li>由Bank类（通过Payment接口）实现的do_pay（）方法实际上负责根据可用资金向商家付款</li>
</ul>
<h3 id="class-DebitCard-Payment">class DebitCard(Payment)</h3>
<blockquote>
<p>代理</p>
</blockquote>
<ul>
<li>DebitCard类是此处的代理。当你想要付款时，它会调用do_pay()方法。这是因为你不想跑去银行提款，然后再跑回商家完成支付。</li>
<li>DebitCard类充当真实主题（银行）的代理</li>
</ul>
<h3 id="代理模式的优点">代理模式的优点</h3>
<ul>
<li>代理可以通过缓存笨重的对象或频繁访问的对象来提高应用程序的性能。</li>
<li>代理还提供对于真实主题的访问授权。因此，只有提供合适权限的情况下，这个模式才会接受委派</li>
<li>远程代理还便于与可作网络连接和数据库连接的远程服务器进行交互，并可用于监视系统</li>
</ul>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>行为型模式</title>
    <url>/2023/02/06/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1>行为型模式</h1>
<blockquote>
<p>行为型模式，顾名思义，它主要关注的是对象的责任。</p>
</blockquote>
<ul>
<li>它们关注对象之间的交互以及对象的响应性</li>
<li>对象应该能够交互，同时仍然保持松散耦合</li>
</ul>
<h2 id="观察者模式">观察者模式</h2>
<blockquote>
<p>在观察者设计模式中，对象（主题）维护了一个依赖（观察者）列表，以便主题可以使用观察者定义的任何方法通知所有观察者它所发生的变化。</p>
</blockquote>
<ul>
<li>它定义了对象之间的一对多的依赖关系，从而使得一个对象中的任何更改都将自动通知给其他对象</li>
<li>它封装了主题的核心组件</li>
</ul>
<h3 id="UML图">UML图</h3>
<p><a href="https://gitee.com/luenci/RepoImg/raw/master/img/20210225223249.png"><img src="https://gitee.com/luenci/RepoImg/raw/master/img/20210225223249.png" alt="image-20210225223249145"></a></p>
<ul>
<li>主题(Subject):类Subject需要了解Observe。Subject类具有许多方法，诸如register()和deregister()等，Observer可以通过这些方法注册到Subject类中。因此，一个Subject可以处理多个Observe。</li>
<li>观察者(Observe)：它为关注主题的对象定义了一个接口。它定义了Observe需要实现的各个方法，以便在主题发生变化时能够获得相应的通知。</li>
<li>具体观察者(ConcreteObserver):它用来保存应该与Subject的状态保持一致的状态。它实现了Observe接口以保持其状态与主题中的变化相一致。</li>
</ul>
<h3 id="代码案例">代码案例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__observer = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">self, observer</span>):</span><br><span class="line">        self.__observer.append(observer)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notifyAll</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">for</span> observer <span class="keyword">in</span> self.__observer:</span><br><span class="line">            observer.notify(self, *args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer1</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, subject</span>):</span><br><span class="line">        subject.register(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notify</span>(<span class="params">self, subject, *args</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">type</span>(self).__name__&#125;</span>:: Got, <span class="subst">&#123;args&#125;</span> from <span class="subst">&#123;subject&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer2</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, subject</span>):</span><br><span class="line">        subject.register(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notify</span>(<span class="params">self, subject, *args</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">type</span>(self).__name__&#125;</span>:: Got, <span class="subst">&#123;args&#125;</span> from <span class="subst">&#123;subject&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    subject = Subject()</span><br><span class="line">    observer1 = Observer1(subject)</span><br><span class="line">    observer2 = Observer2(subject)</span><br><span class="line">    subject.notifyAll(<span class="string">&quot;notify~~~&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="观察者模式的优点和缺点">观察者模式的优点和缺点</h3>
<p>优点：</p>
<ul>
<li>它使得彼此交互的对象之间保持送耦合</li>
<li>它使得我们可以在无需对主题或观察者进行任何修改的情况下高效地发送数据到其他对象</li>
<li>可以随时添加/删除观察者</li>
</ul>
<p>缺点：</p>
<ul>
<li>观察者接口必须由具体观察者实现，这涉及继承。无法进行组合，因为观察者接口可以实例化</li>
<li>如果实现不当的话，观察者可能会增加复杂性，并导致性能降低</li>
<li>在软件应用程序中，通知有时可能是不可靠的，并导致竞争条件或不一致性</li>
</ul>
<span id="more"></span>
<h3 id="现实世界的观察者模式">现实世界的观察者模式</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta</span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsPublisher</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;主题,新闻发布机构.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__subscribers = []</span><br><span class="line">        self.__latestNews = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">attach</span>(<span class="params">self, subscriber</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;订阅.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param subscriber:</span></span><br><span class="line"><span class="string">        :return: list</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.__subscribers.append(subscriber)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detach</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;取消订阅.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param subscriber:</span></span><br><span class="line"><span class="string">        :return: list</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.__subscribers.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subscribers</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取注册的订阅者.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return: list</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">type</span>(x).__name__ <span class="keyword">for</span> x <span class="keyword">in</span> self.__subscribers]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notifySubscribers</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;通知订阅者.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return: obj</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> sub <span class="keyword">in</span> self.__subscribers:</span><br><span class="line">            sub.update()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addNews</span>(<span class="params">self, news</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加新闻.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param news:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.__latestNews = news</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNews</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回最新信息.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Got News: <span class="subst">&#123;self.__latestNews&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subscriber</span>(metaclass=ABCMeta):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;观察者抽象接口.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;抽象方法.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmailSubscriber</span>(<span class="title class_ inherited__">Subscriber</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;观察者1.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, publisher</span>):</span><br><span class="line">        self.publisher = publisher</span><br><span class="line">        self.publisher.attach(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;更新新闻.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">type</span>(self).__name__, self.publisher.getNews())</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SMSSubscriber</span>(<span class="title class_ inherited__">Subscriber</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;观察者2.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, publisher</span>):</span><br><span class="line">        self.publisher = publisher</span><br><span class="line">        self.publisher.attach(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;更新新闻.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">type</span>(self).__name__, self.publisher.getNews())</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnyOtherSubscriber</span>(<span class="title class_ inherited__">Subscriber</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;观察者3.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, publisher</span>):</span><br><span class="line">        self.publisher = publisher</span><br><span class="line">        self.publisher.attach(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;更新新闻.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">type</span>(self).__name__, self.publisher.getNews())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    new_publisher = NewsPublisher()</span><br><span class="line">    <span class="keyword">for</span> Subscribers <span class="keyword">in</span> [SMSSubscriber, EmailSubscriber, AnyOtherSubscriber]:</span><br><span class="line">        Subscribers(new_publisher)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\\n Subscriber:<span class="subst">&#123;new_publisher.subscribers()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    new_publisher.addNews(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    new_publisher.notifySubscribers()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\\n Detach:<span class="subst">&#123;<span class="built_in">type</span>(new_publisher.detach()).__name__&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\\n Subscribers:<span class="subst">&#123;new_publisher.subscribers()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    new_publisher.addNews(<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">    new_publisher.notifySubscribers()</span><br></pre></td></tr></table></figure>
<h2 id="命令模式——封装调用">命令模式——封装调用</h2>
<p>命令模式也是一种行为设计模式，其中对象用于封装在完成以项操作时或在触发一个事件时所需的全部信息。</p>
<p>这些信息包含如下</p>
<ul>
<li>方法名称</li>
<li>拥有方法的对象</li>
<li>方法参数的值</li>
</ul>
<h3 id="命令模式常用术语Command、Receiver、Invoker-和-Client">命令模式常用术语Command、Receiver、Invoker 和 Client</h3>
<ul>
<li>Command对象了解Receiver对象的情况下，并能调用Receiver对象的方法；</li>
<li>调用者方法的参数值存储在Command对象中</li>
<li>调用者知道如何执行命令</li>
<li>客户端用来创建Command对象并设置其接收者</li>
</ul>
<h3 id="命令模式的主要意图如下">命令模式的主要意图如下</h3>
<ul>
<li>将请求封装为对象</li>
<li>可用不用的请求对客户端进行参数化</li>
<li>允许将请求保存在队列中</li>
<li>提供面向对象的回调</li>
</ul>
<h3 id="命令模式的应用场景">命令模式的应用场景</h3>
<ul>
<li>根据需要执行的操作对对象进行参数化</li>
<li>将操作添加到队列并在不同地点执行请求</li>
<li>创建一个结构来根据较小操作完成高级操作</li>
</ul>
<h3 id="UML图-2">UML图</h3>
<p><a href="https://gitee.com/luenci/RepoImg/raw/master/img/20210225223627.png"><img src="https://gitee.com/luenci/RepoImg/raw/master/img/20210225223627.png" alt="image-20210225223627772"></a></p>
<ul>
<li>Command：声明执行操作的接口。</li>
<li>ConcreteCommand：将一个Receiver对象和一个操作绑定在一起。</li>
<li>Client：创建ConcreteCommand对象并设定其接受者。</li>
<li>Invoker：要求改ConcreteCommand执行这个请求。</li>
<li>Receiver：知道如何实施与执行一个请求相关的操作。</li>
</ul>
<h3 id="代码实现">代码实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta</span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span>(metaclass=ABCMeta):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, recv</span>):</span><br><span class="line">        self.recv = recv</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCommand</span>(<span class="title class_ inherited__">Command</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, recv</span>):</span><br><span class="line">        self.recv = recv</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self</span>):</span><br><span class="line">        self.recv.action()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">action</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Receiver Action&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Invoker</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">command</span>(<span class="params">self, cmd</span>):</span><br><span class="line">        self.cmd = cmd</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self</span>):</span><br><span class="line">        self.cmd.execute()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   recv = Receiver()</span><br><span class="line">   cmd = ConcreteCommand(recv)</span><br><span class="line">   invoker = Invoker()</span><br><span class="line">   invoker.command(cmd)</span><br><span class="line">   invoker.execute()</span><br><span class="line"></span><br><span class="line">out：Receiver Action</span><br></pre></td></tr></table></figure>
<h3 id="现实世界的命令模式（一个股票交易例子）">现实世界的命令模式（一个股票交易例子）</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta</span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>(metaclass=ABCMeta):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;订单抽象接口类.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyStockOrder</span>(<span class="title class_ inherited__">Order</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Buy 接口实现类.&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, stock</span>):</span><br><span class="line">        self.stock = stock</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self</span>):</span><br><span class="line">        self.stock.buy()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellStockOrder</span>(<span class="title class_ inherited__">Order</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Sell 接口实现类.&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, stock</span>):</span><br><span class="line">        self.stock = stock</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self</span>):</span><br><span class="line">        self.stock.sell()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StockTrade</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;接收者.&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buy</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;调用交易中所卖入的股票.&quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;You will buy stocks&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sell</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;调用交易中所买入的股票.&quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;You will sell stocks&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Agent</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;代理.&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__orderQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">placeOrder</span>(<span class="params">self, order</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取用户所下的订单.&quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        self.__orderQueue.append(order)</span><br><span class="line">        order.execute()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># client</span></span><br><span class="line">    stock = StockTrade()</span><br><span class="line">    buyStock = BuyStockOrder(stock)</span><br><span class="line">    sellStock = SellStockOrder(stock)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Invoker</span></span><br><span class="line">    agent = Agent()</span><br><span class="line">    agent.placeOrder(buyStock)</span><br><span class="line">    agent.placeOrder(sellStock)</span><br></pre></td></tr></table></figure>
<h3 id="命令模式优缺点">命令模式优缺点</h3>
<h4 id="优点">优点</h4>
<ul>
<li>将调用操作的类与知道如何执行该操作的对象解耦；</li>
<li>提供队列系统后，可以创建一系列命令；</li>
<li>添加新命令更容易，并且无需更改现有代码；</li>
<li>还可以使用命令模式来定义回滚系统，例如：在向导实例中，我们可以编写一个回滚方法。</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>为了实现目标，需要大量的类和对象进行协作。应用程序开发人员为了正确开发这些类，需要加倍小心。</li>
<li>每个单独的命令都是一个ConcreteCommand类，从而增加了需要实现和维护的类的数量。</li>
</ul>
<h2 id="模板方法设计模式">模板方法设计模式</h2>
<p>通过一种称为模板方法的方式来定义程序框架或算法</p>
<ul>
<li>使用基本操作定义算法的框架</li>
<li>重新定义子类的某些操作，而无需修改算法的结构</li>
<li>实现代码重用并避免重复工作</li>
<li>利用通用接口或实现</li>
</ul>
<h3 id="模板方法模式常用术语">模板方法模式常用术语</h3>
<ul>
<li>AbstractClass：声明一个定义算法步骤的接口。</li>
<li>ConcreteClass：定义子类特定的步骤。</li>
<li>template_method()：通过调用步骤方法来定义算法。</li>
</ul>
<h3 id="代码实现（案例1）">代码实现（案例1）</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta</span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Compiler</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">collectSource</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compileToObject</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">complileAndRun</span>(<span class="params">self</span>):</span><br><span class="line">        self.collectSource()</span><br><span class="line">        self.compileToObject()</span><br><span class="line">        self.run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOSCompiler</span>(<span class="title class_ inherited__">Compiler</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">collectSource</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Collecting Swift Source Code&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compileToObject</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Compiling Swift code to LLVM bitcode&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Program running on runtime environment&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    iOS = IOSCompiler()</span><br><span class="line">    iOS.complileAndRun()</span><br></pre></td></tr></table></figure>
<h3 id="UML图-3">UML图</h3>
<p><a href="https://gitee.com/luenci/RepoImg/raw/master/img/20210225223752.png"><img src="https://gitee.com/luenci/RepoImg/raw/master/img/20210225223752.png" alt="image-20210225223752017"></a></p>
<ul>
<li>AbstractClass：在抽象方法的帮助下定义算法的操作或步骤。这些步骤将被具体子类覆盖</li>
<li>template_method()：定义算法的框架。在模板方法中调用抽象方法定义的多个步骤来定义序列或算法本身。</li>
<li>ConcreteClass：实现（由抽象方法定义的）步骤，来执行算法子类的特定步骤。</li>
</ul>
<h3 id="代码案例二">代码案例二</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span>(metaclass=ABCMeta):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">template_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Defining the Algorithm. Operation1 follows Operation2&quot;</span>)</span><br><span class="line">        self.operation2()</span><br><span class="line">        self.operation1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass</span>(<span class="title class_ inherited__">AbstractClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;My Concrete Operation1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;My Concrete Operation2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">self</span>):</span><br><span class="line">        self.concreate = ConcreteClass()</span><br><span class="line">        self.concreate.template_method()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    client = Client()</span><br><span class="line">    client.main()</span><br><span class="line"></span><br><span class="line">out：</span><br><span class="line">My Concrete Operation2</span><br><span class="line">My Concrete Operation1</span><br></pre></td></tr></table></figure>
<h3 id="代码案例三（旅行社例子）">代码案例三（旅行社例子）</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod, ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trip</span>(metaclass=ABCMeta):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;抽象旅行模板类.&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setTransport</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">day1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">day2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">day3</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">returnHome</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">itinerary</span>(<span class="params">self</span>):</span><br><span class="line">        self.setTransport()</span><br><span class="line">        self.day1()</span><br><span class="line">        self.day2()</span><br><span class="line">        self.day3()</span><br><span class="line">        self.returnHome()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VeniceTrip</span>(<span class="title class_ inherited__">Trip</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Venice 旅游实现类.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setTransport</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Take a boat and find your way in the Grand Canal&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">day1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Visit St Mark`s Basilica in St Mark`s Square&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">day2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Appreciate Doge`s Palace&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">day3</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Enjoy the food near the Rialto Bridge&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">returnHome</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Get souvenirs for friends and get back&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaldivesTrip</span>(<span class="title class_ inherited__">Trip</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Maldives 旅游实现类.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setTransport</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;On foot, on any island, wow!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">day1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Enjoy the marine life of Banana Reed&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">day2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Go for the water sports and snorkelling.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">day3</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Relax on the beach and enjoy the sun.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">returnHome</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Don`t feel like leaving the beach..&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TraveAgency</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;代理类.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">arrange_trip</span>(<span class="params">self</span>):</span><br><span class="line">        choice = <span class="built_in">input</span>(<span class="string">&quot;What kind of place you`d like togo historical or to a beach? \\n&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> choice == <span class="string">&#x27;historical&#x27;</span>:</span><br><span class="line">            self.trip = VeniceTrip()</span><br><span class="line">            self.trip.itinerary()</span><br><span class="line">        <span class="keyword">if</span> choice == <span class="string">&#x27;beach&#x27;</span>:</span><br><span class="line">            self.trip = MaldivesTrip()</span><br><span class="line">            self.trip.itinerary()</span><br><span class="line"></span><br><span class="line">TraveAgency().arrange_trip()</span><br></pre></td></tr></table></figure>
<h3 id="模板方法模式优缺点">模板方法模式优缺点</h3>
<h4 id="优点-2">优点</h4>
<ul>
<li>没有重复代码</li>
<li>由于模板方法模式使用继承而不是合成，因此能够对代码进行重用。所以只有为数不多的几个方法需要重写；</li>
<li>灵活性允许子类决定如何实现算法中的步骤</li>
</ul>
<h4 id="缺点-2">缺点</h4>
<ul>
<li>调试和理解模板方法模式中的流程序列有时会令人困惑。你最终实现的方法可能是一个不应该实现的方法，或根本没有实现抽象方法。文档和严格的错误处理必须由程序员完成；</li>
<li>模板框架的维护可能是一个问题，因为任何层次（低层或高层）的变更都可能对实现造成干扰。因此，使用模板方法模式可能会使维护变得异常痛苦。</li>
</ul>
<h2 id="状态设计模式">状态设计模式</h2>
<p>一个对象可以基于其内部状态封装多个行为。状态模式也可以看作是在运行时改变对象行为的一种方式。</p>
<h3 id="状态设计模式常用名词">状态设计模式常用名词</h3>
<ul>
<li>State：这被认为是封装对象行为的接口。这个行为与对象的状态相关联。</li>
<li>ConcreteState：这是实现State接口的子类。ConcreteState实现与对象的特定状态相关联的实际行为。</li>
<li>Context：这定义了用户感兴趣的接口。Context还维护一个ConcreteState子类的实例，该子类在内部定义了对象的特定状态的实现。</li>
</ul>
<h3 id="代码示例1">代码示例1</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span>(metaclass=ABCMeta):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;状态抽象类接口.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Handle</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateB</span>(<span class="title class_ inherited__">State</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;接口子类A.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Handle</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateA</span>(<span class="title class_ inherited__">State</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;接口子类B.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Handle</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateA&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span>(<span class="title class_ inherited__">State</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;用户操作接口.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.state = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getState</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setState</span>(<span class="params">self, state</span>):</span><br><span class="line">        self.state = state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Handle</span>(<span class="params">self</span>):</span><br><span class="line">        self.state.Handle()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    context = Context()</span><br><span class="line">    stateA = ConcreteStateA()</span><br><span class="line">    stateB = ConcreteStateB()</span><br><span class="line"></span><br><span class="line">    context.setState(stateB)</span><br><span class="line">    context.Handle()</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">ConcreteStateB</span><br></pre></td></tr></table></figure>
<h3 id="UML图-4">UML图</h3>
<p><a href="https://gitee.com/luenci/RepoImg/raw/master/img/20210225223938.png"><img src="https://gitee.com/luenci/RepoImg/raw/master/img/20210225223938.png" alt="image-20210225223938505"></a></p>
<ul>
<li>Handle（）方法，根据状态的变化定义要采取的实际行动</li>
<li>Context：这是一个接受客户端请求的类。它维护着对象的当前状态的引用。这样，就可以根据相应的请求，来调用具体的行为。</li>
</ul>
<h3 id="代码示例2（TV播放）">代码示例2（TV播放）</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod, ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span>(metaclass=ABCMeta):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">doThis</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StartState</span>(<span class="title class_ inherited__">State</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">doThis</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Tv Switching ON ..&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StopState</span>(<span class="title class_ inherited__">State</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">doThis</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Tv Switching OFF..&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TVContext</span>(<span class="title class_ inherited__">State</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.state = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getState</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setState</span>(<span class="params">self, state</span>):</span><br><span class="line">        self.state = state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">doThis</span>(<span class="params">self</span>):</span><br><span class="line">        self.state.doThis()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    context = TVContext()</span><br><span class="line">    context.getState()</span><br><span class="line"></span><br><span class="line">    start = StartState()</span><br><span class="line">    stop = StopState()</span><br><span class="line"></span><br><span class="line">    context.setState(stop)</span><br><span class="line">    context.doThis()</span><br><span class="line"></span><br><span class="line">out：</span><br><span class="line">Tv Switching OFF..</span><br></pre></td></tr></table></figure>
<h3 id="一个应用案例（pythonic-电脑状态）">一个应用案例（pythonic 电脑状态）</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerState</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&quot;state&quot;</span></span><br><span class="line">    allowed = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">switch</span>(<span class="params">self, state</span>):</span><br><span class="line">        <span class="keyword">if</span> state.name <span class="keyword">in</span> self.allowed:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Current: <span class="subst">&#123;self&#125;</span> =&gt; switched to new state <span class="subst">&#123;state.name&#125;</span>.&quot;</span>)</span><br><span class="line">            state.__class__ = state</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Current: <span class="subst">&#123;self&#125;</span> =&gt; switching to <span class="subst">&#123;state.name&#125;</span> not possible.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Off</span>(<span class="title class_ inherited__">ComputerState</span>):</span><br><span class="line">    name = <span class="string">&quot;off&quot;</span></span><br><span class="line">    allowed = [<span class="string">&quot;on&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">On</span>(<span class="title class_ inherited__">ComputerState</span>):</span><br><span class="line">    name = <span class="string">&quot;on&quot;</span></span><br><span class="line">    allowed = [<span class="string">&quot;off&quot;</span>, <span class="string">&quot;suspend&quot;</span>, <span class="string">&quot;hibernate&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Suspend</span>(<span class="title class_ inherited__">ComputerState</span>):</span><br><span class="line">    name = <span class="string">&quot;suspend&quot;</span></span><br><span class="line">    allowed = [<span class="string">&quot;on&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hibernate</span>(<span class="title class_ inherited__">ComputerState</span>):</span><br><span class="line">    name = <span class="string">&quot;hibernate&quot;</span></span><br><span class="line">    allowed = [<span class="string">&quot;on&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, model=<span class="string">&quot;HP&quot;</span></span>):</span><br><span class="line">        self.model = model</span><br><span class="line">        self.state = Off()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, state</span>):</span><br><span class="line">        self.state.switch(state)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    comp = Computer()</span><br><span class="line">    <span class="comment"># Switch On</span></span><br><span class="line">    comp.change(On)</span><br><span class="line">    <span class="comment"># Switch Off</span></span><br><span class="line">    comp.change(Off)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Switch on again</span></span><br><span class="line">    comp.change(On)</span><br><span class="line">    <span class="comment"># Suspend</span></span><br><span class="line">    comp.change(Suspend)</span><br><span class="line">    <span class="comment"># Try to hibernate --&gt; can`t</span></span><br><span class="line">    comp.change(Hibernate)</span><br><span class="line">    <span class="comment"># switch on back</span></span><br><span class="line">    comp.change(On)</span><br><span class="line">    <span class="comment"># Finally off</span></span><br><span class="line">    comp.change(Off)</span><br></pre></td></tr></table></figure>
<h3 id="状态模式优缺点">状态模式优缺点</h3>
<h4 id="优点-3">优点</h4>
<ul>
<li>在状态设计模式中，对象的行为是其状态的函数结果，并且行为在运行时根据状态而改变。这消除了对iese或 switch/case条件逻辑的依赖。例如，在电视远程遥控的场景中，我们还可以通过简单地写一个类和方法来实现相应的行为，但是该类和方法将用到参数，并使用ieei句块来执行具体操作（打开/关闭电视）。</li>
<li>使用状态模式，实现多态行为的好处是显而易见的，并且更易于添加状态来支持额外的行为。</li>
<li>状态设计模式还提高了聚合性，因为特定于状态的行为被聚合到 Concretestate类中，并且放置在代码中的同一个地方。</li>
<li>使用状态设计模式，通过只添加一个 Concretestate类来添加行为是非常容易的。因此，状态模式不仅改善了扩展应用程序行为时的灵活性，而且全面提高了代码的可维护性。</li>
</ul>
<h4 id="不足">不足</h4>
<ul>
<li>类爆炸：由于每个状态都需要在 Concretestate的帮助下定义，因此我们可能导致创建了太多功能较为单一的类。我们不妨考虑有限状态机的情况——如果有许多状态，但每个状态与另一个状态没有太大不同，我们仍然需要将它们写成单独的 Concretestate类。这既增加了代码量，又使得状态机的结构更加难以审查</li>
<li>随着每个新行为的引入（即使添加行为只是添加一个 Concretestate）， Context类都需要进行相应的更新以处理每个行为。这使得上下文行为更容易受到每个新的行为的影响。</li>
</ul>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Django信号量初探</title>
    <url>/2023/02/06/django%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
    <content><![CDATA[<h1>django的信号量</h1>
<blockquote>
<p>原文链接:<a href="https://juejin.cn/post/6844903674049724424">https://juejin.cn/post/6844903674049724424</a></p>
</blockquote>
<h2 id="一、关于django信号量">一、关于<code>django</code>信号量</h2>
<blockquote>
<p><code>Django</code>包含一个&quot;信号调度程序&quot;，<strong>它有助于在框架中的其他位置发生操作时通知分离的应用程序</strong>。简而言之，信号允许某些发送者通知一组接收器已经发生了某些动作。当许多代码可能对同一事件感兴趣时，它们特别有用.</p>
</blockquote>
<h2 id="二、django中内置的信号量">二、<code>django</code>中内置的信号量</h2>
<ul>
<li>
<p>1、<code>Model</code>的信号量</p>
<ul>
<li>
<p><code>pre_init</code> # django的modal执行其构造方法前，自动触发</p>
</li>
<li>
<p><code>post_init</code> # django的modal执行其构造方法后，自动触发</p>
</li>
<li>
<p><code>pre_save</code> # django的modal对象保存前，自动触发</p>
</li>
<li>
<p><code>post_save</code> # django的modal对象保存后，自动触发</p>
</li>
<li>
<p><code>pre_delete</code> # django的modal对象删除前，自动触发</p>
</li>
<li>
<p><code>post_delete</code> # django的modal对象删除后，自动触发</p>
</li>
<li>
<p><code>m2m_changed</code> # django的modal中使用m2m字段操作第三张表（add,remove,clear）前后，自动触发</p>
</li>
<li>
<p><code>class_prepared</code> # 程序启动时，检测已注册的app中modal类，对于每一个类，自动触发</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> class_prepared</span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> pre_init</span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> post_init</span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> pre_save</span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> post_save</span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> pre_delete</span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> post_delete</span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> m2m_changed</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>2、<code>Management</code>的信号量</p>
<ul>
<li>
<p><code>pre_migrate</code> # 执行migrate命令前，自动触发</p>
</li>
<li>
<p><code>post_migrate</code> # 执行migrate命令后，自动触发</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> pre_migrate</span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> post_migrate</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>3、<code>Request/Response</code>的信号量</p>
<ul>
<li>
<p><code>request_started</code> # 请求到来前，自动触发</p>
</li>
<li>
<p><code>request_finished</code> # 请求结束后，自动触发</p>
</li>
<li>
<p><code>got_request_exception</code> # 请求异常后，自动触发</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.signals <span class="keyword">import</span> request_finished</span><br><span class="line"><span class="keyword">from</span> django.core.signals <span class="keyword">import</span> request_started</span><br><span class="line"><span class="keyword">from</span> django.core.signals <span class="keyword">import</span> got_request_exception</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>4、<code>Test</code>的信号量</p>
<ul>
<li>
<p><code>setting_changed</code> # 使用test测试修改配置文件时，自动触发</p>
</li>
<li>
<p><code>template_rendered</code> # 使用test测试渲染模板时，自动触发</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.test.signals <span class="keyword">import</span> setting_changed</span><br><span class="line"><span class="keyword">from</span> django.test.signals <span class="keyword">import</span> template_rendered</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>5、<code>Database</code>的信号量</p>
<ul>
<li>
<p><code>connection_created</code> # 创建数据库连接时，自动触发</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.backends.signals <span class="keyword">import</span> connection_created</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h2 id="三、在django中使用connect定义信号量">三、在<code>django</code>中使用<code>connect</code>定义信号量</h2>
<ul>
<li>
<p>1、官网案例</p>
<p>要接收信号，请使用该方法注册接收器功能 Signal.connect()。发送信号时调用接收器功能。</p>
<p><code>Signal.connect（receiver，sender = None，weak = True，dispatch_uid = None）</code></p>
<ul>
<li><code>receiver</code> - 将连接到此信号的回调函数。有关更多信息，请参阅接收器功能。</li>
<li><code>sender</code> - 指定从中接收信号的特定发送方。有关详细信息，请参阅 连接到特定发件人发送的信号。</li>
<li><code>weak</code> - <code>Django</code>默认将信号处理程序存储为弱引用。因此，如果您的接收器是本地功能，它可能是垃圾收集。为防止这种情况，请<code>weak=False</code>在调用信号<code>connect()</code>方法时通过。</li>
<li><code>dispatch_uid</code> - 在可能发送重复信号的情况下信号接收器的唯一标识符。有关更多信息，请参阅 防止重复信号。</li>
</ul>
</li>
<li>
<p>2、自己定义一个数据库保存前后的信号(在项目的<code>__init__.py</code>文件中定义)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> signals</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">before_save</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    定义一个数据保存之前触发的信号</span></span><br><span class="line"><span class="string">    :param args:</span></span><br><span class="line"><span class="string">    :param kwargs:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;===数据保存之前触发===&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(args, kwargs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;===数据保存之前触发===&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">post_save</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    定义一个数据保存之后触发的信号</span></span><br><span class="line"><span class="string">    :param args:</span></span><br><span class="line"><span class="string">    :param kwargs:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;==数据保存之后触发==&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(args, kwargs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;==数据保存之后触发==&#x27;</span>)</span><br><span class="line"></span><br><span class="line">signals.pre_save.connect(before_save)</span><br><span class="line">signals.post_save.connect(post_save)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>3、测试</p>
</li>
</ul>
<h2 id="四、使用receiver装饰器定义信号量">四、使用<code>receiver</code>装饰器定义信号量</h2>
<ul>
<li>
<p>1、同样在项目的<code>__init__.py</code>文件中</p>
</li>
<li>
<p>2、导包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.signals <span class="keyword">import</span> request_finished</span><br><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>3、定义信号量函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@receiver(<span class="params">request_finished</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_callback</span>(<span class="params">sender, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">100</span>)</span><br><span class="line">    <span class="built_in">print</span>(sender, kwargs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Request finished!&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>不指定接受信号者就是作用于全局,一般直接写在项目的<code>__init__.py</code>文件中,如果是仅仅针对个别<code>app</code>来说的,不会全局配置</strong></p>
<h2 id="五、关于指定接收者-组件的信号量">五、关于指定接收者(组件的信号量)</h2>
<ul>
<li>
<p>1、在组件中创建一个<code>signals.py</code>文件</p>
</li>
<li>
<p>2、<code>signals.py</code>中写上信号的接收者</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> signals</span><br><span class="line"><span class="keyword">from</span> app01.models <span class="keyword">import</span> ClassModel, StudentModle</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">before_save</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    定义一个数据保存之前触发的信号</span></span><br><span class="line"><span class="string">    :param args:</span></span><br><span class="line"><span class="string">    :param kwargs:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;===数据保存之前触发===&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(args, kwargs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;===数据保存之前触发===&#x27;</span>)</span><br><span class="line"></span><br><span class="line">signals.pre_save.connect(before_save, sender=ClassModel)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>3、如果是使用装饰器的方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.signals <span class="keyword">import</span> request_finished</span><br><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"><span class="keyword">from</span> .views <span class="keyword">import</span> app02Test</span><br><span class="line"></span><br><span class="line"><span class="meta">@receiver(<span class="params">request_finished, sender=app02Test</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_callback</span>(<span class="params">sender, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">100</span>)</span><br><span class="line">    <span class="built_in">print</span>(sender, kwargs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Request finished!&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="六、自定义信号">六、自定义信号</h2>
<ul>
<li>
<p>1、在<code>app</code>中创建一个文件</p>
</li>
<li>
<p>2、在文件中自定义信号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义信号</span></span><br><span class="line"><span class="keyword">import</span> django.dispatch</span><br><span class="line"></span><br><span class="line">pizza_done = django.dispatch.Signal(providing_args=[<span class="string">&quot;toppings&quot;</span>, <span class="string">&quot;size&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册信号</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">sender, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;callback&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(sender, kwargs)</span><br><span class="line"></span><br><span class="line">pizza_done.connect(callback)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>3、在视图中发送信号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from .文件 import pizza_done</span><br><span class="line">pizza_done.send(sender=&#x27;seven&#x27;, toppings=123, size=456)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Django框架</category>
      </categories>
      <tags>
        <tag>信号量</tag>
      </tags>
  </entry>
  <entry>
    <title>同源和跨域</title>
    <url>/2023/02/06/%E5%85%B3%E4%BA%8E%E8%B7%A8%E5%9F%9F%E5%92%8C%E5%90%8C%E6%BA%90/</url>
    <content><![CDATA[<blockquote>
<p>原文:<a href="https://www.cnblogs.com/rockmadman/p/6836834.html">同源策略、跨域解决方案</a></p>
</blockquote>
<h2 id="一、同源策略">一、同源策略</h2>
<h3 id="1、先来说说什么是源">1、先来说说什么是源</h3>
<p>• 源（origin）就是协议、域名和端口号。<br>
以上url中的源就是：<a href="http://www.company.com:80">http://www.company.com:80</a><br>
若地址里面的协议、域名和端口号均相同则属于同源。<br>
以下是相对于 <a href="http://www.a.com/test/index.html">http://www.a.com/test/index.html</a> 的同源检测</p>
<p>• <a href="http://www.a.com/dir/page.html">http://www.a.com/dir/page.html</a> ----成功<br>
• <a href="http://www.child.a.com/test/index.html">http://www.child.a.com/test/index.html</a> ----失败，域名不同<br>
• <a href="https://www.a.com/test/index.html">https://www.a.com/test/index.html</a> ----失败，协议不同<br>
• <a href="http://www.a.com:8080/test/index.html">http://www.a.com:8080/test/index.html</a> ----失败，端口号不同</p>
<h3 id="2-什么是同源策略？">2.什么是同源策略？</h3>
<p>同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以a.com下的js脚本采用ajax读取b.com里面的文件数据是会报错的。</p>
<p>• 不受同源策略限制的：<br>
1、页面中的链接，重定向以及表单提交是不会受到同源策略限制的。<br>
2、跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的<code>&lt;script src=&quot;...&quot;&gt;``&lt;/script&gt;，&lt;img&gt;</code>，<code>&lt;link&gt;</code>，<code>&lt;iframe&gt;</code>等。</p>
<span id="more"></span>
<h2 id="二、跨域">二、跨域</h2>
<h3 id="1、什么是跨域">1、什么是跨域</h3>
<p>根据前面所讲的浏览器同源策略的影响，不是同源的脚本不能操作其他源下面的对象。想要操作另一个源下的对象是就需要跨域。</p>
<h3 id="2、跨域的实现形式">2、跨域的实现形式</h3>
<h4 id="（1）设置document-domain">（1）设置document.domain</h4>
<ul>
<li>比如<code>home.example.com</code>要读取<code>developer.example.com</code>里面的文档，由于同源策略的限制，就无法读取，我们通过设置<code>document.domain=&quot;example.com&quot;;</code>这时就不再受同源策略的限制了。</li>
</ul>
<h4 id="（2）跨资源共享CORS（Cross-origin-resource-sharing）">（2）跨资源共享CORS（Cross-origin resource sharing）</h4>
<ul>
<li>
<p>CORS采用新的<code>“origin:”</code>请求头和新的<code>Access-Control-Allow-Origin</code>响应头来扩展HTTP。它允许服务器用头信息显示地列出源，或使用通配符来匹配所有的源并允许任何地址请求文件。</p>
</li>
<li>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
</li>
</ul>
<p>从而它允许浏览器向跨源服务器，发出XMLHttpRequest请求，克服了AJAX只能同源使用的限制。</p>
<h4 id="（3）跨文档消息（cross-document-messaging）">（3）跨文档消息（cross-document messaging）</h4>
<ul>
<li>允许来自一个文档的脚本可以传递消息到另一个文档里的脚本，而不管脚本的来源是否不同，通过调用<code>window.postMessage()</code>方法，可以异步传递消息事件(可以使用<code>onmessage</code>事件处理程序函数来处理它)到窗口的文档里。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>RESTful风格</title>
    <url>/2023/02/06/RESTful%E9%A3%8E%E6%A0%BC%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1>RESTful设计方法</h1>
<blockquote>
<p>原文参考自哔哩哔哩: <a href="https://www.bilibili.com/video/BV1k5411p7Kp">https://www.bilibili.com/video/BV1k5411p7Kp</a></p>
</blockquote>
<h2 id="1-域名">1. 域名</h2>
<p>应该尽量将API部署在专用域名之下。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://api.example.com</span><br></pre></td></tr></table></figure>
<p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://example.org/api/</span><br></pre></td></tr></table></figure>
<h2 id="2-版本（Versioning）">2. 版本（Versioning）</h2>
<p>应该将API的版本号放入URL。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">http://www.example.com/app/1.0/foo</span><br><span class="line"></span><br><span class="line">http://www.example.com/app/1.1/foo</span><br><span class="line"></span><br><span class="line">http://www.example.com/app/2.0/foo</span><br></pre></td></tr></table></figure>
<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。<a href="https://developer.github.com/v3/media/#request-specific-version">Github</a>采用这种做法。</p>
<p>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URL。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见<a href="http://www.informit.com/articles/article.aspx?p=1566460">Versioning REST Services</a>）：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>vnd.example-com.foo+json; version=1.0</span><br><span class="line"></span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>vnd.example-com.foo+json; version=1.1</span><br><span class="line"></span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>vnd.example-com.foo+json; version=2.0</span><br></pre></td></tr></table></figure>
<h2 id="3-路径（Endpoint）">3. 路径（Endpoint）</h2>
<p>路径又称&quot;终点&quot;（endpoint），表示API的具体网址，每个网址代表一种资源（resource）</p>
<p><strong>(1) 资源作为网址，只能有名词，不能有动词，而且所用的名词往往与数据库的表名对应。</strong></p>
<p>举例来说，以下是不好的例子:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">/getProducts</span><br><span class="line">/listOrders</span><br><span class="line">/retreiveClientByOrder?orderId=1</span><br></pre></td></tr></table></figure>
<p>对于一个简洁结构，你应该始终用名词。 此外，利用的HTTP方法可以分离网址中的资源名称的操作。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /products ：将返回所有产品清单</span><br><span class="line">POST /products ：将产品新建到集合</span><br><span class="line">GET /products/4 ：将获取产品 4</span><br><span class="line">PATCH（或）PUT /products/4 ：将更新产品 4</span><br></pre></td></tr></table></figure>
<p><strong>(2) API中的名词应该使用复数。无论子资源或者所有资源。</strong></p>
<p>举例来说，获取产品的API可以这样定义</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">获取单个产品：http://127.0.0.1:8080/AppName/rest/products/1</span><br><span class="line">获取所有产品: http://127.0.0.1:8080/AppName/rest/products</span><br></pre></td></tr></table></figure>
<h2 id="3-HTTP动词">3. HTTP动词</h2>
<p>对于资源的具体操作类型，由HTTP动词表示。</p>
<p>常用的HTTP动词有下面四个（括号里是对应的SQL命令）。</p>
<ul>
<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>
<li>POST（CREATE）：在服务器新建一个资源。</li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>
<li>DELETE（DELETE）：从服务器删除资源。</li>
</ul>
<p>还有三个不常用的HTTP动词。</p>
<ul>
<li>PATCH（UPDATE）：在服务器更新(更新)资源（客户端提供改变的属性）。</li>
<li>HEAD：获取资源的元数据。</li>
<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>
</ul>
<p>下面是一些例子。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /zoos：列出所有动物园</span><br><span class="line">POST /zoos：新建一个动物园（上传文件）</span><br><span class="line">GET /zoos/ID：获取某个指定动物园的信息</span><br><span class="line">PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</span><br><span class="line">PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</span><br><span class="line">DELETE /zoos/ID：删除某个动物园</span><br><span class="line">GET /zoos/ID/animals：列出某个指定动物园的所有动物</span><br><span class="line">DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</span><br></pre></td></tr></table></figure>
<h2 id="4-过滤信息（Filtering）">4. 过滤信息（Filtering）</h2>
<p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>
<p>下面是一些常见的参数。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?limit=10：指定返回记录的数量</span><br><span class="line">?offset=10：指定返回记录的开始位置。</span><br><span class="line">?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</span><br><span class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?animal_type_id=1：指定筛选条件</span><br></pre></td></tr></table></figure>
<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoos/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>
<h2 id="6-状态码（Status-Codes）">6. 状态码（Status Codes）</h2>
<p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>
<blockquote>
<ul>
<li><code>200</code> OK - [GET]：服务器成功返回用户请求的数据</li>
<li><code>201</code> CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li>
<li><code>202</code> Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li>
<li><code>204</code> NO CONTENT - [DELETE]：用户删除数据成功。</li>
<li><code>400</code> INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作</li>
<li><code>401</code> Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li>
<li><code>403</code> Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>
<li><code>404</code> NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>
<li><code>406</code> Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>
<li><code>410</code> Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>
<li><code>422</code> Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>
<li><code>500</code> INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>
</ul>
</blockquote>
<p>状态码的完全列表参见<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">这里</a>或<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81">这里</a>。</p>
<h2 id="7-错误处理（Error-handling）">7. 错误处理（Error handling）</h2>
<p>如果状态码是4xx，服务器就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    error<span class="punctuation">:</span> <span class="string">&quot;Invalid API key&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="8-返回结果">8. 返回结果</h2>
<p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>
<ul>
<li>GET /collection：返回资源对象的列表（数组）</li>
<li>GET /collection/resource：返回单个资源对象</li>
<li>POST /collection：返回新生成的资源对象</li>
<li>PUT /collection/resource：返回完整的资源对象</li>
<li>PATCH /collection/resource：返回完整的资源对象</li>
<li>DELETE /collection/resource：返回一个空文档</li>
</ul>
<h2 id="9-其他">9. 其他</h2>
<p>服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</p>
]]></content>
      <categories>
        <category>后端接口风格</category>
      </categories>
      <tags>
        <tag>接口设计</tag>
      </tags>
  </entry>
  <entry>
    <title>鸭子类型介绍</title>
    <url>/2023/02/06/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1>鸭子类型</h1>
<h2 id="定义">定义</h2>
<p><strong>鸭子类型</strong>（英语：<strong>duck typing</strong>）在<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">程序设计</a>中是<a href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1">动态类型</a>的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由&quot;<strong>当前<a href="https://zh.wikipedia.org/wiki/%E6%96%B9%E6%B3%95_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)">方法</a>和属性的集合</strong>&quot;决定。这个概念的名字来源于由<a href="https://zh.wikipedia.org/w/index.php?title=%E8%A9%B9%E5%A7%86%E6%96%AF%C2%B7%E6%83%A0%E7%89%B9%E7%A7%91%E5%A7%86%C2%B7%E8%8E%B1%E5%88%A9&amp;action=edit&amp;redlink=1">詹姆斯·惠特科姆·莱利</a>提出的<a href="https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E6%B5%8B%E8%AF%95">鸭子测试</a>（见下面的“<a href="https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B#%E5%8E%86%E5%8F%B2">历史</a>”章节），“鸭子测试”可以这样表述：</p>
<p>​	“<strong>当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。</strong>”</p>
<ul>
<li>在鸭子类型中，关注点在于对象的行为，能作什么；而不是关注对象所属的类型。例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为&quot;鸭子&quot;的对象，并调用它的&quot;走&quot;和&quot;叫&quot;方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的&quot;走&quot;和&quot;叫&quot;方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的&quot;走&quot;和&quot;叫&quot;方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。</li>
<li><strong>鸭子类型通常得益于&quot;不&quot;测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。</strong></li>
<li>在常规类型中，我们能否在一个特定场景中使用某个对象取决于这个对象的类型，而在鸭子类型中，则取决于这个对象是否具有某种属性或者方法——即只要具备特定的属性或方法，能通过鸭子测试，就可以使用。</li>
</ul>
<h2 id="多态">多态</h2>
<p>为什么会在鸭子类型中去介绍多态这个东西，众所周知，面向对象编程的三大特点 <code>继承</code>、<code>封装</code>、<code>多态</code></p>
<blockquote>
<p>所谓<strong>多态</strong>：就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Customer = namedtuple(<span class="string">&#x27;Customer&#x27;</span>, <span class="string">&#x27;name fidelity&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LineItem</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;订单中单个商品的数量和单价&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, product, quantity, price</span>):</span><br><span class="line">        self.product = product</span><br><span class="line">        self.quantity = quantity</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">total</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.price * self.quantity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;订单&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, customer, cart, promotion=<span class="literal">None</span></span>):</span><br><span class="line">        self.customer = customer</span><br><span class="line">        self.cart = <span class="built_in">list</span>(cart)</span><br><span class="line">        self.promotion = promotion</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">total</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(self, <span class="string">&#x27;__total&#x27;</span>):</span><br><span class="line">            self.__total = <span class="built_in">sum</span>(item.total() <span class="keyword">for</span> item <span class="keyword">in</span> self.cart)</span><br><span class="line">        <span class="keyword">return</span> self.__total</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">due</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.promotion <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            discount = self.promotion.discount(self)</span><br><span class="line">        <span class="keyword">return</span> self.total() - discount</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        fmt = <span class="string">&#x27;&lt;订单 总价: &#123;:.2f&#125; 实付: &#123;:.2f&#125;&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> fmt.<span class="built_in">format</span>(self.total(), self.due())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promotion</span>(<span class="title class_ inherited__">ABC</span>):  <span class="comment"># 策略：抽象基类</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">discount</span>(<span class="params">self, order</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回折扣金额（正值）&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FidelityPromo</span>(<span class="title class_ inherited__">Promotion</span>):  <span class="comment"># 第一个具体策略</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;为积分为1000或以上的顾客提供5%折扣&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">discount</span>(<span class="params">self, order</span>):</span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">0.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BulkItemPromo</span>(<span class="title class_ inherited__">Promotion</span>):  <span class="comment"># 第二个具体策略</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;单个商品为20个或以上时提供10%折扣&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">discount</span>(<span class="params">self, order</span>):</span><br><span class="line">        discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">            <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">                discount += item.total() * <span class="number">0.1</span></span><br><span class="line">        <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LargeOrderPromo</span>(<span class="title class_ inherited__">Promotion</span>):  <span class="comment"># 第三个具体策略</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;订单中的不同商品达到10个或以上时提供7%折扣&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">discount</span>(<span class="params">self, order</span>):</span><br><span class="line">        distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> order.total() * <span class="number">0.07</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">joe = Customer(<span class="string">&#x27;John Doe&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">ann = Customer(<span class="string">&#x27;Ann Smith&#x27;</span>, <span class="number">1100</span>)</span><br><span class="line"></span><br><span class="line">cart = [LineItem(<span class="string">&#x27;banana&#x27;</span>, <span class="number">4</span>, <span class="number">0.5</span>),</span><br><span class="line">        LineItem(<span class="string">&#x27;apple&#x27;</span>, <span class="number">10</span>, <span class="number">1.5</span>),</span><br><span class="line">        LineItem(<span class="string">&#x27;watermellon&#x27;</span>, <span class="number">5</span>, <span class="number">5.0</span>)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;策略一：为积分为1000或以上的顾客提供5%折扣&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(Order(joe, cart, FidelityPromo()))</span><br><span class="line"><span class="built_in">print</span>(Order(ann, cart, FidelityPromo()))</span><br><span class="line"></span><br><span class="line">banana_cart = [LineItem(<span class="string">&#x27;banana&#x27;</span>, <span class="number">30</span>, <span class="number">0.5</span>),</span><br><span class="line">               LineItem(<span class="string">&#x27;apple&#x27;</span>, <span class="number">10</span>, <span class="number">1.5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;策略二：单个商品为20个或以上时提供10%折扣&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(Order(joe, banana_cart, BulkItemPromo()))</span><br><span class="line"></span><br><span class="line">long_order = [LineItem(<span class="built_in">str</span>(item_code), <span class="number">1</span>, <span class="number">1.0</span>) <span class="keyword">for</span> item_code <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;策略三：订单中的不同商品达到10个或以上时提供7%折扣&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(Order(joe, long_order, LargeOrderPromo()))</span><br><span class="line"><span class="built_in">print</span>(Order(joe, cart, LargeOrderPromo()))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先要有一个接口（<code>Promotion</code>），然后各个策略去实现这个接口。然而，<strong>Python 语言没有 interface 关键字</strong>，就是说，Python 里没有像 java、C# 一样的接口。</p>
<p>在上面策略模式代码示例中，使用了<strong>抽象基类</strong>（Abstract Base Class，ABC）来实现接口，<em>这主要是为了写法上看起来和 java、C# 等语言更加的像，易于有这些语言基础的同学理解和对比</em>。</p>
<p>抽象基类是在 Python 语言诞生 15 年后，Python 2.6 才引入的。这里我们不详细介绍抽象基类，因为<strong>即便现在也很少有代码使用抽象基类</strong>。对于多态，Python 有更好的实现方式——<strong>鸭子类型</strong>（duck typing）。</p>
<span id="more"></span>
<h2 id="协议和鸭子类型">协议和鸭子类型</h2>
<blockquote>
<p>所谓 <strong>鸭子类型</strong> 就是：如果一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么它就是鸭子。这个概念的名字来源于 James Whitcomb Riley 提出的鸭子测试。</p>
</blockquote>
<p>初次看到这个描述的小伙伴一定一头雾水，为了理解鸭子类型，我们不得不提到另一个名词——协议。</p>
<blockquote>
<p><strong>在面向对象编程中，协议是非正式的接口，是一组方法，只由文档和约定定义，因此，协议不能像正式接口那样施加强制性约束。而 Python 的哲学就是尽量支持基本协议。</strong></p>
</blockquote>
<p>翻译成人话，就是：<strong>Python 中没有接口，在需要使用接口的地方，就用协议代替</strong>。所谓协议，其实就是一组方法，和接口中定义的方法一个意思。只不过协议不是强制性的约定，如果你不遵守协议，那么也没关系，运行时报错就是了。这样就好理解鸭子类型了，“如果一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子” 这就表示已经遵守了协议，“那么它就是鸭子”，意味着你可以在其他用到“鸭子”的地方，用“这只鸟”替换。这不就是多态吗！用“鸭子类型”来实现策略模式也很简单，删掉抽象基类就可以了。（这就是为什么抽象基类很少使用的原因，因为删掉代码也一样正确啊。）</p>
<p>如果你学的是<code>JAVA</code>或者<code>C++</code>等静态语言，可能对鸭子类型的理解没那么深刻，因为静态语言中对象的特性取决于其父类。而动态语言则不一样，比如迭代器，任何实现了 <code>__iter__ </code>和 <code>__next__ </code>方法的对象都可称之为迭代器，但对象本身是什么类型不受限制，可以自定义为任何类。</p>
<blockquote>
<p><strong>鸭子类型依赖文档、清晰的代码和测试来确保正确使用</strong> 。这既是优点也是缺点，缺点是需要通过文档才能知道参数类型，为了弥补这方面的不足，Python3.6 引入了类型信息，定义变量的时候可以指定类型</p>
</blockquote>
<h2 id="总结">总结</h2>
<ul>
<li>鸭子类型是编程语言中动态类型语言中的一种设计风格，一个对象的特征不是由父类决定，而是通过对象的方法决定的。</li>
<li>我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。</li>
</ul>
<blockquote>
<p>原文参考：<a href="https://juejin.cn/post/6844903825489264653">https://juejin.cn/post/6844903825489264653</a></p>
</blockquote>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Django的logger配置</title>
    <url>/2023/02/06/Django%E7%9A%84logger/</url>
    <content><![CDATA[<h1>Django日志配置</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LOGGING = &#123;</span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&#x27;formatters&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;verbose&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;%(levelname)s %(asctime)s %(pathname)s %(module)s %(lineno)s %(process)d %(thread)d %(message)s&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;loggers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;django&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;default&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filters&#x27;</span>: [<span class="string">&#x27;special&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;handlers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.handlers.RotatingFileHandler&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filename&#x27;</span>: <span class="string">&#x27;/var/logs/django/default.log&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;maxBytes&#x27;</span>: <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>,</span><br><span class="line">            <span class="string">&#x27;backupCount&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;verbose&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filters&#x27;</span>: [<span class="string">&#x27;special&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;filters&#x27;</span>: &#123;  <span class="comment"># 过滤器</span></span><br><span class="line">        <span class="string">&#x27;special&#x27;</span>: &#123;  <span class="comment"># 使用自定义的web.my_logging.ContextFilter，别名special，可以接受其他的参数</span></span><br><span class="line">            <span class="string">&#x27;()&#x27;</span>: <span class="string">&#x27;web.my_logging.ContextFilter&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置分析说明">配置分析说明</h2>
<h3 id="version"><strong>version</strong></h3>
<p>保留字。</p>
<h3 id="disable-existing-loggers"><strong>disable_existing_loggers</strong></h3>
<p>是否禁用已经存在的logger实例。</p>
<ul>
<li>
<p>如果<code>LOGGING</code> 中的<code>disable_existing_loggers</code> 键为<code>True</code>（默认值），那么默认配置中的所有logger 都将禁用。</p>
</li>
<li>
<p>Logger 的禁用与删除不同；logger 仍然存在，但是将默默丢弃任何传递给它的信息，也不会传播给上一级logger。所以，你应该非常小心使用<code>'disable_existing_loggers': True</code>；它可能不是你想要的。你可以设置<code>disable_existing_loggers</code> 为<code>False</code>，并重新定义部分或所有的默认loggers；或者你可以设置<code>LOGGING_CONFIG</code> 为 <code>None</code>，并 <em>自己处理logging 配置</em>。</p>
</li>
<li>
<p>Logging 的配置属于Django <code>setup()</code> 函数的一部分。所以，你可以肯定在你的项目代码中logger 是永远可用的。</p>
</li>
</ul>
<h3 id="formatters"><strong>formatters</strong></h3>
<p>定义输出的日志格式。<br>
常用的格式化属性：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="string">%(name)</span>s <span class="title class_">Logger</span>的名字</span><br><span class="line"><span class="string">%(levelname)</span>s 文本形式的日志级别</span><br><span class="line"><span class="string">%(message)</span>s 用户输出的消息</span><br><span class="line"><span class="string">%(asctime)</span>s 字符串形式的当前时间。默认格式是 “<span class="number">2003</span>-<span class="number">07</span>-08 <span class="number">16</span><span class="symbol">:</span><span class="number">49</span><span class="symbol">:</span><span class="number">45</span>,<span class="number">896</span>”。逗号后面的是毫秒</span><br><span class="line"><span class="string">%(levelno)</span>s 数字形式的日志级别</span><br><span class="line"><span class="string">%(pathname)</span>s 调用日志输出函数的模块的完整路径名，可能没有</span><br><span class="line"><span class="string">%(filename)</span>s 调用日志输出函数的模块的文件名</span><br><span class="line"><span class="string">%(module)</span>s  调用日志输出函数的模块名</span><br><span class="line"><span class="string">%(funcName)</span>s 调用日志输出函数的函数名</span><br><span class="line"><span class="string">%(lineno)</span>d 调用日志输出函数的语句所在的代码行</span><br><span class="line"><span class="string">%(created)</span>f 当前时间，用<span class="variable constant_">UNIX</span>标准的表示时间的浮 点数表示</span><br><span class="line"><span class="string">%(relativeCreated)</span>d 输出日志信息时的，自<span class="title class_">Logger</span>创建以 来的毫秒数</span><br><span class="line"><span class="string">%(thread)</span>d 线程<span class="variable constant_">ID</span>。可能没有</span><br><span class="line"><span class="string">%(threadName)</span>s 线程名。可能没有</span><br><span class="line"><span class="string">%(process)</span>d 进程<span class="variable constant_">ID</span>。可能没有</span><br></pre></td></tr></table></figure>
<p>其他格式化属性请参 <a href="https://docs.python.org/3/library/logging.html#logrecord-attributes">LogRecord attributes</a></p>
<span id="more"></span>
<h3 id="handlers"><strong>handlers</strong></h3>
<p>处理器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;handlers&#x27;</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.handlers.RotatingFileHandler&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;filename&#x27;</span>: <span class="string">&#x27;/var/logs/django/default.log&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;maxBytes&#x27;</span>: 1024 * 1024 * 5,</span><br><span class="line">        <span class="string">&#x27;backupCount&#x27;</span>: 5,</span><br><span class="line">        <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;verbose&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;filters&#x27;</span>: [<span class="string">&#x27;special&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>key为处理器名，values为处理器配置。</p>
</li>
<li>
<p>level：日志处理级别。</p>
</li>
<li>
<p>formatter： 这个参数对应<code>formatters</code>。</p>
</li>
<li>
<p>filters： 对应后面的 <code>filters</code>。</p>
</li>
<li>
<p>class：处理类。常用的有：<code>NullHandler</code>(无任何操作，相当于丢弃日志)，<code>FileHandler</code>(输出到磁盘文件)等。其他处理类请看 <a href="https://docs.python.org/3/library/logging.handlers.html">https://docs.python.org/3/library/logging.handlers.html</a></p>
</li>
<li>
<p>filename：记录日志的文件名。</p>
</li>
<li>
<p>maxBytes：文件最大字节数。</p>
</li>
<li>
<p>backupCount：最大扩展数。这个是和maxBytes一起使用的。例如当日志文件 pro.log 达到最大字节数，那么就会扩展一个文件pro.log.1文件继续记录日志， 依次扩展，达到backupCount的设定值，例如为5，那么到pro.log.5后，后面的日志会再次记入 pro.log文件，相当于轮询。</p>
</li>
</ul>
<h3 id="loggers"><strong>loggers</strong></h3>
<p>定义logger实例。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;loggers&#x27;</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;django&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;default&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;propagate&#x27;</span>: True,</span><br><span class="line">        <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;filters&#x27;</span>: [<span class="string">&#x27;special&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>handlers：对应的handles对象列表。</p>
</li>
<li>
<p>level：logger实例输出的日志级别，但是这个级别并不是最终输出日志的级别，还有根据handlers的级别进行判断，两个level中取级别高的。DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</p>
</li>
<li>
<p>propagate：日志是否向上级传递。True 向上级传，False 不向上级传。默认为True。</p>
</li>
<li>
<p>filters： 对应后面的 <code>filters</code>。<br>
更详细说明请参照：<a href="https://docs.python.org/3/library/logging.html#logrecord-attributes">https://docs.python.org/3/library/logging.html#logrecord-attributes</a></p>
</li>
</ul>
<h3 id="filters"><strong>filters</strong></h3>
<ul>
<li>过滤器。过滤器用来对传递给 Logger 或者 Handler 的日志信息提供附加的控制。</li>
<li>默认情况下，所有满足级别的日志信息都会被处理，但是我们可以通过 filter 来过滤掉 CRITICAL 级别的日志，然后仅允许 ERROR 级别的日志通过。</li>
<li>filter 也可以被用来对前面被忽略掉的日志进行修改，例如，我们可以在一定条件下将 ERROR 日志降级为 WARNING 日志。</li>
<li>过滤器可以安装在 logger 或者 handler 上，多个过滤器可以形成一个链来接连产生作用。</li>
</ul>
<p>配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;filters&#x27;</span>: &#123;  <span class="comment"># 过滤器</span></span><br><span class="line">    <span class="string">&#x27;special&#x27;</span>: &#123;  </span><br><span class="line">    <span class="comment"># 使用自定义的web.my_logging.ContextFilter，别名special，可以接受其他的参数</span></span><br><span class="line">        <span class="string">&#x27;()&#x27;</span>: <span class="string">&#x27;web.my_logging.ContextFilter&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义Filter：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContextFilter</span>(logging.Filter):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This is a filter which injects contextual information into the log.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Rather than use actual contextual information, we just use random</span></span><br><span class="line"><span class="string">    data in this demo.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    USERS = [<span class="string">&#x27;jim&#x27;</span>, <span class="string">&#x27;fred&#x27;</span>, <span class="string">&#x27;sheila&#x27;</span>]</span><br><span class="line">    IPS = [<span class="string">&#x27;123.231.231.123&#x27;</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="string">&#x27;192.168.0.1&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">filter</span>(<span class="params">self, record</span>):</span><br><span class="line">        record.ip = choice(ContextFilter.IPS)</span><br><span class="line">        record.user = choice(ContextFilter.USERS)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>可以不定义类，直接定义函数，返回True表示</p>
]]></content>
      <categories>
        <category>Django框架</category>
      </categories>
      <tags>
        <tag>日志logger</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法和LRU</title>
    <url>/2023/02/06/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%92%8CLRU/</url>
    <content><![CDATA[<h1>回溯算法实现（DFS）</h1>
<blockquote>
<p>回溯算法其实就是我们常说的 DFS 算法，本质上就是一种暴力穷举算法</p>
</blockquote>
<h2 id="递归遍历二叉树">递归遍历二叉树</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">back_track</span>(<span class="params">nums, track, res</span>):</span><br><span class="line">    <span class="comment"># 结束条件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums)== <span class="built_in">len</span>(track):</span><br><span class="line">        <span class="comment"># res.extend(track) # 正常</span></span><br><span class="line">        res.append(track)<span class="comment"># 不正常</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 遍历选择列表</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> track:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        track.append(num)</span><br><span class="line">        back_track(nums, track.copy(), res)</span><br><span class="line">        track.pop()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums =[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    track =[]</span><br><span class="line">    res =[]</span><br><span class="line">    back_track(nums, track, res)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<ul>
<li>某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。</li>
</ul>
<h1>LRU（Least recently used）算法实现</h1>
<blockquote>
<p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>
</blockquote>
<h2 id="算法步骤">算法步骤</h2>
<ol>
<li>新数据插入到链表头部</li>
<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li>
<li>当链表满的时候，将链表尾部的数据丢弃。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 新数据插入到链表头部</span></span><br><span class="line"><span class="comment"># 2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部</span></span><br><span class="line"><span class="comment"># 3. 当链表满的时候，将链表尾部的数据丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lru</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, queen_length: <span class="built_in">int</span></span>):</span><br><span class="line">        self.queen_length = queen_length</span><br><span class="line">        self.queen = deque(maxlen=self.queen_length)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_or_put</span>(<span class="params">self, element</span>):</span><br><span class="line">        <span class="comment"># assert len(self.queen) == 0, &quot;Queen is Empty.&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 命中元素</span></span><br><span class="line">            index = self.queen.index(element)</span><br><span class="line">            <span class="keyword">return</span> self.queen[index]</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            self.queen = self._put(element)</span><br><span class="line">            <span class="keyword">return</span> self.get_or_put(element)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_put</span>(<span class="params">self, element</span>):</span><br><span class="line">        <span class="comment"># deque 自带了增加淘汰策略，暂不用考虑队满和队空的情况</span></span><br><span class="line">        self.queen.appendleft(element)</span><br><span class="line">        <span class="keyword">return</span> self.queen</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lru = Lru(<span class="number">3</span>)</span><br><span class="line">    res = lru.get_or_put(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    <span class="built_in">print</span>(lru.queen)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法演练</category>
      </categories>
      <tags>
        <tag>回溯算法和LRU</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的asyncio(协程)</title>
    <url>/2023/02/06/python%E4%B9%8Basyncio%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>本文转载自:<a href="https://pythonav.com/wiki/detail/6/91/">https://pythonav.com/wiki/detail/6/91/</a></p>
</blockquote>
<h2 id="1-协程">1.协程</h2>
<p>协程（Coroutine），也可以被称为微线程，是一种用户态内的上下文切换技术。简而言之，其实就是通过一个线程实现代码块相互切换执行。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():    </span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>)    </span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():    </span><br><span class="line">  <span class="built_in">print</span>(<span class="number">3</span>)    </span><br><span class="line">  ...    </span><br><span class="line">  <span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">func1()</span><br><span class="line">func2()</span><br></pre></td></tr></table></figure>
<p>上述代码是普通的函数定义和执行，按流程分别执行两个函数中的代码，并先后会输出：<code>1、2、3、4</code>。但如果介入协程技术那么就可以实现函数见代码切换执行，最终输入：<code>1、3、2、4</code> 。</p>
<p>在Python中有多种方式可以实现协程，例如：</p>
<ul>
<li><code>greenlet</code>，是一个第三方模块，用于实现协程代码（Gevent协程就是基于greenlet实现）</li>
<li><code>yield</code>，生成器，借助生成器的特点也可以实现协程代码。</li>
<li><code>asyncio</code>，在Python3.4中引入的模块用于编写协程代码。</li>
<li><code>async &amp; awiat</code>，在Python3.5中引入的两个关键字，结合asyncio模块可以更方便的编写协程代码。</li>
</ul>
<h3 id="1-1-greenlet">1.1 greenlet</h3>
<p>greentlet是一个第三方模块，需要提前安装 <code>pip3 install greenlet</code>才能使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():    </span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>)        <span class="comment"># 第1步：输出 1    </span></span><br><span class="line">  gr2.switch()    <span class="comment"># 第3步：切换到 func2 函数    </span></span><br><span class="line">  <span class="built_in">print</span>(<span class="number">2</span>)        <span class="comment"># 第6步：输出 2    </span></span><br><span class="line">  gr2.switch()    <span class="comment"># 第7步：切换到 func2 函数，从上一次执行的位置继续向后执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():    </span><br><span class="line">  <span class="built_in">print</span>(<span class="number">3</span>)        <span class="comment"># 第4步：输出 3    </span></span><br><span class="line">  gr1.switch()    <span class="comment"># 第5步：切换到 func1 函数，从上一次执行的位置继续向后执行    </span></span><br><span class="line">  <span class="built_in">print</span>(<span class="number">4</span>)        <span class="comment"># 第8步：输出 4</span></span><br><span class="line">gr1 = greenlet(func1)</span><br><span class="line">gr2 = greenlet(func2)</span><br><span class="line"></span><br><span class="line">gr1.switch() <span class="comment"># 第1步：去执行 func1 函数</span></span><br></pre></td></tr></table></figure>
<p>注意：switch中也可以传递参数用于在切换执行时相互传递值。</p>
<h3 id="1-2-yield">1.2 yield</h3>
<p>基于Python的生成器的yield和yield form关键字实现协程代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():    </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>    </span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">from</span> func2()    </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():    </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>    </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">f1 = func1()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> f1:    </span><br><span class="line">  <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>
<p>注意：yield form关键字是在Python3.3中引入的。</p>
<h3 id="1-3-asyncio">1.3 asyncio</h3>
<p>在Python3.4之前官方未提供协程的类库，一般大家都是使用greenlet等其他来实现。在<code>Python3.4</code>发布后官方正式支持协程，即：asyncio模块。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():    </span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>)    </span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">2</span>)  <span class="comment"># 遇到IO耗时操作，自动化切换到tasks中的其他任务    </span></span><br><span class="line">  <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():    </span><br><span class="line">  <span class="built_in">print</span>(<span class="number">3</span>)    </span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">2</span>) <span class="comment"># 遇到IO耗时操作，自动化切换到tasks中的其他任务    </span></span><br><span class="line">  <span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">tasks = [asyncio.ensure_future( func1() ),    asyncio.ensure_future( func2() )]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>
<p>注意：基于asyncio模块实现的协程比之前的要更厉害，因为他的内部还集成了遇到IO耗时操作自动切花的功能。</p>
<h3 id="1-4-async-awit">1.4 async &amp; awit</h3>
<p>async &amp; awit 关键字在Python3.5版本中正式引入，基于他编写的协程代码其实就是 上一示例 的加强版，让代码可以更加简便。</p>
<p>Python3.8之后 <code>@asyncio.coroutine</code> 装饰器就会被移除，推荐使用async &amp; awit 关键字实现协程代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func1</span>():    </span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>)    </span><br><span class="line">  <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)    </span><br><span class="line">  <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>():    </span><br><span class="line">  <span class="built_in">print</span>(<span class="number">3</span>)    </span><br><span class="line">  <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)    </span><br><span class="line">  <span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">tasks = [ asyncio.ensure_future(func1()),    asyncio.ensure_future(func2())]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>
<h3 id="1-5-小结">1.5 小结</h3>
<p>关于协程有多种实现方式，目前主流使用是Python官方推荐的asyncio模块和async&amp;await关键字的方式，例如：在tonado、sanic、fastapi、django3 中均已支持。</p>
<p>接下来，我们也会针对 <code>asyncio模块</code> + <code>async &amp; await</code> 关键字进行更加详细的讲解。</p>
<span id="more"></span>
<h2 id="2-协程的意义">2.协程的意义</h2>
<p>通过学习，我们已经了解到协程可以通过一个线程在多个上下文中进行来回切换执行。</p>
<p><strong>但是</strong>，协程来回切换执行的意义何在呢？（网上看到很多文章舔协程，协程牛逼之处是哪里呢？）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">计算型的操作，利用协程来回切换执行，没有任何意义，来回切换并保存状态 反倒会降低性能。</span><br><span class="line">IO型的操作，利用协程在IO等待时间就去切换执行其他任务，当IO操作结束后再自动回调，那么就会大大节省资源并提供性能，从而实现异步编程（不等待任务结束就可以去执行其他代码）。</span><br></pre></td></tr></table></figure>
<h3 id="2-1-爬虫案例">2.1 爬虫案例</h3>
<p>例如：用代码实现下载 <code>url_list</code> 中的图片。</p>
<ul>
<li>
<p>方式一：同步编程实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;下载图片使用第三方模块requests，请提前安装：pip3 install requests&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_image</span>(<span class="params">url</span>):    </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;开始下载:&quot;</span>,url)    </span><br><span class="line">    <span class="comment"># 发送网络请求，下载图片    </span></span><br><span class="line">  response = requests.get(url)    </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;下载完成&quot;</span>)    </span><br><span class="line">  <span class="comment"># 图片保存到本地文件    </span></span><br><span class="line">  file_name = url.rsplit(<span class="string">&#x27;_&#x27;</span>)[-<span class="number">1</span>]    </span><br><span class="line">  <span class="keyword">with</span> <span class="built_in">open</span>(file_name, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">      file_object.write(response.content)</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:    </span><br><span class="line">   url_list = [        <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg&#x27;</span>,        <span class="string">&#x27;https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg&#x27;</span>,        <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg&#x27;</span>    ]    </span><br><span class="line">   <span class="keyword">for</span> item <span class="keyword">in</span> url_list:        </span><br><span class="line">     download_image(item)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方式二：基于协程的异步编程实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;下载图片使用第三方模块aiohttp，请提前安装：pip3 install aiohttp&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python# </span></span><br><span class="line">-*- coding:utf-<span class="number">8</span> -*-</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch</span>(<span class="params">session, url</span>):    </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;发送请求：&quot;</span>, url)    </span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, verify_ssl=<span class="literal">False</span>) <span class="keyword">as</span> response:</span><br><span class="line">      content = <span class="keyword">await</span> response.content.read()        </span><br><span class="line">    file_name = url.rsplit(<span class="string">&#x27;_&#x27;</span>)[-<span class="number">1</span>]        </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">      file_object.write(content)<span class="keyword">async</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():    </span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">      url_list = [            <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg&#x27;</span>,            <span class="string">&#x27;https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg&#x27;</span>,            <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg&#x27;</span>        ]        </span><br><span class="line">      tasks = [asyncio.create_task(fetch(session, url)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:    </span><br><span class="line">  asyncio.run(main())</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上述两种的执行对比之后会发现，<code>基于协程的异步编程</code> 要比 <code>同步编程</code>的效率高了很多。因为：</p>
<ul>
<li>同步编程，按照顺序逐一排队执行，如果图片下载时间为2分钟，那么全部执行完则需要6分钟。</li>
<li>异步编程，几乎同时发出了3个下载任务的请求（遇到IO请求自动切换去发送其他任务请求），如果图片下载时间为2分钟，那么全部执行完毕也大概需要2分钟左右就可以了。</li>
</ul>
<h3 id="2-2-小结">2.2 小结</h3>
<p>协程一般应用在有IO操作的程序中，因为协程可以利用IO等待的时间去执行一些其他的代码，从而提升代码执行效率。</p>
<p>生活中不也是这样的么，假设 你是一家制造汽车的老板，员工点击设备的【开始】按钮之后，在设备前需等待30分钟，然后点击【结束】按钮，此时作为老板的你一定希望这个员工在等待的那30分钟的时间去做点其他的工作。</p>
<h2 id="3-异步编程">3.异步编程</h2>
<p>基于<code>async</code> &amp; <code>await</code>关键字的协程可以实现异步编程，这也是目前python异步相关的主流技术。</p>
<p>想要真正的了解Python中内置的异步编程，根据下文的顺序一点点来看。</p>
<h3 id="3-1-事件循环">3.1 事件循环</h3>
<p>事件循环，可以把他当做是一个while循环，这个while循环在周期性的运行并执行一些<code>任务</code>，在特定条件下终止循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 伪代码任务列表 = [ 任务1, 任务2, 任务3,... ]</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:    </span><br><span class="line">  可执行的任务列表，已完成的任务列表 = 去任务列表中检查所有的任务，将<span class="string">&#x27;可执行&#x27;</span>和<span class="string">&#x27;已完成&#x27;</span>的任务返回    </span><br><span class="line">  <span class="keyword">for</span> 就绪任务 <span class="keyword">in</span> 已准备就绪的任务列表:</span><br><span class="line">      执行已就绪的任务    </span><br><span class="line">    <span class="keyword">for</span> 已完成的任务 <span class="keyword">in</span> 已完成的任务列表:</span><br><span class="line">        在任务列表中移除 已完成的任务</span><br><span class="line">      如果 任务列表 中的任务都已完成，则终止循环</span><br></pre></td></tr></table></figure>
<p>在编写程序时候可以通过如下代码来获取和创建事件循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncioloop = asyncio.get_event_loop()</span><br></pre></td></tr></table></figure>
<h3 id="3-2-协程和异步编程">3.2 协程和异步编程</h3>
<p>协程函数，定义形式为 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def"><code>async def</code></a> 的函数。</p>
<p>协程对象，调用 <em>协程函数</em> 所返回的对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个协程函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():    </span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 调用协程函数，返回一个协程对象  </span></span><br><span class="line">result = func()</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：调用协程函数时，函数内部代码不会执行，只是会返回一个协程对象。</p>
<h4 id="3-2-1-基本应用">3.2.1 基本应用</h4>
<p>程序中，如果想要执行协程函数的内部代码，需要 <code>事件循环</code> 和 <code>协程对象</code> 配合才能实现，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;协程内部代码&quot;</span>)</span><br><span class="line">  <span class="comment"># 调用协程函数，返回一个协程对象。</span></span><br><span class="line">  result = func()</span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line"><span class="comment"># loop = asyncio.get_event_loop() # 创建一个事件循环</span></span><br><span class="line"><span class="comment"># loop.run_until_complete(result) # 将协程当做任务提交到事件循环的任务列表中，协程执行完成之后终止。</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line"><span class="comment"># 本质上方式一是一样的，内部先 创建事件循环 然后执行 run_until_complete，一个简便的写法。</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># asyncio.run 函数在 Python 3.7 中加入 asyncio 模块，</span></span><br><span class="line">asyncio.run(result)</span><br></pre></td></tr></table></figure>
<p>这个过程可以简单理解为：将<code>协程</code>当做任务添加到 <code>事件循环</code> 的任务列表，然后事件循环检测列表中的<code>协程</code>是否 已准备就绪（默认可理解为就绪状态），如果准备就绪则执行其内部代码。</p>
<h4 id="3-2-2-await">3.2.2 await</h4>
<p>await是一个只能在协程函数中使用的关键字，用于遇到IO操作时挂起 当前协程（任务），当前协程（任务）挂起过程中 事件循环可以去执行其他的协程（任务），当前协程IO处理完成时，可以再次切换回来执行await之后的代码。代码如下：</p>
<p><strong>示例1：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():    </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;执行协程函数内部代码&quot;</span>)</span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。</span></span><br><span class="line">    <span class="comment"># 当前协程挂起时，事件循环可以去执行其他协程（任务）。</span></span><br><span class="line">    response = <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response)</span><br><span class="line"></span><br><span class="line">result = func()asyncio.run(result)</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">others</span>():    </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)    </span><br><span class="line">  <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;返回值&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;执行协程函数内部代码&quot;</span>)</span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。        </span></span><br><span class="line">    response = <span class="keyword">await</span> others()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response)</span><br><span class="line"></span><br><span class="line">asyncio.run( func() )</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">others</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;返回值&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;执行协程函数内部代码&quot;</span>)</span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。        </span></span><br><span class="line">    response1 = <span class="keyword">await</span> others()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response1)</span><br><span class="line">    response2 = <span class="keyword">await</span> others()    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response2)</span><br><span class="line"></span><br><span class="line">asyncio.run( func() )</span><br></pre></td></tr></table></figure>
<p>上述的所有示例都只是创建了一个任务，即：事件循环的任务列表中只有一个任务，所以在IO等待时无法演示切换到其他任务效果。</p>
<p>在程序想要创建多个任务对象，需要使用Task对象来实现。</p>
<h4 id="3-2-3-Task对象">3.2.3 Task对象</h4>
<blockquote>
<p><em>Tasks</em> are used to schedule coroutines <em>concurrently</em>.</p>
<p>When a coroutine is wrapped into a <em>Task</em> with functions like <a href="https://docs.python.org/3.8/library/asyncio-task.html#asyncio.create_task"><code>asyncio.create_task()</code></a> the coroutine is automatically scheduled to run soon。</p>
</blockquote>
<p>Tasks用于并发调度协程，通过<code>asyncio.create_task(协程对象)</code>的方式创建Task对象，这样可以让协程加入事件循环中等待被调度执行。除了使用 <code>asyncio.create_task()</code> 函数以外，还可以用低层级的 <code>loop.create_task()</code> 或 <code>ensure_future()</code> 函数。不建议手动实例化 Task 对象。</p>
<p>本质上是将协程对象封装成task对象，并将协程立即加入事件循环，同时追踪协程的状态。</p>
<p>注意：<code>asyncio.create_task()</code> 函数在 Python 3.7 中被加入。在 Python 3.7 之前，可以改用低层级的 <code>asyncio.ensure_future()</code> 函数。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;返回值&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;main开始&quot;</span>)</span><br><span class="line">    <span class="comment"># 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。</span></span><br><span class="line">    task1 = asyncio.create_task(func())</span><br><span class="line">    <span class="comment"># 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。</span></span><br><span class="line">    task2 = asyncio.create_task(func())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main结束&quot;</span>)</span><br><span class="line">    <span class="comment"># 当执行某协程遇到IO操作时，会自动化切换执行其他任务。</span></span><br><span class="line">    <span class="comment"># 此处的await是等待相对应的协程全都执行完毕并获取结果</span></span><br><span class="line">    ret1 = <span class="keyword">await</span> task1    </span><br><span class="line">    ret2 = <span class="keyword">await</span> task2    </span><br><span class="line">    <span class="built_in">print</span>(ret1, ret2)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():    </span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>)    </span><br><span class="line">  <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)    </span><br><span class="line">  <span class="built_in">print</span>(<span class="number">2</span>)    </span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;返回值&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;main开始&quot;</span>)</span><br><span class="line">    <span class="comment"># 创建协程，将协程封装到Task对象中并添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。</span></span><br><span class="line">    <span class="comment"># 在调用    </span></span><br><span class="line">    task_list = [ asyncio.create_task(func(), name=<span class="string">&quot;n1&quot;</span>), asyncio.create_task(func(), name=<span class="string">&quot;n2&quot;</span>)]          </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main结束&quot;</span>)    </span><br><span class="line">    <span class="comment"># 当执行某协程遇到IO操作时，会自动化切换执行其他任务。    </span></span><br><span class="line">    <span class="comment"># 此处的await是等待所有协程执行完毕，并将所有协程的返回值保存到done    </span></span><br><span class="line">    <span class="comment"># 如果设置了timeout值，则意味着此处最多等待的秒，完成的协程返回值写入到done中，未完成则写到pending中。    </span></span><br><span class="line">    done, pending = <span class="keyword">await</span> asyncio.wait(task_list, timeout=<span class="literal">None</span>)    </span><br><span class="line">    <span class="built_in">print</span>(done, pending)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>注意：<code>asyncio.wait</code> 源码内部会对列表中的每个协程执行ensure_future从而封装为Task对象，所以在和wait配合使用时task_list的值为<code>[func(),func()]</code> 也是可以的。</p>
<p><strong>示例3：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;执行协程函数内部代码&quot;</span>)</span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。        </span></span><br><span class="line">    response = <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response)</span><br><span class="line"></span><br><span class="line">coroutine_list = [func(), func()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误：coroutine_list = [ asyncio.create_task(func()), asyncio.create_task(func()) ]  </span></span><br><span class="line"><span class="comment"># 此处不能直接 asyncio.create_task，因为将Task立即加入到事件循环的任务列表，</span></span><br><span class="line"><span class="comment"># 但此时事件循环还未创建，所以会报错。</span></span><br><span class="line"><span class="comment"># 使用asyncio.wait将列表封装为一个协程，并调用asyncio.run实现执行两个协程</span></span><br><span class="line"><span class="comment"># asyncio.wait内部会对列表中的每个协程执行ensure_future，封装为Task对象。</span></span><br><span class="line"></span><br><span class="line">done,pending = asyncio.run( asyncio.wait(coroutine_list) )</span><br></pre></td></tr></table></figure>
<h4 id="3-2-4-asyncio-Future对象">3.2.4 asyncio.Future对象</h4>
<blockquote>
<p>A <code>Future</code>is a special <strong>low-level</strong> awaitable object that represents an <strong>eventual result</strong> of an asynchronous operation.</p>
</blockquote>
<p>asyncio中的Future对象是一个相对更偏向底层的可对象，通常我们不会直接用到这个对象，而是直接使用Task对象来完成任务的并和状态的追踪。（ Task 是 Futrue的子类 ）</p>
<p>Future为我们提供了异步编程中的 最终结果 的处理（Task类也具备状态处理的功能）。</p>
<p>示例1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():    </span><br><span class="line">  <span class="comment"># 获取当前事件循环</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    <span class="comment"># # 创建一个任务（Future对象），这个任务什么都不干。</span></span><br><span class="line">    fut = loop.create_future()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待任务最终结果（Future对象），没有结果则会一直等下去。    </span></span><br><span class="line">    <span class="keyword">await</span> futasyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">set_after</span>(<span class="params">fut</span>):</span><br><span class="line">  <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    fut.set_result(<span class="string">&quot;666&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  <span class="comment"># 获取当前事件循环</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    <span class="comment"># 创建一个任务（Future对象），没绑定任何行为，则这个任务永远不知道什么时候结束。</span></span><br><span class="line">    fut = loop.create_future()</span><br><span class="line">    <span class="comment"># 创建一个任务（Task对象），绑定了set_after函数，函数内部在2s之后，会给fut赋值。</span></span><br><span class="line">    <span class="comment"># 即手动设置future任务的最终结果，那么fut就可以结束了。</span></span><br><span class="line">    <span class="keyword">await</span> loop.create_task(set_after(fut))</span><br><span class="line">    <span class="comment"># 等待 Future对象获取 最终结果，否则一直等下去</span></span><br><span class="line">    data = <span class="keyword">await</span> fut    </span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>Future对象本身函数进行绑定，所以想要让事件循环获取Future的结果，则需要手动设置。而Task对象继承了Future对象，其实就对Future进行扩展，他可以实现在对应绑定的函数执行完成之后，自动执行<code>set_result</code>，从而实现自动结束。</p>
<p>虽然，平时使用的是Task对象，但对于结果的处理本质是基于Future对象来实现的。</p>
<p>扩展：支持 <code>await 对象</code>语 法的对象课成为可等待对象，所以 <code>协程对象</code>、<code>Task对象</code>、<code>Future对象</code> 都可以被成为可等待对象。</p>
<h4 id="3-2-5-futures-Future对象">3.2.5 futures.Future对象</h4>
<p>在Python的<code>concurrent.futures</code>模块中也有一个Future对象，这个对象是基于线程池和进程池实现异步操作时使用的对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> Future</span><br><span class="line"><span class="keyword">from</span> concurrent.futures.thread <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> concurrent.futures.process <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">value</span>):    </span><br><span class="line">  time.sleep(<span class="number">1</span>)    </span><br><span class="line">  <span class="built_in">print</span>(value)</span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=<span class="number">5</span>)</span><br><span class="line">  <span class="comment"># 或 pool = ProcessPoolExecutor(max_workers=5)</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    fut = pool.submit(func, i)</span><br><span class="line">    <span class="built_in">print</span>(fut)</span><br></pre></td></tr></table></figure>
<p>两个Future对象是不同的，他们是为不同的应用场景而设计，例如：<code>concurrent.futures.Future</code>不支持await语法 等。</p>
<p>官方提示两对象之间不同：</p>
<ul>
<li>unlike asyncio Futures, <a href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.Future"><code>concurrent.futures.Future</code></a> instances cannot be awaited.</li>
<li><a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.result"><code>asyncio.Future.result()</code></a> and <a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.exception"><code>asyncio.Future.exception()</code></a> do not accept the <em>timeout</em> argument.</li>
<li><a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.result"><code>asyncio.Future.result()</code></a> and <a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.exception"><code>asyncio.Future.exception()</code></a> raise an <a href="https://docs.python.org/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError"><code>InvalidStateError</code></a> exception when the Future is not <em>done</em>.</li>
<li>Callbacks registered with <a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.add_done_callback"><code>asyncio.Future.add_done_callback()</code></a> are not called immediately. They are scheduled with <a href="https://docs.python.org/3.8/library/asyncio-eventloop.html#asyncio.loop.call_soon"><code>loop.call_soon()</code></a> instead.</li>
<li>asyncio Future is not compatible with the <a href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.wait"><code>concurrent.futures.wait()</code></a> and <a href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.as_completed"><code>concurrent.futures.as_completed()</code></a> functions.</li>
</ul>
<p>在Python提供了一个将<code>futures.Future</code> 对象包装成<code>asyncio.Future</code>对象的函数 <code>asynic.wrap_future</code>。</p>
<p>接下里你肯定问：为什么python会提供这种功能？</p>
<p>其实，一般在程序开发中我们要么统一使用 asycio 的协程实现异步操作、要么都使用进程池和线程池实现异步操作。但如果 <code>协程的异步</code>和 <code>进程池/线程池的异步</code> 混搭时，那么就会用到此功能了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">  <span class="comment"># 某个耗时操作</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;SB&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  loop = asyncio.get_running_loop()</span><br><span class="line">    <span class="comment"># 1. Run in the default loop&#x27;s executor ( 默认ThreadPoolExecutor )</span></span><br><span class="line">    <span class="comment"># 第一步：内部会先调用 ThreadPoolExecutor 的 submit 方法去线程池中申请一个线程去执行func1函数，并返回一个concurrent.futures.Future对象    </span></span><br><span class="line">    <span class="comment"># 第二步：调用asyncio.wrap_future将concurrent.futures.Future对象包装为asycio.Future对象。</span></span><br><span class="line">    <span class="comment"># 因为concurrent.futures.Future对象不支持await语法，所以需要包装为 asycio.Future对象 才能使用。</span></span><br><span class="line">    </span><br><span class="line">    fut = loop.run_in_executor(<span class="literal">None</span>, func1)</span><br><span class="line">    result = <span class="keyword">await</span> fut</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;default thread pool&#x27;</span>, result)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. Run in a custom thread pool:</span></span><br><span class="line">    <span class="comment"># with concurrent.futures.ThreadPoolExecutor() as pool:</span></span><br><span class="line">    <span class="comment">#     result = await loop.run_in_executor(    </span></span><br><span class="line">    <span class="comment">#     pool, func1)</span></span><br><span class="line">    <span class="comment">#     print(&#x27;custom thread pool&#x27;, result)    </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. Run in a custom process pool:    </span></span><br><span class="line">    <span class="comment"># with concurrent.futures.ProcessPoolExecutor() as pool:</span></span><br><span class="line">    <span class="comment">#     result = await loop.run_in_executor(    </span></span><br><span class="line">    <span class="comment">#         pool, func1)    </span></span><br><span class="line">    <span class="comment">#     print(&#x27;custom process pool&#x27;, result)</span></span><br><span class="line">    </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>应用场景：当项目以协程式的异步编程开发时，如果要使用一个第三方模块，而第三方模块不支持协程方式异步编程时，就需要用到这个功能，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">download_image</span>(<span class="params">url</span>):</span><br><span class="line">  <span class="comment"># 发送网络请求，下载图片（遇到网络下载图片的IO请求，自动化切换到其他任务）</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始下载:&quot;</span>, url)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># requests模块默认不支持异步操作，所以就使用线程池来配合实现了。</span></span><br><span class="line">    future = loop.run_in_executor(<span class="literal">None</span>, requests.get, url)</span><br><span class="line">    response = <span class="keyword">await</span> future</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;下载完成&#x27;</span>)</span><br><span class="line">    <span class="comment"># 图片保存到本地文件</span></span><br><span class="line">    file_name = url.rsplit(<span class="string">&#x27;_&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">      file_object.write(response.content)</span><br><span class="line">      </span><br><span class="line"> <span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   url_list = [        <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg&#x27;</span>,        <span class="string">&#x27;https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg&#x27;</span>,        <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg&#x27;</span>    ]    </span><br><span class="line">   tasks = [download_image(url) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]    </span><br><span class="line">   </span><br><span class="line">   loop = asyncio.get_event_loop()    </span><br><span class="line">   loop.run_until_complete( asyncio.wait(tasks) )</span><br></pre></td></tr></table></figure>
<h4 id="3-2-6-异步迭代器">3.2.6 异步迭代器</h4>
<p><strong>什么是异步迭代器</strong></p>
<p>实现了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aiter__"><code>__aiter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__anext__"><code>__anext__()</code></a> 方法的对象。<code>__anext__</code> 必须返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-awaitable">awaitable</a> 对象。<a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-for"><code>async for</code></a> 会处理异步迭代器的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__anext__"><code>__anext__()</code></a> 方法所返回的可等待对象，直到其引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopAsyncIteration"><code>StopAsyncIteration</code></a> 异常。由 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 引入。</p>
<p><strong>什么是异步可迭代对象？</strong></p>
<p>可在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-for"><code>async for</code></a> 语句中被使用的对象。必须通过它的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aiter__"><code>__aiter__()</code></a> 方法返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-iterator">asynchronous iterator</a>。由 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 引入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Reader</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 自定义异步迭代器（同时也是异步可迭代对象） &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">      self.count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">readline</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="comment"># await asyncio.sleep(1)</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.count == <span class="number">100</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__aiter__</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__anext__</span>(<span class="params">self</span>):</span><br><span class="line">      val = <span class="keyword">await</span> self.readline()</span><br><span class="line">        <span class="keyword">if</span> val == <span class="literal">None</span>:</span><br><span class="line">          <span class="keyword">raise</span> StopAsyncIteration</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="comment"># 创建异步可迭代对象</span></span><br><span class="line">    async_iter = Reader()</span><br><span class="line">    <span class="comment"># async for 必须要放在async def函数内，否则语法错误。</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> item <span class="keyword">in</span> async_iter:</span><br><span class="line">      <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line">asyncio.run(func())</span><br></pre></td></tr></table></figure>
<p>异步迭代器其实没什么太大的作用，只是支持了async for语法而已。</p>
<h4 id="3-2-6-异步上下文管理器">3.2.6 异步上下文管理器</h4>
<p>此种对象通过定义 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aenter__"><code>__aenter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aexit__"><code>__aexit__()</code></a> 方法来对 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-with"><code>async with</code></a> 语句中的环境进行控制。由 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 引入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncContextManager</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">      self.conn = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="comment"># 异步操作数据库</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">666</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__aenter__</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="comment"># 异步链接数据库</span></span><br><span class="line">        self.conn = <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__aexit__</span>(<span class="params">self, exc_type, exc, tb</span>):</span><br><span class="line">      <span class="comment"># 异步关闭数据库链接</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">   <span class="keyword">async</span> <span class="keyword">with</span> AsyncContextManager() <span class="keyword">as</span> f:</span><br><span class="line">      result = <span class="keyword">await</span> f.do_something()</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">asyncio.run(func())</span><br></pre></td></tr></table></figure>
<p>这个异步的上下文管理器还是比较有用的，平时在开发过程中 打开、处理、关闭 操作时，就可以用这种方式来处理。</p>
<h3 id="3-3-小结">3.3 小结</h3>
<p>在程序中只要看到<code>async</code>和<code>await</code>关键字，其内部就是基于协程实现的异步编程，这种异步编程是通过一个线程在IO等待时间去执行其他任务，从而实现并发。</p>
<p>以上就是异步编程的常见操作，内容参考官方文档。</p>
<ul>
<li>中文版：<a href="https://docs.python.org/zh-cn/3.8/library/asyncio.html">https://docs.python.org/zh-cn/3.8/library/asyncio.html</a></li>
<li>英文本：<a href="https://docs.python.org/3.8/library/asyncio.html">https://docs.python.org/3.8/library/asyncio.html</a></li>
</ul>
<h2 id="4-uvloop">4. uvloop</h2>
<p>Python标准库中提供了<code>asyncio</code>模块，用于支持基于协程的异步编程。</p>
<p>uvloop是 asyncio 中的事件循环的替代方案，替换后可以使得asyncio性能提高。事实上，uvloop要比nodejs、gevent等其他python异步框架至少要快2倍，性能可以比肩Go语言。</p>
<p>安装uvloop</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install uvloop</span><br></pre></td></tr></table></figure>
<p>在项目中想要使用uvloop替换asyncio的事件循环也非常简单，只要在代码中这么做就行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> uvloop</span><br><span class="line"></span><br><span class="line">asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())</span><br><span class="line"><span class="comment"># 编写asyncio的代码，与之前写的代码一致。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内部的事件循环自动化会变为</span></span><br><span class="line">uvloopasyncio.run(...)</span><br></pre></td></tr></table></figure>
<p>注意：知名的asgi uvicorn内部就是使用的uvloop的事件循环。</p>
<h2 id="5-实战案例">5.实战案例</h2>
<p>为了更好理解，上述所有示例的IO情况都是以 <code>asyncio.sleep</code> 为例，而真实的项目开发中会用到很多IO的情况。</p>
<h3 id="5-1-异步Redis">5.1 异步Redis</h3>
<p>当通过python去操作redis时，链接、设置值、获取值 这些都涉及网络IO请求，使用asycio异步的方式可以在IO等待时去做一些其他任务，从而提升性能。</p>
<p>安装Python异步操作redis模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install aioredis</span><br></pre></td></tr></table></figure>
<p>示例1：异步操作redis。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aioredis</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">address, password</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;开始执行&quot;</span>, address)</span><br><span class="line">    <span class="comment"># 网络IO操作：创建redis连接</span></span><br><span class="line">    redis = <span class="keyword">await</span> aioredis.create_redis(address, password=password)</span><br><span class="line">    <span class="comment"># 网络IO操作：在redis中设置哈希值car，内部在设三个键值对，即： redis = &#123; car:&#123;key1:1,key2:2,key3:3&#125;&#125;</span></span><br><span class="line">    <span class="keyword">await</span> redis.hmset_dict(<span class="string">&#x27;car&#x27;</span>, key1=<span class="number">1</span>, key2=<span class="number">2</span>, key3=<span class="number">3</span>)    <span class="comment"># 网络IO操作：去redis中获取值    </span></span><br><span class="line">    result = <span class="keyword">await</span> redis.hgetall(<span class="string">&#x27;car&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)    </span><br><span class="line">    <span class="built_in">print</span>(result)    </span><br><span class="line">    redis.close()    <span class="comment"># 网络IO操作：关闭redis连接    </span></span><br><span class="line">    <span class="keyword">await</span> redis.wait_closed()    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>, address)</span><br><span class="line">    </span><br><span class="line">asyncio.run(execute(<span class="string">&#x27;redis://47.93.4.198:6379&#x27;</span>, <span class="string">&quot;root!2345&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>示例2：连接多个redis做操作（遇到IO会切换其他任务，提供了性能）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aioredis</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">address, password</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;开始执行&quot;</span>, address)</span><br><span class="line">    <span class="comment"># 网络IO操作：先去连接 47.93.4.197:6379，遇到IO则自动切换任务，去连接47.93.4.198:6379</span></span><br><span class="line">    redis = <span class="keyword">await</span> aioredis.create_redis_pool(address, password=password)</span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    <span class="keyword">await</span> redis.hmset_dict(<span class="string">&#x27;car&#x27;</span>, key1=<span class="number">1</span>, key2=<span class="number">2</span>, key3=<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务    </span></span><br><span class="line">    result = <span class="keyword">await</span> redis.hgetall(<span class="string">&#x27;car&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    redis.close()</span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务    </span></span><br><span class="line">    <span class="keyword">await</span> redis.wait_closed()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>, address)</span><br><span class="line"></span><br><span class="line">task_list = [execute(<span class="string">&#x27;redis://47.93.4.197:6379&#x27;</span>, <span class="string">&quot;root!2345&quot;</span>),execute(<span class="string">&#x27;redis://47.93.4.198:6379&#x27;</span>, <span class="string">&quot;root!2345&quot;</span>)]</span><br><span class="line"></span><br><span class="line">asyncio.run(asyncio.wait(task_list))</span><br></pre></td></tr></table></figure>
<p>更多redis操作参考aioredis官网：<a href="https://aioredis.readthedocs.io/en/v1.3.0/start.html">https://aioredis.readthedocs.io/en/v1.3.0/start.html</a></p>
<h3 id="5-2-异步MySQL">5.2 异步MySQL</h3>
<p>当通过python去操作MySQL时，连接、执行SQL、关闭都涉及网络IO请求，使用asycio异步的方式可以在IO等待时去做一些其他任务，从而提升性能。</p>
<p>安装Python异步操作redis模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install aiomysql</span><br></pre></td></tr></table></figure>
<p>示例1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiomysql</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute</span>():</span><br><span class="line">  <span class="comment"># 网络IO操作：连接MySQL</span></span><br><span class="line">    conn = <span class="keyword">await</span> aiomysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;123&#x27;</span>, db=<span class="string">&#x27;mysql&#x27;</span>, )</span><br><span class="line">    <span class="comment"># 网络IO操作：创建CURSOR</span></span><br><span class="line">    cur = <span class="keyword">await</span> conn.cursor()</span><br><span class="line">    <span class="comment"># 网络IO操作：执行SQL</span></span><br><span class="line">    <span class="keyword">await</span> cur.execute(<span class="string">&quot;SELECT Host,User FROM user&quot;</span>)</span><br><span class="line">    <span class="comment"># 网络IO操作：获取SQL结果</span></span><br><span class="line">    result = <span class="keyword">await</span> cur.fetchall()</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="comment"># 网络IO操作：关闭链接</span></span><br><span class="line">    <span class="keyword">await</span> cur.close()</span><br><span class="line">    conn.close()</span><br><span class="line">    </span><br><span class="line">asyncio.run(execute())</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiomysql</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">host, password</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>, host)</span><br><span class="line">    <span class="comment"># 网络IO操作：先去连接 47.93.40.197，遇到IO则自动切换任务，去连接47.93.40.198:6379</span></span><br><span class="line">    conn = <span class="keyword">await</span> aiomysql.connect(host=host, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, password=password, db=<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    cur = <span class="keyword">await</span> conn.cursor()</span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    <span class="keyword">await</span> cur.execute(<span class="string">&quot;SELECT Host,User FROM user&quot;</span>)</span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    result = <span class="keyword">await</span> cur.fetchall()</span><br><span class="line">    <span class="built_in">print</span>(result)    </span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    <span class="keyword">await</span> cur.close()</span><br><span class="line">    conn.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>, host)</span><br><span class="line">    </span><br><span class="line">task_list = [execute(<span class="string">&#x27;47.93.40.197&#x27;</span>, <span class="string">&quot;root!2345&quot;</span>),execute(<span class="string">&#x27;47.93.40.197&#x27;</span>, <span class="string">&quot;root!2345&quot;</span>)]</span><br><span class="line"></span><br><span class="line">asyncio.run(asyncio.wait(task_list))</span><br></pre></td></tr></table></figure>
<h3 id="5-3-FastAPI框架">5.3 FastAPI框架</h3>
<p>FastAPI是一款用于构建API的高性能web框架，框架基于Python3.6+的 <code>type hints</code>搭建。</p>
<p>接下里的异步示例以<code>FastAPI</code>和<code>uvicorn</code>来讲解（uvicorn是一个支持异步的asgi）。</p>
<p>安装FastAPI web 框架，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install fastapi</span><br></pre></td></tr></table></figure>
<p>安装uvicorn，本质上为web提供socket server的支持的asgi（一般支持异步称asgi、不支持异步称wsgi）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install uvicorn</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">import</span> aioredis</span><br><span class="line"><span class="keyword">from</span> aioredis </span><br><span class="line"><span class="keyword">import</span> Redis</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line">REDIS_POOL = aioredis.ConnectionsPool(<span class="string">&#x27;redis://47.193.14.198:6379&#x27;</span>, password=<span class="string">&quot;root123&quot;</span>, minsize=<span class="number">1</span>, maxsize=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">  <span class="string">&quot;&quot;&quot; 普通操作接口 &quot;&quot;&quot;</span>    </span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello World&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/red&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">red</span>():</span><br><span class="line">  <span class="string">&quot;&quot;&quot; 异步操作接口 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请求来了&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 连接池获取一个连接</span></span><br><span class="line">    conn = <span class="keyword">await</span> REDIS_POOL.acquire()</span><br><span class="line">    redis = Redis(conn)</span><br><span class="line">    <span class="comment"># 设置值</span></span><br><span class="line">    <span class="keyword">await</span> redis.hmset_dict(<span class="string">&#x27;car&#x27;</span>, key1=<span class="number">1</span>, key2=<span class="number">2</span>, key3=<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 读取值</span></span><br><span class="line">    result = <span class="keyword">await</span> redis.hgetall(<span class="string">&#x27;car&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="comment"># 连接归还连接池</span></span><br><span class="line">    REDIS_POOL.release(conn)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  uvicorn.run(<span class="string">&quot;luffy:app&quot;</span>, host=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">5000</span>, log_level=<span class="string">&quot;info&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>在有多个用户并发请求的情况下，异步方式来编写的接口可以在IO等待过程中去处理其他的请求，提供性能。</p>
<p>例如：同时有两个用户并发来向接口 <code>http://127.0.0.1:5000/red</code> 发送请求，服务端只有一个线程，同一时刻只有一个请求被处理。 异步处理可以提供并发是因为：当视图函数在处理第一个请求时，第二个请求此时是等待被处理的状态，当第一个请求遇到IO等待时，会自动切换去接收并处理第二个请求，当遇到IO时自动化切换至其他请求，一旦有请求IO执行完毕，则会再次回到指定请求向下继续执行其功能代码。</p>
<p>基于上下文管理，来实现自动化管理的案例：<br>
示例1：redis</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">import</span> aioredis</span><br><span class="line"><span class="keyword">from</span> aioredis </span><br><span class="line"><span class="keyword">import</span> Redis</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line">REDIS_POOL = aioredis.ConnectionsPool(<span class="string">&#x27;redis://47.193.14.198:6379&#x27;</span>, password=<span class="string">&quot;root123&quot;</span>, minsize=<span class="number">1</span>, maxsize=<span class="number">10</span>)</span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">  <span class="string">&quot;&quot;&quot; 普通操作接口 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello World&quot;</span>&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/red&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">red</span>():</span><br><span class="line">  <span class="string">&quot;&quot;&quot; 异步操作接口 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请求来了&quot;</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> REDIS_POOL.get() <span class="keyword">as</span> conn:</span><br><span class="line">    redis = Redis(conn)</span><br><span class="line">    <span class="comment"># 设置值</span></span><br><span class="line">    <span class="keyword">await</span> redis.hmset_dict(<span class="string">&#x27;car&#x27;</span>, key1=<span class="number">1</span>, key2=<span class="number">2</span>, key3=<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 读取值 </span></span><br><span class="line">    result = <span class="keyword">await</span> redis.hgetall(<span class="string">&#x27;car&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  uvicorn.run(<span class="string">&quot;fast3:app&quot;</span>, host=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">5000</span>, log_level=<span class="string">&quot;info&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>示例2：mysql</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">import</span> aiomysql</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"><span class="comment"># 创建数据库连接池</span></span><br><span class="line">pool = aiomysql.Pool(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;123&#x27;</span>, db=<span class="string">&#x27;mysql&#x27;</span>,                     minsize=<span class="number">1</span>, maxsize=<span class="number">10</span>, echo=<span class="literal">False</span>, pool_recycle=-<span class="number">1</span>, loop=asyncio.get_event_loop())</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/red&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">red</span>():</span><br><span class="line">  <span class="string">&quot;&quot;&quot; 异步操作接口 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 去数据库连接池申请链接</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> pool.acquire() <span class="keyword">as</span> conn:</span><br><span class="line">      <span class="keyword">async</span> <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cur:</span><br><span class="line">          <span class="comment"># 网络IO操作：执行SQL</span></span><br><span class="line">            <span class="keyword">await</span> cur.execute(<span class="string">&quot;SELECT Host,User FROM user&quot;</span>)</span><br><span class="line">            <span class="comment"># 网络IO操作：获取SQL结果</span></span><br><span class="line">            result = <span class="keyword">await</span> cur.fetchall()</span><br><span class="line">            <span class="built_in">print</span>(result)</span><br><span class="line">            <span class="comment"># 网络IO操作：关闭链接</span></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;result&quot;</span>: <span class="string">&quot;ok&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  uvicorn.run(<span class="string">&quot;fast2:app&quot;</span>, host=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">5000</span>, log_level=<span class="string">&quot;info&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="5-4-爬虫">5.4 爬虫</h3>
<p>在编写爬虫应用时，需要通过网络IO去请求目标数据，这种情况适合使用异步编程来提升性能，接下来我们使用支持异步编程的aiohttp模块来实现。</p>
<p>安装aiohttp模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install aiohttp</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch</span>(<span class="params">session, url</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;发送请求：&quot;</span>, url)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, verify_ssl=<span class="literal">False</span>) <span class="keyword">as</span> response:</span><br><span class="line">      text = <span class="keyword">await</span> response.text()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;得到结果：&quot;</span>, url, <span class="built_in">len</span>(text))</span><br><span class="line">        </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">      url_list = [<span class="string">&#x27;https://python.org&#x27;</span>,<span class="string">&#x27;https://www.baidu.com&#x27;</span>,<span class="string">&#x27;https://www.pythonav.com&#x27;</span>]</span><br><span class="line">        </span><br><span class="line">        tasks = [asyncio.create_task(fetch(session, url)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  asyncio.run(main())</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>为了提升性能越来越多的框架都在向异步编程靠拢，例如：sanic、tornado、django3.0、django channels组件 等，用更少资源可以做处理更多的事，何乐而不为呢。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Python垃圾回收机制</title>
    <url>/2023/02/06/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<ul>
<li>目前垃圾回收比较通用的解决办法有三种，引用计数，标记清除以及分代回收。</li>
</ul>
<h2 id="引用计数">引用计数</h2>
<ul>
<li>引用计数也是一种最直观，最简单的垃圾收集技术。</li>
<li><strong>在 Python 中，大多数对象的生命周期都是通过对象的引用计数来管理的。</strong></li>
<li>其原理非常简单，我们为每个对象维护一个 ref 的字段用来记录对象被引用的次数，每当对象被创建或者被引用时将该对象的引用次数加一，当对象的引用被销毁时该对象的引用次数减一，当对象的引用次数减到零时说明程序中已经没有任何对象持有该对象的引用，换言之就是在以后的程序运行中不会再次使用到该对象了，那么其所占用的空间也就可以被释放了了。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_memory_info</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    内存计算函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    pid = os.getpid()</span><br><span class="line">    p = psutil.Process(pid)</span><br><span class="line"></span><br><span class="line">    info = p.memory_full_info()</span><br><span class="line">    MB = <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line">    memory = info.uss / MB</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s used %d MB&#x27;</span> % (name, memory))</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(): </span><br><span class="line">    print_memory_info(<span class="string">&#x27;test start&#x27;</span>)</span><br><span class="line">    length = <span class="number">1000</span> * <span class="number">1000</span></span><br><span class="line">    list1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">    print_memory_info(<span class="string">&#x27;test end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> list1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = test()</span><br><span class="line">print_memory_info(<span class="string">&quot;main end&quot;</span>)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    test start used <span class="number">4</span> MB</span><br><span class="line">  test end used <span class="number">23</span> MB</span><br><span class="line">  main end used <span class="number">23</span> MB</span><br></pre></td></tr></table></figure>
<p>由上述例子：如下情况会存在引用计数加一</p>
<ul>
<li>对象被创建（num=2）</li>
<li>对象被引用（count=num）</li>
<li>对象作为参数传递到函数内部</li>
<li>对象作为一个元素添加到容器中</li>
</ul>
<p>而如下情况会导致引用次数减一：</p>
<ul>
<li>对象的别名被显式销毁（del num）</li>
<li>对象的别名被赋予新的对象（num=30）</li>
<li>对象离开它的作用域（函数局部变量）</li>
<li>从容器中删除对象，或者容器被销毁</li>
</ul>
<p>引用计数的不足：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    print_memory_info(<span class="string">&quot;foo start&quot;</span>)</span><br><span class="line">    length = <span class="number">1000</span> * <span class="number">1000</span></span><br><span class="line">    list_a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">    list_b = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">    list_a.append(list_b)</span><br><span class="line">    list_b.append(list_a)</span><br><span class="line">    print_memory_info(<span class="string">&quot;foo end&quot;</span>)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    test start used <span class="number">4</span> MB</span><br><span class="line">  test end used <span class="number">42</span> MB</span><br><span class="line">  main end used <span class="number">42</span> MB</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<blockquote>
<p>在函数 test内部生成了两个列表 list_a 和 list_b，然后将两个列表分别添加到另外一个中。由结果可以看出，即使 foo 函数结束之后其所占用的内存空间依然未被释放。这是因为对于 list_a 和 list_b 来说虽然没有被任何外部对象引用，但因为二者之间交叉引用，以至于每个对象的引用计数都不为零，这也就造成了其所占用的空间永远不会被回收的尴尬局面。这个缺点是致命的。</p>
</blockquote>
<p><strong>为了解决交叉引用的问题，Python 引入了标记清除算法和分代回收算法。</strong></p>
<span id="more"></span>
<h2 id="标记清除">标记清除</h2>
<ul>
<li>
<p>由上，可以包含其他对象引用的容器对象都有可能产生交叉引用问题，而标记清除算法就是为了解决交叉引用的问题的。</p>
</li>
<li>
<p>标记清除（Mark—Sweep）算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：</p>
<ul>
<li>第一阶段是标记阶段，GC会把所有的活动对象打上标记</li>
<li>第二阶段是把那些没有标记的对象非活动对象进行回收。</li>
</ul>
<p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。</p>
<p><img src="https://foofish.net/images/mark-sweep.svg" alt="img"></p>
<p>在上图中，可以从程序变量直接访问块1，并且可以间接访问块2和3。程序无法访问块4和5。第一步将标记块1，并记住块2和3以供稍后处理。第二步将标记块2，第三步将标记块3，但不记得块2，因为它已被标记。扫描阶段将忽略块1，2和3，因为它们已被标记，但会回收块4和5。</p>
<p>标记清除算法作为Python的辅助垃圾收集技术，主要处理的是一些容器对象，比如list、dict、tuple等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。</p>
<blockquote>
<p>不过，这种简单粗暴的标记清除算法也有明显的缺点：<strong>清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。</strong></p>
</blockquote>
</li>
</ul>
<h2 id="分代回收">分代回收</h2>
<blockquote>
<p>分代回收是建立在标记清除技术基础之上的，是一种以空间换时间的操作方式。</p>
</blockquote>
<ul>
<li>由于标记清除算法需要扫描整个堆的所有对象导致其性能有所损耗，而且当可以回收的对象越少时性能损耗越高。因此 Python 引入了分代回收算法，将系统中存活时间不同的对象划分到不同的内存区域，共三代，分别是 0 代，1 代 和 2 代。新生成的对象是 0 代，经过一次垃圾回收之后，还存活的对象将会升级到 1 代，以此类推，2 代中的对象是存活最久的对象。</li>
</ul>
<p>那么什么时候触发进行垃圾回收算法呢 ?</p>
<ul>
<li>
<p>事实上随着程序的运行会不断的创建新的对象，同时也会因为引用计数为零而销毁大部分对象，Python 会保持对这些对象的跟踪，由于交叉引用的存在，以及程序中使用了长时间存活的对象，这就造成了新生成的对象的数量会大于被回收的对象数量，一旦二者之间的差值达到某个阈值就会启动垃圾回收机制，使用标记清除算法将死亡对象进行清除，同时将存活对象移动到 1 代。 以此类推，当二者的差值再次达到阈值时又触发垃圾回收机制，将存活对象移动到 2 代。</p>
</li>
<li>
<p>这样通过对不同代的阈值做不同的设置，就可以做到在不同代使用不同的时间间隔进行垃圾回收，以追求性能最大。</p>
</li>
</ul>
<p>事实上，所有的程序都有一个相同的现象，那就是大部分的对象生存周期都是相当短的，只有少量对象生命周期比较长，甚至会常驻内存，从程序开始运行持续到程序结束。而通过分代回收算法，做到了针对不同的区域采取不同的回收频率，节约了大量的计算从而提高 Python 的性能。</p>
<p>除了上面所说的差值达到一定<strong>阈值</strong>会触发垃圾回收之外，<strong>我们还可以显式的调用 <code>gc.collect()</code> 来触发垃圾回收，最后当程序退出时也会进行垃圾回收</strong>。</p>
<h1>python的gc模块</h1>
<h2 id="gc-—-垃圾回收器接口"><a href="https://docs.python.org/zh-cn/3/library/gc.html#module-gc"><code>gc</code></a> — 垃圾回收器接口</h2>
<hr>
<ul>
<li>此模块提供可选的垃圾回收器的接口，提供的功能包括：
<ul>
<li>关闭收集器、调整收集频率、设置调试选项。</li>
</ul>
</li>
<li>它同时提供对回收器找到但是无法释放的不可达对象的访问。<strong>由于 Python 使用了带有引用计数的回收器</strong>，如果你确定你的程序不会产生循环引用，你可以关闭回收器。可以通过调用 <code>gc.disable()</code> 关闭自动垃圾回收。若要调试一个存在内存泄漏的程序，调用 <code>gc.set_debug(gc.DEBUG_LEAK)</code> ；需要注意的是，它包含 <code>gc.DEBUG_SAVEALL</code> ，使得被垃圾回收的对象会被存放在<code> gc.garbage</code> 中以待检查。</li>
</ul>
<p><a href="https://docs.python.org/zh-cn/3/library/gc.html#module-gc"><code>gc</code></a> 模块提供下列函数：</p>
<ul>
<li>
<p><code>gc.enable</code>()</p>
<p>启用自动垃圾回收</p>
</li>
<li>
<p><code>gc.disable</code>()</p>
<p>停用自动垃圾回收</p>
</li>
<li>
<p><code>gc.isenabled</code>()</p>
<p>如果启用了自动回收则返回 <code>True</code>。</p>
</li>
<li>
<p><code>gc.collect</code>(<em>generation=2</em>)</p>
<p>若被调用时不包含参数，则启动完全的垃圾回收。可选的参数 <em>generation</em> 可以是一个整数，指明需要回收哪一代（从 0 到 2 ）的垃圾。当参数 <em>generation</em> 无效时，会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError"><code>ValueError</code></a> 异常。返回发现的不可达对象的数目。每当运行完整收集或最高代 (2) 收集时，为多个内置类型所维护的空闲列表会被清空。 由于特定类型特别是 <a href="https://docs.python.org/zh-cn/3/library/functions.html#float"><code>float</code></a> 的实现，在某些空闲列表中并非所有项都会被释放。</p>
</li>
<li>
<p><code>gc.set_debug</code>(<em>flags</em>)</p>
<p>设置垃圾回收器的调试标识位。调试信息会被写入 <code>sys.stderr</code> 。此文档末尾列出了各个标志位及其含义；可以使用位操作对多个标志位进行设置以控制调试器。</p>
</li>
<li>
<p><code>gc.get_debug</code>()</p>
<p>返回当前调试标识位。</p>
</li>
<li>
<p><code>gc.get_objects</code>(<em>generation=None</em>)</p>
<p>返回一个收集器所跟踪的所有对象的列表，所返回的列表除外。 如果 <em>generation</em> 不为 None，则只返回收集器所跟踪的属于该生成的对象。<em>在 3.8 版更改:</em> 新的 <em>generation</em> 形参。</p>
</li>
<li>
<p><code>gc.get_stats</code>()</p>
<p>返回一个包含三个字典对象的列表，每个字典分别包含对应代的从解释器开始运行的垃圾回收统计数据。字典的键的数目在将来可能发生改变，目前每个字典包含以下内容：<code>collections</code> 是该代被回收的次数；<code>collected</code> 是该代中被回收的对象总数；<code>uncollectable</code> 是在这一代中被发现无法收集的对象总数 （因此被移动到 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.garbage"><code>garbage</code></a> 列表中）。<em>3.4 新版功能.</em></p>
</li>
<li>
<p><code>gc.set_threshold</code>(<em>threshold0</em>[, <em>threshold1</em>[, <em>threshold2</em>]])</p>
<p>设置垃圾回收阈值（收集频率）。 将 <em>threshold0</em> 设为零会禁用回收。垃圾回收器把所有对象分类为三代，取决于对象幸存于多少次垃圾回收。新创建的对象会被放在最年轻代（第 <code>0</code> 代）。如果一个对象幸存于一次垃圾回收，则该对象会被放入下一代。第 <code>2</code> 代是最老的一代，因此这一代的对象幸存于垃圾回收后，仍会留在第 <code>2</code> 代。为了判定何时需要进行垃圾回收，垃圾回收器会跟踪上一次回收后，分配和释放的对象的数目。当分配对象的数量减去释放对象的数量大于阈值 <em>threshold0</em> 时，回收器开始进行垃圾回收。起初只有第 <code>0</code> 代会被检查。当上一次第 <code>1</code> 代被检查后，第 <code>0</code> 代被检查的次数多于阈值 <em>threshold1</em> 时，第 <code>1</code> 代也会被检查。相似的， <em>threshold2</em> 设置了触发第 <code>2</code> 代被垃圾回收的第 <code>1</code> 代被垃圾回收的次数。</p>
</li>
<li>
<p><code>gc.get_count</code>()</p>
<p>将当前回收计数以形为 <code>(count0, count1, count2)</code> 的元组返回。</p>
</li>
<li>
<p><code>gc.get_threshold</code>()</p>
<p>将当前回收阈值以形为 <code>(threshold0, threshold1, threshold2)</code> 的元组返回。</p>
</li>
<li>
<p><code>gc.get_referrers</code>(*<em>objs</em>)</p>
<p>返回直接引用任意一个 <em>ojbs</em> 的对象列表。这个函数只定位支持垃圾回收的容器；引用了其它对象但不支持垃圾回收的扩展类型不会被找到。需要注意的是，已经解除对 <em>objs</em> 引用的对象，但仍存在于循环引用中未被回收时，仍然会被作为引用者出现在返回的列表当中。若要获取当前正在引用 <em>objs</em> 的对象，需要调用 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.collect"><code>collect()</code></a> 然后再调用 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.get_referrers"><code>get_referrers()</code></a> 。在使用 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.get_referrers"><code>get_referrers()</code></a> 返回的对象时必须要小心，因为其中一些对象可能仍在构造中因此处于暂时的无效状态。不要把 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.get_referrers"><code>get_referrers()</code></a> 用于调试以外的其它目的。</p>
</li>
<li>
<p><code>gc.get_referents</code>(*<em>objs</em>)</p>
<p>返回被任意一个参数中的对象直接引用的对象的列表。返回的被引用对象是被参数中的对象的C语言级别方法（若存在） <a href="https://docs.python.org/zh-cn/3/c-api/typeobj.html#c.PyTypeObject.tp_traverse"><code>tp_traverse</code></a> 访问到的对象，可能不是所有的实际直接可达对象。只有支持垃圾回收的对象支持 <a href="https://docs.python.org/zh-cn/3/c-api/typeobj.html#c.PyTypeObject.tp_traverse"><code>tp_traverse</code></a> 方法，并且此方法只会在需要访问涉及循环引用的对象时使用。因此，可以有以下例子：一个整数对其中一个参数是直接可达的，这个整数有可能出现或不出现在返回的结果列表当中。</p>
</li>
<li>
<p><code>gc.is_tracked</code>(<em>obj</em>)</p>
<p>当对象正在被垃圾回收器监控时返回 <code>True</code> ，否则返回 <code>False</code> 。一般来说，原子类的实例不会被监控，而非原子类（如容器、用户自定义的对象）会被监控。然而，会有一些特定类型的优化以便减少垃圾回收器在简单实例（如只含有原子性的键和值的字典）上的消耗。&gt;&gt;&gt;<code>&gt;&gt;&gt; gc.is_tracked(0) False &gt;&gt;&gt; gc.is_tracked(&quot;a&quot;) False &gt;&gt;&gt; gc.is_tracked([]) True &gt;&gt;&gt; gc.is_tracked(&#123;&#125;) False &gt;&gt;&gt; gc.is_tracked(&#123;&quot;a&quot;: 1&#125;) False &gt;&gt;&gt; gc.is_tracked(&#123;&quot;a&quot;: []&#125;) True </code><em>3.1 新版功能.</em></p>
</li>
<li>
<p><code>gc.freeze</code>()</p>
<p>冻结 gc 所跟踪的所有对象 —— 将它们移至永久代并忽略所有未来的集合。 这可以在 POSIX fork() 调用之前使用以便令对写入复制保持友好或加速收集。 并且在 POSIX fork() 调用之前的收集也可以释放页面以供未来分配，这也可能导致写入时复制，因此建议在主进程中禁用 gc 并在 fork 之前冻结，而在子进程中启用 gc。<em>3.7 新版功能.</em></p>
</li>
<li>
<p><code>gc.unfreeze</code>()</p>
<p>解冻永久代中的对象，并将它们放回到年老代中。<em>3.7 新版功能.</em></p>
</li>
<li>
<p><code>gc.get_freeze_count</code>()</p>
<p>返回永久代中的对象数量。<em>3.7 新版功能.</em></p>
</li>
</ul>
<p>提供以下变量仅供只读访问（你可以修改但不应该重绑定它们）：</p>
<ul>
<li>
<p><code>gc.garbage</code></p>
<p>一个回收器发现不可达而又无法被释放的对象（不可回收对象）列表。 从 Python 3.4 开始，该列表在大多数时候都应该是空的，除非使用了含有非 <code>NULL</code> <code>tp_del</code> 空位的 C 扩展类型的实例。如果设置了 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.DEBUG_SAVEALL"><code>DEBUG_SAVEALL</code></a> ，则所有不可访问对象将被添加至该列表而不会被释放。<em>在 3.2 版更改:</em> 当 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-interpreter-shutdown">interpreter shutdown</a> 即解释器关闭时，若此列表非空，会产生 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ResourceWarning"><code>ResourceWarning</code></a> ，即资源警告，在默认情况下此警告不会被提醒。如果设置了 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.DEBUG_UNCOLLECTABLE"><code>DEBUG_UNCOLLECTABLE</code></a> ，所有无法被回收的对象会被打印。<em>在 3.4 版更改:</em> 根据 <a href="https://www.python.org/dev/peps/pep-0442"><strong>PEP 442</strong></a> ，带有 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__del__"><code>__del__()</code></a> 方法的对象最终不再会进入 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.garbage"><code>gc.garbage</code></a> 。</p>
</li>
<li>
<p><code>gc.callbacks</code></p>
<p>在垃圾回收器开始前和完成后会被调用的一系列回调函数。这些回调函数在被调用时使用两个参数： <em>phase</em> 和 <em>info</em> 。<em>phase</em> 可为以下两值之一：“start”: 垃圾回收即将开始。“stop”: 垃圾回收已结束。<em>info</em> is a dict providing more information for the callback. The following keys are currently defined:“generation”（代） ：正在被回收的最久远的一代。“collected”（已回收的 ）: 当<em>phase</em> 为 “stop” 时，被成功回收的对象的数目。“uncollectable”（不可回收的）: 当 <em>phase</em> 为 “stop” 时，不能被回收并被放入 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.garbage"><code>garbage</code></a> 的对象的数目。应用程序可以把他们自己的回调函数加入此列表。主要的使用场景有：统计垃圾回收的数据，如：不同代的回收频率、回收所花费的时间。使应用程序可以识别和清理他们自己的在 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.garbage"><code>garbage</code></a> 中的不可回收类型的对象。<em>3.3 新版功能.</em></p>
</li>
</ul>
<p>以下常量被用于 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.set_debug"><code>set_debug()</code></a> ：</p>
<ul>
<li>
<p><code>gc.DEBUG_STATS</code></p>
<p>在回收完成后打印统计信息。当回收频率设置较高时，这些信息会比较有用。</p>
</li>
<li>
<p><code>gc.DEBUG_COLLECTABLE</code></p>
<p>当发现可回收对象时打印信息。</p>
</li>
<li>
<p><code>gc.DEBUG_UNCOLLECTABLE</code></p>
<p>打印找到的不可回收对象的信息（指不能被回收器回收的不可达对象）。这些对象会被添加到 <code>garbage</code> 列表中。<em>在 3.2 版更改:</em> 当 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-interpreter-shutdown">interpreter shutdown</a> 时，即解释器关闭时，若 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.garbage"><code>garbage</code></a> 列表中存在对象，这些对象也会被打印输出。</p>
</li>
<li>
<p><code>gc.DEBUG_SAVEALL</code></p>
<p>设置后，所有回收器找到的不可达对象会被添加进 <em>garbage</em> 而不是直接被释放。这在调试一个内存泄漏的程序时会很有用。</p>
</li>
<li>
<p><code>gc.DEBUG_LEAK</code></p>
<p>调试内存泄漏的程序时，使回收器打印信息的调试标识位。（等价于 <code>DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | DEBUG_SAVEALL</code> ）。</p>
</li>
</ul>
<blockquote>
<p>参考文章：</p>
<p><a href="https://docs.python.org/zh-cn/3/library/gc.html">https://docs.python.org/zh-cn/3/library/gc.html</a></p>
<p><a href="http://www.ityouknow.com/python/2020/01/06/python-gc-111.html">http://www.ityouknow.com/python/2020/01/06/python-gc-111.html</a></p>
<p><a href="http://www.bieryun.com/5338.html">http://www.bieryun.com/5338.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>python进阶</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>list, tuple, dictionary, set的底层细节（python）</title>
    <url>/2023/02/06/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1>list, tuple, dictionary, set的底层细节</h1>
<h2 id="列表实现细节">列表实现细节</h2>
<ul>
<li>
<p>python中的列表的英文名是list，因此很容易和其它语言(C++, Java等)标准库中常见的链表混淆。事实上CPython的列表根本不是列表（可能换成英文理解起来容易些：python中的list不是list）。在CPython中，列表被实现为长度可变的数组。</p>
<p>​																													<strong>可参考《Python高级编程（第2版）》</strong></p>
</li>
<li>
<p>从细节上看，Python中的列表是由对其它对象的引用组成的连续数组。指向这个数组的指针及其长度被保存在一个列表头结构中。</p>
</li>
<li>
<p>这意味着，每次添加或删除一个元素时，由引用组成的数组需要该标大小（重新分配）。幸运的是，Python在创建这些数组时采用了指数分配，所以并不是每次操作都需要改变数组的大小。但是，也因为这个原因添加或取出元素的平摊复杂度较低。不幸的是，在普通链表上“代价很小”的其它一些操作在Python中计算复杂度相对过高。</p>
<p><strong>利用 list.insert(i,item) 方法在任意位置插入一个元素——复杂度O(N)</strong><br>
<strong>利用 list.pop(i) 或 list.remove(value) 删除一个元素——复杂度O(N)</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>复制</td>
<td>O(N)</td>
</tr>
<tr>
<td>添加元素(在尾部添加)</td>
<td>O(1)</td>
</tr>
<tr>
<td>插入元素(在指定位置插入)</td>
<td>O(N)</td>
</tr>
<tr>
<td>获取元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>修改元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>删除元素</td>
<td>O(N)</td>
</tr>
<tr>
<td>遍历</td>
<td>O(N)</td>
</tr>
<tr>
<td>获取长度为k的切片</td>
<td>O(k)</td>
</tr>
<tr>
<td>删除切片</td>
<td>O(N)</td>
</tr>
<tr>
<td>列表扩展</td>
<td>O(k)</td>
</tr>
<tr>
<td>测试是否在列表中</td>
<td>O(N)</td>
</tr>
<tr>
<td>min()/max()</td>
<td>O(n)</td>
</tr>
<tr>
<td>获取列表长度</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h2 id="字典实现细节">字典实现细节</h2>
<ul>
<li>
<p>CPython使用伪随机探测(pseudo-random probing)的散列表(hash table)作为字典的底层数据结构。由于这个实现细节，只有可哈希的对象才能作为字典的键。</p>
</li>
<li>
<p><strong>Python中所有不可变的内置类型都是可哈希的</strong>。可变类型（如列表，字典和集合）就是不可哈希的，因此不能作为字典的键。</p>
</li>
<li>
<p>字典的三个基本操作（添加元素，获取元素和删除元素）的平均事件复杂度为O(1)，但是他们的平摊最坏情况复杂度要高得多，为O(N).</p>
</li>
<li>
<p>字典的三个基本操作（添加元素，获取元素和删除元素）的平均事件复杂度为O(1)，但是他们的平摊最坏情况复杂度要高得多，为O(N).</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>平均复杂度</th>
<th>平摊最坏情况复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>获取元素</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>修改元素</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>删除元素</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>复制</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>还有一点很重要，<strong>在复制和遍历字典的操作中，最坏的复杂度中的n是字典曾经达到的最大元素数目</strong>，而不是当前的元素数目。换句话说，如果一个字典曾经元素个数很多，后来又大大减小了，那么遍历这个字典可能会花费相当长的事件。因此在某些情况下，如果需要频繁的遍历某个词典，那么最好创建一个新的字典对象，而不是仅在旧字典中删除元素。</p>
</li>
</ul>
<span id="more"></span>
<h2 id="集合实现细节">集合实现细节</h2>
<ul>
<li>
<p>集合是一种鲁棒性很好的数据结构，当元素顺序的重要性不如元素的唯一性和测试元素是否包含在集合中的效率时，大部分情况下这种数据结构极其有用。</p>
</li>
<li>
<p>python的内置集合类型有两种：</p>
</li>
<li>
<p>set(): 一种可变的、无序的、有限的集合，其元素是唯一的、不可变的（可哈希的）对象。</p>
</li>
<li>
<p>frozenset(): 一种不可变的、可哈希的、无序的集合，其元素是唯一的，不可变的哈希对象。</p>
</li>
<li>
<p>CPython中集合和字典非常相似。事实上，集合被实现为带有空值的字典，只有键才是实际的集合元素。此外，集合还利用这种没有值的映射做了其它的优化。</p>
</li>
<li>
<p>由于这一点，可以快速的向集合中添加元素、删除元素、检查元素是否存在。平均时间复杂度为O(1),最坏的事件复杂度是O(n)。</p>
</li>
</ul>
<h1>哈希函数</h1>
<ul>
<li>哈希函数就是一个映射，因此哈希函数的设定很灵活，只要使得任何关键字由此所得的哈希函数值都落在表长允许的范围之内即可；</li>
<li>并不是所有的输入都只对应唯一一个输出，也就是哈希函数不可能做成一个一对一的映射关系，其本质是一个多对一的映射，这也就引出了下面一个概念–冲突。</li>
</ul>
<p>只要不是一对一的映射关系，冲突就必然会发生</p>
<h2 id="冲突解决方法（python所使用的）开放地址">冲突解决方法（python所使用的）开放地址</h2>
<h4 id="线性探测再散列">线性探测再散列</h4>
<p>例如  哈希函数为： H（key） =  key %11,key 为关键字，采用开放地址法中的线性探测再散列解决冲突，依次输入</p>
<p>9 个关键字，19，01，23，14，55，68，11，82，36，构造哈希表（表长=11）</p>
<table>
<thead>
<tr>
<th>散列地址</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>关键字</td>
<td>55</td>
<td>01</td>
<td>23</td>
<td>14</td>
<td>68</td>
<td>11</td>
<td>82</td>
<td>36</td>
<td>19</td>
<td></td>
<td></td>
</tr>
<tr>
<td>探测次数</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>6</td>
<td>2</td>
<td>5</td>
<td>1</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>如上表，例如 14%11=3，将14放入3号位置，11%11 = 0，将11放入0号位置，而此时3号位已经有元素。</p>
<p>就顺着表往后放，直到5号没有元素，11放入5号。</p>
<h4 id="二次探测再散列">二次探测再散列</h4>
<p>例如  哈希函数为： H（key） =  key %11,key 为关键字，采用开放地址法中的二次探测再散列解决冲突，依次输入</p>
<p>9 个关键字，19，01，23，14，55，68，11，82，36，构造哈希表（表长=11）</p>
<table>
<thead>
<tr>
<th>散列地址</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>关键字</td>
<td>55</td>
<td>01</td>
<td>23</td>
<td>14</td>
<td>36</td>
<td>82</td>
<td>68</td>
<td></td>
<td>19</td>
<td></td>
<td>11</td>
</tr>
<tr>
<td>探测次数</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>4</td>
<td></td>
<td>1</td>
<td></td>
<td>3</td>
</tr>
</tbody>
</table>
<p>对于01%11=1，将01放入1号位置， 11%11=0，此时0号位置已经有元素，</p>
<p>则查找 0 + 1^2 = 1,有元素</p>
<p>查找 0 - 1^2 = -1 ,没有则放入，如果还有元素则查找0 + 2^2, 0-2^2… 0+k^2, 0 - k^2。</p>
<h1>扩展（哈希冲突解决方法）</h1>
<h2 id="开放地址">开放地址</h2>
<p>开放地址的意思是<strong>除了哈希函数得出的地址可用，当出现冲突的时候其他的地址也一样可用</strong>，常见的开放地址思想的方法有线性探测再散列，二次探测再散列，这些方法都是在第一选择被占用的情况下的解决方法。</p>
<h2 id="再哈希法">再哈希法</h2>
<p>这个方法是按顺序规定多个哈希函数，每次查询的时候按顺序调用哈希函数，调用到第一个为空的时候返回不存在，调用到此键的时候返回其值。</p>
<h2 id="链地址法">链地址法</h2>
<p><strong>将所有关键字哈希值相同的记录都存在同一线性链表中</strong>，这样不需要占用其他的哈希地址，相同的哈希值在一条链表上，按顺序遍历就可以找到。</p>
<h2 id="公共溢出区">公共溢出区</h2>
<p>其基本思想是：所有关键字和基本表中关键字为相同哈希值的记录，不管他们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。</p>
<h2 id="装填因子α">装填因子α</h2>
<p>一般情况下，处理冲突方法相同的哈希表，其平均查找长度依赖于哈希表的装填因子。哈希表的装填因子定义为表中填入的记录数和哈希表长度的壁纸，也就是<strong>标志着哈希表的装满程度</strong>。直观看来，<strong>α越小，发生冲突的可能性就越小，反之越大。一般0.75比较合适</strong>，涉及数学推导。</p>
]]></content>
      <categories>
        <category>python进阶</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>网站概念</title>
    <url>/2023/02/06/%E7%BD%91%E7%AB%99%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1>网站的组成</h1>
<ul>
<li>目前多数网站由域名，空间服务器，DNS域名解析，网站程序和数据库等组成</li>
</ul>
<span id="more"></span>
<h2 id="空间服务器（以下三种类型）">空间服务器（以下三种类型）</h2>
<ul>
<li>虚拟主机：指在网络服务器上划分一定的磁盘空间供用户放置站点和应用组件等，提供必要的站点功能，数据存放和传输功能。所谓虚拟主机，也叫“网站空间”，就是把一台运行在互联网上的服务器划分成多个”虚拟“的服务器</li>
<li>独立服务器：指性能更强大，整体硬件完全独立的服务器，其cpu都在8核以上。</li>
<li>VPS（虚拟专用服务器）：将一个服务器分区成多个虚拟独立专享服务器的技术。</li>
</ul>
<p>网站的程序:是建设与修改网站所使用的编程语言。</p>
<h1>网站的分类</h1>
<ul>
<li>资讯门户类网站</li>
<li>企业品牌网站</li>
<li>交易类网站
<ul>
<li>B2C（Business To Consumer）网站：商家——消费者，主要是购物网站，用于商家和消费者之间的买卖，如传统的百货商店和购物广场。</li>
<li>B2B（Business To Business）网站：商家——商家，主要是商务网站，用于商家之间的买卖，如传统的原材料市场和大型批发市场</li>
<li>C2C（Consumer To Consumer）网站：消费者——消费者，主要以拍卖网站为主，用于个人的物品的买卖，如传统的旧货市场，跳骚市场，废品收购站等。</li>
</ul>
</li>
<li>办公及政府机构网站
<ul>
<li>企业办公事物类网站</li>
<li>政府办公类事物网站</li>
</ul>
</li>
<li>互动游戏网站</li>
<li>功能性网站
<ul>
<li>这类网站的主要特征是将一个具有广泛需求的共能扩展开来，开发一套强大的功能体系，将功能的实现推向极致。如：百度，goolge</li>
</ul>
</li>
</ul>
<h1>网站开发的常用术语</h1>
<p>域名：用于标识一个或多个ip地址</p>
<p>DNS：域名系统，用于跟踪计算机的域名及其在互联网上的相应的IP地址</p>
]]></content>
      <categories>
        <category>网站知识</category>
      </categories>
      <tags>
        <tag>网站的基本概念</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统组成及工作原理简介</title>
    <url>/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1>计算机系统组成及工作原理简介</h1>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/1563084893334.png" alt=""></p>
<h2 id="硬件系统">硬件系统</h2>
<h3 id="中央控制器-CPU">中央控制器 CPU</h3>
<ul>
<li>
<p>运算器 ALU</p>
<ul>
<li>
<p>又称算数逻辑部件，是计算机用来进行数据运算的部件</p>
<ul>
<li>
<p>算数运算</p>
<ul>
<li>加、减、乘、除四则运算</li>
</ul>
</li>
<li>
<p>逻辑运算</p>
<ul>
<li>与、或、非、异或等逻辑操作，以及移位、比较和传送等操作，亦称算术逻辑部件（ALU）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>控制器  Controller</p>
<ul>
<li>通过地址访问存储器，逐条取出选中单元的指令，分析指令，根据指令产生相应的控制信号，用于其他各个部件，控制其他部件完成指令要求的操作。</li>
</ul>
</li>
</ul>
<h3 id="存储器-Memory：计算机中具有记忆能力的部件，用来存放程序或数据">存储器 Memory：计算机中具有记忆能力的部件，用来存放程序或数据</h3>
<ul>
<li>
<p>内存储器</p>
<ul>
<li>内存，又称主存，是CPU能根据地址线直接寻址的存储空间，是计算机内部存放数据的硬件设备，是程序和数据存储的基本要素。</li>
</ul>
</li>
<li>
<p>外存储器</p>
<ul>
<li>外存，又称辅存，作为一种辅助存储设备，主要用来存放一些暂时不用而又需长期保存的程序或数据。</li>
</ul>
</li>
</ul>
<h3 id="输入设备-Input-Device">输入设备 Input Device</h3>
<ul>
<li>用来输入程序和数据的部件：常用的输入设备有键盘，鼠标，传声器（麦克风），扫描仪，手写板，数码相机，摄像头等。</li>
</ul>
<h3 id="输出设备-Output-Device">输出设备 Output Device</h3>
<ul>
<li>显示输出结果的部件  显示器，音响，打印机，绘图仪。</li>
</ul>
<h2 id="软件系统">软件系统</h2>
<h3 id="系统软件">系统软件</h3>
<ul>
<li>管理，监控，维护计算机正常工作和供用户操作使用的计算机软件。</li>
</ul>
<h3 id="应用软件">应用软件</h3>
<ul>
<li>在某种具体应用，供最终用户使用的软件。</li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机知识</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习</title>
    <url>/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1>计算机网络概述</h1>
<h2 id="OSI七层协议">OSI七层协议</h2>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200501130320493.png" alt=""></p>
<h3 id="物理层">物理层</h3>
<ul>
<li>传输的数据类型：比特流</li>
<li>主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特</li>
</ul>
<h3 id="数据链路层">数据链路层</h3>
<ul>
<li>
<p>传输的数据类型：帧</p>
</li>
<li>
<p>定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。</p>
</li>
</ul>
<h3 id="网络层">网络层</h3>
<ul>
<li>
<p>传输的数据类型：数据报</p>
</li>
<li>
<p>在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</p>
</li>
</ul>
<h3 id="运输层">运输层</h3>
<ul>
<li>
<p>报文段/用户数据报</p>
</li>
<li>
<p>定义了一些传输数据的协议和端口号（WWW端口80等），如：</p>
<ul>
<li>TCP（transmission control protocol –传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据）</li>
<li>UDP（user datagram protocol–用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</li>
</ul>
</li>
</ul>
<h3 id="会话层">会话层</h3>
<ul>
<li>通过运输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）</li>
</ul>
<h3 id="表示层">表示层</h3>
<ul>
<li>可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</li>
</ul>
<h3 id="应用层">应用层</h3>
<ul>
<li>传输的数据类型：报文</li>
</ul>
<span id="more"></span>
<h2 id="五层协议">五层协议</h2>
<h3 id="1-第五层——应用层-application-layer">1 第五层——应用层(application layer)</h3>
<ul>
<li>**应用层(application layer)：**是体系结构中的最高。直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。</li>
<li>在因特网中的应用层协议很多，如支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议，DNS，POP3，SNMP，Telnet等等。</li>
</ul>
<h3 id="2-第四层——运输层-transport-layer">2. 第四层——运输层(transport layer)</h3>
<ul>
<li>**运输层(transport layer)：**负责向两个主机中进程之间的通信提供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能</li>
<li>复用，就是多个应用层进程可同时使用下面运输层的服务。</li>
<li>分用，就是把收到的信息分别交付给上面应用层中相应的进程。</li>
<li><strong>运输层主要使用以下两种协议：</strong><br>
**(1) 传输控制协议TCP(Transmission Control Protocol)：**面向连接的，数据传输的单位是报文段，能够提供可靠的交付。<br>
**(2) 用户数据包协议UDP(User Datagram Protocol)：**无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。</li>
</ul>
<h3 id="3-第三层——网络层-network-layer">3. 第三层——网络层(network layer)</h3>
<ul>
<li><strong>网络层(network layer)主要包括以下两个任务：</strong></li>
<li><strong>(1) 负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报。</strong></li>
<li><strong>(2) 选中合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。</strong></li>
<li><strong>协议：IP,ICMP,IGMP,ARP,RARP</strong></li>
</ul>
<h3 id="4-第二层——数据链路层-data-link-layer">4. 第二层——数据链路层(data link layer)</h3>
<ul>
<li>**数据链路层(data link layer)：**常简称为链路层，我们知道，两个主机之间的数据传输，总是在一段一段的链路上传送的，也就是说，在两个相邻结点之间传送数据是直接传送的(点对点)，这时就需要使用专门的链路层的协议。</li>
<li>在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧(framing)，在两个相邻结点之间的链路上“透明”地传送帧中的数据。</li>
<li>每一帧包括数据和必要的控制信息(如同步信息、地址信息、差错控制等)。典型的帧长是几百字节到一千多字节。</li>
<li>注：”透明”是一个很重要的术语。它表示，某一个实际存在的事物看起来却好像不存在一样。”在数据链路层透明传送数据”表示无力什么样的比特组合的数据都能够通过这个数据链路层。因此，对所传送的数据来说，这些数据就“看不见”数据链路层。或者说，数据链路层对这些数据来说是透明的。<br>
(1)在接收数据时，控制信息使接收端能知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层。<br>
(2)控制信息还使接收端能检测到所收到的帧中有无差错。如发现有差错，数据链路层就简单地丢弃这个出了差错的帧，以免继续传送下去白白浪费网络资源。如需改正错误，就由运输层的TCP协议来完成。</li>
</ul>
<h3 id="5-第一层——物理层-physical-layer">5. 第一层——物理层(physical layer)</h3>
<ul>
<li>**物理层(physical layer)：**在物理层上所传数据的单位是比特。物理层的任务就是透明地传送比特流。</li>
</ul>
<p><img src="https://img-blog.csdn.net/20160126223713317" alt="osi"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>OSI七层协议</category>
      </categories>
      <tags>
        <tag>计算机网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title>python之百度接口语音识别</title>
    <url>/2023/02/06/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1>python编程之百度接口语音识别</h1>
<ul>
<li>首先在百度AI开放平台上创建<a href="https://ai.baidu.com/tech/speech/asr">语音识别</a>应用，创建完毕应用后，得到系统分配给用户的<code>AppID</code>， <code>API Key</code>，  <code>secret Key</code>，均为字符串，用于标识用户，为访问做签名验证。</li>
<li>得到验证后，开始编程
<ul>
<li>1.记录自己声音</li>
<li>2.将记录下来的音频文件上传至云端</li>
<li>3.解析返回后的结果</li>
</ul>
</li>
</ul>
<span id="more"></span>
<ul>
<li>python实现</li>
<li>相关包 pyaudio，baidu-aip</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> aip <span class="keyword">import</span> AipSpeech</span><br><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"><span class="keyword">from</span> pyaudio <span class="keyword">import</span> PyAudio, paInt16</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_wave_file</span>(<span class="params">filename, data</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;save the date to the wavfile&#x27;&#x27;&#x27;</span></span><br><span class="line">    wf = wave.<span class="built_in">open</span>(filename, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">    wf.setnchannels(channels)</span><br><span class="line">    wf.setsampwidth(sampwidth)</span><br><span class="line">    wf.setframerate(framerate)</span><br><span class="line">    wf.writeframes(<span class="string">b&quot;&quot;</span>.join(data))</span><br><span class="line">    wf.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_record</span>():</span><br><span class="line">    pa = PyAudio()</span><br><span class="line">    stream = pa.<span class="built_in">open</span>(<span class="built_in">format</span>=paInt16, channels=<span class="number">1</span>,</span><br><span class="line">                     rate=framerate, <span class="built_in">input</span>=<span class="literal">True</span>,</span><br><span class="line">                     frames_per_buffer=NUM_SAMPLES)</span><br><span class="line">    my_buf = []</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;录音开始&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> count &lt; TIME*<span class="number">10</span>:  <span class="comment"># 控制录音时间</span></span><br><span class="line">        string_audio_data = stream.read(NUM_SAMPLES)</span><br><span class="line">        my_buf.append(string_audio_data)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;录音结束&#x27;</span>)</span><br><span class="line">    save_wave_file(<span class="string">&#x27;01.pcm&#x27;</span>, my_buf)</span><br><span class="line">    stream.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    framerate = <span class="number">16000</span></span><br><span class="line">    NUM_SAMPLES = <span class="number">2000</span></span><br><span class="line">    channels = <span class="number">1</span></span><br><span class="line">    sampwidth = <span class="number">2</span></span><br><span class="line">    TIME = <span class="number">2</span></span><br><span class="line">    my_record()</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 我的 APPID AK SK &quot;&quot;&quot;</span></span><br><span class="line">    APP_ID = <span class="string">&#x27;16795182  &#x27;</span></span><br><span class="line">    API_KEY = <span class="string">&#x27;8io5s7uv8pjYPUrQp1i8PcIg&#x27;</span></span><br><span class="line">    SECRET_KEY = <span class="string">&#x27;gK2MljvbcF3SKS4p0C2ieq1SCBNY48BD&#x27;</span></span><br><span class="line">    client = AipSpeech(APP_ID, API_KEY, SECRET_KEY)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取文件</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_file_content</span>(<span class="params">filePath</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filePath, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            <span class="keyword">return</span> fp.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 识别本地文件</span></span><br><span class="line">    result = client.asr(get_file_content(<span class="string">&#x27;01.pcm&#x27;</span>), <span class="string">&#x27;pcm&#x27;</span>, <span class="number">16000</span>, &#123;</span><br><span class="line">                <span class="string">&#x27;dev_pid&#x27;</span>: <span class="number">1536</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment"># print(type(result))</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;语音识别结果：&quot;</span>, result[<span class="string">&#x27;result&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>语音识别</tag>
      </tags>
  </entry>
  <entry>
    <title>python的进程，线程和协程对比</title>
    <url>/2023/02/06/%E8%BF%9B%E7%A8%8B,%E7%BA%BF%E7%A8%8B,%E5%8D%8F%E7%A8%8B%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h2 id="概念">概念</h2>
<h3 id="进程">进程</h3>
<p>​    进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</p>
<h3 id="线程">线程</h3>
<p>​    线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</p>
<h3 id="协程">协程</h3>
<p>​    协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<h2 id="三者关系">三者关系</h2>
<p><img src="https://i.postimg.cc/zG72gqFb/image-20191116114716551.png" alt="image-20191116114716551"></p>
<span id="more"></span>
<h2 id="应用场景">应用场景</h2>
<ul>
<li>
<p>多进程：密集CPU任务，需要充分使用多核CPU资源（服务器，太量的并行计算）的时候，用多进程。</p>
<ul>
<li>缺陷：多个进程之间通信成本高，切换开销大。</li>
</ul>
</li>
<li>
<p>多线程：密集I/O任务（网络I/O，磁盘以I/O，数据库I/O）使用多线程合适。</p>
<ul>
<li>缺陷：同一个时间切片只能运行一个线程，不能做到高并行，但是可以做到高并发。</li>
</ul>
</li>
<li>
<p>协程：当程中存在太量不需要CPU的操作时（IO），适用于协程；</p>
</li>
<li>
<blockquote>
<p>多线程请求返回是无序的，那个线程有数据返回就处理那个线程，而协程返回的数据是有序的。</p>
</blockquote>
<ul>
<li>缺陷：单线程执行，处理密集CPU和本地磁盘IO的时候，性能较低。处理网络I/O性能还是比较高。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>进程,线程,协程总结</tag>
      </tags>
  </entry>
  <entry>
    <title>python的闭包和装饰器</title>
    <url>/2023/02/06/%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h1>闭包</h1>
<h2 id="引入">引入</h2>
<ul>
<li>函数名是一个特殊的变量，保存了函教的地址和</li>
<li>自定义一个变量可以获取函数地址</li>
<li>自定义变量调用函数 “函数名（）”</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">work</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是一个测试函数&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = work</span><br><span class="line"><span class="built_in">print</span>(ret)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;地址：%X&quot;</span> % <span class="built_in">id</span>(ret))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;地址：%X&quot;</span> % <span class="built_in">id</span>(work))</span><br><span class="line"></span><br><span class="line">ret()</span><br><span class="line">work()</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    &lt;function work at <span class="number">0x00000161E3091E18</span>&gt;</span><br><span class="line">    地址：161E3091E18</span><br><span class="line">    地址：161E3091E18</span><br><span class="line">    我是一个测试函数</span><br><span class="line">    我是一个测试函数</span><br></pre></td></tr></table></figure>
<ul>
<li>当我们定义函数<code>test1</code>后，函数名<code>test1</code>保存的是函数在内存的首地址函数名就是一个特殊的变量，<code>函数名（）</code>调用函数，执行函数体<code>test1()</code>和<code>ret()</code>都会调用函数，并执行函数体</li>
<li>和变量名一样的，函数名数名只是函数代码空间的引用，当函数名赋值给一个对象的时候就是引用传递。</li>
</ul>
<h2 id="闭包概念">闭包概念</h2>
<p>在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包</p>
<blockquote>
<p>维基百科中关于闭包的概念：在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。</p>
</blockquote>
<span id="more"></span>
<h2 id="闭包构成条件">闭包构成条件</h2>
<ul>
<li>必须有一个内嵌函数（函数里定义的函数）–这对应函数之间的嵌套</li>
<li>内嵌函数必须引用一个定义在闭合范围内（外部函数里）的变量–内部函数引用外部变量</li>
<li>外部函数必须返回内嵌函数–必须返回那个内部函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function_out</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1.function_out num = &quot;</span>, num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">function_in</span>(<span class="params">num_in</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;2.---------- function_in -----------------num&quot;</span>, num)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;3.---------- function_in -----------------num_in&quot;</span>, num_in)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> function_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># function_out(10)</span></span><br><span class="line"><span class="comment"># 调用function_out获取内层函数的地址，保存到ret</span></span><br><span class="line">ret = function_out(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用内层函数</span></span><br><span class="line">ret(<span class="number">88</span>)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="number">1.</span>function_out num =  <span class="number">100</span></span><br><span class="line">    <span class="number">2.</span>---------- function_in -----------------num <span class="number">100</span></span><br><span class="line">    <span class="number">3.</span>---------- function_in -----------------num_in <span class="number">88</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通俗理解：</p>
<ul>
<li>存在函数的嵌套关系</li>
<li>内层函数引用了外层函数的临时变量</li>
<li>外层函数返回内层函数的引用</li>
</ul>
<p><img src="https://i.postimg.cc/Pqxknqqx/image-20191117154908036.png" alt="image-20191117154908036"></p>
<h2 id="闭包中的变量">闭包中的变量</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function_out</span>(<span class="params">num</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">function_in</span>():</span><br><span class="line">        <span class="comment"># 如果在内层定义了和外层变量同名的变量，但是要使用外层变量</span></span><br><span class="line">        <span class="comment"># nonlocal 不使用内层函数的，而是使用外层的变量</span></span><br><span class="line">        <span class="keyword">nonlocal</span> num</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;function_in num&quot;</span>, num)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 内部自定义的变量</span></span><br><span class="line">        num = <span class="number">88</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> function_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用外部函数</span></span><br><span class="line">ret = function_out(<span class="number">99</span>)</span><br><span class="line">ret()</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    function_in num <span class="number">99</span></span><br></pre></td></tr></table></figure>
<h1>装饰器入门</h1>
<ul>
<li>装饰器作用：在不改变函数的代码前提下，给函数添加新的功能</li>
<li>装饰器的使用：
<ul>
<li>存在闭包</li>
<li>需要装饰的函数</li>
</ul>
</li>
</ul>
<blockquote>
<p>写代码要道循开放封闭原则，虽然在这个原则是用的面向对象开发，但是也适用于函数式编程，简单来说它规定已经实现的功能代码不允许被修改，但可以被扩展，即：</p>
<ul>
<li>封闭：已实现的勤能代码块</li>
<li>开放：对扩展开放</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function_out</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">function_in</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始验证&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> function_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@function_out</span></span><br><span class="line"><span class="comment"># @function_out装饰了 login() 函数</span></span><br><span class="line"><span class="comment"># 底层实现</span></span><br><span class="line"><span class="comment"># login = function_out(login)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始登陆！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过闭包调用外层函数</span></span><br><span class="line"><span class="comment"># login = function_out(login)</span></span><br><span class="line">login()</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  开始验证</span><br><span class="line">    开始登陆！</span><br></pre></td></tr></table></figure>
<ul>
<li>通用版装饰器</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function_out</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">function_in</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始验证&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;function_in user=&quot;</span>, args)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;function_in password=&quot;</span>, kwargs)</span><br><span class="line">        <span class="keyword">return</span>  func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> function_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@function_out</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始登陆 user=&quot;</span>, args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始登陆 password=&quot;</span>, kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰完 login == function_in</span></span><br><span class="line">result = login(<span class="number">20</span>, a=<span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    开始验证</span><br><span class="line">    function_in user= (<span class="number">20</span>,)</span><br><span class="line">    function_in password= &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line">    开始登陆 user= (<span class="number">20</span>,)</span><br><span class="line">    开始登陆 password= &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line">    <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h2 id="在原装饰器增加外部变量">在原装饰器增加外部变量</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="built_in">print</span>(path)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">function_out</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">function_in</span>():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;开始验证&quot;</span>)</span><br><span class="line">            func()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> function_in</span><br><span class="line">    <span class="comment"># 返回装饰器的引用（装饰器工厂）</span></span><br><span class="line">    <span class="keyword">return</span> function_out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@test(<span class="params"><span class="string">&quot;login.py&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># @test（&quot;login.py&quot;）分解为2步</span></span><br><span class="line"><span class="comment"># 1）test（&quot;login.py&quot;）--&gt;function out 引用(地址)</span></span><br><span class="line"><span class="comment"># 2）@ 第一步的结果--&gt;@function out</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始登陆&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@test(<span class="params"><span class="string">&quot;register.py&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始注册&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">login()</span><br><span class="line">register()</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  login.py</span><br><span class="line">    register.py</span><br><span class="line">    开始验证</span><br><span class="line">    开始登陆</span><br><span class="line">    开始验证</span><br><span class="line">    开始注册</span><br></pre></td></tr></table></figure>
<h2 id="多重装饰器">多重装饰器</h2>
<ul>
<li>给一个函数进行多次装饰</li>
<li>装饰原则：就近原则（靠近待装饰函数的先装饰，随后一层一层装饰）</li>
</ul>
<p><img src="https://i.postimg.cc/dtG52JSD/image-20191117180313143.png" alt="多重装饰器"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &lt;b&gt;helloWord&lt;/b&gt;</span></span><br><span class="line"><span class="comment"># 定义一个让文字加粗的装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">makeBlod</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">function_in</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;b&gt;&#x27;</span> + func() + <span class="string">&#x27;&lt;/b&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> function_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个让文字倾斜的装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">makeItalic</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">function_in</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;i&gt;&#x27;</span> + func() + <span class="string">&#x27;&lt;/i&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> function_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@makeBlod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;helloWord&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@makeItalic</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo2</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Luenci&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@makeBlod</span></span><br><span class="line"><span class="meta">@makeItalic</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo3</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;LYnn&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(demo())</span><br><span class="line"><span class="built_in">print</span>(demo2())</span><br><span class="line"><span class="built_in">print</span>(demo3())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  &lt;b&gt;helloWord&lt;/b&gt;</span><br><span class="line">    &lt;i&gt;Luenci&lt;/i&gt;</span><br><span class="line">    &lt;b&gt;&lt;i&gt;LYnn&lt;/i&gt;&lt;/b&gt;</span><br></pre></td></tr></table></figure>
<h2 id="类装饰器">类装饰器</h2>
<ul>
<li>
<p>装饰器函数其实是这样一个接口约束，它必须接受一个<code>callable对象</code>作为参数，然后返回一个<code>callable对象</code>在Python中一般<code>callable对象</code>都是函数，但也有例外。只要某个对象重写了<code>__call__（）方法</code>，那么这个对象就是<code>callable</code>的。</p>
</li>
<li>
<p>类的书写：</p>
</li>
<li>
<p>必须有两个方法</p>
<ul>
<li>1）<code>__init__ </code>方法，必须接收装饰器传递的参数<code>func</code></li>
</ul>
</li>
<li>
<p>2）<code>__call__</code>方法</p>
<ul>
<li>格式：</li>
<li>@类名
<ul>
<li>待装饰的函数<br>
<code>对象名()</code>调用对象的<code>__call__（）</code>方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 装饰器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__方法&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-- func --&quot;</span>, func)</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在奔跑&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-- 开始验证 --&quot;</span>)</span><br><span class="line">        <span class="comment"># 调用原来login内容</span></span><br><span class="line">        self.func()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Demo</span></span><br><span class="line"><span class="comment"># login = demo(login)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在登陆&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">login()</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    __init__方法</span><br><span class="line">    -- func -- &lt;function login at <span class="number">0x0000024E64D857B8</span>&gt;</span><br><span class="line">    -- 开始验证 --</span><br><span class="line">    正在登陆</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>积善科技（快代理）Python面试总结</title>
    <url>/2023/02/06/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="d11718753e8c12601df89ce910da3e118f555f8465617bf8ceb4847962dc439a">8953ca386829cfa37549ea976a6cbd97393dca213d525f4b0291ee1c04d119d29d6fecce2f27f1f5a20e30236c94aa1c533fc5423f56b7d5d4c45f5be923bacc8cc2f69f932706dd52ddd886540271a412f3917cd249796227029f12518421a223c9a83dfee741375e118604a8de77abae772e9f3fd670335fc0af16cc122c93409e2dc1faddc2ed9bc05071747c07b5c16720f9be3cf825b2df139eaa671410ed3f9c724d5bb38d3da003ce4a93f28295febcdfa360ffac537840b09c5b850d106ccbc3d2b92310a39e8552351290067b79585b82988a2a29455aca143f3305e04bfa2ee254b2a663c1dd3c76127e4a2a1d57e0fa2ed6f4b1adb96b5003aba7cc97c728a645cbe777cec3aedc04efd1bbd7b7fa041e836a4a5a38f57908cb3921f74e04a8095cfcab4bd4539b7c1ed075c72dbb4ef245689991cacf8c543da18399120d927f98fa1c23ad635287fc88736d23b2d05208cc8b0c0cf0fd0e3a67963c02b57f7d06a80d62de4e1cd49b663c69ad96ebda11d138586aad04913bffef0ad2bf1b0ad7322dc19488259f8c99f4ba2f271f9b5c43defbb94cda08b166e0d4d6c5799707f39a59b25b3851e8a1fa091e5dc9630b3b9b1ce45e1fb3973806733cfff93f5f17a2ff756c12a98bd25b58929fb9308fe63dd68d5bc9b40a9df0d31afeca19e11464af403bb1295f73eef68662ddf5c6a74c696a3cac6be53be71d247cc945e82167e1dc54a72ace65172ee8a2ea212e0bfe54f80f53cae8be8e2a412060bb6bafb629658984af8d0fe4fe2279b2a637b8aec816cc8ee486a4405947352813fbf9b48cef1d0cee89512eb116d66faac1faba12609b430c821390eb372e8b337d3fd4ea4ad90a482b0df12f5f1fa27c0c4d5d5fdf3c190bcfeff8375fec0cd542a293a85272af1ace0b5cacb865fe182dfc39ac38d1eeaa933bf41a08b396625b1f28b639a3fa1f0c003a1c127d8a2fa25134a9395ceece19697238094bb3b45db8a7e4f214fd422f34f91c8e393852d0ab0e2dd5a5fba2af7e58cb7797675b76a3a3e2917a1f4150494f3bfa3a33d481dbabf9140b394e3c74ed19bbdc7eff6a347b1775166ce8a646f32db69f3ce1ec5da99af0761ed03c08ab4b4b500c31739d82abe80bbd27b5876c0a14616a2632734c98ed7099226fc65d7e6be9e5529a73e8d94dbc0453f67e1527eac0b34031371df9fb68e85d7b4ae0a38ab8fde7b8c667cf0e491b20ea3ecfd6bcb4039b63fa4f4c67e73d4b4a928c34c0ff99c2b760cb8fbf19a60ddf2b02dd03224417d41505413146e259cd854da46be45a91a271e6422d510f8f9d76031b80076e3c2078a48b13a9d72eb53a8cdca584b4bcfec520395523d8602de57b11864a45f81d474ee60a06176bcf9823e1a42eb3338fb944138dbb89bb3e41a39ddfe44ea8fed9988886e30be75a60ec2560f8f0b1bf3cc2f86631637dabba87cd444cdd0595cb94bdd343c8ac1234315f175eeb5f7dbad1c6570fd92190d182800603ad2a1a3e9128dcd221d56baea772102b27b68f781d5d051882652a732e56ffa15a1c29eaf8716cc2e5b227cc3f17be07e42b6d44e7138358bc11a0d77bf5116054a823d4d1528e1027374575480bb33916d3291c0c85c192bdab6231dc3677ba9bf6b68b279edf496271d673dad616f66510f51ab950aefc3bebd74f9b5ca8fac64264fe26ba8d1115bec7e0513e1ddd6c73e47ce46d64afd5210e49bbbec6f479900c18d8e957d1754d5251c612cf9894336539bfe3d71127450005ba623ce6d22db9dff0618de44d40628b7e8499860e8b0db73e4faeb0e034d5c3ca8ca9f602bf2fd2892eb5ac8bf9d6329a615980688ef72b9f2257271df88047c97db1a510960ad53b28f8777b50ce0af16649eda16d6c801bf13b0929e99aa8fda40129e78d1511aab09cf74c387e676a9645dfd7cda8b9206231ed338e0b254a94a290b8f38182855f61aaa3f0dc5c68167d36a54159fd83823457df60fdda9ca3eb6d04417b6574182bbfde503b5a95d8349cc83d054db0c93cd11be8bda98105432a97ce7c647a7d85271886043733aec88356e400c74b21e52de1d6d808d9ad049716769f53eb2b4ba166170999414cad8ba7f036a568ee8e61b1a0eec00b19b8cea848175a2af2233696b52abb3446392bd3ac702d5a1b1dbea958143ce3d4f534cf714048f00c498a75789445d8885e9037f94dcc37e02f45733139082f60f9cf5e31375a8150054f76a9c40ea79240a68d2377e62d6bbbcac5a6660be26afeb6f34fccd203af2a8a313bceef18044bbfa56afd2b1e6a3f8735a46d47a2ae54e96e11a76ebfa8a4e144169a295255bca6266ab35061df6767f0a38b54a0098cbe45eb1343c24cafff855c6a9fdfe1fad92af93631117a96bd76f7e3e07c7de6ea8badff18771d3a1f18f7fb08e8b29adc26deb49163634e75a27c8af669602863bb76c4e2a80eb47552098457eb5cdba750419b69fe33bef6beb463227709dc866f03f652a6f26f3a660488e73acfaa51dac3a2544942152468d988a73d039ca35e323d9947d05eb25fa0e531e56ddfeb7fce31cf94e254e59a4fe7515d360dc58a4139fe074badb57bfca906005bcf0438dc6b83a5420b2422f4d8df0d08ea54df32a12bc765d0ae3cec4c31d8eda25d5afed6c53597e343d9a42965757eab1a36ce8af44385aa80227a773dd386f258003758adb98bc587138450a4ef9486b339f98b1ee71b25c4f6acdef318bff3d4b1d21176e746508b894df0db52f5a5f9b2de20660658f1bbbe7c76cb060f91efe6d7e76eb6ceaace784550c7f851f8d1003036b39e55fae96a562edea440798cc83b45013e28a27bcf6e32903ba067b9c579b0478bcc1cd86dce264f09c9c056395e89ee24f4d9277a4662451d020b7cc21a11a5245974e122772ddde76ffad7933352ef41cfed165e042c41249a18d8b4e4b338790f71b68dbe608cf50e5b670ff20e910030f15c49e1dbd2317902638f806aa799a6d7347410d1785d4bac9a173c329cd2a42c21355dfb826da79eceb44f5d7c70c0f9b5db3a12842f0ae13c16d687ad3557f5e7a0803685567de85c9cf5f6645cf17286c5e294a83bab729f2e73d212f3212b700a8a49978f16e90db4203b9e2ef72f558c8f55168f059b8a93cf75f0db23c2ddead74b2e75c8e1bc9d28a070d2767657618cad7f17225075f9c2c4b5c9a34afe43d1c318116f34efa733d11f3a6d0b04dca259ffb43bcbf3032ab0262d47c4ca1ec2d328e80efdf6dc1ed6c37c1735193679b7543ee4934b6f831c84d4a12e4e926343989c28317a43e8194430754d9473c39efed15459c1055149f00cd574ad3691a95f5808df42b743965c99bc5cc7781ddcda6ece73ba99cba5c8a4a43bc39b319edd081792ab645e01be750ebc77263b45020f0a62af8bda5ffbb65af97d151da4849602ffb8a92c39f7fbd48ec9043f12e50614b1864bd8ecfb419031ba9538675df3e79086578b2c61d7079902a2e8e6b0ac44123d108acf0328263ff646172a66d5e1ce33e7250f288daaa795ae5b1c3e4f2bf29039d4388731311e76ee4ec466ffd42e6a23e2a349926ddde6502418e52bea42bd36d452c8525ed5212e6ba5ddb7c77dfbc64b027953dc9521532a00e4eb1386d67818158f038da4e153bdbf301267733bd13577419523696456d0628316b98aa33f8b19d1fcdc011999f9673cfcec663950368eb1d6d9d60b210add8fa807e1d5e7501b3f971665b3c84950042b4f81a36a4774212de3e5b6c4b2959ca8b8a3ec2c519a4b27c758fd927ea24bff415c0307d1e3b3256a708670dca230c051334ade76665959aee8f3f838245e8161f85107f3b26ca28cc5d2ccf0e6752ccaf02bd0edb6b1dd71af54d0679042350f26232726bb1393eab544def70ac275ce9fcc1f99da12798247fd87aca06cb69130b990f096b0bee3dbf7a3c9a2be30be9fa90c0bb1cfa09c218f03c0497cef99ab52118f45bb43201fcfb233a14383cbc88b01849db236b1c10e12442bfa29265661a1eb378c59f76094c51ae86685b3c529d27bbcf7abdb63f1690bf96bf6fbcfc8d1da622d22eda10e034dc0cf595154a0c6d07746522560754752c00a228b29e13687d94b60e4bc6aeeb61a4bdc9df74b64955848b7154fc6ce2e29e50b5224332b3991426ab9f9e8f65336ed36cd586a528c270544d2a1f0d8d6aeb755133110adbe06437a70380143375329c0cfec403f5f9390ab60b70b10abf93a0afa5f51f06e07acc9d658e235d2f9484d7508faf433781927b8eb01f6dbf5e13d518cb8001f07c075d8525130f20513b3da1fd759b39d4ffbf25b7f1aeb558c947109186d5b62493b681fd65630968c7ed6cffe73eab530e5209e7fdd5c60bbd4a25a6a89bced4d098ab671b96c22fa17e9592526636ba31c80e49acf9871d2fac82f2a7fb710df1908555b9344b939dd0f7a054c6b8e40832ec94360207f49dedeef0b00f13bc7653169b544ed2dcac66a97b8be2c3aa4150d08cf99e5664df5f54c917ffbcc7cf2e7dba06693d2f13a723d1003c4ebdcd07a4a796f87ea5e614228a1acb13791ed27e731ce265de1124eaf9868690cdc769f46e76b89821a5375320f703b99040823bc2b359dc519ec098df70431feda3e0c09ee212348d8baf2d614ef2feda1f71cec29ab42b78574839c3f2131fdc4e28e1e4f154627d11437f15eff3a586a82ccc7af4f384f9008b9aa5d9999a21d9ecbb1a45ad8fefe1549cf5fc61ef4bf5b577c1f752a6ecff9172eddf9c8acd36fc589a377e7346ddf7804a55c5b9b042bd0969a05969b01ac702d82359e5508b80a2d61a3931e039cd145981de156a4be1a1dbbbcf921255dafe09f2095c095a6dcf0178ce9b29f7a348f8843b15f14e5eeacfe026b4a3e8c8743d96b92a65fe302b7e1eda47a77c55bea123999055ad377e4c3e71a867bb6117e017100fa285c65dbab1632b22c2601306a0abec33cf398eee6ce361deeab938e92c3911346a8c86a7c7813de74d9995aa260744597ec702fd4d6cc5d66660d9ea2dc6dd51045530480be0e612f3d70f6c32bbb93b84982725157fe1d35b3a7bf27a0dac98bb318c5b18ac76a18cbb55dfb23fa0e0c6a0f00c96af55574d9973638714f190f63981606f987658fd988029c3b5a4390506c801b5223ddfba7f124bee76d21f6818bd5f3213f03c27ecce69bf3912bc4203971bb9230a13f835b293579e0d23eb5dfaba4703423b588cc53c03b3c6bad9eaea3ce13e0acb93d227a24901370790a97a6909ab6e63b54d75c3a11e1bef41cb888fc644e430f580a645915275bea24b1fe88ffd8317b795b86e6234877d1a689e4c59a865865311aa54328783d0f4a8516f358242b4e6f7e7dd778937b8ef5d86323ae2fac0b45081f11c26029b298051cdb3be589a56ccbe66db3fd139e7383ba2afd3f5e903dbfd7e37133750778f014dcd55de9a508b41c1fc8ed717f4056fed79024ecbd0b6d69ca663ac23dd8ec5d8d01cba7c6243f484a36b7e6ff6d90b864f491f8c3f9b71e60854abb5d5559216b0bb10842f542e80dffd7adf7425f49c74125a5196bb925e5e9763fa119427898f5568800c1760608033c48b35d2af3cab1960326df5c30964a717aa94b061e8ea2ae593114e353da374a0726134c2ef0c9ce7058fb7921a402915fab87ae709bd91ea70748c1c982dc69003ab8a2c6938173c874f3a853c92511d7a56bb2b8cdb05f697d3d679ff916a379b0caad97e3f8514f3617b36f8f83283ff5eb9d50f8fb8253b0bd8467aa82b5b04497bdfe0ad68b60bb48d1e8eefd9f31e3ca2d1974e26ae733aeddaedb8e08f29ff6ac44dc042e94aef46f15683c844115a5cb3ce171c92d573d7a6ae22b9630ae7e875cadcbe819d8873ffd2c3e958c074f1df9ce808bb269699e7b45c645b45784776f4d0eac09085f9e68ab04374b0ff02baae1eb6620fd197c6ff780eebeba9aa4761b655dd29f3cd442b5ff231c7eb114130aaa14f9a498bd1bb37314b5b84321dd3d5f7ee7e47f554f48b3f9638d6f8cfbb5cc001543a68a70b5b97373e6e4bfa1b284784054de55f3cacb5e8fe279a24d3de4e3bc13fc2b12add3da8f74c027dd51de81b7ff80e828f6cbac34deed7963633dad45996b380aece6b46165384e7a2da90644e0e05caa8ce603516198e0be267cbb5b7f6cb2316cd19a4ca1e055b85e5cb84414b051ba1dcc436e2cad7168672bc6b9a7ebcb26674c6152e548177154b0670b311520bc7a96442325ecbfc94ccc8bd46ad1055b20bd1395a848dabf6f588019a2b54cc98f5d84f70f5330a841e5e20b3e207e025aa4e9578d505eb6d4376a68768c7fdd7088f4355bb6b6950f3bb13b1dd937afb2786e6ccae1185bcd9514713d62d407460cfb838d66b728f1a033d8d26b889d933a15a9477561ecb851a7cbb5a26cf9b7be20dec7803437bfac25bd71f65f6fedc4690d0e2906dd0713276f315a69099d4e44feb2326aab65488304da5705bad2b4510b3cfb724bd1537ea2d12904eb2edb188584ebc111cea3deb05bb285fc32546c74a5a5960cf5200a8abd3a51bafa067c46e98af1029501718cc5d2e936bc568a2a0352d3908e9bd941e5facc9a8cf1d04e98f63bd98a946565a1328398ef33747d3f1cee2decf7c217d14eed26feddd703ec7cae2748234e5835090b127b943f88f7d0d618e1bca8f4ed0886e4e695031958f1e472c230422b4f080d139e07735f57bc5db4b56188b4684d77f3a1fa3868d17a517ba49b8983ea0ce7b5d67b7d7859778959f2023afb7baf9e5079f6532c4e1165b0ab0811c80eeea809c0599fe65d5cea110b266eb8052f5a7b330362b4939513583ba4d2e0e615fc0af1c038165c836388c53cc039a967f8b66bdb88ba2478e05d2854c6a8bfabec6a7ccf49d3df536b178ae0f307c0fef61c814bd675dccdcb1adae04fb7a2415a2b2cb635b3b7bb0dc60c41683087387bb4892279e42205f24dc9d2bd8e074ddb54f33a4e771d62739bf3c5cc2e3b0743268de29b3598e80e145619b29ff02c1d5bd54f5846f350d54f68b26439e49ca511df80d29f124bd4eb5c1469775f13c341e199abfcd6ee84d1dcfe040f16e808640a1992d3becdc1d2bd6e1fe2c35d6b830eaef9e59b6328c0f2035a6098ef1ea87530343195cd49d821105fca95cfa537c080d84834c51c38b5df15487915aa323b6f25ceaf48f2c13f60332ede8a9b421083e8b609dfb66c0bf1dcd373450e87a70b10a64565264735fde00ed5e991f82b07ed245b44484de724b7d56f4af31b4609d7876657cb3029111c81ac2351d168e99c3d6e47c3abfcb180c16af5280a406243b1f20b0c1fc009dbd46176abaccd69dc44a3b3c32104ad6bed0a0e503a49dafe84876cacdb73da59edfd3643e018e05d9436386fb1047f735a60f91944e02e50939656034a36d24eb29bdc46041288c09d7db511dc1e4e87ce8c73eed85b98da4aa25129a58357d25b2dbc3e51d2da08dbda670f8cc8b21bf10467c53193d4be88ca3bb3606fd61d3d7185ef8e2fc659996cdc97e6bb0bc9e04c33744abefe71d267423a2f64a757de23edd6b44d77ddeadef6f29ab0bda6c6ca60f2efa314559cd2d60ad876735ce57f738688e0f6c18a9b8a93f5de58866c141a44c5ad9e71b4b5a41a8f4eabc73265bdb396394eabf1ee3cf9c6379952175965777fad2691a3a4b7ea80173de043b3331bc6a41d0d8b76b51fb93e31414d5bed8f1e3d513d0eefa0dc85c5b60a6a9a34ca52cd5e1dfa03c6f13bde0f0d9931d86976517792375343a657fa719573bf0618d6f87f0edd19191155837b744577ecf32ab64a4bc2acff7f89d98b79a374e10241c7dbe293c7552661c0a03b25090393a9fea33a6d23c51bb7bf500bbf25b5097db6fdb7cb079157b54e3121c1aaf84388f047b91d61cd2becc67742abdb8a499ad96c6d3329062d880fc391f161221a4891f679052c6c091c1d9b57324d5b7869fa142cbd74bd1b7f0ac58c5745757d5ec886824bc56cb8f0483f928ca9ef653c941b3694fb5940d8014e07d2bc61d9abfc583800f3c40ba0479f14e9c64d7975a85eb889f360433a7b8db2fd3a5a7d627a27c5ec8f02c046aa4a011836d1de0f92c89da469a67c9b3a9e12b907d5eb973f24ffef764147d687f5f103c887f2a718bc871ec674c4a6d3cc1098523ff7c641ed4dd1ce790bae0cc5567c93310428e73c0fd9bf6d75b0f9bc03e9cab1e62bdc473dd7e98a71cc163df53f409fe62618be963d85968fc916522f1baf5573422093e52a7b657023a0d91071c0e487b080358a172eb787bde39c876815d42d7f6565e735a3048f847c798a4843f9d1dc676fd08c6701b15ad1c546a5fa65d3de019343300fafd4e2ff870a3a1e90aaf561c1c68035bf19f8073ce997ea0804772c6f48f065b82f8bc09a44763bd37e56e2c69238c63793e4138c7d9ae576dd04c59a4c6cca7c06cbe3b3428ea5cc075ce793c9a6b6a60c9ddb948eef6bd8a7d21c79f066c52455d2e69b4eb631865456c9433e5a4a2802c969631ce500e9aea33de03aedd2a9937d0e382ed0f8ac0c2bb128273b00d3e5c22a4b7fc07084d84199d3c165ef54475907db24468450af0ba247b1cb917dd98146adcd7b7736805046bb840c662e97bfb3f85be61c0fe71db173372e46b28a968cbf54e4c3cb5596271f211eb2891921ea8ead0601c39e50911e4da45d20f8c3fffb85c61b05acf4de291c9176e5576ab270fcb69e2144f20484aaebf833104d07b1aaaff7552a0f4b5ee6ee51cf14ba467b4f70631b61bd406da94ded89ac9ce53176f84bf77fe1973caab4de242cbeea707d12ea56ba6830fef21f937fcd1da816d0292116dd093d3b67209c7d72649d6e09801c36a19112a9a43f995c1bc42f969ef03f5ffc1827de9bf3e25661a7333a995d7fe660af7c549c8899473ac77828ed3b99eee4ee4fbf0e8e5c60d02d2b2117f1ac7b590924fa060058a5191782300d0286b225ca5be2fc9f782f81033502a7a746d116763af3bf6b2682ac15e5a7de74541a985512e708f84877d300aab6ba07da401dcf89cf88e29f6275b82e62cf817b202f7cd835a8161c53fa91a93fe17c0321d4184d8c8c2945573ac7caaf07dac5a38565d15904af2eed1cae14dae79c3fc6e816ee6d5d2acc133cf2295733268f4ce10cd18e38d152ac996931c4878563576514675cf2e6ad1e7b35410b598e1834992ba8216938eb7d42c1d0f885372fabb76e4a987240196e1bd8363eacf997cac1c88b6f4907d3834210fd1efabbcd888acbf2cdfba5e906adb6b599e693553c7bc3e2627171eaf483e3dd6f59817543fbf776fffcee1a23bdad5f5ca482c9ae8789bc367491a09e890aecbbeea6eee0c17becc91fe1e42880d07a4e33f6db794bc9b5b970cbd0d3908421254b0ff9b4303d1a2900437481177c6e32612bb97f369d410ed2015c4a9baf70c477f2ad6991f3d4ce9e0a2051308f697f38e386331e41f2bbcf0a01c492341ecf90a9917265fd3f361bab7750d7581ccee9caf8aad5bd1c2ac3420d8e7c6ddfcf8426f0baaa904ac54127007257c1b1de5bef3650d7c96781ac7a77e3ec9a61c16be84c479853beae748d8714931ce57cb37570d98605e65185e49cf8afb5378a74d7460a33e8c59e07d975c5c99d94bb7dab2d8773d4544d416becbace55ae823014e6c04a16110ee6b1c07768eb55904f9de930c4dcae285fa97ff8fd928597a7a4e4f0229d593f918650db894d7588323757b9943e59fb80b3714bb4c6c19fad2687dbf6d109091d9702b4b8f999da50262ba5e15077201160f6c3efd332ae5245176877a11728756d019ceba7ae547595a3ba4d2c939cdb1361a34833a5f965452d259cc9f08349a6fc6d8dc98379b70767e4088404ace7e0f49243ad8fe1b3211eb807aeded9cee5bb8dacdf3d98aac3afb859ad75157c1fcf7a12f63ddeb453d44b04b2c8761dfa5f23ef0114229f8acc524fcf44f1a9cc3f09bc9d4542dee6ff47242501831bf84c20ce83d9cfb707b4bb06ade2378b5664579466b7e191983325827d6a5a0c27c6e8e4368bb144e7242f1c2ad697ca0b4dc1a4a824547c98f943eb53309433084636d187e71be43d57c3704fd0346e61266705aa45428d7b79440f3c137c86b0d7d426e369516fd7b783d2021d271d7fdc37feb60c48b14f1cfa4228377fc02014b20298dc17c9fc165503891d8163c842b6bab2db6162f9f5674e815b07a638e6cc3451e1bf6f221a7920c52fc68747c3d4cecf0774d1f53417e6b030b11759222e202927cd70697f63604fb0ba256f4cc08b2789f22eb03a666535a4ba5850f8b3de97c01099e222cb4e04f92ff398a4823584838febd36280a624e365d864fb905b2972f87aa49941e5c5521e260ae8e005136550007469cd6cd3ccf21f62665c5b87d8a7b363765400e6cc42a60ef5467417cf6e9a701373a6ea2a0eb34e7c8fa1ceded33fa806ce2840e99ed24d818c6bb81629821b42ea52c50f9c471fb0582b6254e593bac369259557f8f04d9467e61cbd7f779c9647fa0ed25c82dacc86819d305661bc9bd6a07ac4cbec9bb130ba271b3a1edfa332edf7446138baef963474fd7eef5594f1da1c9ac9b22256c9e9a4794faf5ed38b9da536538de29b1eda08908df63b8134cfc1965ae100a47d7fd82f93b478d282e4ad6fdd3f8f691ec7d9e7acc5062d45191a5dfa2e975cdd38bd67efe0d741a2d4c62a6636ba33ed34b773982c7b43abee4ecc2baba3e5cf4ae9db61906b6d875e1bec1d82aa34883df885977ae12b4e2cd2e946d8dd196bdfe869951be91908d28e556175a2b5a6c66ba865df60a2cf5d503dde8e92991476d6f07cafb46a0ec2f5bf52b51fd008418647c35359ac94f09f68f570d7c4eb1ed18b6e08d24450268b1185de8641c81fdc4cb1f37662d0a88725f4db34779607afee25f3847a194b0f9a6442df8d9a8a0af043d8f966b4566224e2f874e9fe9c2d359c98f4d79d8e18c8833ff83456692f51ea20ab1036ff49182b4bcb65abcab719d29638dcfcef3bc5bbe006f8f54c62b8a98489baa0e56ccbff37a07ba3420b0541494ab759f6c8a43885c066a08baf1e62fd33c1cf9801f5521ed6d0e388a4c95289c946ae9699f452271dc0f6ae5261231f0e92358c453be43a07524ce942397a95d3cef38c58d7d49b541ee1986b915eeadcddb5a399ebc1df4e1b3e17d24de337845594818159a227570ccf67df2dff456daa07ef78b10059173138b77bb4b2d54068dcac571c49a6a12d9c8ee7cc6c7ef43326083a0f2823f980284be37cb46815254b1592127882ee4d59b8abf15c99f45fd1611d286b2c4e3ba5d83f26b91e9c571f34b72d5d33ec5eff6cbb787912afcfaaf766be24ec4400a244e020c59229f6909fee4de28ed1fcc9fb3769dde99255a296e3b37a5438d2c5a2f6ce98bbdd274e53eab9dce32307b551aea87e7e32f5659b37c64da88ec21444a299a06449bea9496cc379c5eaf227305769212c7e5d283e8868f530058e3bb2231a9701aefd3ec76ce4e7d8d9c55adda05938c97287b764063b8feca60078aadf94a7c7b14a208173572ffb18d05455f76a3606414f80884c1557ec063b2bf57fe267b6214c3db8557758ed5c0e50c7cfd3f387ad1cf4b50501e29f7ccb540a5fed9a2454871cb9c9e76f2e992e557d2951ae8d0c1b0c9ffe1a142f4ea9c3ba223e2b62b9f2af428b04cc07770225f049410ba2ffc553df3884947949e1559a3711a01f070ea9259f49cb291bf2465c2b249477b9b8279bfc61745e7bdc331d46ae7fede95f9f3bdbb04afac2844db3b30d0508066565974988e66afebb3dd5ba5ce846510d42d25bd2977ff57903628afbe0b5b6dda1ad7c536fbd41d8a75d070a6ec088687c2992bb5411474a7c56a77bccf8babb271eb2000fd6d3d9a72688ce84d88dca1f536a3b4865064f42030e76322d5cb7518b23b4add07dee2b0b20b0c189b5e6313ad17992e49ead5a3b2203c9cbea818530c47db16c5481e42238b8c87920b7f14676a101155e4d08f806cc71bdbaddda9fbfab9a71171e088578b367750483905c719977b2b8eab5ae074fcfc70eb2274845e8c66ca2db9843c9fd6f16da4412fc264141de58de45295b002528a4c0dd5ac4dae07691b8193a07e0590eea82ee150ebdd201a2cd8e25221d85607914dac2a8aba57ddd5c63ed52928e327916a23020b6b7f80842b59e9412e98439283a5f1d32b3fa1fa26a1c65eaff274a40b582b7e6bde344c60b6169ee471fe0b3e149a6f1ea47ce9499f69fe3e692e27fc27f8c62276a9205f34df9fa9ef9d3a0bf4a0051cb66c459dba0c54c71aad0f8f020ed2ae2cd005db603f0d17904d012b2120b8c199568974075cdb3b3bd7fa6fcad8041f5c0280504d37b3139feb1ee453b0c768413c4b114f51f01228d1ea0d81da175d9f0eb1eb6f156c44492024ca15e3d0f6a6febb285788a667ff6f8159b9932f1c5c517ddab9dd1dcf88bb990558dd4aa11b7b42449bbf9685026a061e3c0c44ee0a4be227c5defbe61e40612e7864b09641a32ace778197a362145f17d87bc1e5e3dbec4e6f1cc5ecec11b794c49e50475cd907694d8cbb1a200fcb8795f4673dda97d864b770e91b74dfdb977f44ce397fda858701fa4a96448ffa45ddd03a49401282f526903a694b6e7b2643ca92e155be5e6a054d234baf5314ec9cccc5dd2aeba0c1ab4199b8bb211341c225b494b78d856eca3e1eb32a8fe94e775ec9a7cd3c6b443c69170320d86c9a6f7ab4f8cb4c5accd47c113d203d0c61c4aef4dd522790979cbd0b2f61f8c8deea3f8a4319809b9af169467317381e28df0a30ba79f1b9a0e7dff6065d9486aac917ba104ab2d6cc1f766bb307a680a829c9ed50bb52207558a568b7f51b87e125d9f9d79897ba20eb675bb7769a56f001359b7275b3c581b1e0f8a180616f50f3075c54d284e50e28d812c8f4417ad2b941d685504f851a3f03d6e1f5d28cd50ce6ecd04b67dfa8b9e75a9ff8cb59359f8428738ae59a86eb7aea0cc052cfb0e7512d0d6b2d4ae63fca85982169b1b6306a49565dc9747ec284c7afa0470d0c11a55b8b371dd54bf4f972ca3959367a04d9c9b160f924c816e70a467feb4facad34c754ba6d9578c437fb508d407c2143ecf1c8e6a5881a3de8a6d29699168903e12d0da3490095bcb4e3b09a5a001c6d249fa569eef7da35b67783541859c2a2b2fab901deeba7c7eb36fc5704c9d00ce9a2b3660f1c1e49c36b1259524e694749f2fb88562e6335ae32362305ca719b9fa762d8c70da52fbcd98e8adf583a5e928f3815a0be45559accba6a3ee0c0419fd6c6a66a3c6c3a299a180544230a84b7a9fb029dddca82a31d9c144e9c8ae4fedc04db40dd65ce72a469996f4328bb8667c127d05071fee205f4b8f2f176989a6a0d6b7a688aea2b3bab48ea1754b83af39068411d3b14aa863b4408537ac9057ec0716a2435c6761298b5d2b042385982f5ffdf14e77da5d4526bdda234ce589bf3845a9e6fe595870eeaaaefdc9122337297907a908d1430b3e3984ea743112b6a93c2249c06a826f74333fbb2fab834f1d160974682132c8f0df15c2bb3ac4977a5cf018826e3c5e161374013deeb06992f29fca05768cfa564b2cfdc378f81f26da13b2242af36222571d07bbce9a263a1d969fe981c705d8279d03b5c4c4795ed0b0d1183ba36a879ba3d371db78fecd2af6ef217627b85f386cc0169fbd8141fafbf1fed03d69a4708c223b539eaafb3bf89071d0b5ab9bf65a67c3d03d95a640ea68880ab46d8cb5477fa4e5b5cc4f30f89ca2d1aebba7993986d8762ef8c89bbca6dc87132fe89fa6013283936d240c1029f9f1299cc609112ab61db5bd5a6921c7cf8954e708290401e4316dba85f76420bc7e6c8fd49182e58e1f89f47deb71bfe1f06c86bdae3a1018fc8f2e80f3940df65e4d1f7288d4a72a3ae42fe001ce5a451007f7e4e6ab0488f24c3a0485e2c9cc101437c699ccf3c48c77d5455f5a3e6c085f33ac550d9972d27ff57e61421b00c34e0b91072e46f780824a1ea9c687e954425a2abac2070c9186aba86c6ddd06b05fa820a5cd771427705e4655d2731cc16e65fd2fd14ef6909872ce8581b16e309c712a7de134dcccfbc6a367130db38fc8e9af3964ba3e95ab5e13d10584761eb58dce35589c20959f5c5562887c29ea9e1096cde654dccb9ddcc5d777645ab6691b170d57874f3b97cdbb70ea2cd7e7dbaa2dde60e9e2ae2916e8076cacc55d7871533dffb8c2cd6769a1c1ae902ccc599ee54fd47c4a85de6e05d36cfa244bb75e45e6cef665837e219b123856848d43f3a654b407ff9d6f34cb062c8de64879c05c855b13182e01ee26995cc210a7dcb7329abf65dd230c16251125cc379064b96e9858c817e27f46f33f15e6bbd8c901c711127fad1407d2da4a60c2e014af2aadfd43b7ee2bcfd74e5b8ad00f4bd647fdd7cbe9280730b9d2a2f13a45d9f40c05879311719b4259f0f292f320acb923ad447e0be8f0e37dbb239e8208492d15dd62e5f89f0eaf02de55abce2d81a5f5ed431bb4fcaa6e8a658fe0815a30b02734fededff20fdc5eecc30f4bcac61ec23b84cec301503c639174a683791210e2fd00b1748bf11ca47a36bf03e3640f4038e76374915c6aae05bf6949ba6ae5afadf20a948a837159fba0a40e556b148a8ac98e776fbb3d978e2df9e70f8da2d126034dc2bc3cfcb98863b053e49a887289c1071b9a5394818d0a11d766457865b558cef5028155115021f77588908033187f38dcdb9f47729ae6ebb9e3bc9b4dc72e5a73e75e4457b94394806c6f96c508ecf6dfafab6da1005bb658cdb5a69b481e431f07c7aec621b94c11990da09cd44a718dbc9f3a7bb9bddaa78f7c6071a17527f8d79788e9f97f087b43585afd2aa730c40401dd405454cbc1f922c78b10424a87495f7fb4c375e67a7ca13eec6a9905448af4783266bdfacb83cc784cd1f37e909ba1a3acdf73ca3856e2ca41a2badcc12f410fc5cdb1b8b1526c22b5f4c01aa6d6a479b8fb2e0ae90f5fa7226da1abb4a69f6bd3a21dd8a4e9b5bd69e4a96237f1088cef665bb921d148f5210eeaa10dfa2d5a5c5a3cf0db11a93dcf5a46fc17d6068734b246e50e2da0f6782a3512461d43c383879a3f64167be933f40df792adc7a417bdd21fe02e927fab8c58aa3c3beffbbba5c3babfac2732672df3c5b659c94fa3f7675c8d0de49c92e56351853178e4dd2980d7ae524b4fc7066f699cee2c1ae78b77e7f865211bc46c0f2f6d858dd483f6508a3fc872bb68bdeb7d9fa0adb860088abab1e4be556066c58ce3bd20d14c7f45b5faf8ebb683b2931b9ac1d4a7d5757ad43ada3851cf62dcaeab9bd40529512612e85b55b259ebc97dcb32c54591cff0d56fbd3dba365a956cce3795fc3db604211f20dc3bafb44e44e9d9264c073ae805406dd08f5ccaf84e9f6687a8e07020b2d16711101dffd09b40f3ab0783980e72ea833aef489241992307c176baa987f8a3cae8faade25b2b1829d907769759926d2e1954e31696cac843d158c82c102174f79a6bdb6571b8dabb1ccbd92a72fdcb72b7bb06f0b9e93c4fc5abca25eb505c44f2a65674e045af4c445bf7873b724bfa6dc5718ad2bb283a4f40e97863e2770cf768255ec44e9a0263951ec97ff09a73c0907714515365859afedf343bd7fe4281eaba4ba6d548a28fd748198eb2f98144d8cd224e29424ac2b6a85c90cf902c7bb326927485997ba15ede1aa1835e00966327fe31eaea83fb5dc058ebcf612be00259833113ebf01ec41250e1d8867ac43b3101014b6bf8851a9681b4d22b862db2f5050c4e8c0a127698775213c00af93206cb66213c38b2c1735e3803d963645721c344103b351a628af9703758d825f4e2e536a2fdd66d401bfc8b0fb48c9e0c618a80d2921996f6d3ee803af1be2851a796591dc555f40ace346874010a421538e1c488a3298c5f441c04a9ca8b041a6d8efee94ae53dc292ac19752e70131f25d0b72e3fb11ad019bfbe4492231d52cc120ac333cb9310f93c91aad5552db720a292af33d87f114bfb095219135ea26130ba896c7ebb3b19892513f471e403114b85a033dd427cedbac2f704b390150a8719fdad97230f11616bac594337d8bb5e3ba69ef2ae35ac06c9aa9011995c24eda6e59e69f7e975f4596ca96a622ef204538b31a0fb12c567b271e5cebb5e99cefba9565c4e74fac0b034f47b6c9087478182d03fc82f7396bf3cdc89926565cc0ffd36d87f552026e78fd6c8e2e434734b86f6c9a82ea0a27b35008a0143eeb9d222f3a751015b0d48dee658a698d14a9c6d3ea230f22283fdbad75f6a82b961e77e1a927fa6623ba05f876a68d5e47d6c5692bd664b2353ab9ab0224cb426eebdb372b305d0afaec0f6549bbcab0282b87c330fe6c5f0084fcaf6b81b0311d4439fd3705804fc107a63e74102943217139d7baf96f95e078f337fe399f8c13cb39db17f25379407af4c1479ebe18fc6deebccb385362bfa8ce84451e0057be0850ad19dbb2998cff82b915035ba8e84365988502dc730d30b9d155e322297fc9c903d5dad2d89423094d82ce0992ee329e3f284668e1074750afd3a860461abf6ff99b7504d6a2a06d9baa64d765b4ae1cd2bdc0f66754209f93f52ce75f761eae68fe875c71e443818031a0385a1e8acd7635c73a2a8c13f3fedd2dc6c8de7a98730e7c2a8227418d258e8e2b86b173e191dd926c77e8eb03ea773757d171f4a6b2b99c9c7dcf3430a6731206f9a94fc8a4c80812fed311d8ff5650de14669e2566fe27269917ca103fe6251c05a9544583af3273e1ca72cf7da0d76d581189dcbc9bde0d6402b0336e5cc8cf5dde4566106851e2ecc9252c3206c6de818fc47468af55ff2a11fcabf61dc49453ef803b7f36eaa674e9307de5065cb7950c19aaed149c06893260cf27f9a4017beb504c08bb7a066075920cc3e20e3d0e6f5b90c0063ba3c0f52f4bca2dbf11418ddcecafbb82e7ccb4c2997f3bf262b470525ec8e8fa93346a843e58042c3e6ee36867ee9df47b7b8f87ee7ed552568684e4a9e5781be4fac2eae4a205952b1c968782ef22e0101a50a99d17ab2fa1594822e0362b36a1ad5ef2517a8d830dffc139a37b4756937f0d084c6e10f53ef307d5712a3bae2e30818e2116fc604de57bdc9bb6e2d38059cb4781755be91359a5e1de58129679e2b45a7cb7c51ab4d54711dd030cd4671ac9389695a693a51437a7a3611b99c5f27e193c17e1797df00e565e6abd6b07ab5401ad510267e01f5c53e6cae834203440fe0872cf805baad1721296e476a7c4174dd754ad6a11c6c1eeeacc6e8e652d96ea6cd3c9171f0ac1812d410c1fbb4e3461b650fdd1b30180744f5275d70a9fcdb5869102034ead52df1cfdfd1bdb07287d9745eac170a564be64ded7bba5ab09489a100686e0b6c82355b7396b10ece900b305f2b0db084c3d915b8192f6df0a17462b611bc16538fa8d067e2482f95c046a6c553ed8579142c74ae0a2811190d3bd1405e1ba509c8eb2f0be0df36179fdded5dbb5bd1d6268954473cfb5fe65f40b77195730e5bf75cab71947e48396ea3ead943408955e9cef9c4bb405ce3ebfd79899d1074ebbfb230fe48b5fd321ff1091687890326566f583a1fe4617619c9ac989b66e9cff5017c775fdc45d0e130447eb31c36f6fb37b9b5b5784bbadf56aae4affec81397533526f2d8998b4a8dcf0d3b78031bb7b68ac6f95ab845cc68e49aa37a529e179fafe75189ecc3eb29b09cca874cd34063df5114f07b982d680e2608a0526f10af4a02fc96cc7669c5d23f13acb71c6d92745d86f1a275968febcc1e993a767ead69aa0eb7b091a8e57e017dcf6699660de4c8e4e41095d2370a6076eefb0fd01694f0ae485efa2b695f895ea031870a16afa6d54befe522a8636d9aba5d63c78642b7736b4192b3d111579721c215585af23b3818d4108d41e9402471c44eea76403471bbc6c56d412ece4a26cce06fac95090f107322eadf10e1d6a8319006b09ebdd48502462410f55bcd0965923cca94c7ea164201e89fdd2c9e2b5a5cc45fa54849af4a7c94a200526ccf2c34d39081add4607fd46b6b3b6b4652e5e9ac84491cda70d5e776b39bb8640d818f89ed0d5db167584b9f354151391bd8c27510bdd904cd29a1044f6495a4a1d62c1808e5fef8776d7bff4ee4bedf129f58bc994b3a95ccf702b2ef33f106ab66f5ffaa214863322cd1f688e3261c7bb1bdaf3514b324748fca8cc7c6490408796c1e87a7e824addae7eeeafce6e78c5298fc6748afd65e5921e59ed0bd3bd7826fae103a72d095de2e1ade9dcb6e8c9c8e4fa7a0f06a3261c4dd34725ecf9cba34a6575a5bbbc06cd80df4456fb0a765d7c02e345af66d70c5b6f4b4cf488a3696e8537b16bf65870663cabca7abfd9a467206df6c3812fcc8829aa08cba9c07bb9238e0b65021c76a1133e93cd35c686cfb1b4c7506cb1f1eeef9ff4834982d314cf1228680e428ad575c1d9025cb1bbe9dd6073b6b0139eeb84f3bda45cef56ebe16a71534b1955871b8fb42093c0d54b06d38aa4895829ce4b4093d7dd30d13bd27ece25db4daaab517cf1a21d2ae8f7a0dbf410b0a797de74aa1d457c685b1fb2e92228394378c5092797ad28c28b66136769ba08f4595952efbca55b718d9b776e095ac423a6ce8ddf4d3c7df7016a54cdfb0e990475da4fed63e9037c54ba56a97c5e1f8ffea8bf2608ccf021e810d0c8aee8b54754d96f25a2a58ba26ee20a4f0f61ddc92d3ce28e2b7f616733638e74ef13f724db8ea17533053d23da4d4cc8993b531b87c56c945d1a4053d57f202fb3a736f38da102c5aba15b5956672494d162f769873fefe134caff67935b48d89efd34a0089821d3339c1c1c628afeb11434fcf9413ff82695c7e51d61a5b7c335db93297f1467557051b2eb75be3e79052b34fcdd34c2459ab5652954b78936d49fef5ecfaac28ce47705fffa142f5a357a4ac527e8a672ac3674346e264faf7de333db4a027559cf14c9894eb5262485f290885bab84e0ec0e51bf99e335b820d8a057e69633ec03980c5508ec8200ea291ec22c61c323b3d87b7924d402153bab04de09e8ea98acfa9e116fbcde3aaf08f2e1f3172448ea8b42140f97e8f40819b43717a599b01082c371f42e86a1d04686a0fc6ec7677b42e7ed48938a1048ca6ce5eab23d66ba5f7dfd986a86bdaa221ebee9180bba82d9b08802a269016f4d9299b7c6dc4386ba4ca6232f33943b159aab9e48b6957f3bc811d14f124f92c1e26818cce249c5253f49ec5710e5156a21cc04e330df7a67b80f9c1d2a904be4ced5ec8c337fda9d835697c905cbdffdb6f37ba70ace1b0d19af2c859810fee1cc5c017eea63834d5679031eb131adb470c149a475f2b0e95f013ae8a98d662939e0f1b7f935410049c93ce8ea37e6024cc70132cb6fa11443a3cbdb00781b053e59b190e68589690e409e5fa2e9c3143543609b5194d41e7ca10db2086a77bb8d5bacec4eb7f878b4d8e78a245f586474bb37d5f0af7aca31ac3bbbfa537df2177eaf63eba633249f4680089d88df5fe04554c156c3c8dd453fd721e0fefb6ead7f5217f1357e03a9c03cf1e05dfaddf06b72f2dd18ee32234eeb7a742d0531d79f6f34cbf3cd29db2d9350a33a95eb128f5afecac0bb56650effb26594bba0c93b8006a209e8b3950c98cdea880d38109e98997c86466928addbe6cb6d372943e3b830d94ce92e6d39f45f45c40138673d91b1946ca634001fc4040219e9bb6380271a00ac877759e0547874faa1506c4c0d9b8408332ff0dbaf3a0552a8f90e737a03897b6bf1cf5a88a07b1c7106b9a23c74bbd94fcce369c966e5bb1d5393105cf7896f01bbec9a441715d052510d472261aebcd069e6089d90e3f5f76ce5b823e116f8556d5562c1fa925f590fb8e6a0922c7f9167809dfdbcc5b26243f056e78fa5db4ba13c37a275168c7c312585b52ed79fc35d0b9f4acb0e7c70f174d6b4c80555d1e851d741fd8f40141a5c5d537923e3eb63d2178f1ee6e9a6f3b3b806b800fbfdf309abea44c2c98d90b10ba9545cc3d983416f137adacb83a37324125164347cd820b2953459a75deea9061cb0686e7ed31a6054dd40a69f62f41a10dde4923bf17628e73c6547b453230a21743eb158a17cb855a557d9a428e7731d8af38e4f659bfd621040eeb3eba66e661b6f39345f042faef137ada807d44d5dd547a99dcea82683789cb91c2759430b501d171e46e51f3710afcf2a652425f36f1903fa4d97e0a0736c856a16168a4a74130b9bb67cf94ccc6ec6af4c8b0e3832528c2e3adbb7100a0d7d037c3704a9817f907a460d0335a09068fc1c3680968afa4c27bb9adf17cdc580f5a078def8e9932e19cc473916bbe7bdbb88516323e4b4516e0958f96abd13dd734766d4bd215036162010563471c9fcaa797b36f75ca7b0b67220d55785c9d3e887453946fb66c6218f459a982ed05bab84b1da8a70e75bda54f3b4354406cdde052d44b0d285b192a397c2d7a8c18874c5f4582635649a1dbf1d39e16002105a558b380183b059c847d9a197d7fcd30110fc27842493b5dbe72c9f236352ff0b16f6d63997a20a5808e08a8f540f05320359e42579b1dcaaad8162b7ff8acf15e3396d392abbb0b76f8e42daed6d0579b3190d6274a92e1d5b7f4e589f4d0f431fef45a6f9f25b4cce157fabacaabac679a301030ce8a95204a93e315863b3b0f907a8f2df04e6de7b90603d1d507630f16ce735fba44823cdb3e2530b6fa02a31cbb24db40b1da54af922b245c031279d15fa403bff742e2e37887882c2844fb895f5462319ff02243258181c32bc1ac0ceaf353ca23972382e7f17d4e2b0e0a1764621f17b6b7a458485c6993f9f4061cecc85a02a2ba8a39d7b6495b6c12eaf22500ac6731a88f70e953b4505cbd107fde95a3da7b217931070c7d0e4ac3e84bdeeb40792d94f91066dc169daa845422b7c2883bf0ee44b4cd89383a122497326a0241706b0b17dc11eb1468af0fbf0f0cd85ed654a793a7bb85306bdd79e484f57feae08c18750ef55f66f7afdf8ce932d4b6ec5c14c5a0436316d4bd822091059bfff1ce83779fb524a28e35d81d7566f07d5728d3c459f5063cc3ad64422e05bb17d9cd5a11983c8478b9e95ea16800b355a262a725988e50bc0a6dded1adb054b123dd57333c0015027f06a20019626601cb940a027e191758b43595b90cacbfa44748e500b50d11d5e66be57d77e4b68848831bab17d37efee80350bbed0e418a854cade3038c93b416568e114422601e74cc75013ed7716bc18095acedfb3afed5315cef1f8978f181f6d2e1f8bc9d45b7d7f00c70a6858296116f0a1f0cb7417f5a7ac83d41f876972b034266c35ede4be0701de5c25efa81526ccc1864d7aa58eacb410f4f6ed73a23e5a62e601756bc1bab6ad28ef5551158b92dc7eb003d4a416d6e9c8258fdf9577b6688881ec6993ba0476bd40112d1b21a3d825b1e0d4efae07c68d41187570fdc24024409413b754b900eede773d3608a1dcbd2b534da0317098af0c50c3963eabff81bf82d266291f1393c324b5aa3b25d69b40e442df198f48fa5d4c617b7cfea93445e0e61b614c207f83ca9b1a3b81ac932df6b6ba0dc1f1cfce688977d769bd4e6f79f06fe4358e99aa344da0890c9d6e9775518c9ab6048d1cb6270df0023f209b171c07bdf56d83476ef66e4c66c10733f14d1a7da8c67eb0bc1f7b60854ba8856336dca1a14ca0796be12e2d9374317be9036f576410b9bd9b88878693ff1b2045c4896a0b216df5694fdf9c1ae4593c7001e4359e166c1503a94ba86595a683301d831bc29aadb32a7f753d57aa1fc7c3ee43614a1efee26acf0ce7c0f00a7a471c75af1485893da2ee9406429897b1cb70aa9c738338572d9deb14629f6680abe8ea885fcbe16fe09c099d76e707990a61a3b978d2eff9aebf6a59f5d738b9d1b988e00aefb57a5e1e500a7ce0d7362a12604ac7fa46921b7b0a9b6b8e1b41384bd78cc199744b4b32267d70c70f3151e6feac3f4521501e6900aab2defac909b864a5148e610b35372c830f1bb01230ab29f02229a0e9525ac495701c7ecf85049f7afe3230c99de01023b39ad3544daea9896ac7ee3e99d5b4d3b9c044a2aae347e478220a2ccd44642e2427331ee5d7cc770684ae7c598780142b4de86f906cc77066bcbf86c89c26497fabf28a8138eddbc524342cbf887bd1a98185981a811866f6511e16cef32b112bcd92af73093986174e4465c12fa4edaf2990e4221292184bbf2f77ef598f2a8927f6ca0d9a6f83f6e17d08c0671613d73742313016c6a06b4b0f48c14a75d2635033b5a7f278e5bcd79be2444a341a99b0f93f1c25fd2f0f1292d622a1f5bbc97fa351086ca09064d416f2b16325a69ec63b8f618e4e9d693e5030b70b6a317f2bc990d2ae7115d37efe4bb741146b023808c480bb9cfc7c6a4b45d72cd3a2b27a4826f2a3079858bd69d799632124ddb847cdbec7dd611099f46cba46cba66748de42978cae393a21197920fe4d1b47aed013f78ac0918c936f833af1c3adba5a5e5a4b74fbbfe59ef2a80b30b48bbc13f41159b5f0d8057f752cbb07d103cfe4e48c241a82b363652dc24d21161127075c01f075aa503af2bb44c5efc8b485155b84d34f02ea8823d94e593697cfaa1fe05c5df4d3a62241f14714c3587357a615fe8cdf04e39848838bd83271215bcfbe2cad4d7614527b24f529c47d687868486a97ad8575045c86b5a82a1be6e2ea3973a66165284f51489572dca8e48cb50090a530d70586eda79497bb38b15b3f55ec1a288bdecdb5ece69a90dc07b1964f836809401d13d0a72582d2cbc4cde4571a85f23c0a1ca60b3f6e1cc4bedd21539b1d67ff70765987f9a7e83016881a8052bacd644f2d47b80b40bcc347c30662396771b774fc556d4b3010942d8a13d314415bf786232115c29fae367bd08ca30ff5752a537dea3519d4d8501d816d942f719683d0de225f7d831951d0426107b0a6ca977a2edfe964f67b32163dbcc545e759a804275469594976a005b51364126f5607b47b2ca25ba72f8a27966e9218d178cec65370f0a1cda0cdb549341249f0f8365e55afe604fab1c761d619ee96dcc7e8422a5a57d439368cfdd01ec4a9b8edf484eabc0eaa1055fbb7a54de3be7972aa52a1a8bd69dc8efab4a2e0a10dcfa995bf9155bf850149c62891c78a43f5dd5258ef056722cd6588d1e21fee35805010ee018fecbb8e744f2f4cb144d1e47bd5ef4f54204efee4ebcbbc11d04094b268132c0d5b5eca55dc163c54e57945e0c180322234025df6c2ff0cc43f79728c36c93dc45b917058dfb9755a5f9fffdcfb060072c30c338ec49f91d7a4c8bedde89837e76c5a430e3df4373e6dd845683b52f4511f0946ef7ba1766d168a299648cb374f8da39d52baa3335c3bab6615f09fe5b0f2f55542b81195c26315c64f46c4752a392632039ecfe128fd18fec6ab95d6a2a34c06f6fe673d111a74fb729238fe127ebeda1392a5a73e31b897f6f5ae5c2c9803f807bcfe8c6ae03041322965c7e58c5a74f4ae94d1a9b3fc5070fef4a7783ef26fe2188bde71e3f56bfc3f51e1d22cf2781d46a23af40dccfad84c916ca8a4712986eb6625d9142228751a1e940e7011474ddaeea1549762d7a3d71803bd9c467fa3ed33260d27c295fa27391198616d31b834a64d84c9e6be293c2cf15afec57706c9fecf1a209a258ef43796c21dea8d733f2a0d3580b7eeed144c1e5f46a8488d86953dc33331f943486fe681cebf8c1072829c05e4a9f841be46be7e4cfa055a144d32cac94aab02b6096e64094787e4139523e17b9f2d9632dc0afbbfee722b035ef9d8d78b7afdc68d0f8a8f581681c4e92e20bfeb7276fa20f7363b709a9055863d91b5b6a140e3e15ef14d027e9d9b5113f36df8391ba1b5ef0833b50086efcfdd244402efa260ac1d63edca33ebde1473076b5c071e42012a2525d0b76458a2a25730ac27b96dc753ea317f2378adfad2e8b1049ff787c8334d70ced373a4f709de2352fb2d2c3cf6ba935dfa96bf52eab2249fbe23fc52f7e37582a901f67c1844bc5385a983d7fe75870170fcaa4bd30f036d7ef6abdccf5878aed08576eb299352988a60ea1fac0187151ef894987d0309fbabec95bce63fd645073bfd8637da15b8e727cac93ac82d76d0a18d135d8f7ea621331abb816dde6570060ad27944723fbb808ad37a436735c81423076a1473821d6137758ccb6b0ffc194473e6029b8e7289d9b4d063f15f676e45f4d63b774e7d6ad06f996f69c0738702222bcd73074068244ad51317df9279d576836ae72f93b6560eb8e5be2f85a7b218215565c30a9770bc86e371e1d6dafc0a3f9794ab8dbd6290a56f025c400740f368677e223f4bc9c3d2709617987fdb78bda32c37ae0b1de9133df70f58547b89e0baca8cc38f30deca0a2a92edfeb5d8be5bcf060104fdabf3a44ce5a551f51a6c06272cb654db12cb8f6b3a36dc165a559134acee58837aa94f5c1ec589b260e46e720b6f10fdf0deed564f87cf706566bed2cd5c81e696ef296db66721b242a8da47023fdb6ec64b054264ab4ec0950922fd265869c8a63c0b6460bef7d45bec9655d45fa25c39ed522a698f88a04534336b97c0173636c964d1b16f68deb73ababea014250c30df16dcf74a5d7fb4646c47640fff63d91d09bdc25fa625abc00979459d67edec07c0941588a567518d0a906d6e7a7ecfeb1e2c82e1db83536f95931c7cfe6d5225f6cb05c79424d70441b0acd689c4581ba29f4be25ab80aa712e24330b3bcd50f81b1219f0ad49e35516e049925d65a31c0277c84dc47a3f245096ea354029bfd5cc66a0c5d50d667da835cd2713e8320f3e805ce847e9c65d0d4f7fcd5c1c7d8ed199accdccdcc22dfc0d3567a20827913aa9de676c12798ecf4f96b832dda4c27e959d4894cb2f13ce6566455453e6b5ee55a96952b5322d5c199231e793031924701abbbeeefa2ce379a0e34e93d355821305dfdd98305c0ca4b2a7de9ab5d04a7fab435c81b8037996e819775bf00b2787cc6c150eeb7a3b39d5db403e402c728df64b154e4845536d59322d49a9114a3f3f211c046cedd6a6bc4f4dc61ca9384c9f1513e0071bb1306b4830edeca973f973fc0f2ab817cb73f407f2642b0dfbbba07964c8b0a728e8d2185798dda5360d43673ee4130420532344ea820a6dcca007498fb1c302dbdde90f80ae11103debf0b3335621bb50ada9bd7d5c37cf07516143a7c110bb8507ace9628462ac2095f92f10157f73fe1636026dc99c8268371f7e65cc8c4bc5b729b5e83662c3647c0e1cf54a499fc1f09ccd18cbc9334afc6fe05f57f08778b79bf0f5a6dd4efe92f9f44e32c997bb4a5177838d53912d615d266261b77252f33fd1077f7622237dae6126c12e093763f3d94e3f45c85d8ffdeb7a31bec8b36e531666cc47b23009e53347d3b88d711272cfa38792eab320c1fe24e7d9bb1aa34dd9273882002e472c8946ad7ea19c3b764a6ecf4a968e330f95478119a1e22f0b989eaf4f205d3ba93af82a7a9445fbd022587b883e5c1515f0cc5c31d5af8557a4bd11c60b74e020e5364b881100663ea5ed8a6df74c2171c00ca09f41184a1b51483a40ca12b9dd4b37950344bf68c01ba6c3cedcaae6bc50969adf8e1dc4fef1ddec329269fb50c79819f3b67f9609c0be506ec2b5d63fc705bfa3baadcb6fb4d3d308687d048282c4013702e6ca6623d550a8b6d72795a5613b160beb750c8eaf92fbe68fd4399cfbde955052d3c862654a694bc3560b685cb73c29b8687fdcc067061fd2d70d13b01ac9a323482c2eed0dfd15e57c97f515e865431ba0d06499bd48a4c38053d37b8458663f4da2cf9ff1e60b6f7f4a5bdd7b769662916dba37dac19eb52266f70f1763354e3ad8a3c948610493714c747339e809404b7ae22fc8953f2808ad2737c4289530ab08852fe7e02d85efebcb7f93dd836b795b2aa7b33f48d489850b63d99a9ad0ffe5de00e305c45cb41823946f8987f086d4dcb1ea74be6b8230597855fc07dcc82e83232af955135e2a973f33fe2cd47befc0087bd890fe19e1ae708c85edd63330e3d278b964fd236f928b606ad23804f953d25d3dc24fbbe6a2a5fa006a23cfcf19b01391d8313edc5641d9f211982d324e3d4abdc33910e07cddad166feb99576b8bfd11427af7a214d91e13f07831a2ff6883c9f43810eed77b1a896e61b7119f293df6fa8fd41e135406fb472da381bfeccd64edae71324c46624a17927882806004c7c2a56b5024157e42f253a995287b5bfa0fb2a68243ce5ab5715b1de8d18a65ae320d3210108d129efeb72a2bc1b2c8df96e2747935f689a60ec193d088ad1b78a0d52c24a0206e29a4b359b7c83bab0a582813a9a4be835615cd6a8a7dc873dc731f093ecd4ede2efe344a462248c479831502dbd34d9392d54d4fef4b2b9c2c78781df8d999767be839654e079ce91dea46f6dec5d79bc2be5cc38609d4ab8ea3f6c4791cb1576e266917c6898f99b81fc20a1c05af67bcc126216c89e29a8f365616c6232a4a5683fdfba18ce822f342266841ea42f477d7bfe8ad859a39fb447b0c0694659da60334bb572818fabcea3d2b130b17f11cad35f1eb9a13be31eea6ab68924bb68d308c763eec74719ae19789e6762251451c90080d13fd50ed6bc9584f50ba6d7520d57c184cbd8b53fb1e2012db702c37134484c1156d29637f1f42db66ab36b3d9a5ac3f11efb96cd59f8e9e3169906cb834bdd8e32eca11bbaf6208621e85ac52dab5b347c84a949d1a9418e0df5bfc3543a3c4fb09b052a58c2340dc30f075563ef0e7e6fa199065de57da152df8eaa794d79adfffda12b6280cc81003e5207f9dac0cfddbcbb69b4d0cb7f998f932937e68d61a0866f49b2dfbaecff99266b657166e6c7136f39e4683426385f0b491eadfe3be6e73fb137fc0254e170b4ae80c23059800d69fe6167e1e3231e456ab966b65e1a687c079690e50afdb13098d29710ec030367e185c1a7402d0ba2ab6018be90a89fe0c356534fe1ea28dd44267a22247cd840a99923a865261c56964f9107c627b32f497106093a2475ce5dc1fe3da1ba778de589f295ce3092949c0f6151a412890c734fced4f0503dfc7be71d87a9684d6b568678b7c2dca626b5f6f3c5a3b4e5a289225b1b09b8dc252ac56428f6fcda33e684515ae72f88af30f1112cf3a6919568b260737054d3603e2faf9b9d673399e9aa859edf49e1f29ca973f3c7231e7c1e54d6f367057ab35f9c0d56dd2b61feb816958326098244c829871bfde57967e4ad87437568a2746f316887853711efe0c9fb735f4fb0fa7b48dd01005757ca09b3e7425178ca1b9ac3f8e1dd148b7eab4f98e3cf3fb9509a7327185fff8c928d0eae6305bd806581b233baf36811014d4ec04aea4e25dccad3413490f59b8902348ea8b779cb4f34c352bcb2db0d97de86a693d6c5a9a6aa0b3a939254bd980a3b09a6016a43534d056127512112df136588d37066445ff68f5b89b0320770c86b071b31446d64897f9a2d28fa7644d595493b26365a77b3fc1b3a50e1e3733d088a39c341fba4abb058293a48c6bf5abe7380ce5a46f9872324980a4fb60371e9677393342000bdc09e80fcbad902bc2d496c4614b5912085dd61ae1c2232acc94467d58591c7f13ef7bffad5e85e1ba96c73bcb0976b48515f29b2cb737766b5fdaed80d73c803335c9990a5fcdbc6008d660f1bf1a9dd764418378da10b8715c90ca9178a6749aec994fb8369ab975c4dd0057a5ee344d073e7633c6785a4fbfbe1693763c9903531d1a80cec19f077169cad7ff04a087895b359e8c4e991b4f508443d954bab68bab1382533bd95502bafa29e8b5114185d441d8a46fbd1af594ec1cb2895f885cf5f68de8e18dd6e66fdab8dfe7325808b36bba772febc9b975c33f90063ee6e96ce56005d33367e351ee212e225a7f988671a9cd0a52a3c08ca3fa74fe457842ce9e45761167eec177e17514bce2826aaf1972e849f2456caf14a0b18b311383dbaa2217cf373b27f155f0a41d045ae4048512913452f0b87b3eb2c4260ef0fab4aacafa1d393c68cf4df3b8b68ca2334caa0f497419788a78a227bd9b0e5fb4bb9d5e1c2ecb81cd56b6e4951a2df82aab57018369f6d267c4393585ac2fd329cc6619b42a19e819301cfc5393a55ea306f3a5aba85eb682e535f10ed603fe3949a1bf7beb39ea8b61dffc6b4f9bd57f00b17ddd9dd84b85565a6f08b2f4f2db5e13aab92223ef7bb392024da81238b0452fb34693a8df00cc84a62e215b01e95727a9a749ba0523d4346d29af86d4914528ef6ac2e4514c6a671ddc95c9dbe58a43534943acc586c7d9ceb604a87afc71c8ee6d8e17d9c78d1b47e958bdc6c6210bbdbe617e7fbe563492a51e9839275d4dda8e79ad2cb87e2df7a37cdcff722115c04f0a4ffb18faf6f23e28e777abd728f561efda2a8f8b6c8375e432baee2edd4728203f2618a34898da09364abc04102e0368f73bf5b6770d104d4332ee2ca487c175bb9acedc9884406acbacd4c91e9a8ce1a8a435d12caddd9d72c0f0019901571da4f064160c7c8a701920319f5895fe1f71521d496f2633904035cfc6002cd9164d1427558b086e384ac155d2fd7205a1b01ea4a1241973a43e271d9d3f2ad4a99089bc1b3dd3a7b74d6c4ce0703cdd5e2f4d632d683106cef94c50569170c31b0b5ca4269c84e207c587b74a405b13e97304aca75e32a0722f60219b535c9072bea209dda50a4ba13601c46b46020c1cfd3de68f88d85ba975918ea56d47febd3035efe0884ebadcadb9f8abb91d7d710b4c84d7dcde0eeb21790c94cb5eb35e5396b97a93a1ecca612de15fd9f74c6a74040fa422dd3094db060aa28464f88028569cb8223ed1c839b5e93502fa50e875437d2fdc1a159fd3c373bb499a368ab55e1b7ab2d136e5c909403b843392e52203e1dae09d48b880f9dd0763bf51b79cacf17e63a633bdd612b99425fccb46c5b4016223e6d4849c33ae0f4f7d3c4946385888b6bff2750c25a4df794ec164030ae86a31ad89c5c3c6a2dd08964edd524e9256247cd2237089f852dd2cd14d87d509d64c02882adaa85f89c23adda68fd10b38370c6e233aff40ebe7b9a8e81c38e8b7b2e40be32fdb8920922432d7dff2c04de8f075527f0fbc64c45a2bd66f1f25393e22b27febcb64b90927b761e1d5a271495c6e677206a95c7917543f169edd594cff5a363db1af2f02718669b2665c12a7492c9bd7e3ca0ea021bc6a2854f7cf7372a20487bc54666c71457f74e070f6390d8acbca91772dd70f0f8a23b0111e1cac94b8ee1d258901ec46e15d60c6c68246dde0152cbfc245c3bad6be6bde5ef46aa2edb544af04af9eb03cfd0c15102dec33e71675ad2452f63505d4e230053289a22ad7971bb92bbbcc3d3011f544ef0e5d2bc96f0765b9f58b8e405aee7fd6841c4e8e284fa9c0fcf8261d234c1f2e66698f32d43dd963cbfb770ce60fcc5140e69e70910a9b3a7c25e5c69f7262bed3c71664adf566e76752502fee99f0386fdca24c126556816a111ff1d98e5206ec0b0b131f11c9c4fc6d93669d580dd8b8952add72bdd843a06e0ff30faf068eed450c5f65e9ba244ea1d8c1d56b08a8e606933963870d136187973e3f205b328b2d8adabdf367f699647ee53b0f9e053e82685363383d2bb359c20ff62d0bbea040f8f39cd5c2576dc1d781625ef58353f685eede120b780d019438f449d9a4ddb75579ab602003302ad76fbb0b9ba4e5bd23b5a8b8d58fdfba49b39fd13a4edf9f01dc588873ad37d2d828896a90b74167c63ea29b128469a582f255b7b7ea8c4a056d59a661920933c3441f83f2dedd2025b0a56ecfa70fb39cd66e14016da82ad00fa7f9aa9c39075d1c2ee4b8ef54e8bc46f6ff52b23b7d90bf2c71bfc8689c441385a52cf9cd9897a6cc8724f5d6692d49501494afc77a7a064c439f45ea35ccf01ddb4e1a85a5c4d745892c084d8541a05d930b91a659614803029fe483eb9bbe82b0209890b9d3ce5c0a7168fc43a11d7109e8af1c7479427410b10dce08ba0913d45610bd6f36b9820cf476412372c68351d2ddf248bedb23aa2e19d554cd22fc05574f84333bd0f507d1a64c36393131a0c463dd7469e6947e179e0b24bffbd9b7435de863bad19dc1f17fd06a9bb55727d9b70ab53d141392fb4d5ac22cb715b5636a4f2fbdf9a83c49329b37d53085dd0d59a53d52124219ba234988decacc3d57df98980e753cb15252e629306e3de01251a9058237d23dc945b4a2aad62ed5245fd2bc17d7901635b17ffe9c3a55e24aa741ecf59031dc5d8010d20c9524fafa339cae846f57574465552ecbf4af3cd47df8dada1b284c786f72e092da27c6c5b54f8de6339629de0f273792410392784890d879d616f40cda2722bce2e324e00fcd3d125125d11b75fbfd1ede6caf516b08bd3ba63215a9cb0511732dfd667f6d36bef7715f51d3bcf8c11ab639ab8f384b48d6f301b4b1e5df8e79bb0d14d421545f0791466647a88c0e83ff41d7432371cfee5344ba1622364633534662b1cd33d4431ba4be50c257274d30edd9b7e0e9bfda00374f03fbc41903e186746fdb39a43d70845dadda4bcef463cd477266d818d35c5eb487150c8f7f751875db5d25538ddd2692ce7b07c475d56d68c7a17d478e0cf8c1ca8d449e45e471658719c7b190545a049692f63c5baa8a3118f2082ddd6b0eb6d76f2ae8a2fde03a6c798b86c4bd56c13c0e6d22c0b8524e3ef2203ab231a06cd07ddc9c809c95007706c3a11c8705bb01ce8228e5448b53f0c1d556d801a64e96cce9c566ae352547a6f707d910516bbadf7c2fddc678c441242c873d7b7d5f27de918a9562e1889d6e8d6edbd6a6aca454c56620fed3520033ab81a768049da760177512ade92ee4896d5e1f08fe45407f94da07a083400bcfc10acd341359cab2fc273691988a822ff1c123ca1b36a45bcc7047649c6836c6312e505d87b11a7e8723fe46a9753c1b713936e1f8940509206dcfdc3f7e188f66e5e9a5608e2472f7f28a3d03004ef63dc8e68df78c9e8208346893b62059fc5c14c3485aafd0b1eab1cf3043ea2138bcc616623c9b7b402ed96aaab66fe9e07456ead48e41d68c30807222727f71c4bd2082feb7921251de5bf7dbe21745f2b68b7493b2d477c2d759aa31b8c780b4d2e44685c9c64fcdea2cf078e509bd6b25e56c2bf02ff1d19b2953f3e6949a0db097c9d68aa53dbe203194409aa4e6148a7906aaad7964583489ca87bd96b1e807c3694580e5b55bf5233f496853310553ac7b58653d3f8e0045d6c44b5c6ed07698756e46c024abec10de5ad7abc3d9ae99e5fbcbaae1404fcd27c0f2a0fd9f5e234959f54b0f1858e6037af240b2196d1dec280a24a7679f31b3c08eaae44e6c9eb65dccdcfe159c64fc3c64b2f7678d4189ab7c5429d212586586bc2c70740647cf8813a2b462939dbefa6fbc08d422fd400087b2893dad7076fef6b95e6db8b5792b22d80e95ecc8d8afd144a8b3a923fe54c7b7f0cbff8b2a0fe6d9d7b00ad02ae5a04ec5646d93bf4e9ad849892c53fee5009f7bd76b6d6f515866116294eaaba5c33d64b65bb16a1dc190b6f42c54f78ad05d7082d16b0d53f8d31bf9937e04af7d907304a62467918d1e30469a3a16286edc60afbb75353e37a1ebc4561b2319670dda5ac9778e8470d7a2a7d067f77d9dc6095094df9f91d9bf1aeba247aea7137938dd091056a9af6da7b75402c913679ae965dae45485a4527e3e65ee1be50d95b45392ea033d0b18c95aa5aee272e2d7aff96636329f221b2cec86c93936796386f9368231883388840c7e2a2dd9c1839bc8bb499fd4a04193f98fdc2d7dd69f5f978939eb7218ec6c6f31edbcd8a7f367dec896fa87326eb3975cad8815195c1f29161dd95d1cf71e893c991002a9c814fbf464146fc8f97d25c8f3251cdf08efab6129d92fca074ecbf6a0853b434be637446f308f3c93315d427a36d7ccc24ca1c2f928748f101bba76d6c5c953a8ae67b2e0f93b03365e4266f9dfaa342dfab37b9c9d24c25c4934532480f410e04d111cfc47825a6a13986fcdb86103ac1df49cf964588b0b90c1793682adb6b0677e24959b93142d501a4ed21a56e182c8dbe3ca4e88f48312a82599e90b905c5586ee418669c7568d4e9416f9efb24483333babef039580c37205f99a29d5f38aadec35ae95e4087ee99981f9b7370e0b5c9a4697016777108312e6aa003f5690c6aa808d9013d3d7025a0769a95aca242e09655336bd153b5d74d58074a735a22010f17338db708435d4371935d780356e865d5c84d1f6d8f9eea1248a114c1f6b9dbac973843186285bc6af6289b5ac37cc16268e1345b5c58e8430f720bec145710652b30df88aac5bca51df35f265ddd1bf4cec33a508e18dc07f65b40a167ebf085cee2fe229faa9e38e2d5520a5b300c7db69e28384a682bc96bd7b813c339bf974324d986f831c8fceadc76da42db4906f9edafcdb63f2be6972175951522b33615e3a541ad612ba1a35d80cda336691150e47090e047c8c8a80069b706b24c76cb345f22018cde3ea456270c53ddf0a4a97896e278a7f880079233d2718733c29479704880cbaa8883b6cf2549b48169d183bd635eb9f7dc645c512ec79286fbc5be2984f15073c75a66a0c76f2a6571e7d27595e807441680bf4a6cc69cd39ac48ea53c8f87d9f93b46057dd3b85430d6e07bc0e41ce85c7bd52544a49c74b30b66e286c0fe68030844ece31a6850d202b125fb6f646f3e03fc64b6860c1ebf16fa06e2bc2df62264bf61a0700236e376e2177c096aafdb59ac66d3f391a423702be60da8e271dfa7a58bc3e05c41ea7a0cd5a8aefcf608d6a704610a5c0b8761fd37ad4e9281894054dcd3725d3ccfb5a67c6d4273532b9fef87b2bd01633b8d1dac0cfe16da44fb7e9084995a95da9c635ef02e392823caa4365348f21a0132fc2f2d5894c7d664b2aa6061e2e93acb699f174c8622d4771383445fcb0af15a4e54143b7c0801823913105125c5bc44801fec6c869527ae0fe879d76ce1adbb7ff5223fb930937be69a02e4e77611366003d7f3acee67e77110af7ce9936d994a31fc016897cfcd377d0035f1d8f6fc9e8a5fd4c4c61fa2d55b6b1c2b72fa072389a337a4fea97f195d08e7c2f042fad3becd73063031d301b0372e539d449de86e489f3e591082541a33630de89eeb461e1fe749da862fd72bef881949325bdb8c352e9bb3b56fb575495f789d90d30365d1b3a172cfdaec1ac5a93a6d369fb7afc25cd2bc9582d3037363f7e13e1802972c8c6ae2c925dbef3162df3a35b7abaf27f9dc3621e4dfa5e1b0b3449959f973e97cab9e201435d93592664ff51c2a4bd12cfa5cb77a89368f3fbc1ae8c7d645356bde78c1d4cb32b49b43c0d69ec006c113479400732cd72d406852d385a5c4f03fe4cbebfa24b0fcaf7b4752ee111c8b9fe3796424e3f9d006c0c41c7ebcc4ff5b0fdb75a1e7298dfe6c0d03094fb822a2676dbdde44668b9978e2d686c8439e0eefe89a996642a2c7f233f62559e952aedd2490a1478687728b4aa5c0a73a8ba914113a9942b56bb154ccc22c9a6d35219d50158f4fac999280098b1101e84e12e39b1279facd5759b0efde60f521cd08d6475e74f8e3863f5b04c55a2246ec0ad0b9bab5666f646efa77b434e1a7547aa96768efebbea33631da38d614103b2b00288e0c2241a12997e74b22ceb763e643cae03f2f8b90881a7af11fb507bb946a293b6755580e41fc3f8d62fe34cc92421f4ed9ecca40f0310ef5b78bfa9624ecebfd72bae836c88b7a367150137acc60de29b5d11c546421cb19970ae8e911985e7077d6816a4d6f73dca06606b2769cb54628db2cbeb12629de5686c6cd43062f266cb2ba7f3e9c00a4f1d40f7fcdf5ed568456463c86b2ced7153305bb7668238c43df8443bf9809dd39a62a73e486b0ad486fd3e222c4ebe8269271aeff761002ee4ba8d472863b3a29b487f3aa13b338917232c3a7840b2b1df5222b552252a621cdec316044f09f6abcdccf5d1266e342fad5b7463c0e3b4af50ce8e2dda13634e79c55263d49f343f237b824bd9f64f83bf22525d644994d28a51522ab67bfe61d6306df827fbb6b0c438103c2e1d4909e4dafb39ce26e9c277dc31012d38619993dc067dff3ceb2d05a581ca89adb69518b3dfdbf940b56ed7b95685f783ba6d3f644f5ca04ba4b2c3cec985d8ef75fa2f41e982936759401770bd4e3e5e46d1e3cfade7c8534003c5a4f75eb624e6ca75d85097e2a68dece3588f89b616ab5ecf87d5a895b573a96ce4691350c2d23b9f808c22b9f4fe12aa61f8c38c37e0495b733696d5508da186e37309f522e273033e509e03a2ba4eb81f1a4d08931827c0cd4cada451506e7c6bc904d77bfcc8d2de6a912201f89c7efb0a61293c2c5b15af1464ca87cd74937a8b7c5c13424e7b1ffc7a147e6bb2e78307977bf5eac1075df453e06c464b68402acb04f76d203f675e56b876a0da2f3e316a3693f072088a469428e611328815446b6a0e360225e7d3b0b1d161bb6390752a42ee06de24bf57b3741ea88128939166136da014dd43ef99f8e40dde905550275a413ea0dceedf8dc30c7dd8315a5cc8f98e83b0c4a03421356d88788e79e7c298ddcce2f6737f3a60603561d557afda6e998c5e03ae41a439d1c3f789a0a36847e8069e00c783839c06b159f0ff8235e059dbed899f95f2788e13402b101fa76dd040789886a5b47e46d275d43346ab119fc43a688e6ac4606236ecb5832d8da4183a663cbf681b36da8a1e0242dd823cf9d37b9cb339cfa7cdd383b3d0f4ffe40c99b99e5662d1767f47c45f3ede194c51d408c7a8ede20bd029383f15c661e9dc62f813a956370c85b0eb6512a167f112e8099674575d9b94ff44f9cbca2fa5bc30765f7d15662fad86885b3b9a339a94d72152ee3059b626f70e02acbc064305c99f314b8621878e2271ecc734bc159f7867221a94299869a24cdea4f09266e4fab105c09c4d10a313ac32dfca501e315e6c8b84c00c9e84a3fa05937a324c9c9dca690c0fee831ba1f3c3681afb5f43e50f362c5be623e443e1e70d7e451051478314b1f6f8b9b8b693298a1004dbfd3a435ebde3056dd082b45d38a8929a414d96434bce962991696c76385afb739d21aec8b79d6ac7d7515c616a6c9748fc54cc0cf7f4257edfd20e7610e858eecba3d04b4ebb5d106c8739553a603f0a07229dd87652d95106ff531b2558c1a79f83eff574aadec8b5b7cb4f947cb9fd677b22273f3b59812b94743d7b84d652659ceb6ca158c7270aac21634dfa18d28ab76d5ed8ac55590c862cfcedadd80092764d8e3afc53e4d2f08d4dd64888433897addc78b93d0753ba32dee1ef299a73ef5920fe6b7a0927ea19239e7a86752dca73eb2aedcbac92d1cb7483110c2c140e648db3ae90c1644e3eac492296fc28a0536206277ceccd46cc79d5ae1ac4ecaaa4249a3a6349c9b6135dd9a2f0b35169aeb1984e4ed8c8e1a909aa96e4c96ab30f440ef55ba0a3f01199920c01aef7947f5488c1be73a5c633d308e8f304737992370456fe5076002566c4838e11e414830efe46aa319d8156b20763b3767586073d39dc8971bbba9e2c75e60b12276ccecdeca7592524b3df1a50ea2692e04319b5bf8bab31a65065ade2b7826ea8ad88ae720f19c86efd2f39821c22dd50c278bcbe5eb818f8d7973f803fd61aac8491be8c58d5eab83015dea1867efb7070f8769ab84c535af68a54cb3fe836fc26630b9e6732572a8ecef8e9a9d2da56d07ac098622d38dcb0b101bb1c0cd0d28cf6fad99af3c70e84c07f28962db79f23f4d86f0ad63d8b8155e7c58ae2668dd01192afce8b0d174dc32543540ad642b5066102e34bb1c16355ac5b28fb088a10c65d559fd56d5f48446efa3644588e00b4aeeaf33fb67b07565897f803dbe644124abd4f40d779ed366ed32e37961210a8b599db69aa053aa2e8394cf85213ad1f643bf70767c2682bbc1acc0eb6d8479790afb52dbe397075ce8f9f608880683bfe5f211083bfcb17c0f03b300499a7ed65e910e555a3d9e618cc64e5a4ac4f6eb5da8a4f3edda918dd4158a9ddff70e34649863bb380cb671839021ad6a7f273e5d6761f58674793a3fc20d68dd5abf1a0d6687cbd451ae71bec3ae616f68bad5bf319934813eab2741c66a6e3e706192813d87c2f60be89137dc4a7e69e0d85a563881ea8a6e82894e2f6179c261bef34ecd2610bd9d75e4174c2cde4d27ff22251bd7f306fcabc8d01e6f16bc2b9a8167aa13d6e93c13b84e113069b21dd0670008ecce3a3a1b2ec8e04897c24af177b5911152773c888ed36ebaa4ba09ed26b4246dd489080355658a1e5b1891699a96c42daf3ea1c6436d48123d9a638b613dec224717789ecd3173af911e994deb4c5e4321da8c4814df107d1f108e39032282f00d4f619bdbfafd82b441d2412c44c5e8763b4cc77c2fe76e36223623ecd7bd281397e1fa19b371cf776615b5e21d88ebc3854468c7c14b658f1db15930ab96e44a7318078381ea217a66b693ab10bb3854ca0f3bd893fd3ef52aaa46a265d3e99b6a3fbf44284656f95f08b304da4a067eac1d79e23f525ea532a592dcc758e87bfbde5f2d0895834f7b1b70f69ad69f719ac1d9eb4936cdd32c08a383b3115c5a1d55408344c979ac3f52532ae325bf8507015e2aa61b10bc7541793c7a7f803d412ca3879abdcc365cc98e2962d69d1f0a700c98a5fef9e8f2ef88db8f6cea36b960099acf39ff3759e8e559960879e220bffd28999623d5bd674842e501dfc9fa686d70627edb0642cc20d52af30aa7d84a2f5b5ae8b6f3460f62f20542dfb027d969b9e91510f22628b6b0cfb43782b1f8e960127aa172ce827df27e7dcbb763d899317e446428d70249e6b654618bf6bb9a697c98696eb4311d3f2fe14aa98307ad682870c9164e672c2a2ea2a6b4825ab2439399d3f7ba68b6d2d09144fe2d317912eaa2ed1e1ab14a7ec2016d8fce3a28ee25040b91bb9c79eda9ca7b816d240abfd0992b3859c58742017660a44280811ca9ce0e2539af4965b6110c43016b3b61188e999bd84a68e5c9173ec25c4570a19e31324ff865b92d80a1cf8f625daecca53c62ccdfd259fe43552a185918775605bae0e74fea3fe780e6f7b5549310f16a2ad27b62fb9b05cfe427fe8e4228a0f778451f246455e9c8b1bc2bb3109ea6f070607f8d123ba4bbb02b20df89002f431756b2fdab1d2b1b3b637d888b8c95c6b78d899cee99ddaf8e4d418a5aec1c5ec01011bc4cbfee516736b070c98af229e2d3802dff679f1be1ef202a85e51eb4d483e70cdf6c05e520672697cefd0fc31b34a59d21dfd2d5659c9703f7abdcf2bc2277b47789ea53d76cbf998d89ae820ef9faed112c5ba3b1f14da5d7a1dd5ce2cfa97bb703231a692c9fe500e3e554fd4535f9ef122a8dba87cb1c7dc8cd16efcf741f0eeeb0d3d038824941ccc398499d5976df55e21bd4fae9e77ff5730f7ddf46b708a8829939439acc1ef2a526d74b24dfb1f9107f2dccc4fe9ac4e1b3a86d26e07997ab5b055f0b1a7ffb6b530651a541aa36fc931cfc8a8cbc4d061ec55b3fd2cb765dbea8498b3f036d221d759f70b2663a9a4fb114e3cfc60df6a3e1206a530d57d49e51c7ffd09215586c76e551da1917ccc203f68d71bb393a6ba08b44b7bb55fb8cf75afd5cc89ec9a38fe869723614b394cb87b8998252cb4c480e485dcc5ad73ad7a4432fff9d8b52e2b0705a95f76496923a1497265293f2bf11c3ca51748c026463a6483f1c49b935ee59e04a5799f1eb7d97b98aaadd7332a917c7e121688ae73d671fefa3a6d635a12800b7c64ceab4b9e5f14e0d71364ba0ba5b25549e18dc7a8d6a833186808e4f5c5d6c6412dc492c435f7069f7d089aadaa7a109f40fb8311c9a14e4ec6e90515db55b5d406c4358fa37ff8b8e789d7ebce1373c4d08f8af7bfd44679b7ffaa66ab02ab6028d7b29af371ed3239d71232e5b42645340c4735945e58210193c5f93cef9054ede4ca4e9adab61828ad7785b721dab4b82031e68bfa1aedbc713d4e481e0c6dd2c16fae7bd72657f7aa83d853578db7c00390c0ea3e50d93f8898f1520f40e923d36ea471096a51eee305503151f16342bae60c443c10b77aadad51b3f542e09b83f0e7fc8d6f93e27a83445fdb283ca10d9dd4abe601336ce13e3c7fdd5cb43e392d22bdb158a7b5fc187cbbb5e7ebe1ae450dbc5a889bb2c46d97841c6cbe6f37d0928db1cd3349d727b21754580089832f95bb176d336d9ac1f0fe31f2e7700c652fd8517b42a42da520070760791b81474ef5e4a3ce1cf00f113fc6e4a7e044d6b7352da016b3d7e1fd6ac43011c3a3b8118fa03a8a8beb8f37c97b46ab7ba8af028ec5e47ffb757dee442e57faa6288a075ed7aa5bce0a299510175761e88a484620d2cec10984c0d70d43c7ae5d76864fd849f1c33a35245a0cebe03e996c211cf5057eeb9c1ee7675f3a816cbdef8999590ef046a154a12bb7aa66e812ec1fb0266c0ba522628436d67f00d6bd133e023ac1a72238634edf5fcabadcd385534b2832da2a1041bb39c9400e0a5d6b4bb160895cac8a9c4ca6c3d5b7c33d94ba6c575c6856c1f99cf0ce5d6f5ab2e0c8bc97a3c8fa8a4c4f05d471e85942947cbf6052f13fe69a1f23ffad80a604c9c3ed3c7bef0ae4865f5ed6570568e2ccb1d59e66152e028f72f7c3680256902156bfca1b0b2e68e030b7f1640a3c899f294d4285311b3b586b393f881e4f07946fc5c92f39b3889b70dcfd3b69c91ecf65063eef9f0e1edafa7eeb83916356eac50fb22cc864af0fad0bab1ec2b52902b21456241e5858e7ce17025591fc21a3c479874d44244043655d790642167ce14e521d056a28acd2e7752d58d777f2bf182db4dfd22d78030c25ee5de66232ddbd4e72a6e0bcded1e8604b8379fd96cd69fe8c1c5956f15285a80452d1b74e7e8af364dac0718e52c15f0c8f889411cd4176b244f4d1eebacad9eea788dfc009121f27cb987c94da1ff9662f3d0db31f209e616105a02c3decfdc80a27fb479ceaca7ac159e6ec52d2360e00583915ab6cf3d7661f43f6e0199b2c5e5afc08c95c2eda7615ed71d5e19314b7bce82aeb856a76c4e86c1ff14deecfad782781665001f18d8defea7aeb19cdb293499362fc545acb0b3c1cd770fb3f0f3cbdb6acab325581c7e545d6bbe5cd47c9224fab17e8070338b24cf91119645ac3ecbafe7802474bfcfd0339e860c2fddf88971dfceaf3d1c6cd19b2e5cfa7d48717172427cd1204baee15e3212e26a757f3081eaf3281488a4dc8141b3aff28d0416fe1b7a3ac30ee6a0cb2f9246d72033a357b4c9a9e0a91fb0c20fee10ec12ce8f3fba385fa37bfcf1be22a702675969a45fe9fc1bb3bc2221d3aa636894ccf982dca6068de0c65214f45c2b32bf5d541d3dfc4547ce2fe03ce49f102e40a002669710fbd4b03eed7b9bb8fd9eeac31db276ccb1bd20cd6a4e5e52c15957a6c7d1b7ea1b0715dc3f361a1384419c2a2e50dbd741e2092775d81f827ee9606d1cf3fba6467cacb4957e041810f4b9b6b11f6f7e6d6c823b0e6a9a6e9e43f92fc9698b45e5c445609e7e429aa5d18bbe30cd2d5ede0d1394e648d5323f6d7397257f33680e745ef3cc818e6e2937cbd90c069962205d170c9b2c00470761f0cebb6df5daf55753c385de8edb5479e82a784fc85993127de210642</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>面试经历</category>
      </categories>
      <tags>
        <tag>面试总结</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/02/06/golang%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/</url>
    <content><![CDATA[<h1>Golang 的值传递</h1>
<blockquote>
<p>先导文章：<a href="https://juejin.cn/post/6888117219213967368">（正经版）面试官：切片作为函数参数是传值还是传引用？</a></p>
</blockquote>
<p>Go语言中的 new 和 make 主要区别如下：</p>
<ul>
<li>make 只能用来分配及初始化类型为 slice、map、chan 的数据。new 可以分配任意类型的数据；</li>
<li>new 分配返回的是指针，即类型 *Type。make 返回引用，即 Type；</li>
<li>new 分配的空间被清零。make 分配空间后，会进行初始化；</li>
</ul>
<h2 id="传入参数和传出参数">传入参数和传出参数</h2>
<ul>
<li>传入参数为本身有值，传入函数让函数使用；传出参数本身没值，从函数中带出值（相当于函数的返回值）。</li>
</ul>
<h2 id="函数参数为指针">函数参数为指针</h2>
<p>将指针作为参数传入某个函数时，函数内部会复制指针，也就是会同时出现两个指针指向原有的内存空间，所以 Go 语言中传指针也是传值。</p>
<h2 id="传值">传值</h2>
<p>当我们验证了 Go 语言中大多数常见的数据结构之后，其实能够推测出 Go 语言在传递参数时使用了传值的方式，接收方收到参数时会对这些参数进行复制；了解到这一点之后，<strong>在传递数组或者内存占用非常大的结构体时，我们应该尽量使用指针作为参数类型来避免发生数据拷贝进而影响性能</strong>。</p>
<h2 id="函数小结">函数小结</h2>
<ol>
<li>通过堆栈传递参数，入栈的顺序是从右到左，而参数的计算是从左到右；</li>
<li>函数返回值通过堆栈传递并由调用者预先分配内存空间；</li>
<li>调用函数时都是传值，接收方会对入参进行复制再计算；</li>
</ol>
<span id="more"></span>
<h1>golang 的内存分配之堆和栈</h1>
<ul>
<li>栈 可以简单得理解成一次函数调用内部申请到的内存，它们会随着函数的返回把内存还给系统。</li>
</ul>
<p>下面来看看一个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> **<span class="title">F</span>**<span class="params">()</span></span> &#123;</span><br><span class="line">  temp :**=** <span class="built_in">make</span>([]**<span class="type">int</span>**, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子，内函数内部申请的临时变量，即使你是用make申请到的内存，<strong>如果发现在退出函数后没有用了，那么就把丢到栈上</strong>，毕竟<strong>栈上的内存分配比堆上快很多</strong>。</p>
<p>下面在看看一个堆的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> **<span class="title">F</span>**<span class="params">()</span></span> []**<span class="type">int</span>**&#123;</span><br><span class="line">  a :**=** <span class="built_in">make</span>([]**<span class="type">int</span>**, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">  **<span class="keyword">return</span>** a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而上面这段代码，申请的代码和上面的一模一样，但是<strong>申请后作为返回值返回了，编译器会认为在退出函数之后还有其他地方在引用，当函数返回之后并不会将其内存归还</strong>。那么就申请到堆里。</p>
<p>如果变量都分配到堆上，堆不像栈可以自动清理。它会引起Go频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销。</p>
<h2 id="堆和栈相比"><strong>堆和栈相比</strong></h2>
<ul>
<li>堆适合不可预知的大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。</li>
<li>栈内存分配则会非常快，栈分配内存只需要两个CPU指令：“PUSH”和“RELEASE”分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块。之后要通过垃圾回收才能释放。</li>
</ul>
<h2 id="逃逸分析">逃逸分析</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   resPtr := test3()</span><br><span class="line">   fmt.Println(<span class="string">&quot;rePtr:&quot;</span>, *resPtr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test3</span><span class="params">()</span></span> *<span class="type">string</span> &#123;</span><br><span class="line">   <span class="comment">// 没有被返回，没有逃逸</span></span><br><span class="line">   name := <span class="string">&quot;lynn&quot;</span></span><br><span class="line">   p0 := &amp;name</span><br><span class="line">   fmt.Println(<span class="string">&quot;p0&quot;</span>, *p0)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 地址返回 内存逃逸</span></span><br><span class="line">   city := <span class="string">&quot;上海&quot;</span></span><br><span class="line">   ptr := &amp;city</span><br><span class="line">   fmt.Println(<span class="string">&quot;地址为:&quot;</span>, ptr)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>查看gcflags 追踪内存分配</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> build --gcflags <span class="string">&quot;-m -m -l&quot;</span> <span class="number">10.</span>内存逃逸.<span class="keyword">go</span> &gt; <span class="number">1.</span>txt <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"></span><br><span class="line">grep -E <span class="string">&quot;name|city&quot;</span> <span class="number">1.</span>txt --color</span><br></pre></td></tr></table></figure>
<blockquote>
<p>扩展阅读：<a href="https://zhuanlan.zhihu.com/p/113643434">Golang 内存分配之逃逸分析</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>大数据之Hadoop</title>
    <url>/2023/02/06/hadoop%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1>Hadoop介绍</h1>
<h2 id="组成部分">组成部分</h2>
<ul>
<li>Hadoop主要由3部分组成：
<ul>
<li>Mapreduce编程模型</li>
<li>HDFS分布式文件存储</li>
<li>YARN</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h2 id="配置信息">配置信息</h2>
<p>管理员密码：admin123</p>
<p>DNS1=202.103.24.68<br>
DNS2=202.103.44.150</p>
<p>export HADOOP_HOME=/usr/local/hadoop-2.6.4<br>
export PATH=$HADOOP_HOME/bin$PATH:/usr/java/jdk1.8.0_201-amd64/bin</p>
<h2 id="Hadoop-HDFS-简介">Hadoop HDFS 简介</h2>
<p><strong>概念：</strong></p>
<p><strong>namenode</strong>：负责记录 数据块 的分布情况– 数据元数据信息<br>
<strong>datanode</strong>:负责实际存储 数据块<br>
<strong>block</strong>：是Hadoop最小存储数据单位 默认 128M<br>
<strong>secondarynamenode</strong>: 辅助namenode完成fsimage管理或者优化</p>
<h2 id="HDFS简单命令">HDFS简单命令</h2>
<ul>
<li>
<p>hadoop  version   //查看版本</p>
</li>
<li>
<p>hadoop fs        //文件系统客户端</p>
</li>
<li>
<p>hadoop  jar    //运行jar包</p>
</li>
<li>
<p>hadoop classpath //查看类路径</p>
</li>
<li>
<p>hadoop checknative //检查本地库并压缩</p>
</li>
<li>
<p>hadoop distcp   // 远程递归拷贝文件</p>
</li>
<li>
<p>hadoop credential //认证</p>
</li>
<li>
<p>hadoop trace    //跟踪</p>
</li>
<li>
<p>$ hdfs dfs -mkdir-p /user/ubuntu/        //在hdfs上建立文件夹</p>
</li>
<li>
<p>$ hdfs dfs -puthdfs.cmd  /user/ubuntu/  //将本地文件上传到HDFS</p>
</li>
<li>
<p>$ hdfs dfs -get/user/ubuntu/hadoop.cmd  a.cmd   //将文件从HDFS取回本地</p>
</li>
<li>
<p>$  hdfs dfs -rm -r  -f  /user/ubuntu/    //删除</p>
</li>
<li>
<p>$ hdfs dfs -ls -R/                       //递归展示HDFS文件系统</p>
</li>
</ul>
<p>一、hadoop所在目录<br>
cd usr/local/hadoop<br>
1</p>
<p>二、启动hadoop<br>
bash ./starth.sh<br>
% <a href="http://xn--start-dfs-u17zx81d.sh">运行start-dfs.sh</a><br>
% <a href="http://xn--start-yarn-3f62aw61d.sh">运行start-yarn.sh</a><br>
1<br>
2<br>
3</p>
<p>启动dfs，浏览器查看：</p>
<p>172.16.31.17:50070<br>
1</p>
<p>启动脚本，浏览器查看：</p>
<p>172.16.31.17:8088<br>
1</p>
<p>停止脚本：</p>
<p>bash ./stoph.sh<br>
1<br>
三、常用命令</p>
<p>1.显示hadoop目录结构</p>
<p>hdfs dfs -ls -R /<br>
1</p>
<p>2.在hadoop指定目录内创建新目录</p>
<p>hdfs dfs -mkdir /winnie<br>
1</p>
<p>3.将本地文件夹存储至hadoop</p>
<p>hdfs dfs -put [本地目录] [hadoop目录]<br>
1</p>
<p>4.将本地文件存储至hadoop</p>
<p>hdfs dfs -put [本地地址] [hadoop目录]<br>
1</p>
<p>5.查看指定目录下内容</p>
<p>hdfs dfs -ls [文件目录]<br>
1</p>
<p>6.打开某个已存在文件</p>
<p>hdfs dfs -cat [file_path]<br>
1</p>
<p>7.在hadoop指定目录下新建一个空文件</p>
<p>hdfs dfs -touchz /winnie/test03.txt<br>
1</p>
<p>8.将hadoop上某个文件重命名</p>
<p>hdfs dfs -mv /winnie/test03.txt /winnie/test.txt<br>
1</p>
<p>9.将hadoop上某个文件down至本地已有目录下</p>
<p>hdfs dfs -get [文件目录] [本地目录]<br>
1</p>
<p>10.将hadoop指定目录下所有内容保存为一个文件，同时down至本地</p>
<p>hdfs dfs -getmerge /winnie/hadoop-file /home/spark/hadoop-file/test.txt<br>
1</p>
<p>11.删除hadoop上指定文件</p>
<p>hdfs dfs -rm [文件地址]<br>
1</p>
<p>12.删除hadoop上指定文件夹（包含子目录等）</p>
<p>hdfs dfs -rm -r [目录地址]<br>
hdfs dfs -rmr [目录地址]<br>
1<br>
2</p>
<p>13.将正在运行的hadoop作业kill掉</p>
<p>hadoop job -kill [job-id]<br>
1<br>
14.查看帮助</p>
<p>hdfs dfs -help<br>
1<br>
四、安全模式<br>
1.退出安全模式</p>
<p>NameNode在启动时会自动进入安全模式，安全模式是NameNode的一种状态，在这个阶段，文件系统不允许有任何修改。</p>
<p>系统显示Name node in safe mode，说明系统正处于安全模式，这时只需要等待几十秒即可，也可通过下面的命令退出安全模式：</p>
<p>/usr/local/hadoop$bin/hadoop dfsadmin -safemode leave<br>
1</p>
<p>2.进入安全模式</p>
<p>在必要情况下，可以通过以下命令吧HDFS置于安全模式：</p>
<p>/usr/local/hadoop$bin/hadoop dfsadmin -safemode enter<br>
1</p>
<p>五、补充</p>
<p>1.对hdfs操作的命令格式是hdfs dfs</p>
<p>1.1 -ls 表示对hdfs下一级目录的查看<br>
1.2 -lsr 表示对hdfs目录的递归查看<br>
1.3 -mkdir 创建目录<br>
1.4 -put 从Linux上传文件到hdfs<br>
1.5 -get 从hdfs下载文件到linux<br>
1.6 -text 查看文件内容<br>
1.7 -rm 表示删除文件<br>
1.7 -rmr 表示递归删除文件</p>
<p>2.hdfs在对数据存储进行block划分时，如果文件大小超过block，那么按照block大小进行划分；不如block size的，划分为一个块，是实际数据大小。</p>
<p>3.hadoop常用命令：</p>
<p>hdfs dfs  查看Hadoop HDFS支持的所有命令<br>
hdfs dfs –ls  列出目录及文件信息<br>
hdfs dfs –lsr  循环列出目录、子目录及文件信息<br>
hdfs dfs –tail /user/sunlightcs/test.txt  查看最后1KB的内容</p>
<p>hdfs dfs –copyFromLocal test.txt /user/sunlightcs/test.txt  从本地文件系统复制文件到HDFS文件系统，等同于put命令<br>
hdfs dfs –copyToLocal /user/sunlightcs/test.txt test.txt  从HDFS文件系统复制文件到本地文件系统，等同于get命令</p>
<p>hdfs dfs –chgrp [-R] /user/sunlightcs  修改HDFS系统中/user/sunlightcs目录所属群组，选项-R递归执行，跟linux命令一样<br>
hdfs dfs –chown [-R] /user/sunlightcs  修改HDFS系统中/user/sunlightcs目录拥有者，选项-R递归执行<br>
hdfs dfs –chmod [-R] MODE /user/sunlightcs  修改HDFS系统中/user/sunlightcs目录权限，MODE可以为相应权限的3位数或+/-{rwx}，选项-R递归执行</p>
<p>hdfs dfs –count [-q] PATH  查看PATH目录下，子目录数、文件数、文件大小、文件名/目录名<br>
hdfs dfs –cp SRC [SRC …] DST       将文件从SRC复制到DST，如果指定了多个SRC，则DST必须为一个目录<br>
hdfs dfs –du PATH  显示该目录中每个文件或目录的大小<br>
hdfs dfs –dus PATH  类似于du，PATH为目录时，会显示该目录的总大小</p>
<p>hdfs dfs –expunge  清空回收站，文件被删除时，它首先会移到临时目录.Trash/中，当超过延迟时间之后，文件才会被永久删除</p>
<p>hdfs dfs –getmerge SRC [SRC …] LOCALDST [addnl]   获取由SRC指定的所有文件，将它们合并为单个文件，并写入本地文件系统中的LOCALDST，选项addnl将在每个文件的末尾处加上一个换行符</p>
<p>hdfs dfs –test –[ezd] PATH     对PATH进行如下类型的检查：-e PATH是否存在，如果PATH存在，返回0，否则返回1；-z 文件是否为空，如果长度为0，返回0，否则返回1； -d 是否为目录，如果PATH为目录，返回0，否则返回1</p>
<p>hdfs dfs –text PATH  显示文件的内容，当文件为文本文件时，等同于cat；文件为压缩格式（gzip以及hadoop的二进制序列文件格式）时，会先解压缩</p>
<p>hdfs dfs –help ls  查看某个[ls]命令的帮助文档</p>
<h2 id="Mapreduce解释">Mapreduce解释</h2>
<ul>
<li>
<p>**mapper的角色:**hadoop将用户提交的mapper可执行程序或脚本作为一个单独的进程加载起来，这个进程我们称之为mapper进程，hadoop不断地将文件片段转换为行，传递到我们的mapper进程中，mapper进程通过标准输入的方式一行一行地获取这些数据，然后设法将其转换为键值对，再通过标准输出的形式将这些键值对按照一对儿一行的方式输出出去。</p>
</li>
<li>
<p>虽然在我们的mapper函数中，我们自己能分得清key/value(比方说有可能在我们的代码中使用的是string key,int value)，但是当我们采用标准输出之后，key value是打印到一行作为结果输出的(比如sys.stdout.write(“%s\t%s\n”%(birthyear,gender)))，因此我们为了保证hadoop能从中鉴别出我们的键值对，键值对中一定要以分隔符’\t’即Tab(也可自定义分隔符)字符分隔，这样才能保证hadoop正确地为我们进行partitoner、shuffle等等过程。</p>
</li>
<li>
<p>**reducer的角色:**hadoop将用户提交的reducer可执行程序或脚本同样作为一个单独的进程加载起来，这个进程我们称之为reducer进程，hadoop不断地将键值对(按键排序)按照一对儿一行的方式传递到reducer进程中，reducer进程同样通过标准输入的方式按行获取这些键值对儿，进行自定义计算后将结果通过标准输出的形式输出出去。</p>
</li>
<li>
<p>在reducer这个过程中需要注意的是：传递进reducer的键值对是按照键排过序的，这点是由MR框架的sort过程保证的，因此如果读到一个键与前一个键不同，我们就可以知道当前key对应的pairs已经结束了，接下来将是新的key对应的pairs。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop介绍</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基本知识</title>
    <url>/2023/02/06/java%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1>方法</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义方法的格式</span></span><br><span class="line">修饰符  返回值类型	方法名称(参数类型 参数名称，....)&#123;</span><br><span class="line">  方法体;</span><br><span class="line">  <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>修饰符：现阶段的固定方法，<code>public static</code></li>
<li>返回值类型：也就是方法最终产生的数据结果是什么类型</li>
<li>方法名称：方法的名字，规则和变量一样，小驼峰</li>
<li>参数类型：进入方法的数据对应的变量名称</li>
<li>方法体：方法需要做的事情，若干行代码</li>
<li><code>return</code>：两个作用。
<ul>
<li>停止当前方法</li>
<li>将后面的结果数据返回值返还给调用处</li>
</ul>
</li>
<li>返回值：也就是方法执行后最终产生的数据结果</li>
</ul>
<blockquote>
<p>return后面的“返回值”，必须和方法名称前面的“返回值类型”，保持对应</p>
</blockquote>
<h2 id="注意事项">注意事项</h2>
<ul>
<li>方法应该定义在类中，但是不能在方法 在定义方法。不能嵌套</li>
<li>方法定义的前后顺序无所谓</li>
<li>方法定义之后不会执行，若要执行，必须调用：单独调用，打印调用，赋值调用</li>
<li>如果方法有返回值，那么必须写上“return 返回值”，不能缺失</li>
<li>return后面的返回值类型必须和方法的返回值类型相同，对应。</li>
<li>对于一个<code>void</code>没有返回值的方法，没有返回值。</li>
<li>一个方法中可以含有多个<code>return</code>语句，但是必须保证同时只有一个会被执行到。</li>
</ul>
<h1>方法重载</h1>
<ul>
<li>多个方法的名称一样，但是参数列表不一样</li>
<li>优点：只需要记住唯一一个方法名称，就可以实现类似的多个功能</li>
</ul>
<h2 id="相关因素">相关因素</h2>
<ul>
<li>参数个数不同</li>
<li>参数类型不同</li>
<li>参数的多类型顺序不同</li>
</ul>
<h2 id="无关因素">无关因素</h2>
<ul>
<li>与参数的名称无关</li>
<li>与方法的返回值类型无关</li>
</ul>
<h1>数组</h1>
<p>数组的概念：是一种容器，可以同时存放多个数据值。<br>
数组的特点：</p>
<ul>
<li>1.数组是一种引用数据类型</li>
<li>2.数组当中的多个数据，类型必须统一</li>
<li>3.数组的长度在程序运行期间不可改变</li>
</ul>
<h2 id="数组声明">数组声明</h2>
<ul>
<li>
<p>数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。<br>
两种常见的初始化方式：</p>
</li>
<li>
<p>1.动态初始化（指定长度）</p>
</li>
<li>
<p>2.静态初始化（指定内容）</p>
</li>
</ul>
<p>动态初始化数组的格式：</p>
<ul>
<li>声明格式：<code>数据类型[]数组名称=new数据类型[数组长度]；</code></li>
</ul>
<p>静态初始化数组的格式：</p>
<ul>
<li>声明格式(标准)：<code>数据类型[] 数组名称 = new 数据类型[] &#123;元素1，元素2，...&#125;</code></li>
<li>省略格式：<code>数据类型[] 数组名称 = &#123;元素1，元素2，...&#125;</code></li>
</ul>
<blockquote>
<p>注意事项：<br>
1.静态初始化没有直接指定长度，但是仍然会自动推算得到长度。</p>
<p>2.静态初始化标准格式可以拆分成为两个步骤。</p>
<p>3.动态初始化也可以拆分成为两个步骤。</p>
<p>4.静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。</p>
</blockquote>
<blockquote>
<p>如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化</p>
</blockquote>
<p>使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值。</p>
<p>规则如下：</p>
<ul>
<li>如果是整数类型，那么默认为<code>0</code></li>
<li>如果是浮点类型，那么默认为<code>0.0</code></li>
<li>如果是字符类型，那么默认为<code>'\u0000'</code></li>
<li>如果是布尔类型，那么默认为<code>false</code></li>
<li>如果是引用类型，那么默认为<code>null</code></li>
</ul>
<blockquote>
<p><strong>静态初始化其实也有默认值的过程，只不过系统自动马上将默认值替换成为了大括号当中的具体数值。</strong></p>
<p><em>数组的长度一旦创建，程序运行期间，长度不可变</em></p>
</blockquote>
<span id="more"></span>
<h1>Java中的内存划分</h1>
<ul>
<li>1.栈（Stack）：存放的都是方法中的局部变量。方法的运行一定要在栈当中运行。
<ul>
<li>局部变量：方法的参数，或者是方法内部的变量</li>
<li>作用域：一旦超出作用域，立刻从栈内存当中消失。</li>
</ul>
</li>
<li>2.堆（Heap）：凡是new出来的东西，都在堆当中。
<ul>
<li>堆内存里面的东西都有一个地址值：16进制堆内存里面的数据，都有默认值。规则：
<ul>
<li>如果是整数默认为<code>0</code></li>
<li>如果是浮点数默认为<code>0.0</code></li>
<li>如果是字符默认为<code>'\u0000'</code></li>
<li>如果是布尔默认为<code>false</code></li>
<li>如果是引用类型默认为<code>null</code></li>
</ul>
</li>
<li>3.方法区（Method Area）：存储.class相关信息，包含方法的信息。</li>
</ul>
</li>
<li>4.本地方法栈（Native Method Stack）：与操作系统相关。</li>
<li>5.寄存器（PC Register）：与CPU相关。</li>
</ul>
<p>一个数组的内存图</p>
<p><img src="https://i.ibb.co/Gtp4HbV/image-20191205112848460.png" alt="image-20191205112848460"></p>
<blockquote>
<p>所有的引用类型变量，都可以赋值为一个null值。代表其中什么都没有。</p>
</blockquote>
<h1>面向对象</h1>
<ul>
<li>类是对一类事物的描述，是抽象的</li>
<li>对象是对一类事物的实例，是具体的</li>
<li><strong>类是对象的模板，对象是类的实体</strong></li>
</ul>
<h2 id="类的定义">类的定义</h2>
<ul>
<li>类：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物</li>
<li>属性：就是该事物的状态信息</li>
<li>行为：就是该事物能做什么</li>
</ul>
<p>一个类的对象的内存图</p>
<p><img src="https://upload.cc/i1/2019/12/05/hlVWbs.png" alt="image-20191205215527752"></p>
<p>使用对象类型作为方法的参数</p>
<p><img src="https://upload.cc/i1/2019/12/05/HXt2xO.png" alt="image-20191205223138088"></p>
<h2 id="成员变量和局部变量的区别">成员变量和局部变量的区别</h2>
<ul>
<li>1.定义的位置不一样【重点】
<ul>
<li>局部变量：在方法的内部</li>
<li>成员变量：在方法的外部，直接写在类当中</li>
</ul>
</li>
<li>2.作用范围不一样【重点】
<ul>
<li>局部变量：只有方法当中才可以使用，出了方法就不能再用</li>
<li>成员变量：整个类全都可以通用。</li>
</ul>
</li>
<li>3.默认值不一样【重点】
<ul>
<li>局部变量：没有默认值，如果要想使用，必须手动进行赋值</li>
<li>成员变量：如果没有赋值，会有默认值，规则和数组一样</li>
</ul>
</li>
<li>4.内存的位置不一样（了解）
<ul>
<li>局部变量：位于栈内存</li>
<li>成员变量：位于堆内存</li>
</ul>
</li>
<li>5.生命周期不一样（了解）
<ul>
<li>
<p>局部变量：随着方法进栈而诞生，随着方法出栈而消失</p>
</li>
<li>
<p>成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失</p>
</li>
</ul>
</li>
</ul>
<p>面向对象三大特征：封装，继承，多态</p>
<p>封装性在<code>Java</code>当中的体现：</p>
<ul>
<li>1.方法就是一种封装</li>
<li>2.关键字<code>private</code>也是一种封装封装就是将一些细节信息隐藏起来，对于外界不可见。</li>
</ul>
<h1>private关键字的作用</h1>
<ul>
<li>一旦使用了private关键字修饰，在同一个类中可以访问。但是其他类别不能<code>直接访问</code></li>
</ul>
<p>间接访问</p>
<ul>
<li>定义一对<code>Getter</code>/<code>Setter</code>方法</li>
<li>必须叫<code>setXxx</code>或者是<code>getxxx</code>[如果是布尔值（那么用<code>isXXX</code>的命名会泽）]命名规则。
<ul>
<li>对于Getter来说，不能有参数，返回值类型和成员变量对应；</li>
<li>对于setter来说，不能有返回值，参数类型和成员变量对应。</li>
</ul>
</li>
</ul>
<h1>This关键字的作用</h1>
<ul>
<li>当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，优先使用局部变量</li>
<li>如果要访问类的成员变量需要用关键字：<code>This</code>
<ul>
<li>格式<code>This.成员变量名</code></li>
</ul>
</li>
</ul>
<h1>构造方法</h1>
<ul>
<li>
<p>构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。<br>
格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> 类名称（参数类型参数名称）&#123;</span><br><span class="line">  方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意事项：<br>
1.构造方法的名称必须和所在的<strong>类名称完全一样</strong>，就连大小写也要一样</p>
<p>2.构造方法不要写返回值类型，连void都不写</p>
<p>3.构造方法不能return一个具体的返回值</p>
<p>4.如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，没有参数、方法体什么事情都不做。</p>
<p>5.一旦编写了至少一个构造方法，那么编译器将不再赠送。</p>
<p>6.构造方法也是可以进行重载的。</p>
<ul>
<li>重载：方法名称相同，参数列表不同。</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java标准类</span></span><br><span class="line"><span class="keyword">package</span> object.oriented;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Luenci</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/12/6 10:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseStudent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseStudent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个无参数的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseStudent</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">char</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个全参数的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">char</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>API笔记</h1>
<ul>
<li>
<p>引用类型的一般使用步骤：</p>
</li>
<li>
<p>1.导包</p>
<ul>
<li>
<p><code>import 包路径.类名称</code>；</p>
</li>
<li>
<blockquote>
<p>如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。</p>
<p>只有<code>java.lang</code>包下的内容不需要导包，其他的包都需要import语句。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>2.创建</p>
<ul>
<li><code>类名称 对象名 = new 类名称（）；</code></li>
</ul>
</li>
<li>
<p>3.使用</p>
<ul>
<li><code>对象名.成员方法名()</code></li>
</ul>
</li>
</ul>
<h1>匿名对象</h1>
<ul>
<li>只有右边的对象，没有左边的名字和赋值运算符。
<ul>
<li><code>new 类名称().属性名</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> object.oriented;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Luenci</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/12/7 17:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 匿名对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Student</span>().eat();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名对象作为参数</span></span><br><span class="line"><span class="comment">//        methiordParam(new Scanner(System.in));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名对象作为返回值</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> methodReturn();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;您输入的是：&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methiordParam</span><span class="params">(Scanner sc)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的是：&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Scanner <span class="title function_">methodReturn</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>对象数组</h1>
<ul>
<li>任何数据类型都可以作为数组里面的存储元素。</li>
</ul>
<blockquote>
<p>数组有一个缺点：一旦创建，程序运行期间长度不可以发生改变</p>
</blockquote>
<h2 id="ArrayList集合概述和使用">ArrayList集合概述和使用</h2>
<ul>
<li>ArrayList集合的长度是可以随意变化的。</li>
<li>对于ArrayList来说，有一个尖括号<code>&lt;E&gt;</code>代表泛型。
<ul>
<li>泛型：也就是装在集合当中的所有元素，全都是统一的什么类型。</li>
<li><strong>注意：泛型只能是引用类型，不能是基本类型</strong></li>
</ul>
</li>
</ul>
<p>常用的ArrayList方法：</p>
<ul>
<li>
<p><code>public boolean add（E e）</code>：向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。</p>
<blockquote>
<p>备注：对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用。<br>
但是对于其他集合（今后学习）来说，add添加动作不一定成功。</p>
</blockquote>
</li>
<li>
<p><code>public E get（int index）</code>：从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。</p>
</li>
<li>
<p><code>public E remove（int index）</code>：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。</p>
</li>
<li>
<p><code>public int size（）</code>：获取集合的尺寸长度，返回值是集合中包含的元素个数。</p>
</li>
</ul>
<p>如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的“包装类”。</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类（引用类型，包装类都位于java.lang包下）</th>
</tr>
</thead>
<tbody>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer【特殊】</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>char</td>
<td>Character【特殊】</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody>
</table>
<blockquote>
<p>从 JDK 1.5+ 开始，支持自动装箱、自动拆箱。</p>
<p>自动装箱：基本类型–&gt;包装类型</p>
<p>自动拆箱：包装类型–&gt;基本类型</p>
</blockquote>
<h1>字符串的概述和特点</h1>
<p>字符串的特点：</p>
<ul>
<li>1.字符串的内容永不可变（字符串是常量）。【重点】</li>
<li>2.正是因为字符串不可改变，所以字符串是可以共享使用的。</li>
<li>3.字符串效果上相当于是<code>char[]</code>字符数组，但是底层原理是<code>byte[]</code>字节数组。</li>
</ul>
<p>创建字符串的常见3+1种方式。<br>
三种构造方法：</p>
<ul>
<li><code>public String（）</code>：创建一个空白字符串，不含有任何内容。</li>
<li><code>public String（char[] array）</code>：根据字符数组的内容，来创建对应的字符串。</li>
<li><code>public String（byte[] array）</code>：根据字节数组的内容，来创建对应的字符串。</li>
<li>一种直接创建：</li>
<li><code>string str=&quot;Hello&quot;； </code> 右边直接用双引号</li>
</ul>
<h2 id="字符串常量池">字符串常量池</h2>
<p>字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中</p>
<p>对于基本类型来说，<code>==</code>是进行<code>数值</code>的比较。</p>
<p>对于引用类型来说，<code>==</code>是进行<code>[地址值]</code>的比较。</p>
<p>内存划分：</p>
<p><img src="https://upload.cc/i1/2019/12/11/RXx7sS.png" alt="image-20191211153813833"></p>
<h2 id="常用的API方法">常用的API方法</h2>
<p><code>==</code>是进行对象的地址值比较，如果需要字符串的内容比较，可以使用两个方法：</p>
<ul>
<li>
<p><code>public boolean equals（Object obj）</code>：参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给<code>true</code>；否则返回<code>false</code>。</p>
</li>
<li>
<p>注意事项：</p>
<ul>
<li>1.任何对象都能用<code>Object</code>进行接收。</li>
<li>2.<code>equals</code>方法具有对称性，也就是<code>a.equals（b）</code>和<code>b.equals（a）</code>效果一样。</li>
<li>3.如果比较双方一个常量一个变量，推荐把常量字符串写在前面。</li>
</ul>
</li>
</ul>
<blockquote>
<p>推荐：<code>&quot;abc&quot;.equals（str</code>不推荐：<code>str.equals（&quot;abc&quot;）</code></p>
</blockquote>
<ul>
<li><code>public boolean equalsIgnoreCase（String str）</code>：忽略大小写，进行内容比较。</li>
</ul>
<h1><code>static</code>关键字的介绍</h1>
<p>如果一个成员变量使用了static关键字，那么这个变量不再属于对象自己，而是属于所在的类。</p>
<ul>
<li>多个对象共享同一份数据。</li>
</ul>
<h2 id="static关键字修饰成员变量"><code>static</code>关键字修饰成员变量</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> luenci.staticclass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Luenci</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/12/12 16:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@info</span> 学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">room</span> <span class="operator">=</span> <span class="string">&quot;Java一班&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">idCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = ++idCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = ++idCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getRoom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> room;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setRoom</span><span class="params">(String room)</span> &#123;</span><br><span class="line">        Student.room = room;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> luenci.staticclass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Luenci</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/12/12 16:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@info</span> 实例化例子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Luenci&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Lynn&quot;</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;学号：&quot;</span> + stu1.getId() + <span class="string">&quot;姓名：&quot;</span> + stu1.getName() + <span class="string">&quot;年龄：&quot;</span> + stu1.getAge() + <span class="string">&quot;班级：&quot;</span> + Student.room);</span><br><span class="line">        System.out.println(<span class="string">&quot;学号：&quot;</span> + stu2.getId() + <span class="string">&quot;姓名：&quot;</span> + stu2.getName() + <span class="string">&quot;年龄：&quot;</span> + stu2.getAge() + <span class="string">&quot;班级：&quot;</span> + Student.room);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="static关键字修饰成员方法"><code>static</code>关键字修饰成员方法</h2>
<ul>
<li>一旦使用<code>static</code>修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。</li>
<li>如果没有<code>static</code>关键字，那么必须首先创建对象，然后通过对象才能使用它。</li>
<li>如果有了<code>static</code>关键字，那么不需要创建对象，直接就能通过类名称来使用它。</li>
<li>无论是成员变量，还是成员方法。如果有了<code>static</code>，都推荐使用类名称进行调用。
<ul>
<li>静态变量：<code>类名称.静态变量</code></li>
<li>静态方法：<code>类名称.静态方法（）</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> luenci.staticclass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Luenci</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/12/12 16:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@info</span> 自定义方法类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通的成员方法&quot;</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodStatic</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法&quot;</span>);</span><br><span class="line">        <span class="comment">// 错误访问</span></span><br><span class="line">        <span class="comment">/*System.out.println(num);*/</span></span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> luenci.staticclass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Luenci</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/12/12 16:50</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@info</span> static关键字修饰方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">myClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">myClass</span>();</span><br><span class="line">        <span class="comment">// 普通成员方法 对象名.成员方法（）</span></span><br><span class="line">        obj.method();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态方法 推荐用：类名称.静态方法（）调用</span></span><br><span class="line">        myClass.methodStatic();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在本类中调用自己的静态方法，可以省略类名称</span></span><br><span class="line">        myMethod();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;自己的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意事项：<br>
1.静态不能直接访问非静态。<br>
原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容。<br>
&quot;先人不知道后人，但是后人知道先人。”<br>
2.静态方法当中不能用<code>this</code>关键字。<br>
原因：this代表当前对象，通过谁调用的方法，谁就是当前对象。</p>
</blockquote>
<h2 id="static内存图"><code>static</code>内存图</h2>
<p><img src="https://upload.cc/i1/2019/12/12/2pXYU7.png" alt="image-20191212171254182"></p>
<h2 id="静态代码块">静态代码块</h2>
<ul>
<li>特点：当第一次用到本类时，静态代码块执行唯一的一次。</li>
<li>静态内容总是优先于非静态，所以静态代码块比构造方法先执行。</li>
<li>静态代码块的典型用途：
<ul>
<li>用来一次性地对静态成员变量进行赋值。</li>
</ul>
</li>
</ul>
<h1>Arrays类常用方法</h1>
<ul>
<li><code>java.util.Arrays</code>是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。</li>
<li><code>public static String tostring（数组）</code>：将参数数组变成字符串（按照默认格式：[元素1，元素2，元素3…]）</li>
<li><code>public static void sort（数组）</code>：按照默认升序（从小到大）对数组的元素进行排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> luenci.array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Luenci</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/12/12 17:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@info</span> Arrays类的常见的使用方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraysDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Arrays.toString(array);</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] array1 = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        Arrays.sort(array1);</span><br><span class="line">        System.out.println(Arrays.toString(array1));</span><br><span class="line"></span><br><span class="line">        String[] array2 = &#123;<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;ccc&quot;</span>,<span class="string">&quot;bbb&quot;</span>&#125;;</span><br><span class="line">        Arrays.sort(array2);</span><br><span class="line">        System.out.println(Arrays.toString(array2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">out</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">    [aaa, bbb, ccc]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>备注：</p>
<p>1.如果是数值，sort默认按照升序从小到大排序</p>
<p>2.如果是字符串，sort默认按照字母升序</p>
<p>3.如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。</p>
</blockquote>
<h1>Math相关的类方法</h1>
<ul>
<li><code>java.util.Math</code>类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作。</li>
<li><code>public static double abs（double num）</code>：获取绝对值。有多种重载。</li>
<li><code>public static double ceil（double num）</code>：向上取整。</li>
<li><code>public static double floor（double num）</code>：向下取整。</li>
<li><code>public static long round（double num）</code>：四舍五入。</li>
</ul>
<h1><code>final</code>关键字</h1>
<ul>
<li><code>final</code>关键字代表最终、不可改变的。</li>
</ul>
<h2 id="常见四种用法">常见四种用法</h2>
<h3 id="修饰类">修饰类</h3>
<ul>
<li>当final关键字用来修饰一个类的时候，格式：<br>
<code>public final class 类名称（//…&#125;</code></li>
<li>含义：当前这个类不能有任何的子类。（太监类）</li>
<li>注意事项：一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写。（没法继承，没有儿子）</li>
</ul>
<h3 id="修饰方法">修饰方法</h3>
<ul>
<li>当<code>final</code>关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。</li>
<li>格式：<br>
<code>修饰符final 返回值类型方法名称（参数列表）（//方法体&#125;</code></li>
<li>注意事项：对于类、方法来说，<code>abstract</code>关键字和<code>final</code>关键字不能同时使用，因为矛盾。</li>
</ul>
<h3 id="修饰局部变量">修饰局部变量</h3>
<ul>
<li>一旦使用final用来修饰局部变量，那么这个变量就不能进行更改。</li>
<li><strong>“一次赋值，终生不变”</strong></li>
</ul>
<blockquote>
<p>对于基本类型来说，不可变说的是变量当中的【<strong>数据</strong>】不可改变<br>
对于引用类型来说，不可变说的是变量当中的【<strong>地址值</strong>】不可改变</p>
</blockquote>
<h3 id="修饰成员变量">修饰成员变量</h3>
<ul>
<li>由于成员变量具有默认值，所以用了<code>final</code>之后必须手动赋值，不会再给默认值了。</li>
<li>对于<code>final</code>的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。</li>
<li>必须保证类当中所有重载的构造方法，都最终会对<code>final</code>的成员变量进行赋值。</li>
</ul>
<h1>四种权限修饰符</h1>
<table>
<thead>
<tr>
<th>类别  \ 关键字</th>
<th>public</th>
<th>protected</th>
<th style="text-align:center">（default）默认</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一个类</td>
<td>YES</td>
<td>YES</td>
<td style="text-align:center">YES</td>
<td>YES</td>
</tr>
<tr>
<td>同一个类</td>
<td>YES</td>
<td>YES</td>
<td style="text-align:center">YES</td>
<td>NO</td>
</tr>
<tr>
<td>不同包子类</td>
<td>YES</td>
<td>YES</td>
<td style="text-align:center">NO</td>
<td>NO</td>
</tr>
<tr>
<td>不同包非子类</td>
<td>YES</td>
<td>NO</td>
<td style="text-align:center">NO</td>
<td>NO</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意事项：（default）并不是关键字“default”，而是根本不写。</p>
</blockquote>
<h1>内部类</h1>
<ul>
<li>如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。<br>
例如：身体和心脏的关系。又如：汽车和发动机的关系。</li>
<li>分类：
<ul>
<li>成员内部类</li>
<li>局部内部类（包含匿名内部类）</li>
</ul>
</li>
</ul>
<h3 id="成员内部类">成员内部类</h3>
<ul>
<li>
<p>成员内部类的定义格式：</p>
</li>
<li>
<pre><code class="language-java">修饰符 class 外部类名称&#123; 
	修饰符 class 内部类名称&#123;
		// …
	&#125;

	// ...
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 注意：</span><br><span class="line"></span><br><span class="line">  - 内用外，随意访问</span><br><span class="line">  - 外用内，需要内部类对象</span><br><span class="line"></span><br><span class="line">- 如何使用成员内部类：</span><br><span class="line"></span><br><span class="line">- 1.间接方式：在外部类的方法当中，使用内部类；然后`main`只是调用外部类的方法。</span><br><span class="line"></span><br><span class="line">- 2.直接方式，公式：</span><br><span class="line"></span><br><span class="line">  - `类名称 对象名=new 类名称（）；`</span><br><span class="line">  - `【外部类名称.内部类名称对象名=new外部类名称（）.new内部类名称（）；】`</span><br><span class="line"></span><br><span class="line">内部类同名变量的访问</span><br><span class="line"></span><br><span class="line">- 如果出现了重名现象，那么格式是：`外部类名称.this.外部类成员变量名`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 局部内部类</span><br><span class="line"></span><br><span class="line">- 如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。</span><br><span class="line"></span><br><span class="line">- “局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。</span><br><span class="line"></span><br><span class="line">- 定义格式：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">修饰符 class 外部类名称&#123;</span><br><span class="line">    修饰符 返回值 类型外部类方法名称（参数列表）&#123;</span><br><span class="line">        class 局部内部类名称&#123;</span><br><span class="line">            //…</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<blockquote>
<p>局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效<code>final</code>的】</p>
<p>备注：从Java 8+开始，只要局部变量事实不变，那么<code>final</code>关键字可以省略。</p>
<p>原因：</p>
<p>1.<code>new</code>出来的对象在堆内存当中。</p>
<p>2.局部变量是跟着方法走的，在栈内存当中。</p>
<p>3.方法运行结束之后，立刻出栈，局部变量就会立刻消失。</p>
<p>4.但是<code>new</code>出来的对象会在堆当中持续存在，直到垃圾回收消失。</p>
</blockquote>
<h3 id="匿名内部类">匿名内部类</h3>
<ul>
<li>
<p>如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】。</p>
</li>
<li>
<p>匿名内部类的定义格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口名称 对象名 = <span class="keyword">new</span> 接口名称（）&#123;</span><br><span class="line">    <span class="comment">//覆盖重写所有抽象方法</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对格式“<code>new 接口名称（）&#123;..&#125;</code>”进行解析：<br>
1.<code>new</code>表示创建对象的动作<br>
2.接口名称就是匿名内部类需要实现哪个接口<br>
3.<code>&#123;.…&#125;</code>这才是匿含内部类的内容</p>
</li>
<li>
<p>注意几点问题：</p>
</li>
<li>
<p>1.匿名内部类，在【创建对象】的时候，只能使用唯一一次。如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了。</p>
</li>
<li>
<p>2.匿名对象，在【调用方法】的时候，只能调用唯一一次。如果希望同一个对象，调用多次方法，那么必须给对象起个名字。</p>
</li>
<li>
<p>3.匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】<br>
强调：匿名内部类和匿名对象不是一回事</p>
</li>
</ul>
<h2 id="注意事项-2">注意事项</h2>
<ul>
<li>
<p>小节一下类的权限修饰符：<br>
<code>public &gt; protected &gt;（default）&gt; private</code>定义一个类的时候，权限修饰符规则：</p>
</li>
<li>
<p>1.外部类：<code>public/（default）</code></p>
</li>
<li>
<p>2.成员内部类：<code>public/protected/（deffult）/private</code></p>
</li>
<li>
<p>3.局部内部类：什么都不能加</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Java语言概述</title>
    <url>/2023/02/06/java%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="Java语言简史">Java语言简史</h2>
<ul>
<li>Java语言是美国Sun公司（Stanford University Network），在1995年推出的高级编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。</li>
</ul>
<p>Java语言发展历史</p>
<ul>
<li>1995年Sun公司发布Java1.0版本</li>
<li>1997年发布Java1.1版本</li>
<li>1998年发布Java1.2版本</li>
<li>2000年发布Java1.3版本</li>
<li>2002年发布Java1.4版本</li>
<li>2004年发布Java5版本（更新频率较大）</li>
<li>2006年发布Java6版本</li>
<li>2009年Oracle甲骨文公司收购Sun公司，并于2011发布Java7版本</li>
<li>2014年发布Java8版本（更新频率较大，市场占有率最大）</li>
<li>2017年9月发布Java9版本</li>
<li>2018年3月发布Java10版本</li>
</ul>
<h2 id="Java-平台的三个版本">Java 平台的三个版本</h2>
<p>作用：</p>
<ul>
<li>这使软件开发人员、服务提供商和设备生产商可以针对特定的市场进行开发：</li>
</ul>
<h3 id="Java-SE（Java-Platform，Standard-Edition）">Java SE（Java Platform，Standard Edition）</h3>
<ul>
<li>Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为 Java Platform，Enterprise Edition（Java EE）提供基础。</li>
</ul>
<h3 id="Java-EE（Java-Platform，Enterprise-Edition）">Java EE（Java Platform，Enterprise Edition）</h3>
<ul>
<li>这个版本以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 2.0 应用程序。</li>
</ul>
<h3 id="Java-ME（Java-Platform，Micro-Edition）">Java ME（Java Platform，Micro Edition）</h3>
<ul>
<li>这个版本以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</li>
</ul>
<blockquote>
<p>开发环境，推荐Eclipse,NetBeans,这两个IDE可以挂接对应的插件，进行开发。还有一点，那就是这三个应用，se,标准应用，以学习为主，由于界面，开发成本，速度等问题，很少用来做程序，但不是说，他不能做程序，Eclipse,NetBeans,都是javase写起来的。Me,移动设备应用，对于一些中高端应用还好了！以前用他做过手机游戏，呵呵呵！EE,企业级解决方案，开发套件全部免费，可控性好，安全性高，乃是当前B2B的规范。再者，这三个应用，都需要虚拟机的支持。</p>
</blockquote>
<span id="more"></span>
<h2 id="字节">字节</h2>
<ul>
<li>位（bit）：一个数字0或者一个数字1，代表一位。</li>
<li>字节（Byte）：每逢8位是一个字节，这是数据存储的最小单位。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> Byte = <span class="number">8</span> bit</span><br><span class="line"><span class="number">1</span> KB = <span class="number">1024</span> Byte</span><br><span class="line"><span class="number">1</span> MB = <span class="number">1024</span> KB</span><br><span class="line"><span class="number">1</span> GB = <span class="number">1024</span> MB</span><br><span class="line"><span class="number">1</span> TB = <span class="number">1024</span> GB</span><br><span class="line"><span class="number">1</span> PB = <span class="number">1024</span> TB</span><br><span class="line"><span class="number">1</span> EB = <span class="number">1024</span> PB</span><br><span class="line"><span class="number">1</span> ZB = <span class="number">1024</span> EB</span><br></pre></td></tr></table></figure>
<h2 id="Java虚拟机——JVM">Java虚拟机——JVM</h2>
<ul>
<li><code>JVM</code>（Java Virtual Machine）：Java虚拟机，简称<code>JVM</code>，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java最具吸引力的特性之一。我们编写的<code>Java</code>代码，都运行在<code>JVM</code>之上。</li>
<li>跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为<code>Java</code>语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在<code>JVM</code>上，而<code>JVM</code>运行在操作系统上。</li>
</ul>
<blockquote>
<p>Java的虚拟机本身不具备跨平台功能的，每个操作系统下都有不同版本的虚拟机。</p>
</blockquote>
<h2 id="JRE和JDK">JRE和JDK</h2>
<ul>
<li><code>JRE</code>（Java Runtime Environment）：是<code>Java</code>程序的运行时环境，包含<code>Jvm</code>和运行时所需要的核心类。</li>
<li><code>JDK</code>（Java Development Kit）：是<code>Java</code>程序开发工具包，包含JRE]和开发人员使用的工具。<br>
我们想要运行一个已有的<code>Java</code>程序，那么只需安装<code>JRE</code>即可。<br>
我们想要开发一个全新<code>java</code>程序，那么必须安装<code>JDK</code>。</li>
</ul>
<p><img src="https://upload.cc/i1/2019/12/03/iHdtNp.png" alt="image-20191130121256831"></p>
<h2 id="Java程序运行步骤">Java程序运行步骤</h2>
<ul>
<li>编写源程序， 后缀名为<code>.java</code>的文件</li>
<li>编译源程序， 用<code>javac</code>命令将后缀名为<code>.java</code>的源程序编译成<code>.class</code>的字节码文件</li>
<li>运行源程序， 用<code>java</code>命令 将<code>.class</code>文件在计算机上解释出来（JVM上运行）。</li>
</ul>
<h2 id="Java标识符">Java标识符</h2>
<ul>
<li>
<p>标识符：是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。</p>
</li>
<li>
<p>命名规则：<code>硬性要求</code></p>
</li>
<li>
<p>标识符可以包含英文字母26个（区分大小写）、0-9数字、$（美元符号）和<code>_</code>（下划线）。</p>
</li>
<li>
<p>标识符不能以数字开头。</p>
</li>
<li>
<p>标识符不能是关键字。</p>
</li>
<li>
<p>命名规范：<code>软性建议</code>(代码命名规范建议)</p>
</li>
<li>
<p>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。</p>
</li>
<li>
<p>变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。</p>
</li>
<li>
<p>方法名规范：同变量名。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Luenci.demo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Luenci</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/30 18:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoCode1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 字符串常量 和 字符常量（里面有且仅有一个字符）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我是字符串常量&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&#x27;h&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 整数常量</span></span><br><span class="line">        System.out.println(<span class="number">200</span>);</span><br><span class="line">        System.out.println(-<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 浮点数常量</span></span><br><span class="line">        System.out.println(<span class="number">0.22</span>);</span><br><span class="line">        System.out.println(<span class="number">0.8989</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 布尔常量</span></span><br><span class="line">        System.out.println(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 空常量:不能用来打印输出</span></span><br><span class="line">        <span class="comment">// System.out.println(null);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Java数据类型">Java数据类型</h2>
<p>Java的数据类型分为两大类：</p>
<ul>
<li>基本数据类型：整数、浮点数、字符、布尔。</li>
<li>引用数据类型：类、数组、接口。</li>
</ul>
<h3 id="基本数据类型">基本数据类型</h3>
<ul>
<li>整数型  <code>byte</code> <code>short</code> <code>int</code> <code>log</code></li>
<li>浮点型 <code>float</code>  <code>double</code></li>
<li>字符型 <code>char</code></li>
<li>布尔型 <code>boolean</code></li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>关键字</th>
<th>内存占用</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>字节型</td>
<td>byte</td>
<td>1个字节</td>
<td>-128 - 127</td>
</tr>
<tr>
<td>短整型</td>
<td>short</td>
<td>2个字节</td>
<td>-32768 - 32767</td>
</tr>
<tr>
<td>整型</td>
<td>int（默认）</td>
<td>4个字节</td>
<td>-2^31 - 2^31-1</td>
</tr>
<tr>
<td>长整型</td>
<td>long</td>
<td>8个字节</td>
<td>-2^63 - 2^63.1</td>
</tr>
<tr>
<td>单精度浮点数</td>
<td>float</td>
<td>4个字节</td>
<td>1.4013E - 45-3.4028E+38</td>
</tr>
<tr>
<td>双精度浮点数</td>
<td>double（默认）</td>
<td>8个字节</td>
<td>4.9E-324 ~ 1.7977E+308</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
<td>2个字节</td>
<td>0-65535</td>
</tr>
<tr>
<td>布尔类型</td>
<td>honlean</td>
<td>1个字节</td>
<td>true false</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意事项：</p>
<ul>
<li>字符串不是基本类型，而是引用类型。</li>
<li>浮点型可能只是一个近似值，并非精确的值。</li>
<li>数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节。</li>
<li>浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F。</li>
<li>如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L。推荐使用大写字母后缀。</li>
</ul>
</blockquote>
<p>【作用域】：从定义变量的行开始，一直到直接所属的大括号结束为止。</p>
<h2 id="数据类型转换">数据类型转换</h2>
<ul>
<li>自动类型转换（隐式）
<ul>
<li>特点：代码不需要进行特殊处理，自动完成</li>
<li>规则：数据范围从小到大</li>
</ul>
</li>
<li>强制类型转换（显示）
<ul>
<li>特点：代码需要进行特殊的格式处理，不能自动完成</li>
<li>格式：范围小的类型 范围小的变量名 = （范围小的类型） 原本范围大的数据;</li>
</ul>
</li>
</ul>
<blockquote>
<p>强制类型转换 （注意）</p>
<ul>
<li>
<p>使用时注意精度损失和数据溢出等情况</p>
</li>
<li>
<p>byte/short/char这三种类型都可以发生数学运算，例如加法“+”.</p>
</li>
<li>
<p><em><strong>byte/short/char这三种类型在运算的时候，都会被首先提升成为int类型，然后再计算。</strong></em></p>
</li>
<li>
<p>boolean类型不能发生数据类型变换</p>
</li>
</ul>
</blockquote>
<h2 id="ASCII码字符表">ASCII码字符表</h2>
<ul>
<li>0 对应的ascill码值为  32</li>
<li>A 对应的ascill码值为 65</li>
<li>a  对应的ascill码值为 97</li>
</ul>
<blockquote>
<p>其余的向后推理即可</p>
</blockquote>
<h2 id="运算符">运算符</h2>
<table>
<thead>
<tr>
<th>算数运算符包括</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code></td>
<td>加法运算，字符串连接运算</td>
</tr>
<tr>
<td><code>-</code></td>
<td>减法运算</td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘法运算</td>
</tr>
<tr>
<td><code>\</code></td>
<td>除法运算</td>
</tr>
<tr>
<td><code>%</code></td>
<td>取模运算，两个数字相除1取余数</td>
</tr>
<tr>
<td><code>++</code>, <code>--</code></td>
<td>自增自减运算</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Luenci.demo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Luenci</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/12/2 20:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 四则运算符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>,b = <span class="number">25</span>;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">        System.out.println(a - b);</span><br><span class="line">        System.out.println(a * b);</span><br><span class="line">        System.out.println(a / b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用字符串进行连接的时候结果都会变成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Luenci&quot;</span>;</span><br><span class="line">        System.out.println(str + <span class="number">404</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单独使用的时候++在前和++在后没什么区别</span></span><br><span class="line">        <span class="comment">// 和变量等在一起使用的时候是++在前的时候【先加后用】</span></span><br><span class="line">        <span class="comment">// 和变量等在一起使用的时候是++在后的时候【先用后加】</span></span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(num);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------- 分割线 -----------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        System.out.println(num1++);  <span class="comment">// 20</span></span><br><span class="line">        System.out.println(num1);    <span class="comment">// 21</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        System.out.println(++num2); <span class="comment">// 31</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="number">35</span></span><br><span class="line">    -<span class="number">15</span></span><br><span class="line">    <span class="number">250</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    Luenci404</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    -------------- 分割线 -----------------</span><br><span class="line">    <span class="number">20</span></span><br><span class="line">    <span class="number">21</span></span><br><span class="line">    <span class="number">31</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>常量不可使用 ++，–</p>
<p>赋值运算符其中  隐含了一个强制类型转换</p>
</blockquote>
<h2 id="比较运算符">比较运算符</h2>
<table>
<thead>
<tr>
<th>比较运算符类别</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code></td>
<td>比较两边的数据是否相等，相等结果为True</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>比较左边的数据是否小于右边的数据，小于结果为True</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>比较左边的数据是否大于右边的数据，大于结果为True</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>比较左边的数据是否小于或等于右边的数据，小于或等于结果为True</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>比较左边的数据是否大于或等于右边的数据，大于或等于结果为True</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>比较两边的数据是否相等，不相等结果为True</td>
</tr>
</tbody>
</table>
<h2 id="逻辑运算符">逻辑运算符</h2>
<p>与（并且）<code>&amp;&amp;</code>全都是true，才是true；否则就是false</p>
<p>或（或者）<code>||</code>至少一个是true，就是true；全都是false， 才是false</p>
<p>非（取反）<code>！</code>本来是true，变成false；本来是false，变成true</p>
<h2 id="编译器的两点优化">编译器的两点优化</h2>
<ul>
<li>对于<code>byte/short/char</code>三种类型来说，如果右侧赋值的数值没有超过范围，那么<code>javac</code>编译器将会自动隐含地为我们补上一个<code>（byte）（short）（char）</code>。
<ul>
<li>1.如果没有超过左侧的范围，编译器补上强转。</li>
<li>2.如果右侧超过了左侧范围，那么直接编译器报错。</li>
</ul>
</li>
</ul>
<p>编译器的常量优化</p>
<ul>
<li>在给变量进行赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。
<ul>
<li>如:<code>short result=5+8</code>；//等号右边全都是常量，没有任何变量参与运算编译之后，得到的<code>.class</code>字节码文件当中相当于【直接就是】：<code>short result=13；</code></li>
</ul>
</li>
</ul>
<h2 id="程序流程控制">程序流程控制</h2>
<h3 id="判断语句">判断语句</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Luenci.method;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Luenci</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/12/3 17:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 从键盘处获得成绩值</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入您的成绩&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">score</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断成绩优秀否</span></span><br><span class="line">        <span class="keyword">if</span> ( Integer.parseInt(score) &gt;= <span class="number">90</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您的成绩优秀&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Integer.parseInt(score) &gt; <span class="number">80</span> &amp;&amp; Integer.parseInt(score) &lt; <span class="number">90</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你的成绩良好&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Integer.parseInt(score) &gt; <span class="number">60</span> &amp;&amp; Integer.parseInt(score) &lt;<span class="number">80</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您的成绩合格&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您的成绩不合格&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getType</span><span class="params">(Object o)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o.getClass().toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="选择结构">选择结构</h3>
<blockquote>
<h3 id="switch语句使用的注意事项：">switch语句使用的注意事项：</h3>
<p>​	1.多个case后面的数值不可以重复。</p>
<p>​	2.switch后面小括号当中只能是下列数据类型：</p>
<p>​		基本数据类型：byte/short/char/int</p>
<p>​		引用数据类型：String字符串、enum枚举</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Luenci.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Luenci</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/12/4 11:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 设置日期格式</span></span><br><span class="line">        <span class="comment">// SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span></span><br><span class="line">        <span class="comment">// new Date()为获取当前系统时间</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="comment">// 使用SimpleDateFormat格式化日期</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;EEEE&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">currSun</span> <span class="operator">=</span> df.format(date);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (currSun)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;星期一&quot;</span>:</span><br><span class="line">                System.out.println(currSun + <span class="string">&quot;开始上班&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;星期六&quot;</span>:</span><br><span class="line">                System.out.println(currSun + <span class="string">&quot;休息第一天&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;星期五&quot;</span>:</span><br><span class="line">                System.out.println(currSun + <span class="string">&quot;放假前夕&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(currSun + <span class="string">&quot;上班中&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="循环语句">循环语句</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Luenci.method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Luenci</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/12/4 15:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i,a;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)&#123;</span><br><span class="line">            a += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="whlie循环">whlie循环</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Luenci.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.jmx.snmp.internal.SnmpSubSystem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Luenci</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/12/4 15:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 初始化语句</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (a &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;打印&quot;</span> + a + <span class="string">&quot;遍&quot;</span>);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="do-…while-循环">do …while 循环</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Luenci.method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Luenci</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/12/4 15:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DowhlieDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// do ..... while 循环的第一次是  无条件执行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;打印&quot;</span> + i + <span class="string">&quot;遍&quot;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三种循环的区别">三种循环的区别</h2>
<ul>
<li>1.如果条件判断从来没有满足过，那么for循环和while循环将会执行0次，但是do-while循环会执行至少一次。</li>
<li>2.for循环的变量在小括号当中定义，只有循环内部才可以使用。while循环和do-while循环初始化语句本来就在外面，所以出来循环之后还可以继续使用。</li>
</ul>
<h3 id="break关键字的用法有常见的两种">break关键字的用法有常见的两种</h3>
<ul>
<li>
<p>1.可以用在<code>switch</code>语句当中，一旦执行，整个<code>switch</code>语句立刻结束。</p>
</li>
<li>
<p>2.还可以用在循环语句当中，一旦执行，<code>整个循环</code>语句立刻结束。打断循环。</p>
</li>
</ul>
<blockquote>
<p>关于循环的选择，有一个小建议：<br>
凡是次数确定的场景多用for循环；否则多用while循环。</p>
</blockquote>
<h3 id="另一种循环控制语句是continue关键字。">另一种循环控制语句是continue关键字。</h3>
<ul>
<li>一旦执行，立刻跳过当前次循环剩余内容，马上开始下一次循环</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas函数</title>
    <url>/2023/02/06/pandas%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1>【python】Pandas中DataFrame基本函数整理</h1>
<h5 id="构造函数">构造函数</h5>
<ul>
<li>DataFrame([data, index, columns, dtype, copy]) 	#构造数据框1</li>
</ul>
<h5 id="属性和数据">属性和数据</h5>
<p>DataFrame.axes                                #index: 行标签；columns: 列标签<br>
DataFrame.as_matrix([columns])                #转换为矩阵<br>
DataFrame.dtypes                              #返回数据的类型<br>
DataFrame.ftypes                              #返回每一列的 数据类型float64:dense<br>
DataFrame.get_dtype_counts()                  #返回数据框数据类型的个数<br>
DataFrame.get_ftype_counts()                  #返回数据框数据类型float64:dense的个数<br>
DataFrame.select_dtypes([include, include])   #根据数据类型选取子数据框<br>
DataFrame.values                              #Numpy的展示方式<br>
DataFrame.axes                                #返回横纵坐标的标签名<br>
DataFrame.ndim                                #返回数据框的纬度<br>
DataFrame.size                                #返回数据框元素的个数<br>
DataFrame.shape                               #返回数据框的形状<br>
DataFrame.memory_usage()                      #每一列的存储12345678910111213</p>
<h5 id="类型转换">类型转换</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.astype(dtype[, copy, errors])       <span class="comment">#转换数据类型</span></span><br><span class="line">DataFrame.copy([deep])                        <span class="comment">#deep深度复制数据</span></span><br><span class="line">DataFrame.isnull()                            <span class="comment">#以布尔的方式返回空值</span></span><br><span class="line">DataFrame.notnull()                           <span class="comment">#以布尔的方式返回非空值1234</span></span><br></pre></td></tr></table></figure>
<h5 id="索引和迭代">索引和迭代</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.head([n])                           <span class="comment">#返回前n行数据</span></span><br><span class="line">DataFrame.at                                  <span class="comment">#快速标签常量访问器</span></span><br><span class="line">DataFrame.iat                                 <span class="comment">#快速整型常量访问器</span></span><br><span class="line">DataFrame.loc                                 <span class="comment">#标签定位，使用名称</span></span><br><span class="line">DataFrame.iloc                                <span class="comment">#整型定位，使用数字</span></span><br><span class="line">DataFrame.insert(loc, column, value)          <span class="comment">#在特殊地点loc[数字]插入column[列名]某列数据</span></span><br><span class="line">DataFrame.<span class="built_in">iter</span>()                              <span class="comment">#Iterate over infor axis</span></span><br><span class="line">DataFrame.iteritems()                         <span class="comment">#返回列名和序列的迭代器</span></span><br><span class="line">DataFrame.iterrows()                          <span class="comment">#返回索引和序列的迭代器</span></span><br><span class="line">DataFrame.itertuples([index, name])           <span class="comment">#Iterate over DataFrame rows as namedtuples, with index value as first element of the tuple.</span></span><br><span class="line">DataFrame.lookup(row_labels, col_labels)      <span class="comment">#Label-based “fancy indexing” function for DataFrame.</span></span><br><span class="line">DataFrame.pop(item)                           <span class="comment">#返回删除的项目</span></span><br><span class="line">DataFrame.tail([n])                           <span class="comment">#返回最后n行</span></span><br><span class="line">DataFrame.xs(key[, axis, level, drop_level])  <span class="comment">#Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.</span></span><br><span class="line">DataFrame.isin(values)                        <span class="comment">#是否包含数据框中的元素</span></span><br><span class="line">DataFrame.where(cond[, other, inplace, …])    <span class="comment">#条件筛选</span></span><br><span class="line">DataFrame.mask(cond[, other, inplace, …])     <span class="comment">#Return an object of same shape as self and whose corresponding entries are from self where cond is False and otherwise are from other.</span></span><br><span class="line">DataFrame.query(expr[, inplace])              <span class="comment">#Query the columns of a frame with a boolean expression.123456789101112131415161718</span></span><br></pre></td></tr></table></figure>
<h5 id="二元运算">二元运算</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.add(other[,axis,fill_value])        <span class="comment">#加法，元素指向</span></span><br><span class="line">DataFrame.sub(other[,axis,fill_value])        <span class="comment">#减法，元素指向</span></span><br><span class="line">DataFrame.mul(other[, axis,fill_value])       <span class="comment">#乘法，元素指向</span></span><br><span class="line">DataFrame.div(other[, axis,fill_value])       <span class="comment">#小数除法，元素指向</span></span><br><span class="line">DataFrame.truediv(other[, axis, level, …])    <span class="comment">#真除法，元素指向</span></span><br><span class="line">DataFrame.floordiv(other[, axis, level, …])   <span class="comment">#向下取整除法，元素指向</span></span><br><span class="line">DataFrame.mod(other[, axis,fill_value])       <span class="comment">#模运算，元素指向</span></span><br><span class="line">DataFrame.<span class="built_in">pow</span>(other[, axis,fill_value])       <span class="comment">#幂运算，元素指向</span></span><br><span class="line">DataFrame.radd(other[, axis,fill_value])      <span class="comment">#右侧加法，元素指向</span></span><br><span class="line">DataFrame.rsub(other[, axis,fill_value])      <span class="comment">#右侧减法，元素指向</span></span><br><span class="line">DataFrame.rmul(other[, axis,fill_value])      <span class="comment">#右侧乘法，元素指向</span></span><br><span class="line">DataFrame.rdiv(other[, axis,fill_value])      <span class="comment">#右侧小数除法，元素指向</span></span><br><span class="line">DataFrame.rtruediv(other[, axis, …])          <span class="comment">#右侧真除法，元素指向</span></span><br><span class="line">DataFrame.rfloordiv(other[, axis, …])         <span class="comment">#右侧向下取整除法，元素指向</span></span><br><span class="line">DataFrame.rmod(other[, axis,fill_value])      <span class="comment">#右侧模运算，元素指向</span></span><br><span class="line">DataFrame.rpow(other[, axis,fill_value])      <span class="comment">#右侧幂运算，元素指向</span></span><br><span class="line">DataFrame.lt(other[, axis, level])            <span class="comment">#类似Array.lt</span></span><br><span class="line">DataFrame.gt(other[, axis, level])            <span class="comment">#类似Array.gt</span></span><br><span class="line">DataFrame.le(other[, axis, level])            <span class="comment">#类似Array.le</span></span><br><span class="line">DataFrame.ge(other[, axis, level])            <span class="comment">#类似Array.ge</span></span><br><span class="line">DataFrame.ne(other[, axis, level])            <span class="comment">#类似Array.ne</span></span><br><span class="line">DataFrame.eq(other[, axis, level])            <span class="comment">#类似Array.eq</span></span><br><span class="line">DataFrame.combine(other,func[,fill_value, …]) <span class="comment">#Add two DataFrame objects and do not propagate NaN values, so if for a</span></span><br><span class="line">DataFrame.combine_first(other)                <span class="comment">#Combine two DataFrame objects and default to non-null values in frame calling the method.123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure>
<h5 id="函数应用-分组-窗口">函数应用&amp;分组&amp;窗口</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.apply(func[, axis, broadcast, …])   <span class="comment">#应用函数</span></span><br><span class="line">DataFrame.applymap(func)                      <span class="comment">#Apply a function to a DataFrame that is intended to operate elementwise, i.e.</span></span><br><span class="line">DataFrame.aggregate(func[, axis])             <span class="comment">#Aggregate using callable, string, dict, or list of string/callables</span></span><br><span class="line">DataFrame.transform(func, *args, **kwargs)    <span class="comment">#Call function producing a like-indexed NDFrame</span></span><br><span class="line">DataFrame.groupby([by, axis, level, …])       <span class="comment">#分组</span></span><br><span class="line">DataFrame.rolling(window[, min_periods, …])   <span class="comment">#滚动窗口</span></span><br><span class="line">DataFrame.expanding([min_periods, freq, …])   <span class="comment">#拓展窗口</span></span><br><span class="line">DataFrame.ewm([com, span, halflife,  …])      <span class="comment">#指数权重窗口12345678</span></span><br></pre></td></tr></table></figure>
<h5 id="描述统计学">描述统计学</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.<span class="built_in">abs</span>()                               <span class="comment">#返回绝对值</span></span><br><span class="line">DataFrame.<span class="built_in">all</span>([axis, bool_only, skipna])      <span class="comment">#Return whether all elements are True over requested axis</span></span><br><span class="line">DataFrame.<span class="built_in">any</span>([axis, bool_only, skipna])      <span class="comment">#Return whether any element is True over requested axis</span></span><br><span class="line">DataFrame.clip([lower, upper, axis])          <span class="comment">#Trim values at input threshold(s).</span></span><br><span class="line">DataFrame.clip_lower(threshold[, axis])       <span class="comment">#Return copy of the input with values below given value(s) truncated.</span></span><br><span class="line">DataFrame.clip_upper(threshold[, axis])       <span class="comment">#Return copy of input with values above given value(s) truncated.</span></span><br><span class="line">DataFrame.corr([method, min_periods])         <span class="comment">#返回本数据框成对列的相关性系数</span></span><br><span class="line">DataFrame.corrwith(other[, axis, drop])       <span class="comment">#返回不同数据框的相关性</span></span><br><span class="line">DataFrame.count([axis, level, numeric_only])  <span class="comment">#返回非空元素的个数</span></span><br><span class="line">DataFrame.cov([min_periods])                  <span class="comment">#计算协方差</span></span><br><span class="line">DataFrame.cummax([axis, skipna])              <span class="comment">#Return cumulative max over requested axis.</span></span><br><span class="line">DataFrame.cummin([axis, skipna])              <span class="comment">#Return cumulative minimum over requested axis.</span></span><br><span class="line">DataFrame.cumprod([axis, skipna])             <span class="comment">#返回累积</span></span><br><span class="line">DataFrame.cumsum([axis, skipna])              <span class="comment">#返回累和</span></span><br><span class="line">DataFrame.describe([percentiles,include, …])  <span class="comment">#整体描述数据框</span></span><br><span class="line">DataFrame.diff([periods, axis])               <span class="comment">#1st discrete difference of object</span></span><br><span class="line">DataFrame.<span class="built_in">eval</span>(expr[, inplace])               <span class="comment">#Evaluate an expression in the context of the calling DataFrame instance.</span></span><br><span class="line">DataFrame.kurt([axis, skipna, level, …])      <span class="comment">#返回无偏峰度Fisher’s  (kurtosis of normal == 0.0).</span></span><br><span class="line">DataFrame.mad([axis, skipna, level])          <span class="comment">#返回偏差</span></span><br><span class="line">DataFrame.<span class="built_in">max</span>([axis, skipna, level, …])       <span class="comment">#返回最大值</span></span><br><span class="line">DataFrame.mean([axis, skipna, level, …])      <span class="comment">#返回均值</span></span><br><span class="line">DataFrame.median([axis, skipna, level, …])    <span class="comment">#返回中位数</span></span><br><span class="line">DataFrame.<span class="built_in">min</span>([axis, skipna, level, …])       <span class="comment">#返回最小值</span></span><br><span class="line">DataFrame.mode([axis, numeric_only])          <span class="comment">#返回众数</span></span><br><span class="line">DataFrame.pct_change([periods, fill_method])  <span class="comment">#返回百分比变化</span></span><br><span class="line">DataFrame.prod([axis, skipna, level, …])      <span class="comment">#返回连乘积</span></span><br><span class="line">DataFrame.quantile([q, axis, numeric_only])   <span class="comment">#返回分位数</span></span><br><span class="line">DataFrame.rank([axis, method, numeric_only])  <span class="comment">#返回数字的排序</span></span><br><span class="line">DataFrame.<span class="built_in">round</span>([decimals])                   <span class="comment">#Round a DataFrame to a variable number of decimal places.</span></span><br><span class="line">DataFrame.sem([axis, skipna, level, ddof])    <span class="comment">#返回无偏标准误</span></span><br><span class="line">DataFrame.skew([axis, skipna, level, …])      <span class="comment">#返回无偏偏度</span></span><br><span class="line">DataFrame.<span class="built_in">sum</span>([axis, skipna, level, …])       <span class="comment">#求和</span></span><br><span class="line">DataFrame.std([axis, skipna, level, ddof])    <span class="comment">#返回标准误差</span></span><br><span class="line">DataFrame.var([axis, skipna, level, ddof])    <span class="comment">#返回无偏误差 12345678910111213141516171819202122232425262728293031323334</span></span><br></pre></td></tr></table></figure>
<h5 id="从新索引-选取-标签操作">从新索引&amp;选取&amp;标签操作</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.add_prefix(prefix)                  <span class="comment">#添加前缀</span></span><br><span class="line">DataFrame.add_suffix(suffix)                  <span class="comment">#添加后缀</span></span><br><span class="line">DataFrame.align(other[, join, axis, level])   <span class="comment">#Align two object on their axes with the</span></span><br><span class="line">DataFrame.drop(labels[, axis, level, …])      <span class="comment">#返回删除的列</span></span><br><span class="line">DataFrame.drop_duplicates([subset, keep, …])  <span class="comment">#Return DataFrame with duplicate rows removed, optionally only</span></span><br><span class="line">DataFrame.duplicated([subset, keep])          <span class="comment">#Return boolean Series denoting duplicate rows, optionally only</span></span><br><span class="line">DataFrame.equals(other)                       <span class="comment">#两个数据框是否相同</span></span><br><span class="line">DataFrame.<span class="built_in">filter</span>([items, like, regex, axis])  <span class="comment">#过滤特定的子数据框</span></span><br><span class="line">DataFrame.first(offset)                       <span class="comment">#Convenience method for subsetting initial periods of time series data based on a date offset.</span></span><br><span class="line">DataFrame.head([n])                           <span class="comment">#返回前n行</span></span><br><span class="line">DataFrame.idxmax([axis, skipna])              <span class="comment">#Return index of first occurrence of maximum over requested axis.</span></span><br><span class="line">DataFrame.idxmin([axis, skipna])              <span class="comment">#Return index of first occurrence of minimum over requested axis.</span></span><br><span class="line">DataFrame.last(offset)                        <span class="comment">#Convenience method for subsetting final periods of time series data based on a date offset.</span></span><br><span class="line">DataFrame.reindex([index, columns])           <span class="comment">#Conform DataFrame to new index with optional filling logic, placing NA/NaN in locations having no value in the previous index.</span></span><br><span class="line">DataFrame.reindex_axis(labels[, axis, …])     <span class="comment">#Conform input object to new index with optional filling logic, placing NA/NaN in locations having no value in the previous index.</span></span><br><span class="line">DataFrame.reindex_like(other[, method, …])    <span class="comment">#Return an object with matching indices to myself.</span></span><br><span class="line">DataFrame.rename([index, columns])            <span class="comment">#Alter axes input function or functions.</span></span><br><span class="line">DataFrame.rename_axis(mapper[, axis, copy])   <span class="comment">#Alter index and / or columns using input function or functions.</span></span><br><span class="line">DataFrame.reset_index([level, drop, …])       <span class="comment">#For DataFrame with multi-level index, return new DataFrame with labeling information in the columns under the index names, defaulting to ‘level_0’, ‘level_1’, etc.</span></span><br><span class="line">DataFrame.sample([n, frac, replace, …])       <span class="comment">#返回随机抽样</span></span><br><span class="line">DataFrame.select(crit[, axis])                <span class="comment">#Return data corresponding to axis labels matching criteria</span></span><br><span class="line">DataFrame.set_index(keys[, drop, append ])    <span class="comment">#Set the DataFrame index (row labels) using one or more existing columns.</span></span><br><span class="line">DataFrame.tail([n])                           <span class="comment">#返回最后几行</span></span><br><span class="line">DataFrame.take(indices[, axis, convert])      <span class="comment">#Analogous to ndarray.take</span></span><br><span class="line">DataFrame.truncate([before, after, axis ])    <span class="comment">#Truncates a sorted NDFrame before and/or after some particular index value.12345678910111213141516171819202122232425</span></span><br></pre></td></tr></table></figure>
<h5 id="处理缺失值">处理缺失值</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DataFrame.dropna([axis, how, thresh, …])      #Return object with labels on given axis omitted where alternately any</span><br><span class="line">DataFrame.fillna([value, method, axis, …])    #填充空值</span><br><span class="line">DataFrame.replace([to_replace, value, …])     #Replace values given in ‘to_replace’ with ‘value’.123</span><br></pre></td></tr></table></figure>
<h5 id="从新定型-排序-转变形态">从新定型&amp;排序&amp;转变形态</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.pivot([index, columns, values])     <span class="comment">#Reshape data (produce a “pivot” table) based on column values.</span></span><br><span class="line">DataFrame.reorder_levels(order[, axis])       <span class="comment">#Rearrange index levels using input order.</span></span><br><span class="line">DataFrame.sort_values(by[, axis, ascending])  <span class="comment">#Sort by the values along either axis</span></span><br><span class="line">DataFrame.sort_index([axis, level, …])        <span class="comment">#Sort object by labels (along an axis)</span></span><br><span class="line">DataFrame.nlargest(n, columns[, keep])        <span class="comment">#Get the rows of a DataFrame sorted by the n largest values of columns.</span></span><br><span class="line">DataFrame.nsmallest(n, columns[, keep])       <span class="comment">#Get the rows of a DataFrame sorted by the n smallest values of columns.</span></span><br><span class="line">DataFrame.swaplevel([i, j, axis])             <span class="comment">#Swap levels i and j in a MultiIndex on a particular axis</span></span><br><span class="line">DataFrame.stack([level, dropna])              <span class="comment">#Pivot a level of the (possibly hierarchical) column labels, returning a DataFrame (or Series in the case of an object with a single level of column labels) having a hierarchical index with a new inner-most level of row labels.</span></span><br><span class="line">DataFrame.unstack([level, fill_value])        <span class="comment">#Pivot a level of the (necessarily hierarchical) index labels, returning a DataFrame having a new level of column labels whose inner-most level consists of the pivoted index labels.</span></span><br><span class="line">DataFrame.melt([id_vars, value_vars, …])      <span class="comment">#“Unpivots” a DataFrame from wide format to long format, optionally</span></span><br><span class="line">DataFrame.T                                   <span class="comment">#Transpose index and columns</span></span><br><span class="line">DataFrame.to_panel()                          <span class="comment">#Transform long (stacked) format (DataFrame) into wide (3D, Panel) format.</span></span><br><span class="line">DataFrame.to_xarray()                         <span class="comment">#Return an xarray object from the pandas object.</span></span><br><span class="line">DataFrame.transpose(*args, **kwargs)          <span class="comment">#Transpose index and columns1234567891011121314</span></span><br></pre></td></tr></table></figure>
<h5 id="Combining-joining-merging">Combining&amp; joining&amp;merging</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.append(other[, ignore_index, …])    <span class="comment">#追加数据</span></span><br><span class="line">DataFrame.assign(**kwargs)                    <span class="comment">#Assign new columns to a DataFrame, returning a new object (a copy) with all the original columns in addition to the new ones.</span></span><br><span class="line">DataFrame.join(other[, on, how, lsuffix, …])  <span class="comment">#Join columns with other DataFrame either on index or on a key column.</span></span><br><span class="line">DataFrame.merge(right[, how, on, left_on, …]) <span class="comment">#Merge DataFrame objects by performing a database-style join operation by columns or indexes.</span></span><br><span class="line">DataFrame.update(other[, join, overwrite, …]) <span class="comment">#Modify DataFrame in place using non-NA values from passed DataFrame.12345</span></span><br></pre></td></tr></table></figure>
<h5 id="时间序列">时间序列</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.asfreq(freq[, method, how, …])      <span class="comment">#将时间序列转换为特定的频次</span></span><br><span class="line">DataFrame.asof(where[, subset])               <span class="comment">#The last row without any NaN is taken (or the last row without</span></span><br><span class="line">DataFrame.shift([periods, freq, axis])        <span class="comment">#Shift index by desired number of periods with an optional time freq</span></span><br><span class="line">DataFrame.first_valid_index()                 <span class="comment">#Return label for first non-NA/null value</span></span><br><span class="line">DataFrame.last_valid_index()                  <span class="comment">#Return label for last non-NA/null value</span></span><br><span class="line">DataFrame.resample(rule[, how, axis, …])      <span class="comment">#Convenience method for frequency conversion and resampling of time series.</span></span><br><span class="line">DataFrame.to_period([freq, axis, copy])       <span class="comment">#Convert DataFrame from DatetimeIndex to PeriodIndex with desired</span></span><br><span class="line">DataFrame.to_timestamp([freq, how, axis])     <span class="comment">#Cast to DatetimeIndex of timestamps, at beginning of period</span></span><br><span class="line">DataFrame.tz_convert(tz[, axis, level, copy]) <span class="comment">#Convert tz-aware axis to target time zone.</span></span><br><span class="line">DataFrame.tz_localize(tz[, axis, level, …])   <span class="comment">#Localize tz-naive TimeSeries to target time zone.12345678910</span></span><br></pre></td></tr></table></figure>
<h5 id="作图">作图</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.plot([x, y, kind, ax, ….])          <span class="comment">#DataFrame plotting accessor and method</span></span><br><span class="line">DataFrame.plot.area([x, y])                   <span class="comment">#面积图Area plot</span></span><br><span class="line">DataFrame.plot.bar([x, y])                    <span class="comment">#垂直条形图Vertical bar plot</span></span><br><span class="line">DataFrame.plot.barh([x, y])                   <span class="comment">#水平条形图Horizontal bar plot</span></span><br><span class="line">DataFrame.plot.box([by])                      <span class="comment">#箱图Boxplot</span></span><br><span class="line">DataFrame.plot.density(**kwds)                <span class="comment">#核密度Kernel Density Estimate plot</span></span><br><span class="line">DataFrame.plot.hexbin(x, y[, C, …])           <span class="comment">#Hexbin plot</span></span><br><span class="line">DataFrame.plot.hist([by, bins])               <span class="comment">#直方图Histogram</span></span><br><span class="line">DataFrame.plot.kde(**kwds)                    <span class="comment">#核密度Kernel Density Estimate plot</span></span><br><span class="line">DataFrame.plot.line([x, y])                   <span class="comment">#线图Line plot</span></span><br><span class="line">DataFrame.plot.pie([y])                       <span class="comment">#饼图Pie chart</span></span><br><span class="line">DataFrame.plot.scatter(x, y[, s, c])          <span class="comment">#散点图Scatter plot</span></span><br><span class="line">DataFrame.boxplot([column, by, ax, …])        <span class="comment">#Make a box plot from DataFrame column optionally grouped by some columns or</span></span><br><span class="line">DataFrame.hist(data[, column, by, grid, …])   <span class="comment">#Draw histogram of the DataFrame’s series using matplotlib / pylab.1234567891011121314</span></span><br></pre></td></tr></table></figure>
<h5 id="转换为其他格式">转换为其他格式</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.from_csv(path[, header, sep, …])    <span class="comment">#Read CSV file (DEPRECATED, please use pandas.read_csv() instead).</span></span><br><span class="line">DataFrame.from_dict(data[, orient, dtype])    <span class="comment">#Construct DataFrame from dict of array-like or dicts</span></span><br><span class="line">DataFrame.from_items(items[,columns,orient])  <span class="comment">#Convert (key, value) pairs to DataFrame.</span></span><br><span class="line">DataFrame.from_records(data[, index, …])      <span class="comment">#Convert structured or record ndarray to DataFrame</span></span><br><span class="line">DataFrame.info([verbose, buf, max_cols, …])   <span class="comment">#Concise summary of a DataFrame.</span></span><br><span class="line">DataFrame.to_pickle(path[, compression, …])   <span class="comment">#Pickle (serialize) object to input file path.</span></span><br><span class="line">DataFrame.to_csv([path_or_buf, sep, na_rep])  <span class="comment">#Write DataFrame to a comma-separated values (csv) file</span></span><br><span class="line">DataFrame.to_hdf(path_or_buf, key, **kwargs)  <span class="comment">#Write the contained data to an HDF5 file using HDFStore.</span></span><br><span class="line">DataFrame.to_sql(name, con[, flavor, …])      <span class="comment">#Write records stored in a DataFrame to a SQL database.</span></span><br><span class="line">DataFrame.to_dict([orient, into])             <span class="comment">#Convert DataFrame to dictionary.</span></span><br><span class="line">DataFrame.to_excel(excel_writer[, …])         <span class="comment">#Write DataFrame to an excel sheet</span></span><br><span class="line">DataFrame.to_json([path_or_buf, orient, …])   <span class="comment">#Convert the object to a JSON string.</span></span><br><span class="line">DataFrame.to_html([buf, columns, col_space])  <span class="comment">#Render a DataFrame as an HTML table.</span></span><br><span class="line">DataFrame.to_feather(fname)                   <span class="comment">#write out the binary feather-format for DataFrames</span></span><br><span class="line">DataFrame.to_latex([buf, columns, …])         <span class="comment">#Render an object to a tabular environment table.</span></span><br><span class="line">DataFrame.to_stata(fname[, convert_dates, …]) <span class="comment">#A class for writing Stata binary dta files from array-like objects</span></span><br><span class="line">DataFrame.to_msgpack([path_or_buf, encoding]) <span class="comment">#msgpack (serialize) object to input file path</span></span><br><span class="line">DataFrame.to_sparse([fill_value, kind])       <span class="comment">#Convert to SparseDataFrame</span></span><br><span class="line">DataFrame.to_dense()                          <span class="comment">#Return dense representation of NDFrame (as opposed to sparse)</span></span><br><span class="line">DataFrame.to_string([buf, columns, …])        <span class="comment">#Render a DataFrame to a console-friendly tabular output.</span></span><br><span class="line">DataFrame.to_clipboard([excel, sep])          <span class="comment">#Attempt to write text representation of object to the system cli</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python数据挖掘</category>
      </categories>
      <tags>
        <tag>pandas函数</tag>
      </tags>
  </entry>
  <entry>
    <title>python的值传递和引用传递</title>
    <url>/2023/02/06/python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="函数的传参">函数的传参</h2>
<p>函数参数传递机制问题在本质上是调用函数（过程）和被调用函数（过程）在调用发生时进行通信的方法问题。基本的参数传递机制有两种：<code>值传递</code>和<code>引用传递</code>。</p>
<ul>
<li><code>值传递（pass-by-value）</code>过程中，被调函数的形式参数作为被调函数的局部变量处理，即在堆栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。</li>
<li><code>引用传递(pass-by-reference)</code>过程中，被调函数的形式参数虽然也作为局部变量在堆栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过堆栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="keyword">import</span> os.path</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 传入不可变类型</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">x</span>):</span><br><span class="line"></span><br><span class="line">  ...:   <span class="built_in">print</span>(<span class="string">&quot;test before&quot;</span>)</span><br><span class="line"></span><br><span class="line">  ...:   <span class="built_in">print</span>(<span class="built_in">id</span>(c))</span><br><span class="line"></span><br><span class="line">  ...:   c+=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">  ...:   <span class="built_in">print</span>(<span class="string">&quot;test add&quot;</span>)</span><br><span class="line"></span><br><span class="line">  ...:   <span class="built_in">print</span>(<span class="built_in">id</span>(c))</span><br><span class="line"></span><br><span class="line">  ...:   <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: <span class="built_in">id</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">11496672</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: n = test(a)</span><br><span class="line"></span><br><span class="line">test before</span><br><span class="line"></span><br><span class="line"><span class="number">11496672</span></span><br><span class="line"></span><br><span class="line">test add</span><br><span class="line"></span><br><span class="line"><span class="number">11496736</span></span><br><span class="line"></span><br><span class="line">\<span class="comment"># 传入可变类型</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: <span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">x</span>):</span><br><span class="line"></span><br><span class="line">   ...:   <span class="built_in">print</span>(<span class="string">&quot;test before&quot;</span>)</span><br><span class="line"></span><br><span class="line">   ...:   <span class="built_in">print</span>(<span class="built_in">id</span>(x))</span><br><span class="line"></span><br><span class="line">   ...:   x[<span class="number">0</span>] = <span class="number">45</span></span><br><span class="line"></span><br><span class="line">   ...:   <span class="built_in">print</span>(<span class="string">&quot;test after&quot;</span>)</span><br><span class="line"></span><br><span class="line">   ...:   <span class="built_in">print</span>(<span class="built_in">id</span>(x))</span><br><span class="line"></span><br><span class="line">   ...:   <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: e = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: <span class="built_in">id</span>(e)</span><br><span class="line"></span><br><span class="line">Out[<span class="number">19</span>]: <span class="number">140323019352896</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: g = test2(e)</span><br><span class="line"></span><br><span class="line">test before</span><br><span class="line"></span><br><span class="line"><span class="number">140323019352896</span></span><br><span class="line"></span><br><span class="line">test after</span><br><span class="line"></span><br><span class="line"><span class="number">140323019352896</span></span><br></pre></td></tr></table></figure>
<p>结论：<strong>python不允许程序员选择采用传值还是传引用</strong>。Python参数传递采用的肯定是<code>“传对象引用”</code>的方式。<strong>这种方式相当于传值和传引用的一种综合</strong>。</p>
<ul>
<li>如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。</li>
<li>如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象－－相当于通过“传值’来传递对象。</li>
</ul>
<span id="more"></span>
<h1>函数的返回值</h1>
<p><strong>与函数传参一样，返回的也是“对象引用”，如果返回的对象是可变对象，则将函数的返回值赋值给新变量之后，对新变量的修改会直接影响到源对象。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 传入可变类型</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: dic = &#123;<span class="string">&quot;luenci&quot;</span>:<span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: <span class="keyword">def</span> <span class="title function_">return_test</span>(<span class="params">x</span>):</span><br><span class="line"></span><br><span class="line">  ...:   <span class="built_in">print</span>(<span class="built_in">id</span>(x))</span><br><span class="line"></span><br><span class="line">  ...:   <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">  ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: new = return_test(dic)</span><br><span class="line"></span><br><span class="line"><span class="number">140153653660544</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: <span class="built_in">id</span>(new)</span><br><span class="line"></span><br><span class="line">Out[<span class="number">11</span>]: <span class="number">140153653660544</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: <span class="built_in">id</span>(dic)</span><br><span class="line"></span><br><span class="line">Out[<span class="number">12</span>]: <span class="number">140153653660544</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: new[<span class="string">&quot;luenci&quot;</span>]=<span class="string">&#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: dic</span><br><span class="line"></span><br><span class="line">Out[<span class="number">14</span>]: &#123;<span class="string">&#x27;luenci&#x27;</span>: <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">\<span class="comment"># 传入不可变类型</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: a = <span class="string">&#x27;luenci&#x27;</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: <span class="keyword">def</span> <span class="title function_">return_test2</span>(<span class="params">x</span>):</span><br><span class="line"></span><br><span class="line">   ...:   <span class="built_in">print</span>(<span class="built_in">id</span>(x))</span><br><span class="line"></span><br><span class="line">   ...:   <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: b = return_test2(a)</span><br><span class="line"></span><br><span class="line"><span class="number">140153665839728</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: <span class="built_in">id</span>(a)</span><br><span class="line"></span><br><span class="line">Out[<span class="number">20</span>]: <span class="number">140153665839728</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: <span class="built_in">id</span>(b)</span><br><span class="line"></span><br><span class="line">Out[<span class="number">21</span>]: <span class="number">140153665839728</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python进阶</category>
      </categories>
      <tags>
        <tag>对象引用传递</tag>
      </tags>
  </entry>
  <entry>
    <title>python函数补充</title>
    <url>/2023/02/06/python%E5%87%BD%E6%95%B0%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h1>递归函数</h1>
<ul>
<li>
<p>递归特性</p>
<ul>
<li>1.必须有一个明确的结束条件</li>
<li>2.每次进入更深一层递归时，问题规模相比上次递归都应有所减少</li>
<li>3.递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出）</li>
</ul>
</li>
<li>
<p>代码演练</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">student</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(student) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;All student revice messges&#x27;</span></span><br><span class="line">    one = student.pop()</span><br><span class="line">    <span class="keyword">if</span> one == <span class="string">&#x27;luenci&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;luenci get&#x27;</span>)</span><br><span class="line">        send(student)</span><br><span class="line">    <span class="keyword">elif</span> one == <span class="string">&#x27;jack&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;jack get&#x27;</span>)</span><br><span class="line">        send(student)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;xiaoming get&#x27;</span>)</span><br><span class="line">        send(student)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    student_list = [<span class="string">&#x27;luenci&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;xiaoming&#x27;</span>]</span><br><span class="line">    send(student_list)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>函数作用域</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    name = <span class="string">&#x27;luenci&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">        name = <span class="string">&#x27;xiaoming&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">tt</span>():</span><br><span class="line">            <span class="built_in">print</span>(name)</span><br><span class="line">        <span class="keyword">return</span> tt</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo)</span><br><span class="line"><span class="built_in">print</span>(foo())</span><br><span class="line"><span class="built_in">print</span>(foo()())</span><br><span class="line"><span class="comment"># bar=foo()</span></span><br><span class="line"><span class="comment"># tt=bar()</span></span><br><span class="line"><span class="comment"># print(tt)</span></span><br><span class="line"><span class="comment"># tt()</span></span><br><span class="line">foo()()()</span><br><span class="line"></span><br><span class="line">out&gt;&gt;</span><br><span class="line"></span><br><span class="line">&lt;function foo at <span class="number">0x0000020655A92E18</span>&gt;</span><br><span class="line">&lt;function foo.&lt;<span class="built_in">locals</span>&gt;.bar at <span class="number">0x00000206577809D8</span>&gt;</span><br><span class="line">&lt;function foo.&lt;<span class="built_in">locals</span>&gt;.bar.&lt;<span class="built_in">locals</span>&gt;.tt at <span class="number">0x0000020657780A60</span>&gt;</span><br><span class="line">xiaoming</span><br></pre></td></tr></table></figure>
<h1>函数式编程</h1>
<h2 id="匿名函数">匿名函数</h2>
<ul>
<li>函数声明：<code>lambda 参数:表达式返回值</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">fun = <span class="keyword">lambda</span> x:x+<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(fun(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="初始版">初始版</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">return</span> num+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">subtraction</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">return</span> num-<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">return</span> num**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">opertion</span>(<span class="params">func,args</span>):</span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">        res = func(i)</span><br><span class="line">        ret.append(res)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h3 id="进阶版">进阶版</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">opertion</span>(<span class="params">func,args</span>):</span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">        res = func(i)</span><br><span class="line">        ret.append(res)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(opertion(<span class="keyword">lambda</span> x: x + <span class="number">1</span>, num_l))</span><br></pre></td></tr></table></figure>
<h3 id="map函数版">map函数版</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="keyword">lambda</span> x: x + <span class="number">1</span>, num_l)</span><br></pre></td></tr></table></figure>
<h3 id="filter函数">filter函数</h3>
<ul>
<li>
<p>用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列</p>
</li>
<li>
<p>该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p>
</li>
<li>
<pre><code class="language-python">filter(function, iterable)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 参数</span><br><span class="line"></span><br><span class="line">- function -- 判断函数。</span><br><span class="line">- iterable -- 可迭代对象。</span><br><span class="line"></span><br><span class="line">### reduce()函数</span><br><span class="line"></span><br><span class="line">- ```python</span><br><span class="line">  reduce(function, iterable[, initializer])</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>对参数序列中元素进行累积</p>
</li>
</ul>
<h4 id="参数">参数</h4>
<ul>
<li>function – 函数，两个参数</li>
<li>iterable – 可迭代对象</li>
<li>initializer – 可选，初始参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">num_l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(reduce(<span class="keyword">lambda</span> x, y: x + y, num_l))</span><br></pre></td></tr></table></figure>
<h1>一些内置函数</h1>
<ul>
<li>
<p>abs（）</p>
<ul>
<li>返回绝对值</li>
</ul>
</li>
<li>
<p>eval（）</p>
<ul>
<li>
<p>解除引号的束缚</p>
</li>
<li>
<pre><code class="language-python">&gt;&gt;&gt; info = '&#123;&quot;name&quot;: &quot;LiHua&quot;, &quot;age&quot;: 12&#125;'
&gt;&gt;&gt; eval(info)
&#123;'name': 'LiHua', 'age': 12&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- dir （）</span><br><span class="line"></span><br><span class="line">  - 函数返回属性列表</span><br><span class="line"></span><br><span class="line">- id （）</span><br><span class="line"></span><br><span class="line">  - 函数返回对象地址</span><br><span class="line"></span><br><span class="line">- isinstance（） </span><br><span class="line"></span><br><span class="line">  - 判断对象的类型</span><br><span class="line"></span><br><span class="line">- type （） </span><br><span class="line"></span><br><span class="line">  - 返回对象的类型</span><br><span class="line"></span><br><span class="line">- enumerate 函数</span><br><span class="line"></span><br><span class="line">  - 返回元素的序号与对应值</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">In [3]: for i,elm in enumerate(seq):</span><br><span class="line">   ...:     print(i,elm)</span><br><span class="line">   ...:</span><br><span class="line">    0 P</span><br><span class="line">    1 y</span><br><span class="line">    2 t</span><br><span class="line">    3 h</span><br><span class="line">    4 o</span><br><span class="line">    5 n</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>python进阶</category>
      </categories>
      <tags>
        <tag>函数补充</tag>
      </tags>
  </entry>
  <entry>
    <title>一些核心模块的介绍</title>
    <url>/2023/02/06/python%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="sys模块">sys模块</h2>
<table>
<thead>
<tr>
<th>模块方法</th>
<th>解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sys.argv</td>
<td>传递到Python脚本的命令行参数列表，第一个元素是程序本身路径</td>
</tr>
<tr>
<td>sys.executable</td>
<td>返回Python解释器在当前系统中的绝对路径</td>
</tr>
<tr>
<td>sys.exit(arg)</td>
<td>程序中间的退出，arg=0为正常退出</td>
</tr>
<tr>
<td>sys.path</td>
<td>返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</td>
</tr>
<tr>
<td>sys.platform</td>
<td>返回操作系统平台名称，Linux是linux2，Windows是win32</td>
</tr>
<tr>
<td>sys.stdout.write(str)</td>
<td>输出的时候把换行符\n去掉</td>
</tr>
<tr>
<td>val = sys.stdin.readline()[:-1]</td>
<td>拿到的值去掉\n换行符</td>
</tr>
<tr>
<td>sys.version</td>
<td>获取Python解释程序的版本信息</td>
</tr>
</tbody>
</table>
<h2 id="os模块">os模块</h2>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">os.mkdir()</td>
<td style="text-align:center">创建目录</td>
</tr>
<tr>
<td style="text-align:center">os.rmdir()</td>
<td style="text-align:center">删除目录</td>
</tr>
<tr>
<td style="text-align:center">os.rename()</td>
<td style="text-align:center">重命名</td>
</tr>
<tr>
<td style="text-align:center">os.remove()</td>
<td style="text-align:center">删除文件</td>
</tr>
<tr>
<td style="text-align:center">os.getcwd()</td>
<td style="text-align:center">获取当前工作路径</td>
</tr>
<tr>
<td style="text-align:center">os.walk()</td>
<td style="text-align:center">遍历目录</td>
</tr>
<tr>
<td style="text-align:center">os.path.join()</td>
<td style="text-align:center">连接目录与文件名</td>
</tr>
<tr>
<td style="text-align:center">os.path.split()</td>
<td style="text-align:center">分割文件名与目录</td>
</tr>
<tr>
<td style="text-align:center">os.path.abspath()</td>
<td style="text-align:center">获取绝对路径</td>
</tr>
<tr>
<td style="text-align:center">os.path.dirname()</td>
<td style="text-align:center">获取路径</td>
</tr>
<tr>
<td style="text-align:center">os.path.basename()</td>
<td style="text-align:center">获取文件名或文件夹名</td>
</tr>
<tr>
<td style="text-align:center">os.path.splitext()</td>
<td style="text-align:center">分离文件名与扩展名</td>
</tr>
<tr>
<td style="text-align:center">os.path.isfile()</td>
<td style="text-align:center">判断给出的路径是否是一个文件</td>
</tr>
<tr>
<td style="text-align:center">os.path.isdir()</td>
<td style="text-align:center">判断给出的路径是否是一个目录</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h2 id="json模块">json模块</h2>
<ul>
<li>
<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。</p>
</li>
<li>
<p>数据格式可以简单地理解为<strong>键值对</strong>的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。</p>
</li>
<li>
<p>值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure>
<ul>
<li>Pyhton的json模块提供了把<strong>内存中的对象序列化的方法</strong>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列化数据</span></span><br><span class="line"><span class="comment"># f = open(&#x27;JsonDemo.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;)</span></span><br><span class="line"><span class="comment"># dic = &#123;&#x27;name&#x27;: &#x27;luenci&#x27;&#125;</span></span><br><span class="line"><span class="comment"># tmp = json.dumps(dic)</span></span><br><span class="line"><span class="comment"># f.write(tmp)</span></span><br><span class="line"><span class="comment"># f.close()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 反序列化数据</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;JsonDemo.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">res = json.loads(f.read())</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(res))</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;luenci&#x27;&#125;</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;dict&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="json-dumps"><code>json.dumps</code></h3>
<p><code>dump</code>的功能就是把<code>Python</code>对象<code>encode</code>为json对象，一个编码过程。注意<code>json</code>模块提供了<code>json.dumps</code>和<code>json.dump</code>方法，区别是<code>dump</code>直接到文件，而<code>dumps</code>到一个字符串，这里的<code>s</code>可以理解为<code>string</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [ &#123; <span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;b&#x27;</span>:(<span class="number">2</span>, <span class="number">4</span>), <span class="string">&#x27;c&#x27;</span>:<span class="number">3.0</span> &#125; ]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;DATA:&#x27;</span>, <span class="built_in">repr</span>(data)</span><br><span class="line"></span><br><span class="line">data_string = json.dumps(data)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;JSON:&#x27;</span>, data_string</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DATA<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span>&#x27;a&#x27;<span class="punctuation">:</span> &#x27;A&#x27;<span class="punctuation">,</span> &#x27;c&#x27;<span class="punctuation">:</span> <span class="number">3.0</span><span class="punctuation">,</span> &#x27;b&#x27;<span class="punctuation">:</span> (<span class="number">2</span><span class="punctuation">,</span> <span class="number">4</span>)<span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">JSON<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;a&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;c&quot;</span><span class="punctuation">:</span> <span class="number">3.0</span><span class="punctuation">,</span> <span class="attr">&quot;b&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>查看其类型，发现是<code>string</code>对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(data)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(data_string)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="json-dump"><code>json.dump</code></h3>
<p>不仅可以把<code>Python</code>对象编码为<code>string</code>，还可以写入文件。因为我们不能把<code>Python</code>对象直接写入文件，这样会报错<code>TypeError: expected a string or other character buffer object</code>，我们需要将其序列化之后才可以。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [ &#123; <span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;b&#x27;</span>:(<span class="number">2</span>, <span class="number">4</span>), <span class="string">&#x27;c&#x27;</span>:<span class="number">3.0</span> &#125; ]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;output.json&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    json.dump(data,fp)</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;a&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;c&quot;</span><span class="punctuation">:</span> <span class="number">3.0</span><span class="punctuation">,</span> <span class="attr">&quot;b&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<h3 id="json-loads"><code>json.loads</code></h3>
<p>从<code>Python</code>内置对象<code>dump</code>为<code>json</code>对象我们知道如何操作了，那如何从<code>json</code>对象<code>decode</code>解码为<code>Python</code>可以识别的对象呢？是的用<code>json.loads</code>方法，当然这个是基于<code>string</code>的，如果是文件，我们可以用<code>json.load</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">decoded_json = json.loads(data_string)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 和之前一样，还是list</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(decoded_json)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 像访问 data = [ &#123; &#x27;a&#x27;:&#x27;A&#x27;, &#x27;b&#x27;:(2, 4), &#x27;c&#x27;:3.0 &#125; ]一样</span></span><br><span class="line"><span class="built_in">print</span> decoded_json[<span class="number">0</span>][<span class="string">&#x27;a&#x27;</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure>
<h3 id="json-load"><code>json.load</code></h3>
<p>可以直接<code>load</code>文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;output.json&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">type</span>(fp)</span><br><span class="line">    loaded_json = json.load(fp)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;file&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 和之前一样，还是list</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(decoded_json)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 像访问 data = [ &#123; &#x27;a&#x27;:&#x27;A&#x27;, &#x27;b&#x27;:(2, 4), &#x27;c&#x27;:3.0 &#125; ]一样</span></span><br><span class="line"><span class="built_in">print</span> decoded_json[<span class="number">0</span>][<span class="string">&#x27;a&#x27;</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure>
<h3 id="数据类型对应">数据类型对应</h3>
<p><code>json</code>和<code>Python</code>对象转换过程中，数据类型不完全一致，有对应。</p>
<table>
<thead>
<tr>
<th>Python</th>
<th>Json</th>
</tr>
</thead>
<tbody>
<tr>
<td>dict</td>
<td>object</td>
</tr>
<tr>
<td>list,tuple</td>
<td>array</td>
</tr>
<tr>
<td>str, unicode</td>
<td>string</td>
</tr>
<tr>
<td>int,long,float</td>
<td>number</td>
</tr>
<tr>
<td>True</td>
<td>true</td>
</tr>
<tr>
<td>False</td>
<td>false</td>
</tr>
<tr>
<td>None</td>
<td>null</td>
</tr>
</tbody>
</table>
<h3 id="json-dumps常用参数"><code>json.dumps</code>常用参数</h3>
<p>一些参数，可以让我们更好地控制输出。常见的比如<code>sort_keys</code>，<code>indent</code>，<code>separators</code>，<code>skipkeys</code>等。</p>
<p><code>sort_keys</code>名字就很清楚了，输出时字典的是按键值排序的，而不是随机的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [ &#123; <span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;b&#x27;</span>:(<span class="number">2</span>, <span class="number">4</span>), <span class="string">&#x27;c&#x27;</span>:<span class="number">3.0</span> &#125; ]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;DATA:&#x27;</span>, <span class="built_in">repr</span>(data)</span><br><span class="line"></span><br><span class="line">unsorted = json.dumps(data)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;JSON:&#x27;</span>, json.dumps(data)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;SORT:&#x27;</span>, json.dumps(data, sort_keys=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="attr">DATA</span>: [&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3.0</span>, <span class="string">&#x27;b&#x27;</span>: (<span class="number">2</span>, <span class="number">4</span>)&#125;]</span><br><span class="line"><span class="title class_">JSON</span>: [&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3.0</span>, <span class="string">&quot;b&quot;</span>: [<span class="number">2</span>, <span class="number">4</span>]&#125;]</span><br><span class="line"><span class="attr">SORT</span>: [&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;b&quot;</span>: [<span class="number">2</span>, <span class="number">4</span>], <span class="string">&quot;c&quot;</span>: <span class="number">3.0</span>&#125;]</span><br></pre></td></tr></table></figure>
<p><code>indent</code>就是更个缩进，让我们更好地看清结构。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [ &#123; <span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;b&#x27;</span>:(<span class="number">2</span>, <span class="number">4</span>), <span class="string">&#x27;c&#x27;</span>:<span class="number">3.0</span> &#125; ]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;DATA:&#x27;</span>, <span class="built_in">repr</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;NORMAL:&#x27;</span>, json.dumps(data, sort_keys=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;INDENT:&#x27;</span>, json.dumps(data, sort_keys=<span class="literal">True</span>, indent=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DATA: [&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: 3.0, <span class="string">&#x27;b&#x27;</span>: (2, 4)&#125;]</span><br><span class="line">NORMAL: [&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;b&quot;</span>: [2, 4], <span class="string">&quot;c&quot;</span>: 3.0&#125;]</span><br><span class="line">INDENT: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;a&quot;</span>: <span class="string">&quot;A&quot;</span>, </span><br><span class="line">    <span class="string">&quot;b&quot;</span>: [</span><br><span class="line">      2, </span><br><span class="line">      4</span><br><span class="line">    ], </span><br><span class="line">    <span class="string">&quot;c&quot;</span>: 3.0</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><code>separators</code>是提供分隔符，可以出去白空格，输出更紧凑，数据更小。默认的分隔符是<code>(', ', ': ')</code>，有白空格的。不同的<code>dumps</code>参数，对应文件大小一目了然。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [ &#123; <span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;b&#x27;</span>:(<span class="number">2</span>, <span class="number">4</span>), <span class="string">&#x27;c&#x27;</span>:<span class="number">3.0</span> &#125; ]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;DATA:&#x27;</span>, <span class="built_in">repr</span>(data)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;repr(data)             :&#x27;</span>, <span class="built_in">len</span>(<span class="built_in">repr</span>(data))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;dumps(data)            :&#x27;</span>, <span class="built_in">len</span>(json.dumps(data))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;dumps(data, indent=2)  :&#x27;</span>, <span class="built_in">len</span>(json.dumps(data, indent=<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;dumps(data, separators):&#x27;</span>, <span class="built_in">len</span>(json.dumps(data, separators=(<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;:&#x27;</span>)))</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">DATA: [&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3.0</span>, <span class="string">&#x27;b&#x27;</span>: (<span class="number">2</span>, <span class="number">4</span>)&#125;]</span><br><span class="line">repr(<span class="keyword">data</span>)             : <span class="number">35</span></span><br><span class="line">dumps(<span class="keyword">data</span>)            : <span class="number">35</span></span><br><span class="line">dumps(<span class="keyword">data</span>, indent=<span class="number">2</span>)  : <span class="number">76</span></span><br><span class="line">dumps(<span class="keyword">data</span>, separators): <span class="number">29</span></span><br></pre></td></tr></table></figure>
<p><code>json</code>需要字典的的键是字符串，否则会抛出<code>ValueError</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [ &#123; <span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;b&#x27;</span>:(<span class="number">2</span>, <span class="number">4</span>), <span class="string">&#x27;c&#x27;</span>:<span class="number">3.0</span>, (<span class="string">&#x27;d&#x27;</span>,):<span class="string">&#x27;D tuple&#x27;</span> &#125; ]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;First attempt&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span> json.dumps(data)</span><br><span class="line"><span class="keyword">except</span> (TypeError, ValueError) <span class="keyword">as</span> err:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;ERROR:&#x27;</span>, err</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Second attempt&#x27;</span></span><br><span class="line"><span class="built_in">print</span> json.dumps(data, skipkeys=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">First attempt</span><br><span class="line">ERROR: keys must be a <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">Second attempt</span><br><span class="line">[&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3.0</span>, <span class="string">&quot;b&quot;</span>: [<span class="number">2</span>, <span class="number">4</span>]&#125;]</span><br></pre></td></tr></table></figure>
<p>转载自：<em>作者：米乐乐果</em><br>
<em>链接：<a href="https://www.jianshu.com/p/e29611244810">https://www.jianshu.com/p/e29611244810</a></em></p>
<h2 id="pickle-模块">pickle 模块</h2>
<ul>
<li>对于类和函数对象，json不能进行序列化，可以使用 pickle 模块来进行相应的操作</li>
<li>pickle 模块只能用于Python中，不同版本的Python可能彼此都不兼容，因此，只能用Pickle保存那些不重要的数据</li>
</ul>
<p>pickle 写入方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">data = pickle.dumps(foo)</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test1&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">f.write(data)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<ul>
<li>pickle 的读取方式与 json 模块一致，同为 dump ，dumps 函数</li>
</ul>
<h2 id="shelve-模块">shelve 模块</h2>
<ul>
<li>shelve 模块是一个简单的数据存储方案，类似key-value数据库，可以很方便的保存python对象，其内部是通过pickle协议来实现数据序列化。</li>
<li>shelve 使用方式：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> shelve.<span class="built_in">open</span>(<span class="string">&quot;shelve_test&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f[<span class="string">&quot;name&quot;</span>] = <span class="string">&#x27;alex&#x27;</span></span><br><span class="line">    f[<span class="string">&quot;age&quot;</span>] = <span class="string">&#x27;25&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 这里直接保存到了文件中，生成了3个文件shelve_test.bak,shelve_test.dat,shelve_test.dir</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> shelve.<span class="built_in">open</span>(<span class="string">&#x27;shelve_test&#x27;</span>) <span class="keyword">as</span> f:  <span class="comment"># 只使用shelvefile名字即可</span></span><br><span class="line">    <span class="built_in">print</span>(f[<span class="string">&quot;name&quot;</span>])</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> f.items():</span><br><span class="line">        <span class="built_in">print</span>(key, <span class="string">&#x27;: &#x27;</span>, value)</span><br><span class="line"> &gt;&gt;&gt; alex</span><br><span class="line">     age :  <span class="number">25</span></span><br><span class="line">     name :  alex</span><br></pre></td></tr></table></figure>
<h2 id="logging模块">logging模块</h2>
<ul>
<li>
<p><strong>logging模块是Python内置的标准模块，主要用于输出运行日志，可以设置输出日志的等级、日志保存路径、日志文件回滚等；相比print，具备如下优点：</strong></p>
<ul>
<li>可以通过设置不同的日志等级，在release版本中只输出重要信息，而不必显示大量的调试信息；</li>
<li>print将所有信息都输出到标准输出中，严重影响开发者从标准输出中查看其它数据；logging则可以由开发者决定将信息输出到什么地方，以及怎么输出</li>
</ul>
</li>
<li>
<p><code>basicConfig </code>配置了 level 信息和 format 信息</p>
<ul>
<li>
<p><code>level </code>配置为 INFO 信息，即只输出 INFO 级别的信息</p>
</li>
<li>
<p><code>filename</code>：即日志输出的文件名，如果指定了这个信息之后，实际上会启用 FileHandler，而不再是 StreamHandler，这样日志信息便会输出到文件中了。</p>
</li>
<li>
<p><code>filemode</code>：这个是指定日志文件的写入方式，有两种形式，一种是 w，一种是 a，分别代表清除后写入和追加写入。</p>
</li>
<li>
<p><code>format=</code>：指定了 format 格式的字符串，包括 asctime运行时间 name模块名称、levelname（日志级别）message （日志内容）</p>
</li>
<li>
<pre><code class="language-python">%(levelno)s：打印日志级别的数值。
%(levelname)s：打印日志级别的名称。
%(pathname)s：打印当前执行程序的路径，其实就是sys.argv[0]。
%(filename)s：打印当前执行程序名。
%(funcName)s：打印日志的当前函数。
%(lineno)d：打印日志的当前行号。
%(asctime)s：打印日志的时间。
%(thread)d：打印线程ID。
%(threadName)s：打印线程名称。
%(process)d：打印进程ID。
%(processName)s：打印线程名称。
%(module)s：打印模块名称。
%(message)s：打印日志信息。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - `datefmt`：指定时间的输出格式。</span><br><span class="line"></span><br><span class="line">  - `logging.setLevel` :设定日志级别，只有大于或等于这个级别才输出</span><br><span class="line"></span><br><span class="line">    - `DEBUG` 级别0</span><br><span class="line">  - `INFO`级别1</span><br><span class="line">    </span><br><span class="line">    - `WARNING`级别2</span><br><span class="line">  - `ERROR`级别3</span><br><span class="line">    </span><br><span class="line">  - `CRITICAL`级别4</span><br><span class="line">    </span><br><span class="line">  - `style`：如果 format 参数指定了，这个参数就可以指定格式化时的占位符风格，如 %、&#123;、$ 等。</span><br><span class="line">  </span><br><span class="line">  - `level`：指定日志输出的类别，程序会输出大于等于此级别的信息。</span><br><span class="line">  </span><br><span class="line">  - `stream`：在没有指定 `filename` 的时候会默认使用` StreamHandler`，这时 `stream` 可以指定初始化的文件流。指定将日志的输出流，可以指定输出到`sys.stderr`，`sys.stdout`或者文件，默认输出到`sys.stderr`，当`stream`和`filename`同时指定时，`stream`被忽略；</span><br><span class="line">  </span><br><span class="line">  - `handlers`：可以指定日志处理时所使用的 Handlers，必须是可迭代的。</span><br><span class="line"></span><br><span class="line">## `configparse`模块</span><br><span class="line"></span><br><span class="line">- 读取和写入类似字典操作</span><br><span class="line">- `read(filename)`      直接读取文件内容</span><br><span class="line">- `get(section, option)` 获取`section` 下具体某一配置项的值(返回的是字符串)</span><br><span class="line">- `sections()` 得到所有的section，并以列表的形式返回</span><br><span class="line">- `options(section)`    得到该section的所有option</span><br><span class="line">- `items(section)` 键值对的形式 得到该section的所有option</span><br><span class="line"></span><br><span class="line">- 写入配置</span><br><span class="line"></span><br><span class="line"> ```python</span><br><span class="line">import configparser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config[&#x27;DEFAULT&#x27;] = &#123;&#x27;serveraliveinterval&#x27; : &#x27;4&#x27;,</span><br><span class="line">                     &#x27;compression&#x27; : &#x27;yes&#x27;,</span><br><span class="line">                     &#x27;compressionlevel&#x27; : &#x27;9&#x27;&#125;</span><br><span class="line"></span><br><span class="line">config[&#x27;bitbucket&#x27;] = &#123;&#125;</span><br><span class="line">config[&#x27;bitbucket&#x27;][&#x27;user&#x27;] = &#x27;luenci&#x27;</span><br><span class="line"></span><br><span class="line">config[&#x27;topsecrect&#x27;] = &#123;&#125;</span><br><span class="line">topsecrect = config[&#x27;topsecrect&#x27;]</span><br><span class="line"></span><br><span class="line">topsecrect[&#x27;port&#x27;] = &#x27;22&#x27;</span><br><span class="line"></span><br><span class="line">with open(&#x27;example.ini&#x27;, &#x27;w&#x27;) as f:</span><br><span class="line">    config.write(f)</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>读取配置文件</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取配置文件</span></span><br><span class="line">config.read(<span class="string">&#x27;example.ini&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(config.sections())</span><br><span class="line"><span class="built_in">print</span>(config.options(<span class="string">&#x27;bitbucket&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> config[<span class="string">&#x27;DEFAULT&#x27;</span>].values():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s%s&quot;</span>%(key,<span class="built_in">type</span>(key)))</span><br><span class="line"></span><br><span class="line">out：</span><br><span class="line">[<span class="string">&#x27;bitbucket&#x27;</span>, <span class="string">&#x27;topsecrect&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;serveraliveinterval&#x27;</span>, <span class="string">&#x27;compression&#x27;</span>, <span class="string">&#x27;compressionlevel&#x27;</span>]</span><br><span class="line"><span class="number">4</span>&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line">yes&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="number">9</span>&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="操作函数">操作函数</h3>
<ul>
<li><code>add_section(section)</code>   添加一个新的section</li>
<li><code>set(section, option, value)</code> 对section中添加 option 和 value</li>
<li><code>remove_section(section)</code> 删除某个 section</li>
<li><code>remove_option(section, option)</code>  删除某个 section 下的 option</li>
<li><code>write()</code> 将设置的新的 section 和 option 写到文件中</li>
</ul>
<h3 id="configparse支持的数据类型">configparse支持的数据类型</h3>
<ul>
<li>一般情况下，configpaser类是无法识别配置文件中的value的数据类型的，它总是以字符串的形式来存储这些类型，所以当涉及到<code>int</code> <code>float</code>等类型的时候就需要我们自己对它进行转换</li>
<li>configparser 为我们提供了<code>getboolean() getint() getfloat()</code>方法用来对读对应类型的配置
<ul>
<li>其中getboolean方法可以识别 <code>'yes'/'no', 'on'/'off', 'true'/'false' and '1'/'0'</code>等数据并转换为布尔值</li>
</ul>
</li>
</ul>
<h2 id="hashlib模块"><code>hashlib</code>模块</h2>
<ul>
<li>用于加密有关的操作，主要有SHA1，SHA224，SHA256，SHA384，SHA512，MD5算法。替代了在python3中已废弃了md5和sha模块。</li>
<li>md5加密</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">p = hashlib.md5()</span><br><span class="line">p.update(<span class="string">&#x27;12345&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(p.hexdigest())</span><br></pre></td></tr></table></figure>
<ul>
<li>sha1加密</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = hashlib.sha1()</span><br><span class="line">p.update(<span class="string">&#x27;12345&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(p.hexdigest())</span><br></pre></td></tr></table></figure>
<ul>
<li>以上加密算法虽然依然非常厉害，但时候存在缺陷，即：通过撞库可以反解。所以，有必要对加密算法中添加自定义key再来做加密。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加盐</span></span><br><span class="line">p = hashlib.md5(<span class="string">&#x27;password&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">p.update(<span class="string">&#x27;12345&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(p.hexdigest())</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>核心模块</tag>
      </tags>
  </entry>
  <entry>
    <title>妹子图爬虫（爬取妹子图图片）</title>
    <url>/2023/02/06/python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1>python实现妹子图爬虫（爬取妹子网图片）</h1>
<ul>
<li>一个简单的小爬虫实现爬取妹子图网站上的图片。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">all_url = <span class="string">&#x27;http://www.mzitu.com&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#http请求头</span></span><br><span class="line">Hostreferer = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>:<span class="string">&#x27;http://www.mzitu.com&#x27;</span></span><br><span class="line">               &#125;</span><br><span class="line">Picreferer = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>:<span class="string">&#x27;http://i.meizitu.net&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#此请求头破解盗链</span></span><br><span class="line"></span><br><span class="line">start_html = requests.get(all_url,headers = Hostreferer)</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存地址</span></span><br><span class="line">path = <span class="string">&quot;D:\\mzitu\\&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#找寻最大页数</span></span><br><span class="line">soup = BeautifulSoup(start_html.text,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">page = soup.find_all(<span class="string">&#x27;a&#x27;</span>,class_=<span class="string">&#x27;page-numbers&#x27;</span>)</span><br><span class="line">max_page = page[-<span class="number">2</span>].text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">same_url = <span class="string">&#x27;http://www.mzitu.com/all/&#x27;</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">int</span>(max_page)+<span class="number">1</span>):</span><br><span class="line">    ul = same_url+<span class="built_in">str</span>(n)</span><br><span class="line">    start_html = requests.get(ul, headers = Hostreferer)</span><br><span class="line">    soup = BeautifulSoup(start_html.text,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    all_a = soup.find(<span class="string">&#x27;div&#x27;</span>,class_=<span class="string">&#x27;all&#x27;</span>).find_all(<span class="string">&#x27;a&#x27;</span>,target=<span class="string">&#x27;_blank&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> all_a:</span><br><span class="line">        title = a.get_text() <span class="comment">#提取文本</span></span><br><span class="line">        <span class="keyword">if</span>(title != <span class="string">&#x27;&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;准备扒取：&quot;</span>+title)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#win不能创建带？的目录</span></span><br><span class="line">            <span class="keyword">if</span>(os.path.exists(path+title.strip().replace(<span class="string">&#x27;?&#x27;</span>,<span class="string">&#x27;&#x27;</span>))):</span><br><span class="line">                    <span class="comment">#print(&#x27;目录已存在&#x27;)</span></span><br><span class="line">                    flag=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                os.makedirs(path+title.strip().replace(<span class="string">&#x27;?&#x27;</span>,<span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">                flag=<span class="number">0</span></span><br><span class="line">            os.chdir(path + title.strip().replace(<span class="string">&#x27;?&#x27;</span>,<span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">            href = a[<span class="string">&#x27;href&#x27;</span>]</span><br><span class="line">            html = requests.get(href,headers = Hostreferer)</span><br><span class="line">            mess = BeautifulSoup(html.text,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">            pic_max = mess.find_all(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                pic_max = pic_max[<span class="number">9</span>].text <span class="comment">#最大页数</span></span><br><span class="line">                <span class="keyword">if</span>(flag == <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">len</span>(os.listdir(path+title.strip().replace(<span class="string">&#x27;?&#x27;</span>,<span class="string">&#x27;&#x27;</span>))) &gt;= <span class="built_in">int</span>(pic_max)):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;已经保存完毕，跳过&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(pic_max)+<span class="number">1</span>):</span><br><span class="line">                    pic = href+<span class="string">&#x27;/&#x27;</span>+<span class="built_in">str</span>(num)</span><br><span class="line">                    html = requests.get(pic,headers = Hostreferer)</span><br><span class="line">                    mess = BeautifulSoup(html.text,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">                    pic_url = mess.find(<span class="string">&#x27;img&#x27;</span>,alt = title)</span><br><span class="line">                    <span class="built_in">print</span>(pic_url[<span class="string">&#x27;src&#x27;</span>])</span><br><span class="line">                    <span class="comment">#exit(0)</span></span><br><span class="line">                    html = requests.get(pic_url[<span class="string">&#x27;src&#x27;</span>],headers = Picreferer)</span><br><span class="line">                    file_name = pic_url[<span class="string">&#x27;src&#x27;</span>].split(<span class="string">r&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">                    f = <span class="built_in">open</span>(file_name,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">                    f.write(html.content)</span><br><span class="line">                    f.close()</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;完成   &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第&#x27;</span>,n,<span class="string">&#x27;页完成&#x27;</span>)</span><br><span class="line"></span><br><span class="line">原文参考：https://blog.csdn.net/baidu_35085676/article/details/<span class="number">68958267</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>爬虫实践</tag>
      </tags>
  </entry>
  <entry>
    <title>Python类中的 私有变量 和 私有方法</title>
    <url>/2023/02/06/python%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1>Python中的类</h1>
<p>原文转自：<a href="https://blog.csdn.net/sxingming/article/details/52875125">https://blog.csdn.net/sxingming/article/details/52875125</a></p>
<ul>
<li>
<p>默认情况下，Python中的成员函数和成员变量都是公开的(public),在python中没有类似public,private等关键词来修饰成员函数和成员变量。</p>
</li>
<li>
<p>在python中定义私有变量只需要在变量名或函数名前加上 <code>__</code>两个下划线，那么这个函数或变量就是私有的了。</p>
</li>
<li>
<p>在内部，python使用一种 name mangling 技术，将 <code>__membername</code>替换成<code> _classname__membername</code>，也就是说，类的内部定义中,所有以双下划线开始的名字都被&quot;翻译&quot;成前面加上单下划线和类名的形式。</p>
</li>
<li>
<p>例如：为了保证不能在class之外访问私有变量，Python会在类的内部自动的把我们定义的<code>__spam</code>私有变量的名字替换成为<br>
<code>_classname__spam</code>(注意，<code>classname</code>前面是一个下划线，<code>spam</code>前是两个下划线)，因此，用户在外部访问<code>__spam</code>的时候就会提示找不到相应的变量。</p>
</li>
<li>
<p>python中的私有变量和私有方法仍然是可以访问的</p>
</li>
</ul>
<p>访问方法如下：<br>
<code>私有变量:实例._类名__变量名</code><br>
<code>私有方法:实例._类名__方法名()</code></p>
<ul>
<li>其实，Python并没有真正的私有化支持，但可用下划线得到伪私有。</li>
</ul>
<blockquote>
<p>尽量避免定义以下划线开头的变量！</p>
</blockquote>
<ul>
<li>（1）<code>_xxx </code>   &quot;单下划线 &quot; 开始的成员变量叫做保护变量，意思是只有类实例和子类实例能访问到这些变量，<br>
需通过类提供的接口进行访问；不能用’from module import *'导入</li>
<li>（2）<code>__xxx </code>  类中的私有变量/方法名 （Python的函数也是对象，所以成员方法称为成员变量也行得通。）,<br>
&quot; 双下划线 &quot; 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。</li>
<li>（3）<code>__xxx__ </code>系统定义名字，前后均有一个“双下划线” 代表python里特殊方法专用的标识，如 <code>__init__（）</code>代表类的构造函数。</li>
</ul>
<span id="more"></span>
<p>下面我们看几个例子：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment">#翻译成 self._A__data=[]</span></span><br><span class="line">        self.__data=[]  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,item</span>):</span><br><span class="line">    <span class="comment">#翻译成 self._A__data.append(item)</span></span><br><span class="line">        self.__data.append(item) </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printData</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment">#翻译成 self._A__data</span></span><br><span class="line">        <span class="built_in">print</span>(self.__data)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">a=A()</span><br><span class="line"></span><br><span class="line">a.add(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a.add(<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a.printData()</span><br><span class="line"></span><br><span class="line"><span class="comment">#外界不能访问私有变量 AttributeError: &#x27;A&#x27; object has no attribute &#x27;__data&#x27;</span></span><br><span class="line"><span class="comment">#print a.__data  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过这种方式，在外面也能够访问“私有”变量；这一点在调试中是比较有用的！</span></span><br><span class="line"><span class="built_in">print</span> a._A__data </span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;python&#x27;</span>]</span><br><span class="line">    [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;python&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取实例的所有属性        print a.__dict__</span></span><br><span class="line"><span class="comment"># 获取实例的所有属性和方法  print dir(a) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment">#私有变量，翻译成 self._A__name=&#x27;python&#x27;</span></span><br><span class="line">        self.__name=<span class="string">&#x27;python&#x27;</span> </span><br><span class="line">        </span><br><span class="line">  <span class="comment">#私有方法,翻译成 def _A__say(self)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__say</span>(<span class="params">self</span>): </span><br><span class="line">    <span class="comment">#翻译成 self._A__name</span></span><br><span class="line">        <span class="built_in">print</span>(self.__name)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">a=A()</span><br><span class="line"><span class="comment">#访问私有属性,报错!AttributeError: A instance has no attribute &#x27;__name&#x27;</span></span><br><span class="line"><span class="comment">#print a.__name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查询出实例a的属性的集合</span></span><br><span class="line"><span class="built_in">print</span>(a.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment">#这样，就可以访问私有变量了</span></span><br><span class="line"><span class="built_in">print</span>(a._A__name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用私有方法，报错。AttributeError: A instance has no attribute &#x27;__say&#x27;</span></span><br><span class="line"><span class="comment">#a.__say()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取实例的所有属性和方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment">#这样，就可以调用私有方法了</span></span><br><span class="line">a._A__say() </span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    &#123;<span class="string">&#x27;_A__name&#x27;</span>: <span class="string">&#x27;python&#x27;</span>&#125;</span><br><span class="line">    python</span><br><span class="line">    [<span class="string">&#x27;_A__name&#x27;</span>, <span class="string">&#x27;_A__say&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>]</span><br><span class="line">    python</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>从上面看来,python还是非常的灵活，它的oop没有做到真正的不能访问，只是一种约定让大家去遵守，<br>
比如大家都用self来代表类里的当前对象，其实，我们也可以用其它的，只是大家习惯了用self  。</p>
</li>
<li>
<p>小漏洞：派生类和基类取相同的名字就可以使用基类的私有变量</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        self.__name=<span class="string">&#x27;python&#x27;</span> <span class="comment">#翻译成self._A__name=&#x27;python&#x27;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment">#翻译成print self._B__name</span></span><br><span class="line">        <span class="built_in">print</span>(self.__name )</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">instance=B()</span><br><span class="line"><span class="comment">#报错：AttributeError: B instance has no attribute &#x27;_B__name&#x27;</span></span><br><span class="line"><span class="comment">#instance.func()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(instance.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(instance._A__name)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    &#123;<span class="string">&#x27;_A__name&#x27;</span>: <span class="string">&#x27;python&#x27;</span>&#125;</span><br><span class="line">  python</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">     <span class="comment">#翻译成self._A__name=&#x27;python&#x27;</span></span><br><span class="line">        self.__name=<span class="string">&#x27;python&#x27;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">A</span>): <span class="comment">#派生类和基类取相同的名字就可以使用基类的私有变量。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment">#翻译成print self._A__name</span></span><br><span class="line">        <span class="built_in">print</span>(self.__name) </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">instance=A()</span><br><span class="line"></span><br><span class="line">instance.func()</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    python </span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>面向对象编程</tag>
      </tags>
  </entry>
  <entry>
    <title>python解释器介绍</title>
    <url>/2023/02/06/python%E8%A7%A3%E9%87%8A%E5%99%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1>CPython</h1>
<ul>
<li>
<p>当我们从<a href="https://www.python.org/">Python官方网站</a>下载并安装好Python 3.x后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行<code>python</code>就是启动CPython解释器。</p>
<span id="more"></span>
</li>
</ul>
<h1>IPython</h1>
<ul>
<li>
<p>IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。</p>
</li>
<li>
<p>CPython用<code>&gt;&gt;&gt;</code>作为提示符，而IPython用<code>In [序号]:</code>作为提示符。</p>
</li>
</ul>
<h1>Jpython</h1>
<ul>
<li>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</li>
</ul>
<h1>PyPy</h1>
<ul>
<li>
<p>PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用<a href="http://en.wikipedia.org/wiki/Just-in-time_compilation">JIT技术</a>（just-in-time compiler 即时编译器，通俗解释就是边编译边执行），对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。</p>
</li>
<li>
<p>绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解<a href="http://pypy.readthedocs.org/en/latest/cpython_differences.html">PyPy和CPython的不同点</a>。、</p>
</li>
</ul>
<h1>IronPython</h1>
<ul>
<li>IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。</li>
</ul>
]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>python编译器</tag>
      </tags>
  </entry>
  <entry>
    <title>模块、迭代器，生成器和装饰器</title>
    <url>/2023/02/06/python%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<h1>module模块和包的介绍</h1>
<h2 id="模块的介绍">模块的介绍</h2>
<ul>
<li><code>python</code>给我们提供了十分简单的方法去创建一个模块，我们只需要写一个<code>python</code>文件即可，也就是说写一个<code>.py</code>为后缀的文件。</li>
</ul>
<h2 id="包的介绍">包的介绍</h2>
<ul>
<li>简单来说，包就是多个模块的集合。当项目较大，模块较多时，我们就可以把模块放在包中，便于管理。</li>
<li>我们在包中一般带有<code>__init__.py</code>文件，随你建包的时候就默认生成。</li>
</ul>
<h1>迭代器和生成器</h1>
<h3 id="迭代器">迭代器</h3>
<ul>
<li>迭代器只不过是一个实现迭代器协议的容器对象。它基于两个方法：
<ul>
<li><code>next</code>  ：返回容器的下一个项目
<ul>
<li>在<code>3.x</code>的版本中为<code>__next__</code>或者<code>next(可迭代对象)</code></li>
</ul>
</li>
<li><code>__iter__</code> : 返回迭代器本身</li>
</ul>
</li>
<li>迭代器可以通过使用一个<code>iter</code>内建函数和一个序列来创建，示例如下。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: a = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">In [<span class="number">22</span>]: a = <span class="built_in">iter</span>(a)</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: <span class="built_in">next</span>(a)</span><br><span class="line">Out[<span class="number">23</span>]: <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: a.__next__()</span><br><span class="line">Out[<span class="number">24</span>]: <span class="string">&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="生成器">生成器</h3>
<ul>
<li>生成器</li>
<li>从<code>Python2.2</code>起，生成器提供了一种出色的方法，使得需要返回一系列元素的函数所需的代码更加简单、高效。基于yield指令，可以暂停一个函数并返回中间结果。该函数将保存执行环境并且可以在必要时恢复。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: <span class="keyword">def</span> <span class="title function_">fibonanci</span>():</span><br><span class="line">    ...:     a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    ...:     <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ...:         <span class="keyword">yield</span> b</span><br><span class="line">    ...:         a, b = b, a + b</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: fib = fibonanci()</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: fib.__next__()</span><br><span class="line">Out[<span class="number">28</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: fib.__next__()</span><br><span class="line">Out[<span class="number">29</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: fib.__next__()</span><br><span class="line">Out[<span class="number">30</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: fib.__next__()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>yield</code>可以理解为<code>return</code>,每次调用<code>next()</code>就<code>yield</code>值,下次<code>next()</code>从上次的yield处开始运行</li>
<li>该函数将返回一个特殊的迭代器，也就是generator对象，它知道如何保存执行环境。对它的调用是不确定的，每次都将产生序列中的下一个元素。这种语法很简洁，算法的不确定特性并没有影响代码的可读性。不必提供使函数可停止的方法。实际上，这看上去像是用伪代码设计的序列一样。</li>
</ul>
<span id="more"></span>
<h1>高阶函数的定义</h1>
<ul>
<li>函数的接收参数是一个函数名</li>
<li>函数的返回值是一个函数名</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">father</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am father %s&quot;</span> %name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">son</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;i am son&quot;</span>)</span><br><span class="line">    <span class="comment"># print(locals())</span></span><br><span class="line">    <span class="keyword">return</span> son</span><br><span class="line"></span><br><span class="line">father(<span class="string">&quot;luenci&quot;</span>)</span><br><span class="line">father(<span class="string">&quot;luenci&quot;</span>)()</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">I am father luenci</span><br><span class="line">I am father luenci</span><br><span class="line">i am son</span><br></pre></td></tr></table></figure>
<h1>简单的装饰器</h1>
<ul>
<li><code>@</code>语法糖:相当于执行下面<code>timmer(test)()</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def timmer(func):</span><br><span class="line">    def wrapper():</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop_time = time.time()</span><br><span class="line">        print(&quot;函数运行时间为: %s&quot;%(stop_time - start_time))</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@timmer</span><br><span class="line"># timmer(test)() @ 语法糖</span><br><span class="line">def test():</span><br><span class="line">    time.sleep(3)</span><br><span class="line">    print(&quot;test函数运行完毕&quot;)</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"># timmer(test)()</span><br></pre></td></tr></table></figure>
<h1>带参数的装饰器</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timmer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(*args)</span><br><span class="line">        <span class="comment"># print(**kwargs)</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        stop_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;程序运行时间为：%s&quot;</span> % (stop_time - start_time))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timmer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">name, age, gender</span>):</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是%s,今年%s,性别%s&quot;</span> % (name, age, gender))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;sucess&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = test(<span class="string">&quot;lusheng&quot;</span>, <span class="number">18</span>, gender=<span class="string">&quot;男&quot;</span>)</span><br><span class="line"><span class="comment"># print(res)</span></span><br></pre></td></tr></table></figure>
<h1>装饰器应用案例</h1>
<h2 id="登录验证">登录验证</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user_list = [</span><br><span class="line">    &#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;luenci&quot;</span>, <span class="string">&quot;pswd&quot;</span>: <span class="string">&quot;123&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;lynn&quot;</span>, <span class="string">&quot;pswd&quot;</span>: <span class="string">&quot;456&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;lu&quot;</span>, <span class="string">&quot;pswd&quot;</span>: <span class="string">&quot;789&quot;</span>&#125;,</span><br><span class="line">]</span><br><span class="line">current_dic = &#123;<span class="string">&quot;username&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;login&quot;</span>: <span class="literal">False</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> current_dic[<span class="string">&#x27;username&#x27;</span>] <span class="keyword">and</span> current_dic[<span class="string">&#x27;login&#x27;</span>]:</span><br><span class="line">            res = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        username = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名:&quot;</span>).strip()</span><br><span class="line">        pswd = <span class="built_in">input</span>(<span class="string">&quot;请输入密码:&quot;</span>).strip()</span><br><span class="line">        <span class="keyword">for</span> user <span class="keyword">in</span> user_list:</span><br><span class="line">            <span class="keyword">if</span> user[<span class="string">&#x27;username&#x27;</span>] == username <span class="keyword">and</span> user[<span class="string">&#x27;pswd&#x27;</span>] == pswd:</span><br><span class="line">                current_dic[<span class="string">&#x27;username&#x27;</span>] = username</span><br><span class="line">                current_dic[<span class="string">&#x27;login&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">                res = func(*args, **kwargs)</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;用户名或密码错误&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@verify</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shop</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我的购物车&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@verify</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我的信息&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@verify</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">things</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我的商品&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;登录前的状态:%s&#x27;</span>%(current_dic))</span><br><span class="line">user()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;登录后的状态:%s&#x27;</span>%(current_dic))</span><br><span class="line">shop()</span><br><span class="line">things()</span><br></pre></td></tr></table></figure>
<h2 id="日志记录">日志记录</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_logger</span>():</span><br><span class="line">    logger = logging.getLogger(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line">    <span class="comment"># 设定日志级别，只有大于或等于这个级别才输出</span></span><br><span class="line">    logger.setLevel(level=logging.DEBUG)</span><br><span class="line">    <span class="comment"># 当前路径下创建test_log文件记录错误日志</span></span><br><span class="line">    fh = logging.FileHandler(<span class="string">&quot;test_log&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    ch = logging.StreamHandler()</span><br><span class="line"></span><br><span class="line">    fm = logging.Formatter(fmt=<span class="string">&#x27;%(asctime)s %(name)s %(pathname)s[%(lineno)d] %(message)s&#x27;</span>, datefmt=<span class="string">&#x27;%Y/%m/%d %H:%M:%S&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    fh.setFormatter(fm)</span><br><span class="line">    ch.setFormatter(fm)</span><br><span class="line"></span><br><span class="line">    logger.addHandler(fh)</span><br><span class="line">    logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logger</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decoratore</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;当前运行方法&quot;</span>, func.__name__)</span><br><span class="line">            <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            get_logger().error(<span class="string">f&quot;<span class="subst">&#123;func.__name__&#125;</span> is error,here are details:<span class="subst">&#123;traceback.format_exc()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> log</span><br><span class="line"></span><br><span class="line"><span class="meta">@decoratore</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<p>​</p>
]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js的基本知识</title>
    <url>/2023/02/06/vue%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1><code>Vue.js</code>概念</h1>
<ul>
<li><code>Vue.js </code>是目前最火的一个前端框架，<code>React</code>是最流行的一个前端框架（React除了开发网站，还可以开发手机<code>App</code>，<code>Vue</code>语法也是可以用于进行手机<code>App</code>开发的，需要借助于<code>Weex</code>）</li>
<li><code>Vue.js</code> 是前端的主流框架之一，和<code>Angularjs</code>、<code>Reactjs</code>一起，并成为前端三大主流框架！·</li>
<li><code>Vue.js</code> 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（<code>Vue</code>有配套的第三方类库，可以整合起来做大型项目的开发）</li>
</ul>
<h1>框架和库的区别</h1>
<ul>
<li>框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。</li>
<li>库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。</li>
</ul>
<h1>后端中的<code>MVC</code>与前端中的<code>MVVM</code>之间的区别</h1>
<ul>
<li><code>MVC</code>是后端的分层开发概念；</li>
<li><code>MVVM</code>是前端视图层的概念，主要关注于视图层分离，也就是说：<code>MVVM</code>把前端的视图层，分为了三部分<code>Model</code>，<code>View</code>，<code>VM</code> ,<code>ViewModel</code></li>
</ul>
<p><img src="https://upload.cc/i1/2019/12/25/XTm4Gf.png" alt="image-20191225111448702"></p>
<span id="more"></span>
<h1><code>vue.js</code>基本架构</h1>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导入Vue的包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将来new的实例，会控制这个元素中的所有内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 创建一个vue的实例</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 当我们导入包之后，在浏览器的内存中，就多了一个vue构造函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>, <span class="comment">//表示，当前我们new的这个vue实例，要控制页面上的哪个区域</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123; <span class="comment">// data属性中存放的是 el 中要用到的内容</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">msg</span>: <span class="string">&#x27;欢迎学习Vue&#x27;</span> <span class="comment">//通过vue提供的指令，很方便的就能把数据渲染到页面上，程序员不再手动操作DOM元素了</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1>基本事件语法</h1>
<ul>
<li><code>&lt;！--1.如何定义一个基本的vue代码结构--&gt;</code></li>
<li><code>&lt;！--2.插值表达式和 v-text--&gt;</code></li>
<li><code>&lt;!--3.v-cloak--&gt;</code></li>
<li><code>&lt;!--4.v-html--&gt;</code></li>
<li><code>&lt;！--5.v-bind vue提供的属性绑定机制缩写是 : --&gt;</code></li>
<li><code>&lt;l--6.v-on vue提供的事件绑定机制缩写是 @ --&gt;</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-attr">[v-cloak]</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- v-cloak能够解决 插值表达式闪烁的问题 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-cloak</span>&gt;</span>++++++ &#123;&#123; msg &#125;&#125; ----------<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 默认v-text没有闪烁问题 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--v-text会覆盖元素中原本的内容，但是插值表达式只会替换自己的这个占位符，不会把整个元素的内容清空--&gt;</span>I</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            &#123;&#123;msg2&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">&quot;msg2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&quot;msg2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- v-bind: 是vue中，提供用于绑定属性的指令 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- v-bind 也可以简写为 :要绑定的属性 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- v-bind 中可以写合法的js表达式 --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Vue中提供了 v-on: 事件绑定机制 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;input type=&quot;button&quot; value=&quot;按钮&quot; :title=&quot;myTitle&quot; v-on:click = &quot;alter(&#x27;Hello&#x27;)&quot;&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;show&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">msg</span>: <span class="string">&#x27;123&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">msg2</span>: <span class="string">&#x27;&lt;h2&gt;Luenci&lt;/h2&gt;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">myTitle</span>: <span class="string">&#x27;自定义标题&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">show</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&#x27;Hello&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1><code>Vue</code>指令之事件修饰符</h1>
<p>事件修饰符</p>
<ul>
<li><code>.stop</code> 阻止冒泡</li>
<li><code>.prevent</code> 阻止默认事件</li>
<li><code>.capture</code> 添加事件侦听器时使用事件捕获模式</li>
<li><code>.self</code>只当事件在该元素本身（比如不是子元素）触发时触发回调</li>
<li><code>.once</code>事件只触发一次</li>
</ul>
<h1><code>Vue</code>指令之<code>v-model</code>和双向数据绑定</h1>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.btn</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>:<span class="number">100%</span>&#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--v-bind只能实现数据的单向绑定，从M自动绑定到V，无法实现数据的双向绑定--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;input type=&quot;text&quot; v-bind:value=&quot;msg&quot; style=&quot;width：100%；&quot;&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用v-mode1指令，可以实现表单元素和 Model 中数据的双向数据绑定--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注意：v-mode1只能运用在表单元素中--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--input（radio，text，address，email....）select checkbox textarea--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">msg</span>:<span class="string">&#x27;hello Vue.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1><code>Vue</code>中使用样式</h1>
<h2 id="使用class样式">使用class样式</h2>
<ul>
<li>
<p>1.数组</p>
<p><code>&lt;h1 :class=&quot;['red','thin']&quot;&gt;这是一个H1&lt;/h1&gt;</code></p>
</li>
<li>
<p>2.数组中使用三元表达<br>
<code>&lt;h1 :class=&quot;['red','thin',is active?'active':'']&quot;&gt;这是一个H1&lt;/h1&gt;</code></p>
</li>
<li>
<p>3.数组中嵌套对象<br>
<code>&lt;h1 :class=&quot;['red','thin', &#123;'active':isactive&#125;]&quot;&gt;这是一个H1&lt;/h1&gt;</code></p>
</li>
<li>
<p>4.直接使用对象<br>
<code>&lt;h1 :class=&quot;&#123;red:true, italic:true, active:true，thin:true&#125;&quot;&gt;这是一个H1&lt;/h1&gt;</code></p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Luenci<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.red</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.thin</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-weight</span>: <span class="number">200</span>;</span></span><br><span class="line"><span class="language-css">        &#125; </span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.italic</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-style</span>: italic;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.active</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">letter-spacing</span>: <span class="number">0.5em</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;h1 class=&quot;red&quot;&gt;这是一个很大很大的H1&lt;/h1&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--第一种使用方式，直接传递一个数组，注意：这里的class需要使用 v-bind 做数据绑定--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">&quot;[&#x27;thin&#x27;, &#x27;active&#x27;]&quot;</span>&gt;</span>这是一个很大很大的H1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 数组中使用三元表达式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">&quot;[&#x27;thin&#x27;, &#x27;active&#x27;, falg ? &#x27;red&#x27;:&#x27;italic&#x27;]&quot;</span>&gt;</span>这是一个很大很大的H1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 数组中嵌套对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">&quot;[&#x27;thin&#x27;, &#x27;active&#x27;, &#123;&#x27;red&#x27;:falg&#125;]&quot;</span>&gt;</span>这是一个很大很大的H1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 直接使用对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;&#x27;thin&#x27;: true, &#x27;active&#x27;: true, &#x27;italic&#x27;: false&#125;&quot;</span>&gt;</span>这是一个很大很大的H1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vm  = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">falg</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>:&#123;&#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用内联样式">使用内联样式</h2>
<ul>
<li>
<p>1.直接在元素上通过<code>style</code>的形式，书写样式对象</p>
<ul>
<li><code>&lt;h1 :style=&quot;&#123;color:‘red'，'font-size'：'40px'&#125;&quot;&gt;这是一个善良的H1&lt;/hl&gt;</code></li>
</ul>
</li>
<li>
<p>2.将样式对象，定义到<code>data</code>中，并直接引用到<code>:style</code>中</p>
<ul>
<li>
<p>在data上定义样式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">  histyObj:&#123;color:&#x27;red&#x27;，&#x27;font-size&#x27;：&#x27;40px&#x27;，&#x27;font-weight&#x27;：200&#x27;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在元素中，通过属性绑定的形式，将样式对象应用到元素中：<br>
<code>&lt;h1 :style=&quot;histyObj&quot;&gt;这是一个h1&lt;/h1&gt;</code></p>
</li>
</ul>
</li>
<li>
<p>3.在<code>:style</code>中通过数组，引用多个<code>data</code>上的样式对象</p>
<ul>
<li>
<p>在data上定义样式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">    histy0bj:&#123;color:&#x27;red&#x27;，&#x27;font-size&#x27;：‘40px&#x27;，‘font-weight&quot;：&#x27;200&#x27;&#125;,     	</span><br><span class="line">  histy0bj2:&#123;fontstyle:&#x27;italic&#x27;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在元素中，通过属性绑定的形式，将样式对象应用到元素中：</p>
<p><code>&lt;h1 :style=&quot;[histy0bj，histy0bj2]&quot;&gt;这是一个h1&lt;/h1&gt;</code></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 直接在元素上通过`style`的形式，书写样式对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;color:&#x27;red&#x27;, &#x27;font-weight&#x27;:200&#125;&quot;</span>&gt;</span>我是一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 2.将样式对象，定义到`data`中，并直接引用到`:style`中 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:style</span>=<span class="string">&quot;styleObj&quot;</span>&gt;</span>我是一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 3.在`:style`中通过数组，引用多个`data`上的样式对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:style</span>=<span class="string">&quot;[styleObj, styleObj2]&quot;</span>&gt;</span>我是一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">styleObj</span>: &#123; <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;font-weight&#x27;</span>: <span class="number">200</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">styleObj2</span>: &#123; <span class="string">&#x27;font-style&#x27;</span>: <span class="string">&#x27;italic&#x27;</span> &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">methods</span>: &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>  </span><br></pre></td></tr></table></figure>
<h1><code>Vue</code>指令之<code>v-for</code>和<code>key</code>属性</h1>
<ul>
<li>1.迭代数组</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;1i v-for=&quot;（item，i）in list&quot;&gt;索引：&#123;&#123;i&#125;&#125;---姓名：&#123;&#123;item.name&#125;&#125;---年龄：&#123;&#123;item.age&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2.迭代对象中的属性</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;4--循环遍历对象身上的属性--&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;（val，key，i）in userInfo&quot;</span>&gt;</span>&#123;&#123;val&#125;&#125;---&#123;&#123;key&#125;&#125;---&#123;&#123;i]&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>3.迭代数字<br>
<code>&lt;p v-for=&quot;ks in 8&quot;&gt;这是第（&#123;i&#125;&#125;个P标签&lt;/p&gt;</code></p>
<blockquote>
<p>22.0+的版本里，当在细件中使用v-for时，key现在是必须的。</p>
</blockquote>
</li>
<li>
<p>当<code>Vue.js</code> 用<code>v-for</code>正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，<code>Vue</code>将不是移动<code>DOM</code>元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定素引下显示已被渲染过的每个元素。<br>
为了给<code>Vue</code>一个提示，<strong>以便它能跟踪每个节点的身份，从而重用和重新排序现有元素</strong>，你需要为每项提供一个唯一<code>key </code>属性。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0,minimal-ui:ios&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 循环普通数组 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,i) in list&quot;</span>&gt;</span>索引值:&#123;&#123;i&#125;&#125;-----数值:&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 循环对象数组 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;(user,i) in list2&quot;</span>&gt;</span>&#123;&#123;user.id&#125;&#125;====&#123;&#123;user.name&#125;&#125;------&#123;&#123;i&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 循环对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key, i) in list3&quot;</span>&gt;</span>&#123;&#123;i&#125;&#125;-------&#123;&#123;key&#125;&#125;----&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 循环数字 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;count in 6&quot;</span>&gt;</span>第&#123;&#123;count&#125;&#125;循环<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">list</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">list2</span>: [</span></span><br><span class="line"><span class="language-javascript">                    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;Luenci&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">                    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;Lynn&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">                    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;lucy&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">                    &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">name</span>: <span class="string">&#x27;ll&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">                ],</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">list3</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">user</span>: <span class="string">&#x27;Luenci&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">age</span>: <span class="number">20</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">methods</span>: &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1><code>Vue</code>指令之<code>v-if</code>和<code>v-show</code></h1>
<ul>
<li>一般来说，<code>v-if </code>有更高的切换消精而</li>
<li><code>v-show</code> 有更高的初始渲染消耗。</li>
<li>如果需要频繁切换<code>v-show</code>较好</li>
<li>如果元素可能永远也不会被显示出来被用户看到，则推荐使用<code>v-if</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0,minimal-ui:ios&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;flag=!flag&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- v-if的特点：每次都会重新删除或创建元素 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- v-show的特点：每次不会重新进行DoM的删除和创建操作，只是切换了元素的 display:none 样式 --&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- v-if有较高的切换性能消耗 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- v-show 有较高的初始渲染消耗 --&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 如果元素涉及到频繁的切换，最好不要使用v-if --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 如果元素可能永远也不会被显示出来被用户看到，则推荐使用v-if --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;flag&quot;</span>&gt;</span>这是v-if控制的元素<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;flag&quot;</span>&gt;</span>这是v-show控制的元素<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">flag</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">methods</span>: &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1>过滤器</h1>
<ul>
<li>概念：<code>Vue.js</code>允许你自定义过滤器，可被用作一些嚣见的文本格式化。</li>
<li>过滤器可以用在两个地方：<code>mustache</code>插值和<code>v-bind</code> 表达式。过滤器应该被添加在<code>JavaScript</code>表达式的尾部，由“管道”符指示</li>
</ul>
<h2 id="全局过滤器">全局过滤器</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;time&#x27;</span>, <span class="keyword">function</span> (<span class="params">Ctime, pattern = <span class="string">&#x27;&#x27;</span></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> dt = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Ctime</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = dt.<span class="title function_">getFullYear</span>()</span><br><span class="line"><span class="keyword">var</span> m = dt.<span class="title function_">getMonth</span>() + <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> d = dt.<span class="title function_">getDate</span>()</span><br><span class="line"><span class="comment">// return y + &#x27;--&#x27; + m + &#x27;--&#x27; + d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pattern.<span class="title function_">toLowerCase</span>() === <span class="string">&#x27;yyyy-mm-dd&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span>`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> hh = dt.<span class="title function_">getHours</span>()</span><br><span class="line">  <span class="keyword">var</span> mm = dt.<span class="title function_">getMinutes</span>()</span><br><span class="line">  <span class="keyword">var</span> ss = dt.<span class="title function_">getSeconds</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="局部过滤器">局部过滤器</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm2 = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">            <span class="attr">el</span>: <span class="string">&#x27;#app2&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: [</span><br><span class="line">                dt = <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">methods</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">filters</span>: &#123;</span><br><span class="line">            <span class="comment">// 定义私有过滤器过滤器有两个条件【过滤器名称和处理函数】                             </span></span><br><span class="line">            <span class="comment">// 过滤器调用的时候，采用的是`就近原则`，</span></span><br><span class="line">            <span class="comment">//如果私有过滤器和全局过滤器名称一致了，这时候优先调用私有过滤器</span></span><br><span class="line">                <span class="attr">deteFormat</span>: <span class="keyword">function</span> (<span class="params">dateStr, pattern = <span class="string">&#x27;&#x27;</span></span>) &#123;</span><br><span class="line">                    <span class="keyword">var</span> dt = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Ctime</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">var</span> y = dt.<span class="title function_">getFullYear</span>()</span><br><span class="line">                    <span class="keyword">var</span> m = dt.<span class="title function_">getMonth</span>() + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">var</span> d = dt.<span class="title function_">getDate</span>()</span><br><span class="line">                    <span class="comment">// return y + &#x27;--&#x27; + m + &#x27;--&#x27; + d</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (pattern.<span class="title function_">toLowerCase</span>() === <span class="string">&#x27;yyyy-mm-dd&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">var</span> hh = dt.<span class="title function_">getHours</span>()</span><br><span class="line">                        <span class="keyword">var</span> mm = dt.<span class="title function_">getMinutes</span>()</span><br><span class="line">                        <span class="keyword">var</span> ss = dt.<span class="title function_">getSeconds</span>()</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ES6</code>中的字符串新方法<code> String</code>，<code>prototype</code>，<code>padStart(maxlength，fillString=''）</code>或 <code>String</code>，<code>prototype</code>，<code>padEnd(maxlength，filString=''）</code>来填充字符串；</p>
</blockquote>
<h1>Vue指令</h1>
<h2 id="钩子函数">钩子函数</h2>
<p>指令提供了几个钩子函数</p>
<ul>
<li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。</li>
<li><code>inserted</code>：被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于<code>document</code>中）。</li>
<li><code>update</code>：所在组件的<code>VNode</code>更新时调用，但是可能发生在其孩子的<code>VNode</code>更新之前。指令的值可能发生了改变也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新（详细的钩子函数参数见下）。</li>
<li><code>componentUpdated</code>：所在组件的<code>VNode</code> 及其孩子的<code>VNode</code>全部更新时调用。</li>
<li><code>unbind</code>：只调用一次，指令与元素解绑时调用。<br>
接下来我们来看一下钩子函数的参数（包括<code>el，binding，vnode，oldVnode</code>）</li>
</ul>
<h2 id="钩子函数参数">钩子函数参数</h2>
<p>指令钩子函数会被传入以下参数：</p>
<ul>
<li><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM 。</li>
<li><code>binding</code>：一个对象，包含以下属性：
<ul>
<li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li>
<li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li>
<li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li>
<li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li>
<li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li>
<li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>&#123; foo: true, bar: true &#125;</code>。</li>
</ul>
</li>
<li><code>vnode</code>：Vue 编译生成的虚拟节点。移步 <a href="https://cn.vuejs.org/v2/api/#VNode-%E6%8E%A5%E5%8F%A3">VNode API</a> 来了解更多详情。</li>
<li><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li>
</ul>
<blockquote>
<p>除了 <code>el</code> 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/dataset"><code>dataset</code></a> 来进行。</p>
</blockquote>
<h1>Vue实例的生命周期</h1>
<ul>
<li>
<p>仕么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期</p>
</li>
<li>
<p>生命周期钩子 = 生命周期函数 = 生命周期事件：就是生命周期事件的别名而已；</p>
</li>
<li>
<p>主要的生命周期函数分类：</p>
<ul>
<li>创建期间的生命周期函数：
<ul>
<li><code>beforeCreate</code>：实例刚在内存中被创建出来，此时，还没有初始化好<code>data</code>和<code>methods</code>属性</li>
<li><code>created</code>：实例已经在内存中创建OK，此时<code>data</code>和<code>methods</code>已经创建OK，此时还没有开始编译模板</li>
<li><code>beforeMount</code>：此时已经完成了模板的编译，但是还没有挂载到页面中</li>
<li><code>mounted</code>：此时，已经将编译好的模板，挂载到了页面指定的容器中显示</li>
</ul>
</li>
<li>运行期间的生命周期函数：
<ul>
<li><code>beforeUpdate</code>：状态更新之前执行此函数，此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为此时还没有开始重新渲染DOM节点</li>
<li><code>updated</code>：实例更新完毕之后调用此函数，此时<code>data</code>中的状态值和界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li>
</ul>
</li>
<li>销般期间的生命周期函数：
<ul>
<li><code>abeforeDestroy</code>：实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li><code>destroyed</code>:Vue 实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>
</ul>
</li>
</ul>
<p><img src="https://upload.cc/i1/2020/01/01/NqHeSg.png" alt="lifecycle"></p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">msg</span>:<span class="string">&#x27;ok&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">show</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行了show方法&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123; <span class="comment">// 这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会执行它</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// console.log（this.msg）</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// this.show（）</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 注意：在beforecreate生命周期函数执行的时候，data和methods中的数据都还没有没初始化</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">created</span>(<span class="params"></span>) &#123; <span class="comment">//这是遇到的第二个生命周期函数</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// console.log（this.msg）</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// this.show（）</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 在created中，data和methdas都已经被初始化好了！</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">beforeMount</span>(<span class="params"></span>) &#123; <span class="comment">//这是遇到的第3个生命周期函数，表示模板已经在内存中编辑完成了，但是尚未把模板渲染到页面中</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//console.1og（document.getElementById（&#x27;h31）.innerText）</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//在beforeMount执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">mounted</span>(<span class="params"></span>) &#123; <span class="comment">//这是遇到的第4个生命周期函数，表示，内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>((<span class="string">&quot;h3&quot;</span>).<span class="property">innerText</span>))</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//注意：mounted是实例创建期间的最后一个生命周期函数，当执行完mounted就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的躺在我们的内存中，一动不动</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Vue框架</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 配置同时使用 Gitlab、Github、Gitee(码云) 共存的开发环境（转载）</title>
    <url>/2023/02/06/windows%20%E9%85%8D%E7%BD%AE%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%20Gitlab%E3%80%81Github%E3%80%81Gitee(%E7%A0%81%E4%BA%91)%20%E5%85%B1%E5%AD%98%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<blockquote>
<p>原文链接：<a href="https://blog.csdn.net/flowerspring/article/details/104962002">https://blog.csdn.net/flowerspring/article/details/104962002</a></p>
</blockquote>
<h1>清除 git 的全局设置（针对已安装 git）</h1>
<ul>
<li>
<p>新安装 git 跳过。</p>
</li>
<li>
<p>若之前对 git 设置过全局的 <a href="http://user.name">user.name</a> 和 user.email。<br>
类似 (用 git config --global --list 进行查看你是否设置)</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;你的名字&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email  <span class="string">&quot;你的邮箱&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>必须删除该设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global --<span class="built_in">unset</span> user.name <span class="string">&quot;你的名字&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global --<span class="built_in">unset</span> user.email <span class="string">&quot;你的邮箱&quot;</span></span></span><br></pre></td></tr></table></figure>
<h1>生成新的 SSH keys</h1>
<h2 id="1）Gitee-密钥">1）Gitee 密钥</h2>
<ul>
<li>
<p>跳转到keygen目录，git bash here。</p>
</li>
<li>
<p>先键入第二行命令</p>
</li>
<li>
<p>第四行 指定 id 文件名称为id_rsa_gitee</p>
</li>
<li>
<p>第五、六行 设置无密码，直接回车两次。</p>
</li>
<li>
<p>会在keygen目录下生成文件  id_rsa_gitee 和 id_rsa_gitee.pub。</p>
</li>
<li>
<p>id_rsa_gitee.pub中存放的是公钥。</p>
</li>
<li>
<p>把公钥保存到gitee网页密钥中。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">honey@honey MINGW64 /d/keygen</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C yourmail@.com</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/c/Users/honey/.ssh/id_rsa): id_rsa_gitee</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in id_rsa_gitee.</span><br><span class="line">Your public key has been saved in id_rsa_gitee.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">...</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>也可指定文件路径，方便后面操作：<code>~/.ssh/id_rsa.gitlab </code></li>
</ul>
<p><code>ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitee -C &quot;yourmail@.com&quot;</code></p>
<ul>
<li>直接回车3下，什么也不要输入，就是默认没有密码。</li>
<li>注意 gitee 和 gitlab 的文件名是不同的。</li>
</ul>
<span id="more"></span>
<h2 id="2）GitLab-密钥">2）GitLab 密钥</h2>
<p>同上</p>
<ul>
<li>
<p>跳转到keygen目录，git bash here。</p>
</li>
<li>
<p>先键入第二行命令</p>
</li>
<li>
<p>第四行 指定 id 文件名称为id_rsa_gitlab</p>
</li>
<li>
<p>第五、六行 设置无密码，直接回车两次。</p>
</li>
<li>
<p>会在keygen目录下生成文件  id_rsa_gitlab 和 id_rsa_gitlab.pub。</p>
</li>
<li>
<p>id_rsa_gitlab.pub中存放的是公钥。</p>
</li>
<li>
<p>把公钥保存到gitlab网页密钥中。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">honey@honey MINGW64 /d/keygen</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -f id_rsa_gitlab -C <span class="string">&quot;yourmail@.com&quot;</span>`</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">id_rsa_gitlab already exists.</span><br><span class="line">Overwrite (y/n)? y</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in id_rsa_gitlab.</span><br><span class="line">Your public key has been saved in id_rsa_gitlab.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">...</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitlab -C &quot;yourmail@.com&quot;</code></p>
<h2 id="3）GitHub-密钥">3）GitHub 密钥</h2>
<p>同上</p>
<p><code>ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C &quot;yourmail@.com&quot;</code></p>
<h2 id="4-完成后会在-ssh目录下生成以下文件">4)完成后会在~/.ssh目录下生成以下文件</h2>
<ul>
<li>
<p>id_rsa_github</p>
</li>
<li>
<p>id_rsa_github.pub</p>
</li>
<li>
<p>id_rsa_gitlab</p>
</li>
<li>
<p>id_rsa_gitlab.pub</p>
</li>
<li>
<p>id_rsa_gitee</p>
</li>
<li>
<p>id_rsa_gitee.pub</p>
</li>
</ul>
<h2 id="config文件">config文件</h2>
<ul>
<li>
<p>需要在.ssh文件夹下新建config文件，先新建config.txt，然后修改文件名去掉后缀。</p>
</li>
<li>
<p>config文件内容如下：</p>
</li>
<li>
<p>其中第二行和第三中 需要填写gitlab的仓库地址</p>
</li>
</ul>
<h3 id="gitlab">gitlab</h3>
<pre><code>Host git.xxx.cn
HostName git.xxx.cn
PreferredAuthentications publickey
IdentityFile ~/.ssh/id_rsa_gitlab
User git
</code></pre>
<h3 id="gitee">gitee</h3>
<pre><code>Host gitee.com
HostName gitee.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/id_rsa_gitee
User git
</code></pre>
<h3 id="github">github</h3>
<pre><code>Host github.com
HostName github.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/id_rsa_github
User git
</code></pre>
<h1>测试</h1>
<p>1）Gitee 测试</p>
<p>$ ssh -T <a href="mailto:git@gitee.com">git@gitee.com</a><br>
步骤如下：</p>
<p>在gitee注册用户登录，创建仓库。<a href="https://gitee.com/XXXX/c_demo">https://gitee.com/XXXX/c_demo</a></p>
<p>在.ssh目录 git bash here</p>
<p>honey@honey MINGW64 ~/.ssh<br>
$ ssh -T <a href="mailto:git@gitee.com">git@gitee.com</a><br>
Warning: Permanently added the ECDSA host key for IP address ‘180.97.125.228’ to the list of known hosts.<br>
Hi fengmi! You’ve successfully authenticated, but <a href="http://GITEE.COM">GITEE.COM</a> does not provide shell access.<br>
显示successfully。</p>
<p>2）GitLab 测试<br>
<a href="mailto:git@git.XXX.cn">git@git.XXX.cn</a> 是gitlab的仓库地址</p>
<p>$ ssh -T <a href="mailto:git@git.XXX.cn">git@git.XXX.cn</a><br>
步骤如下：</p>
<p>跳转到.ssh目录，git bash here。</p>
<p>honey@honey MINGW64 ~/.ssh<br>
$ ssh -T <a href="mailto:git@git.XXX.cn">git@git.XXX.cn</a><br>
The authenticity of host ‘<a href="http://git.XXX.cn">git.XXX.cn</a> (111.203.245.108)’ can’t be established.<br>
ECDSA key fingerprint is …<br>
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes<br>
Warning: Permanently added ‘<a href="http://git.emapgo.cn">git.emapgo.cn</a>,111.203.245.108’ (ECDSA) to the list of known hosts.<br>
Welcome to GitLab, @mygitlabhostname!<br>
显示welcome to gitlab。</p>
<p>3）Github 测试<br>
同gitee</p>
<p>4)~/.ssh / 目录下最终拥有如下文件<br>
windows .ssh目录 是 C:\Users\honey.ssh 即C:\Users\windows登录名.ssh</p>
<p>id_rsa_github<br>
id_rsa_github.pub<br>
id_rsa_gitlab<br>
id_rsa_gitlab.pub<br>
id_rsa_gitee<br>
id_rsa_gitee.pub<br>
config<br>
known_hosts</p>
<ol start="4">
<li>查看电脑中自己的配置信息<br>
$ cat config<br>
honey@honey MINGW64 ~/.ssh<br>
$ cat config</li>
</ol>
<h1>使用</h1>
<h3 id="1）Gitlab">1）Gitlab</h3>
<p>在本地以后gitlab仓库，git pull ,git commit -m “XXX”,git push 会提示 tell me who you are</p>
<p>此时需要填写local 用户名和邮箱，而不是 --global</p>
<p>$ ssh git config --local <a href="http://user.name">user.name</a> “你的名字”<br>
$ ssh git config --local user.email  “你的邮箱”</p>
<h3 id="2）Gitee">2）Gitee</h3>
<p>同上类似</p>
<h3 id="3）Github">3）Github</h3>
<p>同上类似</p>
<h2 id="配置文件和配置字段信息解释">配置文件和配置字段信息解释</h2>
<ul>
<li>
<p><code>Host</code><br>
它涵盖了下面一个段的配置，我们可以通过他来替代将要连接的服务器地址。<br>
这里可以使用任意字段或通配符。<br>
当ssh的时候如果服务器地址能匹配上这里Host指定的值，则Host下面指定的HostName将被作为最终的服务器地址使用，并且将使用该Host字段下面配置的所有自定义配置来覆盖默认的<code>/etc/ssh/ssh_config</code>配置信息。</p>
</li>
<li>
<p><code>Port</code><br>
自定义的端口。默认为22，可不配置</p>
</li>
<li>
<p><code>User</code><br>
自定义的用户名，默认为git，可不配置   ， User git #默认就是git，可以不写</p>
</li>
<li>
<p><code>HostName</code><br>
真正连接的服务器地址</p>
</li>
<li>
<p><code>PreferredAuthentications</code><br>
指定优先使用哪种方式验证，支持密码和秘钥验证方式</p>
</li>
<li>
<p><code>IdentityFile</code><br>
指定本次连接使用的密钥文件</p>
</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git配置</tag>
      </tags>
  </entry>
  <entry>
    <title>京东全网爬虫</title>
    <url>/2023/02/06/%E4%BA%AC%E4%B8%9C%E5%85%A8%E7%BD%91%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<p>完整代码见： <a href="https://github.com/Lucareful/JingDongSpider">https://github.com/Lucareful/JingDongSpider</a></p>
<p>写在前面：</p>
<blockquote>
<p>折腾了很久的用python做爬虫项目到现在也该告一段落了，看视频学，遇到bug自己查找，代码思路不对重新写，环境不对自己配置…一路上跌跌撞撞，过程很艰苦，所幸结果为好。</p>
<p>代码就像一面明镜，照见我自身的不足。继续加油</p>
</blockquote>
<h2 id="需求">需求</h2>
<ul>
<li>抓取首页的分类信息
<ul>
<li>大分类的url</li>
<li>中分类的url</li>
<li>小分类的url</li>
</ul>
</li>
<li>抓取商品信息
<ul>
<li>商品名称</li>
<li>价格</li>
<li>评论信息</li>
<li>店铺</li>
<li>促销</li>
<li>选项</li>
<li>图片</li>
</ul>
</li>
</ul>
<h2 id="开发环境和技术">开发环境和技术</h2>
<ul>
<li>技术选择：</li>
<li>由于全网爬虫，抓取页面非常多，为了提高抓的速度，选择使用<code>scrapy</code>框架+<code>scrapy_redis</code>分布式组件</li>
<li>由于京东全网的数据量达到了亿级，存储又是结构化数据，</li>
<li>数据库，选择使用MongoDB；</li>
</ul>
<span id="more"></span>
<h1>京东全网爬虫的实现步骤</h1>
<ul>
<li>采取广度优先策略，我们把类别和商品信息的抓取分开来做</li>
</ul>
<blockquote>
<p>优点，提高程序的稳定性</p>
</blockquote>
<ul>
<li>总体设计</li>
</ul>
<p><img src="https://i.ibb.co/FDqW9vd/image-20191120143929099.png" alt="image-20191120143929099"></p>
<h2 id="实现步骤">实现步骤</h2>
<ol>
<li>创建爬虫项目</li>
<li>根据需求，定义数据数据模型</li>
<li>实现分类起虫</li>
<li>保存分类信息</li>
<li>实现商品爬虫</li>
<li>保存商品信息</li>
<li>实现随机User-Agent和代理IP下载器中间件，解决IP反爬。</li>
</ol>
<h2 id="创建爬虫项目">创建爬虫项目</h2>
<p><code>scrapy startproject jingDong</code></p>
<h2 id="定义数据模型（要抓取的数据）">定义数据模型（要抓取的数据）</h2>
<h3 id="类别数据模型类">类别数据模型类</h3>
<ul>
<li>
<p>用于存储类别信息（Category）-字段：</p>
</li>
<li>
<p><code>b.category_name</code>：大类别名称。</p>
</li>
<li>
<p><code>b_category_url</code>：大类别URL。</p>
</li>
<li>
<p><code>m_category_name</code>：中分类名称。</p>
</li>
<li>
<p><code>m_category_url</code>：中分类URL。</p>
</li>
<li>
<p><code>s_category_name</code>：小分类名称</p>
</li>
<li>
<p><code>s_category_url</code>：小分类URL</p>
</li>
</ul>
<h3 id="商品数据模型">商品数据模型</h3>
<ul>
<li>商品数据模型类：用于存储商品信息（Product）字段：</li>
<li>oproduct_category：商品类别</li>
<li>product_sku_id：商品ID</li>
<li>product_name：商品名称</li>
<li>product_img_url：商品图片URL</li>
<li>product_book_info：图书信息，作者，出版社</li>
<li>product_option：商品选项</li>
<li>product_shop：商品店铺</li>
<li>product_comments：商品评论数量</li>
<li>product_ad：商品促销</li>
<li>product_price：商品价格</li>
</ul>
<h2 id="商品的分类爬虫">商品的分类爬虫</h2>
<ul>
<li>创建爬虫</li>
<li>进入项目目录：cd mall_spider</li>
<li>创建爬虫：scrapy genslider category_spider <a href="http://jd.com">jd.com</a></li>
<li>指定起始URL</li>
<li>修改起始URL: <a href="https://dc.3.cn/category/get">https://dc.3.cn/category/get</a></li>
</ul>
<h2 id="实现保存分类的pipeline类">实现保存分类的pipeline类</h2>
<ul>
<li>open_spider 方法中，链接MongoDB数据库，获取要操作的集合</li>
<li>process_item 方法中，向MongoDB中插入类别数据</li>
<li>close_spider 方法中，关闭MongoDB的链接</li>
</ul>
<h1>实现商品爬虫</h1>
<ul>
<li>
<p>步骤</p>
<ul>
<li>分析，确定数据所在的URL</li>
<li>代码实现（核心）</li>
<li>商品爬虫实现分布式</li>
</ul>
</li>
<li>
<p>分析，确定数据所在的URL</p>
<ul>
<li>解析列表页，提取商品sku_id，实现翻页，确定翻页的URL</li>
<li>获取商品的基本信息，通过手机抓包（APP），确定URL</li>
<li>PC详情页面，确定商品的促销信息的URL</li>
<li>PC详情页面，确定评论信息的URL</li>
<li>PC详情页面，确定商品价格信息的URL</li>
</ul>
</li>
<li>
<p>代码实现</p>
</li>
<li>
<p>1.重写start_requests方法，根据分类信息构建列表页的请求</p>
</li>
<li>
<p>2.解析列表页，提取商品的skuid，构建商品基本的信息请求；实现列表翻页</p>
<p>1.确定商品基本的信息请求</p>
<p>1.URL:<a href="https://cdnware.m.jd.com/c1/skuDetail/apple/7.3.0/32962088964.json">https://cdnware.m.jd.com/c1/skuDetail/apple/7.3.0/32962088964.json</a><br>
2.请求方法：GET<br>
3.参数/数据：32962088964商品的skuid<br>
2.解析列表页，提取商品的skuid<br>
3.构建商品基本的信息请求<br>
4.实现列表翻页</p>
</li>
<li>
<p>解析促销信息，构建商品评价信息的请求</p>
</li>
<li>
<p>1.解析促销信息</p>
<ul>
<li>
<p>1.produft_ad：商品促销</p>
</li>
<li>
<p>2.构建商品评价信息的请求</p>
<ul>
<li>1.准备评价信息的请求</li>
</ul>
</li>
</ul>
</li>
<li>
<p>解析商品评价信息，构建价格信息的请求</p>
</li>
<li>
<p>解析商品评价信息</p>
<ul>
<li>1.product_comments：商品评论数量</li>
<li>2.评价数量，好评数量，差拜数量，好评率</li>
<li>2.构建价格信息的请求</li>
</ul>
</li>
<li>
<p>准备价格请求：</p>
<ul>
<li>1.URL:<a href="https://p.3.cn/prices/mgets?skulds=J_69334292">https://p.3.cn/prices/mgets?skulds=J_69334292</a>.</li>
<li>2.请求方法：GET</li>
<li>3.参数：skulds=J_6933429，j后跟这个商品的sku_id</li>
</ul>
</li>
<li>
<p>解析价格信息</p>
<ul>
<li>1.product_price：商品价格</li>
<li>2.把商品数据交给引擎</li>
</ul>
</li>
</ul>
<h1>商品爬虫实现分布式</h1>
<ul>
<li>修改爬虫类
<ul>
<li>修改继承关系</li>
<li>指定redis_key</li>
<li>把重写start_requests改为重写make_request from data I</li>
</ul>
</li>
<li>在settings文件中配置scrapy_redis
<ul>
<li>直接拷贝scrapy_redis配置信息，到settings.py中.</li>
</ul>
</li>
<li>写一个程序用于把MongoDB中分类信息，放入到爬虫redis_key指定的列表中</li>
</ul>
<h1>保存商品数据</h1>
<ul>
<li>实现存储商品Pipeline类
<ul>
<li>在open_spider方法，建立MongoDB数据库连接，获取要操作的集合</li>
<li>在process_item方法，把数据插入到MongoDB中</li>
<li>在close_spider方法，关闭数据库连接</li>
</ul>
</li>
<li>在settings.py中开启这个管道</li>
</ul>
<h1>实现下载器中间件</h1>
<ul>
<li>
<p>实现随机User-Agent的中间件</p>
</li>
<li>
<p>在settings.py中开启上面的下载器中间<br>
件</p>
</li>
</ul>
]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>scrapy框架</tag>
      </tags>
  </entry>
  <entry>
    <title>python的协程</title>
    <url>/2023/02/06/%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<h1>可迭代对象</h1>
<ul>
<li>可遍历对象就是可迭代对象</li>
<li>列表、元组、字典、字符串都是可迭代对象</li>
<li>100和自定义<code>myclass</code> 默认都是不可以迷代的</li>
<li><code>myclass </code>对象所属的类<code>MyClass</code>如果包含了<code>__iter__（）</code>方法，此时
<ul>
<li><code>myclass</code>就是一个可送代对象</li>
</ul>
</li>
<li>可送代对象的本质：对象所属的类中包含了<code>__iter__（）</code>方法</li>
<li>检测一个对象是否可以送代，用<code>isinstance（）</code>函数检测。</li>
</ul>
<h1>迭代器</h1>
<ul>
<li>我们发现选代器最核心的功能就是可以通过next0函数的调用来返回下一个数据值。如果每次返回的数据值不是在一个已有的数据集合中读取的，而是通过程序按照一定的规律计算生成的，那么也就意味着可以不用再依赖一个已有的数据集合，也就是说不用再将所有要迭代的数据都一次性缓存下来供后续依次读取，这样可以节省大量的存储（内存）空间。</li>
<li>举个例子，比如，数学中有个著名的斐波拉契数列（Fibonacci），数列中第一个数为0，第二个数为1，其后的每一个数都可由前两个数相加得到：</li>
</ul>
<h2 id="特点">特点</h2>
<ul>
<li>
<p>记录遍历的位置</p>
</li>
<li>
<p>提供下一个元素的值（配合next（）函数）</p>
</li>
<li>
<p>迭代器生成斐波那契数列</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fibanacci</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="comment"># 实例化生成列属性</span></span><br><span class="line">        self.num = num</span><br><span class="line">        self.a = <span class="number">1</span></span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line">        self.current_index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 返回自己</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.current_index &lt; self.num:</span><br><span class="line">            <span class="comment"># 生成斐波那契数列</span></span><br><span class="line">            <span class="comment"># 定义变量保存a的值</span></span><br><span class="line">            data = self.a</span><br><span class="line">            self.a, self.b = self.b, self.a + self.b</span><br><span class="line">            self.current_index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fib = Fibanacci(<span class="number">8</span>)</span><br><span class="line">    value = <span class="built_in">next</span>(fib)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fib:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">out:</span><br><span class="line">  <span class="number">1</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">    <span class="number">8</span></span><br><span class="line">    <span class="number">13</span></span><br><span class="line">    <span class="number">21</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1>生成器</h1>
<ul>
<li><strong>生成器是一类特殊的迭代器。</strong></li>
<li>利用选代器，我们可以在每次迭代获取数据（通过<code>next()</code>方法）时按照特定的规律进行生成。但是我们在实现一个迭代器时，关于当前迭代到的状态需要我们自己记录，进而才能根据当前状态生成下一个数据。为了达到记录当前状态，并配合<code>next()</code>函数进行迭代使用，我们可以采用更简便的语法，即<code>生成器（generator)</code>。
<ul>
<li>创建生成器方法1要创建一个生成器，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成（）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列表推导式</span></span><br><span class="line">data_list = [x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data_list:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器的创建</span></span><br><span class="line">data_list1 = (x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过next()获取下一个值</span></span><br><span class="line">value = <span class="built_in">next</span>(data_list1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------&gt;&quot;</span>, value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> data_list1:</span><br><span class="line">    <span class="built_in">print</span>(j)</span><br><span class="line">    </span><br><span class="line">out:</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">    <span class="number">4</span></span><br><span class="line">    <span class="number">6</span></span><br><span class="line">    <span class="number">8</span></span><br><span class="line">    --------&gt; <span class="number">0</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">    <span class="number">4</span></span><br><span class="line">    <span class="number">6</span></span><br><span class="line">    <span class="number">8</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数中使用<code>yield</code>关键字生成生成器</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    m = test()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;m:&quot;</span>, m)</span><br><span class="line">    n = test2()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;n&quot;</span>, n)</span><br><span class="line">    value = <span class="built_in">next</span>(n)</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line">    </span><br><span class="line">out：</span><br><span class="line">  m: <span class="number">10</span></span><br><span class="line">    n &lt;generator <span class="built_in">object</span> test2 at <span class="number">0x000002A2C4C6D0F8</span>&gt;</span><br><span class="line">    <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h2 id="生成器生成斐波那契数列">生成器生成斐波那契数列</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fibnacci</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 初始化a, b的值</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 纪录迭代位置</span></span><br><span class="line">    current_index = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----1------&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> current_index &lt; n:</span><br><span class="line">        <span class="comment"># 保存a的值</span></span><br><span class="line">        data = a</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        current_index += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-----2------&quot;</span>)</span><br><span class="line">        <span class="keyword">yield</span> data</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-----3------&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fib = fibnacci(<span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(fib))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(fib))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(fib))</span><br><span class="line">    </span><br><span class="line">out:</span><br><span class="line">    -----<span class="number">1</span>------</span><br><span class="line">    -----<span class="number">2</span>------</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    -----<span class="number">3</span>------</span><br><span class="line">    -----<span class="number">2</span>------</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    -----<span class="number">3</span>------</span><br><span class="line">    -----<span class="number">2</span>------</span><br><span class="line">    <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="yield作用">yield作用</h2>
<ul>
<li>充当<code>return</code>作用</li>
<li>保存程序的运行状态并且暂停程序执行</li>
<li>当next的时候，可以继续唤醒程序从yield位置继续向下执行</li>
</ul>
<h2 id="生成器中使用return问题">生成器中使用return问题</h2>
<ul>
<li>生成器客户以使用<code>return</code>关键字，语法上没有问题，但是如果执行到<code>return</code>语句以后，生成器会停止迭代，抛出停止迭代的异常</li>
</ul>
<h2 id="send作用">send作用</h2>
<ul>
<li>
<p>生成器.send(传递给生成器的值)</p>
</li>
<li>
<p>传递</p>
<ul>
<li>
<pre><code class="language-python">a = fib.send(1)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 接收</span><br><span class="line">  - ``` python </span><br><span class="line">    xxx = yield data</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
</li>
</ul>
<h1>协程</h1>
<ul>
<li>协程，又称微线程，纤程。英文名Coroutine。从技术的角度来说，“协程就是你可以暂停执行的函数”。如果你把它理解成“就像生成器一样”，那么你就想对了。</li>
<li>线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作则是程序员。</li>
<li>协程存在的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程（单线程），在一个线程中规定某个代码块执行顺序。</li>
</ul>
<p><img src="https://i.postimg.cc/vBkZ8L6h/image-20191116100828999.png" alt="image-20191116100828999"></p>
<h2 id="协程应用场景">协程应用场景</h2>
<ul>
<li>协程的适用场景：当程序中存在大量不需要CPU的操作时（IO），适用于协程；通俗的理解：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定</li>
</ul>
<h2 id="协程和线程差异">协程和线程差异</h2>
<ul>
<li>
<p>不开辟新的线程的基础上，实现多个任务</p>
</li>
<li>
<p>在实现多任务时，线程切换从系统层面远不止保存和恢复CPU上下文这么简单。操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------------------ 携程的原始实现 --------------------</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;work1正在工作....&quot;</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work2</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;work2正在工作.............&quot;</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 =work1()</span><br><span class="line">    t2 = work2()</span><br><span class="line">    <span class="built_in">print</span>(t1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">next</span>(t1)</span><br><span class="line">        <span class="built_in">next</span>(t2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>greenlet库</h1>
<ul>
<li>greenlet 可以实现协程</li>
<li>Greenlet是python的一个C扩展，来源于Stackless python，旨在提供可<strong>自行调度的“微线程’，即协程</strong>。</li>
<li>generator实现的协程在yield value时只能将value返回给调用者（caller）。而在greenlet中，<code>target.switch（value）</code>可以切换到指定的协程（target），然后<code>yield value。greenlet</code>用<code>switch</code>来表示协程的切换，从一个协程切换到另一个协程需要显式指定。<br>
<code>GNI GREENLE</code> T为了更好使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变的更加简单</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># work1生成器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;work1正在工作....&quot;</span>)</span><br><span class="line"></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 切换到第二个任务</span></span><br><span class="line">        g2.switch()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># work1生成器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work2</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;work2正在工作.............&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 切换到第一个任务</span></span><br><span class="line">        g1.switch()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    g1 = greenlet(work1)</span><br><span class="line">    g2 = greenlet(work2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#执行work1</span></span><br><span class="line">    g1.switch()</span><br></pre></td></tr></table></figure>
<h1>gevent 库</h1>
<ul>
<li>
<p>自动调度协程，自动识别程序中的耗时操作</p>
</li>
<li>
<p><code>greenlet</code>已经实现了协程，但是这个还的人工切换</p>
</li>
<li>
<p>python还有一个比<code>greenlet</code>更强大的并且能够自动切换任务的第三方库 <code>gevent</code>其原理是当一个<code>greenlet</code>遇到IO（指的是input/ output 输入输出，比如网络、文件操作等）操作时，比如访问网络，就自动切换到其他的<code>greenlet</code>，等到<code>IO</code>操作完成，再在适当的时候切换回来继续执行。</p>
</li>
<li>
<p>由于IO操作非常耗时，经常使程序处于等待状态，有了<code>gevent</code>为我们自动切换协程，就保证总有greenlet在运行，而不是等待</p>
</li>
<li>
<p>使用步骤</p>
</li>
<li>
<p>导入模块</p>
</li>
<li>
<p><code>Iimport gevent</code></p>
</li>
<li>
<p>指派任务</p>
<ul>
<li><code>g1= gevent.spawn（函数名，参数1，参数2，…）</code></li>
</ul>
</li>
<li>
<p>join（）让主线程等待协程执行完毕后再退出</p>
<ul>
<li><code>g1.join()</code></li>
</ul>
</li>
</ul>
<h2 id="打猴子补丁补丁">打猴子补丁补丁</h2>
<ul>
<li>
<p>给程序打补丁（猴子补丁）关于猴子补丁为啥叫猴子补丁，据说是这样子的：</p>
<blockquote>
<p>这个叫法起源于Zope框架，大家在修正Zope的Bug的时候经常在程序后面追加更新部分，这些被称作是“杂牌军补丁<code>（guerilla patch）</code>”，后来<code>guerilla</code>就渐渐的写成了<code>gorlia（塑猩）</code>，再后来就写了monkey（猴子）：所以猴子补丁的叫法是这么莫名其妙的得来的。</p>
</blockquote>
</li>
<li>
<p>猴子补丁主要有以下几个用处：</p>
<ul>
<li>1.在运行时替换方法、属性等</li>
<li>2.在不修改第三方代码的情况下增加原来不支持的功能</li>
<li>3.在运行时为内存中的对象增加patch而不是在盏盘的源代码中增加</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 打补丁</span><br><span class="line">from gevent import monkey</span><br><span class="line"># 破解所有</span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">import gevent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def work1():</span><br><span class="line">    while True:</span><br><span class="line">        print(&quot;work1正在工作....&quot;)</span><br><span class="line">        time.sleep(0.5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def work2():</span><br><span class="line">    while True:</span><br><span class="line">        print(&quot;work2正在工作.............&quot;)</span><br><span class="line">        # gevent.sleep(0.5)</span><br><span class="line">        time.sleep(0.5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # 指派任务</span><br><span class="line">    g1 = gevent.spawn(work1)</span><br><span class="line">    g2 = gevent.spawn(work2)</span><br><span class="line"></span><br><span class="line">    # 让主线程等待协程执行完毕再运行</span><br><span class="line">    g1.join()</span><br><span class="line">    g2.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>小福利</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 妹子图爬虫多协程版</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">all_url = <span class="string">&#x27;http://www.mzitu.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># http请求头</span></span><br><span class="line">Hostreferer = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;http://www.mzitu.com&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Picreferer = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;http://i.meizitu.net&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 此请求头破解盗链</span></span><br><span class="line"></span><br><span class="line">start_html = requests.get(all_url, headers=Hostreferer)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存地址</span></span><br><span class="line">path = <span class="string">&quot;E:\\mzitu\\&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找寻最大页数</span></span><br><span class="line">soup = BeautifulSoup(start_html.text, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">page = soup.find_all(<span class="string">&#x27;a&#x27;</span>, class_=<span class="string">&#x27;page-numbers&#x27;</span>)</span><br><span class="line">max_page = page[-<span class="number">2</span>].text</span><br><span class="line"></span><br><span class="line">same_url = <span class="string">&#x27;http://www.mzitu.com/all/&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_img</span>(<span class="params">pic_url</span>):</span><br><span class="line">    html = requests.get(pic_url, headers=Picreferer)</span><br><span class="line">    file_name = pic_url.split(<span class="string">r&#x27;/&#x27;</span>)[-<span class="number">1</span>].replace(<span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(file_name)</span><br><span class="line">    f = <span class="built_in">open</span>(file_name, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">    f.write(html.content)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(max_page) + <span class="number">1</span>):</span><br><span class="line">    ul = same_url + <span class="built_in">str</span>(n)</span><br><span class="line">    start_html = requests.get(ul, headers=Hostreferer)</span><br><span class="line">    soup = BeautifulSoup(start_html.text, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    all_a = soup.find(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;all&#x27;</span>).find_all(<span class="string">&#x27;a&#x27;</span>, target=<span class="string">&#x27;_blank&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> all_a:</span><br><span class="line">        <span class="comment"># 提取文本</span></span><br><span class="line">        title = a.get_text()</span><br><span class="line">        <span class="keyword">if</span> title != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;准备扒取：&quot;</span> + title)</span><br><span class="line">            <span class="comment"># win不能创建带？的目录</span></span><br><span class="line">            <span class="keyword">if</span> os.path.exists(path + title.strip().replace(<span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;&#x27;</span>)):</span><br><span class="line">                <span class="comment"># print(&#x27;目录已存在&#x27;)</span></span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                os.makedirs(path + title.strip().replace(<span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">            os.chdir(path + title.strip().replace(<span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">            href = a[<span class="string">&#x27;href&#x27;</span>]</span><br><span class="line">            html = requests.get(href, headers=Hostreferer)</span><br><span class="line">            mess = BeautifulSoup(html.text, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">            pic_max = mess.find_all(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 最大页数</span></span><br><span class="line">                pic_max = pic_max[<span class="number">9</span>].text</span><br><span class="line">                <span class="keyword">if</span> flag == <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">len</span>(os.listdir(path + title.strip().replace(<span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;&#x27;</span>))) &gt;= <span class="built_in">int</span>(pic_max):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;已经保存完毕，跳过&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            pic_url = []</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(pic_max) + <span class="number">1</span>):</span><br><span class="line">                pic = href + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">str</span>(num)</span><br><span class="line">                html = requests.get(pic, headers=Hostreferer)</span><br><span class="line">                mess = BeautifulSoup(html.text, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">                pic_url.append(mess.find(<span class="string">&#x27;img&#x27;</span>, alt=title))</span><br><span class="line">                <span class="comment"># print(&quot;图片路径：&quot;, pic_url[&#x27;src&#x27;])</span></span><br><span class="line">            pic_url = re.findall(<span class="string">r&quot;[a-zA-z]+://[^\s]*&quot;</span>, <span class="built_in">str</span>(pic_url))</span><br><span class="line">            <span class="built_in">print</span>(pic_url)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将列表编程迭代器</span></span><br><span class="line">            a = pic_url.__iter__()</span><br><span class="line">            <span class="comment"># 开启多个协程</span></span><br><span class="line">            <span class="type">Coroutine</span> = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pic_url)):</span><br><span class="line">                <span class="type">Coroutine</span>.append(gevent.spawn(download_img(<span class="built_in">next</span>(a))))</span><br><span class="line">            gevent.joinall(<span class="type">Coroutine</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;完成&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第&#x27;</span>, n, <span class="string">&#x27;页完成&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>协程知识</tag>
      </tags>
  </entry>
  <entry>
    <title>python多线程，并发和锁</title>
    <url>/2023/02/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1>多任务</h1>
<ul>
<li>同一个时间有多个任务在执行</li>
<li>python程序默认是单任务</li>
</ul>
<h1>线程</h1>
<ul>
<li>线程概念
<ul>
<li>线程，可简单理解为是程序执行的一条分支，也是程序执行流的最小单元。</li>
<li><strong>线程是被系统独立调度和分底的基本单位</strong>，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程为其它线程共享进程所拥有的全部资源。</li>
</ul>
</li>
</ul>
<p><img src="https://i.postimg.cc/C1xWN60d/image-20191113140837489.png" alt="image-20191113140837489"></p>
<h2 id="主线程">主线程</h2>
<ul>
<li>
<p>当一个程序后动时，就有一个进程被操作系统（OS）创建，与此同时一个线程也立刻运行，该线程通常叫做程序的主线程，简而言之；程序后动就会创建一个主线程。</p>
</li>
<li>
<p>Copy主线程的重要性有两方面：</p>
<blockquote>
<p>1）是产生其他子线程的线程；</p>
<p>2）通常它必须最后完成执行比如执行各种关闭动作·</p>
</blockquote>
</li>
</ul>
<span id="more"></span>
<h2 id="子线程">子线程</h2>
<ul>
<li>可以看做是程序执行的一条分支，当子线程后动后会和主线程一起同时执行</li>
<li>主线程会等待所以子线程结束之后再结束</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop0</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;start loop0 at:&#x27;</span>, ctime())</span><br><span class="line">  sleep(<span class="number">4</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;loop0 done at:&#x27;</span>, ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop1</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;start loop1 at:&#x27;</span>, ctime())	</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;loop1 done at:&#x27;</span>, ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;starting at :&#x27;</span>, ctime())</span><br><span class="line">  <span class="comment"># 使用threading.Thread创建对象（子进程对象）</span></span><br><span class="line">  <span class="comment"># threading.Thread（target=函数名）</span></span><br><span class="line">  thread_1 = threading.Thread(target=loop0)</span><br><span class="line">  thread_2 = threading.Thread(target=loop1)</span><br><span class="line">  thread_1.start()</span><br><span class="line">  thread_2.start()</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;all done at:&#x27;</span>, ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main()</span><br><span class="line">    </span><br><span class="line">out：</span><br><span class="line">    starting at : Wed Nov <span class="number">13</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">27</span> <span class="number">2019</span></span><br><span class="line">    start loop0 at: Wed Nov <span class="number">13</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">27</span> <span class="number">2019</span></span><br><span class="line">    start loop1 at: Wed Nov <span class="number">13</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">27</span> <span class="number">2019</span></span><br><span class="line">    loop1 done at: Wed Nov <span class="number">13</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">27</span> <span class="number">2019</span></span><br><span class="line">    <span class="built_in">all</span> done at: Wed Nov <span class="number">13</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">27</span> <span class="number">2019</span></span><br><span class="line">    loop0 done at: Wed Nov <span class="number">13</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">31</span> <span class="number">2019</span></span><br></pre></td></tr></table></figure>
<h1>线程数量</h1>
<ul>
<li>目标
<ul>
<li>能够如何查看正在活动的线程数量</li>
<li>1.查看线程数量</li>
<li><code>threading.enumerate（）</code>获取当前所有活跃的线程对象列表。使用<code>len()</code>对列表求长度可以看到当前活跃的线程的个数</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop0</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;start loop0 at&#123;&#125;:&#x27;</span>.<span class="built_in">format</span>(threading.current_thread(), ctime()))</span><br><span class="line">    sleep(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;loop0 done at:&#x27;</span>, ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;start loop1 at&#123;&#125;:&#x27;</span>.<span class="built_in">format</span>(threading.current_thread(), ctime()))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;loop1 done at:&#x27;</span>, ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;starting at :&#x27;</span>, ctime())</span><br><span class="line">    <span class="comment"># 使用threading.Thread创建对象（子进程对象）</span></span><br><span class="line">    <span class="comment"># threading.Thread（target=函数名）</span></span><br><span class="line">    thread_1 = threading.Thread(target=loop0)</span><br><span class="line">    thread_2 = threading.Thread(target=loop1)</span><br><span class="line">    thread_1.start()</span><br><span class="line">    thread_2.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;all done at:&#x27;</span>, ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    main()</span><br><span class="line">    thread_list = threading.<span class="built_in">enumerate</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前线程数量：%d&quot;</span> % <span class="built_in">len</span>(thread_list))</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    starting at : Wed Nov <span class="number">13</span> <span class="number">14</span>:<span class="number">41</span>:<span class="number">20</span> <span class="number">2019</span></span><br><span class="line">    &lt;Thread(Thread-<span class="number">1</span>, started <span class="number">9916</span>)&gt;start loop0 atWed Nov <span class="number">13</span> <span class="number">14</span>:<span class="number">41</span>:<span class="number">20</span> <span class="number">2019</span>:</span><br><span class="line">    &lt;Thread(Thread-<span class="number">2</span>, started <span class="number">2868</span>)&gt;start loop1 atWed Nov <span class="number">13</span> <span class="number">14</span>:<span class="number">41</span>:<span class="number">20</span> <span class="number">2019</span>:</span><br><span class="line">    loop1 done at: Wed Nov <span class="number">13</span> <span class="number">14</span>:<span class="number">41</span>:<span class="number">20</span> <span class="number">2019</span></span><br><span class="line">    <span class="built_in">all</span> done at: Wed Nov <span class="number">13</span> <span class="number">14</span>:<span class="number">41</span>:<span class="number">20</span> <span class="number">2019</span></span><br><span class="line">    当前线程数量：<span class="number">2</span></span><br><span class="line">    loop0 done at: Wed Nov <span class="number">13</span> <span class="number">14</span>:<span class="number">41</span>:<span class="number">24</span> <span class="number">2019</span></span><br></pre></td></tr></table></figure>
<h1>线程参数及顺序</h1>
<ul>
<li>线程中传递参数有三种方法
<ul>
<li>1.使用元组传递<code> threading.Thread(target=fun_name,args=(参数。。。))</code><br>
<code>thread_1 = threading.Thread(target=loop0, args=(10, 21, 22))</code></li>
<li>2.使用字典传递 <code>threading.Thread(target=fun_name,kwargs=&#123;&quot;参数名&quot;: &quot;参数值&quot;....&#125;)</code><br>
<code>thread_1 = threading.Thread(target=loop0, kwargs=&#123;&quot;a&quot;: 10, &quot;b&quot;: 21, &quot;c&quot;: 22&#125;)</code></li>
<li>3.混合使用元组和字典传递 <code>threading.Thread(target=fun_name,args=(10, 21, 22), kwargs=&#123;&quot;参数名&quot;: &quot;参数值&quot;....&#125;)</code><br>
<code>thread_1 = threading.Thread(target=loop0, args=(10, 21), kwargs=&#123;&quot;c&quot;: 22&#125;)</code></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop0</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;参数：&quot;</span>, a, b, c)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start loop0 at:&quot;</span>, ctime())</span><br><span class="line">    sleep(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;loop0 done at:&quot;</span>, ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start loop1 at:&quot;</span>, ctime())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;loop1 done at:&quot;</span>, ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;starting at :&quot;</span>, ctime())</span><br><span class="line">    <span class="comment"># 线程中传递参数有三种方法</span></span><br><span class="line">    <span class="comment"># 1.使用元组传递 threading.Thread(target=fun_name,args=(参数。。。))</span></span><br><span class="line">    <span class="comment"># thread_1 = threading.Thread(target=loop0, args=(10, 21, 22))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.使用字典传递 threading.Thread(target=fun_name,kwargs=&#123;&quot;参数名&quot;: &quot;参数值&quot;....&#125;)</span></span><br><span class="line">    <span class="comment"># thread_1 = threading.Thread(target=loop0, kwargs=&#123;&quot;a&quot;: 10, &quot;b&quot;: 21, &quot;c&quot;: 22&#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.混合使用元组和字典传递 threading.Thread(target=fun_name,args=(10, 21, 22), kwargs=&#123;&quot;参数名&quot;: &quot;参数值&quot;....&#125;)</span></span><br><span class="line">    thread_1 = threading.Thread(target=loop0, args=(<span class="number">10</span>, <span class="number">21</span>), kwargs=&#123;<span class="string">&quot;c&quot;</span>: <span class="number">22</span>&#125;)</span><br><span class="line"></span><br><span class="line">    thread_2 = threading.Thread(target=loop1)</span><br><span class="line">    thread_1.start()</span><br><span class="line">    thread_2.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;all done at:&quot;</span>, ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  starting at : Wed Nov <span class="number">13</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">2019</span></span><br><span class="line">    参数： <span class="number">10</span> <span class="number">21</span> <span class="number">22</span></span><br><span class="line">    start loop0 at: Wed Nov <span class="number">13</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">2019</span></span><br><span class="line">    start loop1 at: Wed Nov <span class="number">13</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">2019</span></span><br><span class="line">    loop1 done at: Wed Nov <span class="number">13</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">2019</span></span><br><span class="line">    <span class="built_in">all</span> done at: Wed Nov <span class="number">13</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">2019</span></span><br><span class="line">    loop0 done at: Wed Nov <span class="number">13</span> <span class="number">15</span>:<span class="number">00</span>:04 <span class="number">2019</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>守护线程</h1>
<ul>
<li>守护线程：如果在程序中将子线程设置为守护线程，则该子线程会在主线程结束时自动退出，设置方式为<code>threaj.setDaemon（True）</code>，要在<code>thread.start0</code>之前设置，默认是<code>false</code>的，也就是主线程结束时，子线程依然在执行。</li>
<li>对于python应用我们都知道<code>main</code>方法是入口，它的运行代表着主线程开始工作了，我们都知道<code>Python</code>虚拟机里面有垃圾回收器的存在使得我们放心让<code>main</code>运行，然而这背后是垃圾回收线程作为守护着主线程的守护线程。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在执行work1...&quot;</span>, i)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建子线程</span></span><br><span class="line">    thread_woek1 = threading.Thread(target=work1)</span><br><span class="line">    <span class="comment"># 将子线程设置为守护线程</span></span><br><span class="line">    thread_woek1.setDaemon(<span class="literal">True</span>)</span><br><span class="line">    thread_woek1.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 睡眠</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;game over&quot;</span>)</span><br><span class="line">    <span class="comment"># 让程序退出，主线程主动结束</span></span><br><span class="line">    exit()</span><br><span class="line">    </span><br><span class="line">out:</span><br><span class="line">    正在执行work1... <span class="number">0</span></span><br><span class="line">    正在执行work1... <span class="number">1</span></span><br><span class="line">    正在执行work1... <span class="number">2</span></span><br><span class="line">    正在执行work1... <span class="number">3</span></span><br><span class="line">    game over</span><br></pre></td></tr></table></figure>
<h1>并行和并发</h1>
<ul>
<li>多任务的原理剖析
<ul>
<li>操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒…….这样反复执行下去。</li>
<li>表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。</li>
</ul>
</li>
</ul>
<p><img src="https://i.postimg.cc/Y0BWGx99/image-20191113153014444.png" alt="image-20191113153014444"></p>
<ul>
<li>并发：指的是任务数多于cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一超执行而已）</li>
<li>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。</li>
<li><strong>并发：任务数量大于CPU的核心数</strong></li>
</ul>
<p><img src="https://i.postimg.cc/DyVgLqD1/image-20191113152928736.png" alt="image-20191113152928736"></p>
<ul>
<li>并行：指的是任务数小于等于cpu核数，即任务真的是一起执行的</li>
<li><strong>并行：任务数量小于或等于CPU的核心数</strong></li>
</ul>
<p><img src="https://i.postimg.cc/2SYNcLqZ/image-20191113153308305.png" alt="d"></p>
<h1>多线程——共享全局变量</h1>
<ul>
<li>当多个线程修改同一个资源的时候，会出现资源竞争，导致计算结果有误</li>
<li>调用<code>join</code>方法优先让某个线程先执行
<ul>
<li>缺点：将多线程变成了单线程，影响执行效率</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="comment"># 声明g_num是一个全局变量</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;work1-----------------&quot;</span>, g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work2</span>():</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;work2-----------------&quot;</span>, g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    work_1 = threading.Thread(target=work1)</span><br><span class="line">    work_2 = threading.Thread(target=work2)</span><br><span class="line"></span><br><span class="line">    work_1.start()</span><br><span class="line">    <span class="comment"># 优先让t1线程先执行， t1执行完毕后，t2才能执行</span></span><br><span class="line">    work_1.join()</span><br><span class="line">    work_2.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>()) != <span class="number">1</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main-----------&quot;</span>, g_num)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>同步和异步</h1>
<ul>
<li>同步：<strong>多任务</strong>，多个任务之间执行的时候要求有先后顺序，必须一个先执行完成之后，另一个才能继续执行，<strong>只有一个主线</strong>。如：你说完，我再说（同一时间只能做一件事情）</li>
<li>异步，指的是：多个任务之间执行没有先后顺序，可以同时运行，执行的先后顺序不会有什么影响，<strong>存在的多条运行主线</strong>。如：发微信（可以不用等对方回复，继续发）、点外卖（点了外卖后，可以继续忙其他的事情，而不是坐等外卖，啥也不做）</li>
</ul>
<h1>线程锁</h1>
<p><img src="https://i.postimg.cc/fRzttk8Z/image-20191113180221255.png" alt="image-20191113180221255"></p>
<h2 id="互斥锁">互斥锁</h2>
<ul>
<li>当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制线程同步能够保证多个线程安全访问竞争源，最简单的同步机制是引入互斥锁。</li>
<li>互斥锁为资源引入一个状态：锁定/非锁定</li>
<li>某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。</li>
<li>互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="comment"># 声明g_num是一个全局变量</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">        <span class="comment"># 上锁</span></span><br><span class="line">        lock1.acquire()</span><br><span class="line"></span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 释放锁</span></span><br><span class="line">        lock1.release()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;work1-----------------&quot;</span>, g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work2</span>():</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">        <span class="comment"># 上锁</span></span><br><span class="line">        lock1.acquire()</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 解锁</span></span><br><span class="line">        lock1.release()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;work2-----------------&quot;</span>, g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(time.ctime())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一把互斥锁</span></span><br><span class="line">    lock1 = threading.Lock()</span><br><span class="line"></span><br><span class="line">    work_1 = threading.Thread(target=work1)</span><br><span class="line">    work_2 = threading.Thread(target=work2)</span><br><span class="line"></span><br><span class="line">    work_1.start()</span><br><span class="line">    work_2.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>()) != <span class="number">1</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main-----------&quot;</span>, g_num)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;总时间:&quot;</span>, time.ctime())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="死锁">死锁</h2>
<ul>
<li>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。</li>
<li>注意：使用完毕及时释放</li>
</ul>
<p><img src="https://i.postimg.cc/SKFn39T6/image-20191113203902756.png" alt="image-20191113203902756"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_value</span>(<span class="params">index</span>):</span><br><span class="line"></span><br><span class="line">    data_list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">    lock1.acquire()</span><br><span class="line">    <span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(data_list):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;下标越界&quot;</span>, index)</span><br><span class="line">        <span class="comment"># 若不释放就产生死锁</span></span><br><span class="line">        lock1.release()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(data_list[index])</span><br><span class="line">    lock1.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建一把锁</span></span><br><span class="line">    lock1 = threading.Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        t1 = threading.Thread(target=get_value, args=(i, ))</span><br><span class="line">        t1.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>线程概念</tag>
      </tags>
  </entry>
  <entry>
    <title>python的进程概念</title>
    <url>/2023/02/06/%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h1>进程</h1>
<h2 id="进程概念">进程概念</h2>
<ul>
<li>
<p>进程（Process）是资源分配的最小单位，是线程的容器。</p>
</li>
<li>
<p>程序是固定不变的，而进程会根据运行需要，让操作系统动态分配各种资源的CPU的时间片轮转，在不同的时间段切换执行不同的进程，但是切换进程是比较耗时的；就引来了轻量级进程，也就是所谓的线程，一个进程中包括多个线程（代码流，其实也就是进程中同时跑的多个方法体）</p>
</li>
<li>
<p>程序：例<code>xxx.py</code>这是程序，是一个静态的</p>
</li>
<li>
<p>进程：一个程序运行起来后，代码+用到的资源称之为进程，它是操作系统分配资源的基本单元。</p>
</li>
</ul>
<h2 id="进程状态">进程状态</h2>
<ul>
<li>
<p>工作中，任务数往往大于cpu的核数，即一定有一些任务正在执行，而另外一些任务在等待cpu进行执行，因此导致了有了不同的状态</p>
</li>
<li>
<p>进程状态</p>
<ul>
<li>就绪态：运行的条件都已经满足，正在等在cpu执行</li>
<li>执行态：cpu正在执行其功能</li>
<li>等待态：等待某些条件满足，例如一个程序sleep了，此时就处于等待态</li>
</ul>
</li>
</ul>
<h2 id="进程的创建-multiprocessing">进程的创建 - multiprocessing</h2>
<ul>
<li>
<p>multiprocessing模块就是跨平台版本的多进程模块，提供了一个Process类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情。</p>
</li>
<li>
<p>·创建子进程跟创建线程十分类似，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start0方法后动</p>
</li>
<li>
<p>Process语法结构如下：<br>
<code>Process([group [，target[，name，[args[，kwargs]]]）</code></p>
<ul>
<li>target：如果传递了函数的引用，这个子进程就执行这里（函数）的代码</li>
<li>args：给target指定的函数传递的参数，以元组的方式传递</li>
<li>kwargs：给target指定的函数传递命名参数</li>
<li>name：给进程设定一个名字，可以不设定</li>
<li>group：指定进程组，大多数情况下用不到</li>
</ul>
</li>
<li>
<p>Process创建的实例对象的常用方法：</p>
<ul>
<li>start()：后动子进程实例（创建子进程）</li>
<li>is_alive：判断进程子进程是否还在活着</li>
<li>join([timeout]）：是否等待子进程执行结束，或等待多少秒o</li>
<li>terminate：不管任务是否完成，立即终止子进程</li>
</ul>
</li>
<li>
<p>Process创建的实例对象的常用属性：</p>
<ul>
<li>name：当前进程的别名，默认为Process-N，N为从1开始递增的整数</li>
<li>pid：当前进程的pid（进程号）</li>
</ul>
</li>
<li>
<p><code>linux</code>系统可使用<code>kill</code>命令结束进程</p>
<span id="more"></span>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="comment"># 获取进程的父id</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在运行work1  第&#123;&#125;次..进程id&#123;&#125;，父进程id&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, os.getpid(), os.getppid()))</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 获取主进程名称</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;主进程名称&quot;</span>, multiprocessing.current_process())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取进程的编号</span></span><br><span class="line">    <span class="comment"># 1.获取进程id multiprocessing.current_process().pid</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;主进程编号&quot;</span>, multiprocessing.current_process().pid)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 模块os</span></span><br><span class="line">    <span class="comment"># print(os.getpid())</span></span><br><span class="line"></span><br><span class="line">    process_obj = multiprocessing.Process(target=work1, name=<span class="string">&quot;进程一&quot;</span>)</span><br><span class="line">    process_obj.start()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;XXXX&quot;</span>)</span><br><span class="line">    </span><br><span class="line">out:</span><br><span class="line">    主进程名称 &lt;_MainProcess(MainProcess, started)&gt;</span><br><span class="line">    主进程编号 <span class="number">31776</span></span><br><span class="line">    XXXX</span><br><span class="line">    正在运行work1  第<span class="number">0</span>次..进程id43088，父进程id31776</span><br><span class="line">    正在运行work1  第<span class="number">1</span>次..进程id43088，父进程id31776</span><br><span class="line">    正在运行work1  第<span class="number">2</span>次..进程id43088，父进程id31776</span><br><span class="line">    正在运行work1  第<span class="number">3</span>次..进程id43088，父进程id31776</span><br><span class="line">    正在运行work1  第<span class="number">4</span>次..进程id43088，父进程id31776</span><br><span class="line">    正在运行work1  第<span class="number">5</span>次..进程id43088，父进程id31776</span><br><span class="line">    正在运行work1  第<span class="number">6</span>次..进程id43088，父进程id31776</span><br><span class="line">    正在运行work1  第<span class="number">7</span>次..进程id43088，父进程id31776</span><br><span class="line">    正在运行work1  第<span class="number">8</span>次..进程id43088，父进程id31776</span><br><span class="line">    正在运行work1  第<span class="number">9</span>次..进程id43088，父进程id31776</span><br></pre></td></tr></table></figure>
<h2 id="进程参数，全局变量">进程参数，全局变量</h2>
<ul>
<li>进程间不能共享全局变量</li>
<li>子进程在运行时候，会将主进程的内容<code>复制</code>到自己进程中，修改只限自己进程有效。不影响其他进程和主进程</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;work1---------&quot;</span>, g_num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;work1---------&quot;</span>, g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p1 = multiprocessing.Process(target=work1)</span><br><span class="line">    p2 = multiprocessing.Process(target=work2)</span><br><span class="line"></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---------main-----------&quot;</span>, g_num)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    work1--------- <span class="number">20</span></span><br><span class="line">    work1--------- <span class="number">10</span></span><br><span class="line">    ---------main----------- <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="守护进程">守护进程</h2>
<ul>
<li><code>p1.daemon=True</code>设置子进程<code>p1</code>守护主进程，当主进程结束的时候，子进程也随之结束</li>
<li><code>p1.terminate（）</code>终止进程执行，并非是守护进程</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在运行work1...&#123;&#125;&quot;</span>.<span class="built_in">format</span>(time.ctime()))</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    process_obj = multiprocessing.Process(target=work1)</span><br><span class="line">    <span class="comment"># 开启守护</span></span><br><span class="line">    <span class="comment"># process_obj.daemon = True</span></span><br><span class="line">    process_obj.start()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我睡两秒就结束&quot;</span>, time.ctime())</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 终止进程</span></span><br><span class="line">    process_obj.terminate()</span><br><span class="line">    exit()</span><br><span class="line">out:</span><br><span class="line">    我睡两秒就结束   Thu Nov <span class="number">14</span> <span class="number">16</span>:04:<span class="number">29</span> <span class="number">2019</span></span><br><span class="line">    正在运行work1...Thu Nov <span class="number">14</span> <span class="number">16</span>:04:<span class="number">29</span> <span class="number">2019</span></span><br><span class="line">    正在运行work1...Thu Nov <span class="number">14</span> <span class="number">16</span>:04:<span class="number">30</span> <span class="number">2019</span></span><br><span class="line">    正在运行work1...Thu Nov <span class="number">14</span> <span class="number">16</span>:04:<span class="number">30</span> <span class="number">2019</span></span><br><span class="line">    正在运行work1...Thu Nov <span class="number">14</span> <span class="number">16</span>:04:<span class="number">31</span> <span class="number">2019</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>进程线程对比</h1>
<ul>
<li>功能
<ul>
<li>进程，能够完成多任务，比如在一台电脑上能够同时运行多个<code>QQ</code></li>
<li>线程，能够完成多任务，比如一个<code>QQ</code>中的多个聊天窗口</li>
</ul>
</li>
<li>使用区别
<ul>
<li><code>进程是系统进行资源分配和调度的一个独立单位</code>。</li>
<li><code>线程是进程的一介实体，是CPU调度和分派的基本单位</code>，它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程.</li>
<li>线程的划分尺度小于进程（资源比进程少），使得多线程程序的并发性高。</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率</li>
</ul>
</li>
<li>线程不能独立运行，必须依赖于线程</li>
</ul>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>多进程</th>
<th>多线程</th>
<th>总结</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据共享，同步</td>
<td>数据共享复杂，需要用<code>IPC</code>；数据是分开因为共享进程数据，数据共享简单</td>
<td>因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td>
<td>各有千秋</td>
</tr>
<tr>
<td>内存、CPU</td>
<td>占用内存多，切换复杂，CPU利用率低</td>
<td>占用内存少，切换简单，PU利用率高CPU</td>
<td>线程占优</td>
</tr>
<tr>
<td>创建销毁、切换</td>
<td>创建销毁、切换复杂，速度慢</td>
<td>创建销毁、切换简单，速度很快</td>
<td>线程占优</td>
</tr>
<tr>
<td>编程，调试</td>
<td>编程简单，调试简单</td>
<td>编程复杂，调试复杂</td>
<td>进程占优</td>
</tr>
<tr>
<td>可靠性</td>
<td>进程间不会互相影响</td>
<td>一个线程挂掉将导致整个进程挂掉</td>
<td>进程占优</td>
</tr>
<tr>
<td>分布式</td>
<td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td>
<td>应用于多核分布式</td>
<td>进程占优</td>
</tr>
</tbody>
</table>
<h2 id="进程线程取舍">进程线程取舍</h2>
<ul>
<li>需要频繁创建销毁的先使用线程；（如：Web服务器）</li>
<li>线程的切换速度快，所以在需要大量计算，切换频繁时用线程（如图像处理、算法处理）</li>
<li>因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；</li>
<li>需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。</li>
<li>都满足需求的情况下，用你最熟悉、最拿手的方式<br>
需要提醒的是：虽然有这么多的选择原则，但实际应用中基本上都是“进程+线程”的结合方式</li>
<li>在Python的原始解释器CPython中存在着GlL（Global Interpreter Lock，全局解释器锁），因此在解释执行python代码时，会产生互斥锁来限制线程对共享资源的访问，直到解释器遇到I/O操作或者操作次数达到一定数目时才会释放GlL。造成了即使在多核CPU中，多线程也只是做着分时切换而已</li>
</ul>
<h1>消息队列</h1>
<ul>
<li>可以使用multiprocessing模块的Queue实现多进程之间的数据传递</li>
<li>Queue本身是一个消息列队程序</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建队列(指定长度)</span></span><br><span class="line">queue = multiprocessing.Queue(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向队列中放值</span></span><br><span class="line">queue.put(<span class="string">&quot;Luenci&quot;</span>)</span><br><span class="line">queue.put(<span class="number">1</span>)</span><br><span class="line">queue.put([<span class="number">5</span>, <span class="number">2</span>])</span><br><span class="line">queue.put((<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>))</span><br><span class="line">queue.put(&#123;<span class="string">&quot;a&quot;</span>: <span class="number">6</span>, <span class="string">&quot;b&quot;</span>: <span class="number">8</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断队列是否全满</span></span><br><span class="line">isfull = queue.full()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列为全满：&quot;</span>, isfull)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 长度为5，放入第6个数据后，队列就进行入了阻塞状态，默认会等待以列先取出值再放入新的值</span></span><br><span class="line"><span class="comment"># queue.put(22)</span></span><br><span class="line"><span class="comment"># 不等待的放入</span></span><br><span class="line"><span class="comment"># queue.put_nowait(11)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向队列中取值</span></span><br><span class="line"><span class="comment"># 当队列为空的时候，再取值的时候，程序会进行阻塞状态，等待队列中有值再取</span></span><br><span class="line"></span><br><span class="line">value = queue.get()</span><br><span class="line"><span class="built_in">print</span>(value)</span><br><span class="line"><span class="comment"># 当队列为空的时候，再取值的时候，程序会直接报错</span></span><br><span class="line"><span class="comment"># value = queue.get_nowait()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 队列元素个数</span></span><br><span class="line">num = queue.qsize()</span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断队列是否为空</span></span><br><span class="line">empty = queue.empty()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列为空？：&quot;</span>, empty)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>进程池</h1>
<ul>
<li>进程池概述</li>
<li>当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。</li>
</ul>
<p><img src="https://i.postimg.cc/wMY848xp/image-20191114203943978.png" alt="image-20191114203943978"></p>
<ul>
<li>初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务。</li>
</ul>
<h2 id="进程池实现方式">进程池实现方式</h2>
<ul>
<li>同步方式：<code>pool.apply()</code></li>
<li>异步方式<code>pool.apply_async（copy_work）</code></li>
</ul>
<h2 id="核心方法">核心方法</h2>
<ul>
<li><code>multiprocessing.Pool</code>常用函数解析：
<ul>
<li>apply（）：–进程池中进程以同步方式执行任务</li>
</ul>
</li>
</ul>
<p><img src="https://i.postimg.cc/SR4Q2zMC/image-20191114204338304.png" alt="image-20191114204338304"></p>
<ul>
<li><code>apply_async（func[，args[，kwds]]）</code>：–使用非阻塞方式调用<code>func</code>（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），<code>args</code>为传递给<code>func</code>的参数列表，<code>kwds</code>为传递给<code>func</code>的关键字参数列表</li>
</ul>
<p><img src="https://i.postimg.cc/vTGgRKXJ/image-20191114204556059.png" alt="image-20191114204556059"></p>
<h1>进程池中的进程通信</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_queue</span>(<span class="params">queue</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span> queue.full():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;队列已满&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            queue.put(i)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;成功添加：&quot;</span>, i)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_queue</span>(<span class="params">queue</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> queue.qsize() == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;队列已空&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        value = queue.get()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;已经读取&quot;</span>, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建进程池</span></span><br><span class="line">    pool = multiprocessing.Pool(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建进程池中的队列</span></span><br><span class="line">    queue = multiprocessing.Manager().Queue(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 同步的方式执行</span></span><br><span class="line">    <span class="comment"># pool.apply(write_queue, args=(queue,))</span></span><br><span class="line">    <span class="comment"># pool.apply(read_queue, args=(queue,))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 异步的方式执行</span></span><br><span class="line">    <span class="comment"># apply_async（）返回值ApplyResult对象，该对象有一个wait（）的方法</span></span><br><span class="line">    result = pool.apply_async(write_queue, args=(queue,))</span><br><span class="line">    result.wait()</span><br><span class="line">    pool.apply_async(read_queue, args=(queue,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不再接收新的任务</span></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">out:</span><br><span class="line">    成功添加： <span class="number">0</span></span><br><span class="line">    成功添加： <span class="number">1</span></span><br><span class="line">    成功添加： <span class="number">2</span></span><br><span class="line">    成功添加： <span class="number">3</span></span><br><span class="line">    成功添加： <span class="number">4</span></span><br><span class="line">    成功添加： <span class="number">5</span></span><br><span class="line">    成功添加： <span class="number">6</span></span><br><span class="line">    成功添加： <span class="number">7</span></span><br><span class="line">    成功添加： <span class="number">8</span></span><br><span class="line">    成功添加： <span class="number">9</span></span><br><span class="line">    已经读取 <span class="number">0</span></span><br><span class="line">    已经读取 <span class="number">1</span></span><br><span class="line">    已经读取 <span class="number">2</span></span><br><span class="line">    已经读取 <span class="number">3</span></span><br><span class="line">    已经读取 <span class="number">4</span></span><br><span class="line">    已经读取 <span class="number">5</span></span><br><span class="line">    已经读取 <span class="number">6</span></span><br><span class="line">    已经读取 <span class="number">7</span></span><br><span class="line">    已经读取 <span class="number">8</span></span><br><span class="line">    已经读取 <span class="number">9</span></span><br><span class="line">    队列已空</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>进程概念</tag>
      </tags>
  </entry>
  <entry>
    <title>数据科学之数据可视化</title>
    <url>/2023/02/06/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>数据可视化概述</h1>
<ul>
<li>可视化的目的，是对数据进行可视化处理，以更明确地，有效的传递信息。</li>
</ul>
<h2 id="数据可视化意义">数据可视化意义</h2>
<ul>
<li>数据可视化是为了从数据中寻找三个方面的信息。
<ul>
<li>模式。指数据中的规律。</li>
<li>关系。指数据间的相关性。
<ul>
<li>数据间的比较</li>
<li>数据的构成</li>
<li>数据的分布或联系</li>
</ul>
</li>
<li>异常。指有问题的数据。</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h2 id="数据可视化的作用">数据可视化的作用</h2>
<ul>
<li>记录信息。用图形的方式描述各种具体或抽象的事物。</li>
<li>分析推理。有效的提升了信息认知的效率，从而有助于人们更快地分析和推理出有效信息。</li>
<li>信息传播和协同。</li>
</ul>
<h2 id="数据可视化的分类">数据可视化的分类</h2>
<ul>
<li>科学可视化</li>
<li>信息可视化</li>
<li>可视分析学</li>
</ul>
<h2 id="数据可视化基础">数据可视化基础</h2>
<ul>
<li>
<p>数据类型</p>
<ul>
<li>
<p>根据数据模型，可将数据分为</p>
<ul>
<li>浮点数，整数，字符等</li>
</ul>
</li>
<li>
<p>根据概念模型</p>
<ul>
<li>
<p>类别型数据，有序型数据，区间型数据和比值型数据</p>
<ul>
<li>
<p>类别型数据：用于区分物体</p>
</li>
<li>
<p>有序型数据：用来表示对象间的顺序关系</p>
</li>
<li>
<p>区间型数据：用于得到对象间的定量关系。</p>
</li>
<li>
<p>用于比较数值间的比列关系，可以精确地定义比例</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据预处理">数据预处理</h3>
<ul>
<li>数据的预处理的目的是提升数据质量</li>
<li>数据质量包含以下六方面
<ul>
<li>有效性：数据与实际情况对应时，是否违背约束条件</li>
<li>准确性：数据能否精确的反映现实。</li>
<li>完整性：采集数据集是否包含了数据源中 的所有数据点：且样本的属性都是完整的。</li>
<li>一致性：整个数据集中的数据的衡量标准要一致</li>
<li>时效性：数据适合当下时间区间内的分析任务</li>
<li>可行性：数据源中的数据是使用者可依赖的。</li>
</ul>
</li>
<li>数据预处理步骤如下
<ul>
<li>数据清理：指修正数据中的错误，识别脏数据，更正不一致数据的过程。</li>
<li>数据集成：指把来自不同数据的同类数据进行合并，减少数据冲突，降低数据冗余程度等。</li>
<li>数据归约：指在保证数据挖掘结果准确性的前提下，最大限度地精简数据量，得到简化的数据集。</li>
<li>数据转换：指对数据进行规范化处理</li>
</ul>
</li>
</ul>
<h3 id="数据组织与管理">数据组织与管理</h3>
<ul>
<li>大数据存储利用的是分布式存储与访问计数，它具有高效，容错性强等特点。
<ul>
<li>分布式文件系统
<ul>
<li>分布式文件系统是指文件在物理上可能被分散存储在不同地点的节点上，各节点通过计算机网络进行通信和数据传输，但仍然是一个完整的文件。常用的分布式系统有HDFS（hadoop分布式文件系统），GFS（Google分布式文件系统）等。</li>
<li>文档存储
<ul>
<li>文档存储支持对结构化数据的访问，一般以键值对的方式进行存储。</li>
<li>文档存储类型也支持数组和列值键</li>
</ul>
</li>
<li>列式存储
<ul>
<li>列式存储是指以流的方式在列中存储所有的数据</li>
</ul>
</li>
<li>键式存储
<ul>
<li>以Key-Value存储，简称KV存储</li>
</ul>
</li>
<li>图形数据库
<ul>
<li>图形数据库是NOSQL数据库的一种，是一种非关系型的数据库，它应用图形理论存储实体间的关系信息。</li>
</ul>
</li>
<li>关系型数据库
<ul>
<li>关系模型是最传统的数据存储模型，数据按行存储在有架构界定的表中。用户可使用基于关系代数演算的结构化查询语言提供相应的语法查找符合条件的记录。</li>
</ul>
</li>
<li>内存数据库
<ul>
<li>内存数据库就是将数据放在内存中直接操作的数据库。特点速度快，能处理实时型业务</li>
</ul>
</li>
<li>数据仓库
<ul>
<li>数据仓库是一种特殊的数据库，一般用于存储海量数据，并直接支持后续的分析和决策操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据分析与数据挖掘">数据分析与数据挖掘</h3>
<ul>
<li>
<p>数据分析</p>
<ul>
<li>统计分析
<ul>
<li>是指对数据进行统计描述和统计推断的过程</li>
</ul>
</li>
<li>探索性数据分析
<ul>
<li>是对调查，观测所得到的一些初步的杂乱无章的数据，在尽量少的先验假设下进行处理，通过作图，制表等形式和方程拟合，计算某些特征量等手段，探索数据的结构和规律的一种数据分析方法。</li>
</ul>
</li>
<li>验证性数据分析
<ul>
<li>是指在已经有事先假设的关系模型等情况下，通过数据分析来验证已提出的假设</li>
</ul>
</li>
<li>在线分析和处理
<ul>
<li>是一种交互式探索大规模多维数据集的方法。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数据挖掘</p>
<ul>
<li>数据挖掘一般是指从大量的数据中通过算法搜索隐藏于其中的信息的过程。</li>
</ul>
</li>
<li>
<p>常见的数据挖掘分析方法有分类与预测，聚类分析，关联性分析和异常分析等。</p>
<ul>
<li>
<p>分类与预测</p>
</li>
<li>
<p>聚类分析</p>
</li>
<li>
<p>关联分析</p>
</li>
<li>
<p>异常分析</p>
</li>
</ul>
</li>
<li>
<p>数据挖掘的步骤</p>
<ul>
<li>确定业务对象</li>
<li>数据准备</li>
<li>数据挖掘</li>
<li>结果分析</li>
<li>知识的同化</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>数据可视化概念</tag>
      </tags>
  </entry>
  <entry>
    <title>数据科学之统计学习</title>
    <url>/2023/02/06/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>统计学</h1>
<h2 id="中心倾向">中心倾向</h2>
<ul>
<li>均值（常用的额）</li>
<li>中位数</li>
<li>分位数：它表示少于数据中特定百分比的一个值</li>
<li>众数</li>
</ul>
<span id="more"></span>
<h2 id="离散度">离散度</h2>
<ul>
<li>
<p>极差</p>
</li>
<li>
<p>方差</p>
<ul>
<li>
<p>统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数</p>
</li>
<li>
<p>概率论中方差用来度量随机变量)和其数学期望（即均值）之间的偏离程度</p>
</li>
<li>
<p>计算公式</p>
</li>
<li>
<p>$$<br>
s^2 = \frac{\sum_{}(x-u)^2}{N}<br>
$$</p>
</li>
</ul>
</li>
<li>
<p>标准差</p>
<ul>
<li>
<p>中文环境中又常称<code>均方差</code>，是离均差平方的算术平均数的平方根，用σ表示。标准差是方差的算术平方根</p>
</li>
<li>
<p>计算公式</p>
</li>
<li>
<p>$$<br>
σ = \sqrt\frac{\sum_{}(x-u)^2}{N}<br>
$$</p>
</li>
</ul>
</li>
</ul>
<h2 id="相关性">相关性</h2>
<ul>
<li>
<p>协方差</p>
<ul>
<li><strong>协方差</strong>（Covariance）在概率论和统计学中用于衡量两个变量的总体误差。而方差是协方差的一种特殊情况，即当两个变量是相同的情况。</li>
<li>计算公式</li>
<li><img src="http://chuantu.xyz/t6/702/1563087781x2073530529.jpg" alt=""></li>
</ul>
</li>
</ul>
<h1>概率论</h1>
<h2 id="不独立和独立">不独立和独立</h2>
<ul>
<li>
<p>如果事件E和事件F独立意味着两个事同时发生的概率等于它们分别发生的概率的乘积。</p>
</li>
<li>
<p>$$<br>
P（E, F） = P(E)*P(F)<br>
$$</p>
</li>
<li>
<p>条件概率</p>
<ul>
<li>
<p>如果事件E与事件F独立，那么定义：</p>
<ul>
<li>$$<br>
P（E, F） = P(E)*P(F)<br>
$$</li>
</ul>
</li>
<li>
<p>如果两者不一定独立（并且概率都不为0），那么概率公式为：（已知F发生，在此条件下E发生的概率）<br>
$$<br>
P（E|F） = P（E, F）/P（F）<br>
$$</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>统计学和概率论</category>
      </categories>
      <tags>
        <tag>数学知识</tag>
      </tags>
  </entry>
  <entry>
    <title>socket网络编程实战-斗鱼弹幕获取</title>
    <url>/2023/02/06/%E6%96%97%E9%B1%BC%E5%BC%B9%E5%B9%95%E6%8A%93%E5%8F%96/</url>
    <content><![CDATA[<h1>asyncore模块</h1>
<h2 id="介绍">介绍</h2>
<blockquote>
<p>这个模块为异步socket的服务器客户端通信提供简单的接口。</p>
<p>该模块提供了异步socket服务客户端和服务器的基础架构。</p>
<p>相比python原生的socket api，asyncore具备有很大的优势，asyncore对原生的socket进行封装，提供非常简洁优秀的接口，利用asyncore覆写相关需要处理的接口方法，就可以完成一个socket的网络编程，从而需要处理复杂的socket网络状况以及多线程处理等等。</p>
</blockquote>
<h2 id="实现流程">实现流程</h2>
<p><img src="https://i.postimg.cc/VvCFY8Qg/image-20191029171333100.png" alt="image-asynocre"></p>
<h1>客户端 Socket 开发基本使用</h1>
<p>1.定义类继承自<code>asyncore.dispatcher</code></p>
<p>2.实现类中的回调代码</p>
<ul>
<li>
<p>实现构造函数</p>
<ul>
<li>调用父类方法</li>
<li>创建 <code>Socket</code>对象</li>
<li>连接服务器</li>
</ul>
</li>
<li>
<p>实现<code>handle_connect</code>回调函数</p>
<blockquote>
<p>当<code>socket</code>连接服务器成功时回调该函数</p>
</blockquote>
</li>
<li>
<p>实现<code>writable</code>回调函数</p>
<blockquote>
<p>描述是否有数据需要被发送到服务器。返回值为<code>True</code>表示可写，<code>False</code>表示不可写，如果不实现默认返回为<code>True</code>，当返回<code>True</code>时，回调函数<code>handle_write</code>将被触发</p>
</blockquote>
</li>
<li>
<p>实现<code>handle_write</code> 回调函数</p>
<blockquote>
<p>当有数据需要发送时（<code>writable</code>回调函数返回<code>True</code>时），该函数被触发，通常情况下在该函数中编写<code>send</code>方法发送数据</p>
</blockquote>
</li>
<li>
<p>实现<code>readable</code>回调函数</p>
<blockquote>
<p>描述是否有数据从服务端读取。返回<code>True</code> 表示有数据需要读取，<code>False</code>表示没有数据需要被读取，当不实现默认返回为<code>True</code>，当返回<code>True</code> 时，回调函数<code>handle_read</code>将被触发</p>
</blockquote>
</li>
<li>
<p>实现<code>handle_read </code>回调函数</p>
<blockquote>
<p>当有数据需要读取时触发（<code>readable</code>回调函数返回<code>True</code><br>
时），该函数被触发，通常情况下在该函数中编写<code>recv</code>方法接收数据</p>
</blockquote>
</li>
<li>
<p>实现<code>handle_error</code>回调函数</p>
<blockquote>
<p>当程序运行过程发生异常时回调</p>
</blockquote>
</li>
<li>
<p>实现<code>handle_close</code>回调函数</p>
<blockquote>
<p>当连接被关闭时触发</p>
</blockquote>
</li>
<li>
<p>3.创建对象并且执行<code>asyncore.loop</code>进入运行循环</p>
<ul>
<li><code>timeout</code>表示一次循环所需要的时长</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncore</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义类继承自 asyncore.dispather</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">scoket_client</span>(asyncore.dispatcher):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实现类中的回调代码</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host, port</span>):</span><br><span class="line">        <span class="comment"># 调用父类的方法</span></span><br><span class="line">        asyncore.dispatcher.__init__(self)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建 Scoket 服务器</span></span><br><span class="line">        self.create_socket()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 连接地址</span></span><br><span class="line">        address = (host, port)</span><br><span class="line">        self.connect(address)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实现handle_connect回调函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_connect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;连接成功&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实现writable函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">writable</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实现handle_write回调函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_write</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 内部实现对服务器发送数据代码</span></span><br><span class="line">        <span class="comment"># 调用 send 方法发送数据，参数是字节数据</span></span><br><span class="line">        self.send(<span class="string">&quot;hello world&quot;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="comment"># self.send(&quot;hello world&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实现readable回调函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">readable</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实现handle_read回调函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_read</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 主动接收数据</span></span><br><span class="line">        result = self.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实现handle_error回调函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_error</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 编写处理错误方法</span></span><br><span class="line">        t, e, trace = sys.exc_info()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实现handle_close回调函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_close</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;连接关闭&quot;</span>)</span><br><span class="line">        self.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象并且执行asyncore.loop 进入循环</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    client = scoket_client(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始启动运行循环</span></span><br><span class="line">    asyncore.loop(timeout=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1>斗鱼弹幕实战</h1>
<ul>
<li>
<p>文档资料</p>
<ul>
<li>斗鱼弹幕服务器第三方接入协议V1.6.2.pdf 官方提供协议文档弹幕</li>
</ul>
</li>
</ul>
<h2 id="客户端开发流程">客户端开发流程</h2>
<ul>
<li>
<p>连接初始化</p>
<ul>
<li>使用TCP连接服务器
<ul>
<li>IP地址：<a href="http://openbarrage.douyutv.com">openbarrage.douyutv.com</a></li>
<li>端口：8601</li>
</ul>
</li>
<li>客户端向弹幕服务器发送登录请弧，登录弹幕服务器</li>
<li>弹幕服务器收到客户端登录请求并完成登录后，返回登录成功消息给客户端</li>
<li>客户端收到登录成功消息后发送进入弹幕分组请求给弹幕服务器</li>
<li>弹幕服务器接受到客户端弹幕分组请求后将客户端添加到请求指定的弹幕分组中</li>
</ul>
</li>
<li>
<p>服务过程</p>
<ul>
<li>客户端每隔45秒发送心跳给弹幕服务器，弹幕服务器回复心跳信息给客户端</li>
<li>弹幕服务器如有广播信息，则推送给客户端，服务器消息协议</li>
</ul>
</li>
<li>
<p>断开连接</p>
<ul>
<li>客户端发送登出消息</li>
<li>客户端关闭TCP连接</li>
</ul>
</li>
</ul>
<h2 id="数据发送和接收流程">数据发送和接收流程</h2>
<p><img src="https://i.postimg.cc/qMp1Qkm8/image-20191030102511977.png" alt="image-数据发送和接收流程"></p>
<h3 id="数据包讲解">数据包讲解</h3>
<p><img src="https://i.postimg.cc/4dShcQFL/image-20191030103731258.png" alt="image-20191030103731258"></p>
<ul>
<li>消息长度：4 字节小端整数，表示整条消息（包括自身）长度（字节数）消息长度出现两遍，二者相同</li>
<li>消息类型：2 字节小端整数，表示消息类型。</li>
<li>取值如下：
<ul>
<li>689 客户端发送给弹幕服务器的文本格式数据</li>
<li>690 弹幕服务器发送给客户端的文本格式数据。</li>
</ul>
</li>
<li>加密字段：暂时未用，默认为 0。</li>
<li>保留字段：暂时未用，默认为 0。</li>
<li>数据部分：斗鱼独创序列化文本数据，结尾必须为‘\0’。</li>
<li>详细序列化、反序列化算法见下节。（所有协议内容均为 UTF-8 编码）</li>
</ul>
<h3 id="数据包的封装">数据包的封装</h3>
<blockquote>
<p>对数据包进行对象化封装，对数据的封装方便以后使用，实现对象和二进制数据之间的转换</p>
</blockquote>
<ul>
<li>通过参数构建数据包对象</li>
<li>实现获取数据包长度的方法</li>
<li>实现获取二进制数据的方法</li>
</ul>
<h2 id="实现发送数据包">实现发送数据包</h2>
<p><img src="https://i.postimg.cc/NGH0BBG3/image-20191030165625836.png" alt="image-20191030165625836"></p>
<ul>
<li>构建发送数据包的容器</li>
<li>实现回调函数，判断容器中有数据就发送没有数据不发送</li>
<li>实现登录函数
<ul>
<li>构建登录数据包</li>
<li>把数据包添加到发送数据包容器中</li>
</ul>
</li>
</ul>
<h2 id="实现接收数据">实现接收数据</h2>
<p><img src="https://i.postimg.cc/mkDvTKnp/image-20191030174404676.png" alt="image-20191030174404676"></p>
<ul>
<li>构建接收数据包队列</li>
<li>读取回调函数中读取数据
<ul>
<li>读取长度</li>
<li>读取内容</li>
<li>构建数据包对象</li>
<li>把数据包放入接收数据包容器中</li>
</ul>
</li>
<li>构建处理数据包线程
<ul>
<li>构建线程</li>
<li>实现回调函数处理数据</li>
</ul>
</li>
</ul>
<h2 id="实现外部传入回调函散">实现外部传入回调函散</h2>
<blockquote>
<p>通过外部指定回调函数实现自定义数据处理</p>
</blockquote>
<ul>
<li>添加参数<code>callback</code>
<ul>
<li>构造函数中添加参数</li>
<li>外部传入自定义回调函数</li>
</ul>
</li>
<li>在处理接收数据包的线程中调用回调函数</li>
</ul>
<h2 id="数据内容序列话与反序列化">数据内容序列话与反序列化</h2>
<ul>
<li>1 键 key 和值 value 直接采用‘@=’分割</li>
<li>2 数组采用‘/’分割</li>
<li>3 如果 key 或者 value 中含有字符‘/’，则使用‘@S’转义</li>
<li>4 如果 key 或者 value 中含有字符‘@’ ，使用‘@A’转义<br>
举例：
<ul>
<li>多个键值对数据：key1@=value1/key2@=value2/key3@=value3/</li>
<li>数组数据：value1/value2/value3/</li>
</ul>
</li>
<li>不同消息有相同的协议头、序列化方式</li>
</ul>
<h2 id="加入弹幕分组">加入弹幕分组</h2>
<blockquote>
<p>​        第三方平台建议选择-9999（即海量弹幕模式  )</p>
</blockquote>
<h2 id="心跳机制">心跳机制</h2>
<blockquote>
<p>作用是让服务器解决假死连接问题，客户端必须每隔45秒发送一次请求，否则就会被主动断开。</p>
</blockquote>
<ul>
<li>实现发送心跳函数
<ul>
<li>构建心跳数据包</li>
<li>把数据包添加到发送数据包容器队列中</li>
</ul>
</li>
<li>构建心跳线程
<ul>
<li>构建心跳线程</li>
<li>添加触发机制</li>
<li>添加暂停机制</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>查看mysql连接状况</title>
    <url>/2023/02/06/%E6%9F%A5%E7%9C%8Bmysql%E8%BF%9E%E6%8E%A5%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<p>使用<a href="http://www.boke365.net/archives/tag/mysql">mysql</a>- uroot -p登录后</p>
<ul>
<li>
<p>执行命令: show processlist;</p>
</li>
<li>
<p>查询当前数据库用户连接情况.</p>
</li>
<li>
<p>如果是root帐号,你能看到所有用户的当前连接.</p>
</li>
<li>
<p>如果是其它普通帐号,只能看到自己占用的连接.</p>
</li>
<li>
<p>只列出前100条</p>
<ul>
<li><code>show processlist;</code></li>
</ul>
</li>
<li>
<p>如果想全列出请使用</p>
<ul>
<li><code>show full processlist;</code></li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> processlist;</span><br><span class="line"></span><br><span class="line">命令： <span class="keyword">show</span> status;</span><br><span class="line"></span><br><span class="line">命令：<span class="keyword">show</span> status <span class="keyword">like</span> ‘<span class="operator">%</span>下面变量<span class="operator">%</span>’;</span><br></pre></td></tr></table></figure>
<ul>
<li>Aborted_clients	由于客户没有正确关闭连接已经死掉,已经放弃的连接数量.</li>
<li>Aborted_connects	尝试已经失败的MySQL服务器的连接的次数.</li>
<li>Connections	试图连接MySQL服务器的次数.</li>
<li>Created_tmp_tables	当执行语句时,已经被创造了的隐含临时表的数量.</li>
<li>Delayed_insert_threads	正在使用的延迟插入处理器线程的数量.</li>
<li>Delayed_writes	用INSERT DELAYED写入的行数.</li>
<li>Delayed_errors	用INSERT DELAYED写入的发生某些错误(可能重复键值)的行数.</li>
<li>Flush_commands	执行FLUSH命令的次数.</li>
<li>Handler_delete	请求从一张表中删除行的次数.</li>
</ul>
<span id="more"></span>
<ul>
<li>Handler_read_first	请求读入表中第一行的次数.</li>
<li>Handler_read_key	请求数字基于键读行.</li>
<li>Handler_read_next	请求读入基于一个键的一行的次数.</li>
<li>Handler_read_rnd	请求读入基于一个固定位置的一行的次数.</li>
<li>Handler_update	请求更新表中一行的次数.</li>
<li>Handler_write	请求向表中插入一行的次数.</li>
<li>Key_blocks_used	用于关键字缓存的块的数量.</li>
<li>Key_read_requests	请求从缓存读入一个键值的次数.</li>
<li>Key_reads	从磁盘物理读入一个键值的次数.</li>
<li>Key_write_requests	请求将一个关键字块写入缓存次数.</li>
<li>Key_writes	将一个键值块物理写入磁盘的次数.</li>
<li>Max_used_connections	同时使用的连接的最大数目.</li>
<li>Not_flushed_key_blocks	在键缓存中已经改变但是还没被清空到磁盘上的键块.</li>
<li>Not_flushed_delayed_rows	在INSERT DELAY队列中等待写入的行的数量.</li>
<li>Open_tables	打开表的数量.</li>
<li>Open_files	打开文件的数量.</li>
<li>Open_streams	打开流的数量(主要用于日志记载）</li>
<li>Opened_tables	已经打开的表的数量.</li>
<li>Questions	发往服务器的查询的数量.</li>
<li>Slow_queries	要花超过long_query_time时间的查询数量.</li>
<li>Threads_connected	当前打开的连接的数量.</li>
<li>Threads_running	不在睡眠的线程数量.</li>
<li>Uptime 服务器工作了多少秒.</li>
</ul>
]]></content>
      <categories>
        <category>SQL知识</category>
      </categories>
      <tags>
        <tag>SQL命令</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的正则表达式</title>
    <url>/2023/02/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="匹配小数">匹配小数</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0-9]&#123;1,&#125;[.][0-9]*</span><br></pre></td></tr></table></figure>
<h2 id="匹配整数">匹配整数</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0-9]</span><br></pre></td></tr></table></figure>
<h2 id="中文的匹配">中文的匹配</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[\u4e00-\u9fa5]</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="特殊符号和字符：">特殊符号和字符：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[A-Z0-9a-z]:  A,1,a</span><br><span class="line">[abc]*:  aaa,abc,acc,匹配前面的正则0次或多次</span><br><span class="line">a？:  a,匹配前面的出现正则0次或一次</span><br><span class="line">.：  匹配任意字符\n\t1,2.3,4,5.a,c</span><br><span class="line">.*:  acb,aaa,weaijdiajdw,desd</span><br><span class="line">.*?:  非贪婪匹配</span><br><span class="line">\d:  匹配任何数字  [0-9]*:002121,5498464</span><br><span class="line">\s:  匹配任意空白符 \n\t\v\r\f</span><br><span class="line">\w:  匹配任何数字，字母，字符 [A-Za-z0-9][u4e00-u9fa5]  ：匹配中文</span><br><span class="line"></span><br><span class="line">a|b a,b</span><br><span class="line">1|2 1,2</span><br><span class="line"></span><br><span class="line">&#123;int&#125;:指明正则出现的次数</span><br><span class="line">+：匹配前面出现的正则一次或多次</span><br><span class="line">?：0次或一次</span><br><span class="line">*：0次或多次</span><br><span class="line">^:匹配开头</span><br><span class="line">$:匹配结尾</span><br><span class="line">^$:空</span><br><span class="line">[^A-Z]: 除了A-Z都匹配</span><br></pre></td></tr></table></figure>
<h2 id="匹配双字节字符-包括汉字在内-：">匹配<strong>双字节字符</strong>(包括汉字在内)：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[^\x00-\xff]</span><br></pre></td></tr></table></figure>
<h2 id="匹配空白行的正则表达式：">匹配<strong>空白行</strong>的正则表达式：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\n\s*\r</span><br></pre></td></tr></table></figure>
<h2 id="匹配HTML标记的正则表达式：">匹配<strong>HTML标记</strong>的正则表达式：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;(\s*?)[^&gt;]*&gt;.*?|&lt;.*?&gt;</span><br></pre></td></tr></table></figure>
<h2 id="匹配首尾空白字符的正则表达式：">匹配<strong>首尾空白字符</strong>的正则表达式：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^\s*|\s*$</span><br></pre></td></tr></table></figure>
<h2 id="匹配Email地址的正则表达式：">匹配<strong>Email地址</strong>的正则表达式：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="匹配网址URL的正则表达式：">匹配<strong>网址URL</strong>的正则表达式：</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[a-zA-z]+://[^\s]*</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="匹配帐号是否合法-字母开头，允许5-16字节，允许字母数字下划线-：">匹配<strong>帐号是否合法</strong>(字母开头，允许5-16字节，允许字母数字下划线)：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="匹配国内电话号码：">匹配<strong>国内电话号码</strong>：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="匹配腾讯QQ号：">匹配<strong>腾讯QQ号</strong>：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1-9][0-9]&#123;4,&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="匹配中国邮政编码：">匹配<strong>中国邮政编码</strong>：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1-9]\d&#123;5&#125;(?!\d)</span><br><span class="line">评注：中国邮政编码为6位数字</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="匹配身份证：">匹配<strong>身份证</strong>：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\d&#123;15&#125;|\d&#123;18&#125;</span><br><span class="line">评注：中国的身份证为15位或18位</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="匹配ip地址：">匹配<strong>ip地址</strong>：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\d+\.\d+\.\d+\.\d+</span><br><span class="line">评注：提取ip地址时有用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="匹配特定数字：">匹配<strong>特定数字</strong>：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[1-9]\d*$　 　 //匹配正整数</span><br><span class="line">^-[1-9]\d*$ 　 //匹配负整数</span><br><span class="line">^-?[1-9]\d*$　　 //匹配整数</span><br><span class="line">^[1-9]\d*|0$　 //匹配非负整数（正整数 + 0）</span><br><span class="line">^-[1-9]\d*|0$　　 //匹配非正整数（负整数 + 0）</span><br><span class="line">^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$　　 //匹配正浮点数</span><br><span class="line">^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$　 //匹配负浮点数</span><br><span class="line">^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$　 //匹配浮点数</span><br><span class="line">^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）</span><br><span class="line">^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$　　//匹配非正浮点数（负浮点数 + 0）</span><br><span class="line">评注：处理大量数据时有用，具体应用时注意修正</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="匹配特定字符串：">匹配<strong>特定字符串</strong>：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串</span><br><span class="line">^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串</span><br><span class="line">^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串</span><br><span class="line">^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串</span><br><span class="line">^\w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>高德无人机科技研发岗（测试工程师）面试总结</title>
    <url>/2023/02/06/%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8bac687529142365b613f5c4f7d5a22a6f210232d97441adcbebf7ab9b7019da">09f4ce2f9c598f3c74d211220e98fd099e7b9420685eb2146a81fbf485178846fc0af7b2cd8fdb6fa80af7d2d40a2aa50fb89ea0241a939e13325ef40119c1c220d047fadde2ec51f56dc2915ddf7d838d0cdb691197da8c5a5fcd1e0e1effb645eac2ab0e9de820ba4c3380f1322e3abf77adaa382830edc71a6d93ab4175093f3450f3b5b9c8a9a2a036384a502c44cfa39c807df2985250bc805fe9425fb0847453b8de459ca36200ca9459552f8fc469c7cfd018f2e4943ef19838644249953a5045ba776a19907e4d1270fcfb5c5a78e4f852c933f8818a9155dd2a3a3854ed27a7b7fb2832e1b5381925f56c76dc7aa97e509fc2f370223000041dfe61f1d20ef439ab8d72c11f8bb873ce6feed2a5e292d354aa11e39698d80a69b84f519712d05477c641883947a0a20945f44570359b8f3d267c1964c7a1e3177b9c665b6d17388cecde937833a4870a42d1e8a53cbc64e9965e9356e021e3a626cd7ac3d0384333b7e88dbf793b63a22c8b86ed0f1a31976e64dba4e5c04a25b607598fe4be3620078262871e78a62f1eb2909ca3bc38345cd017b310a5ee6d62a7e5c9174c76dcc6476cbcba2ded882d3239a47c667bd148e91ced744acfde43dc50737fe49ff8f1a37b1b18f1f2f6a69165ebb190599cefade557f03cee69cb5c6cd1d9b3c7d07b91042fc391def7576b356d303e5c050c4a73f22bedac014848d2812e416fbdf886a1ab6fcdc81a8765f09d6f43eb37ca3a9780119bf7facc063e5edbeaee2ae2928dad22b08150dab07f94d20e9cbecf84b3bbad95f2fc8e5cfb247f3fb1768ff5a58f98e0b79ca5d87d869fb77b2d9249e21eddb3cf7b4524464234b05227ee0d962642153db2324fd4c42f77e103598c9581ac2fc001db9a27c1f01dd02c8347c29feb7eda1cbbd108b37485479dd2cc383401d4abd20987563c9a9bded1e3c154acb6dc83b9a67674fe72b047853e2611cf3d1dc33f15f11f490be281ca9a01ccb07677dbac449ea5c0d4c91aa34d45c857a5fd796a131edc157c126f527f26170b895406a2a86fc39d9df6f175b9d40000b69f2c24e4ed9d93c3103147d3d5afb513f2c8fe994fbbe883afad37bafb0dede230b110ab9f6b2cece5d00cfa51944442d14f703c0571e9897a96c278a5d05d90f7ac681092a4ed92d4610368f702a74a534b39d1c94dc85178630e3d6011fda77834e65d602e97fb33f45e10325937c065083a44970a5df91bdc2aeae08194b9f2270d49fa7a6201838199546db9a9fbb19142c724548ddfe091313e5057d773ce9b9d5756bb03f0a8e2768bc2b346f49c326663024d2e7e5073a5b095329af97ac54236933f0e852af13a60718b91600e14ad2ffbacb1b06c06e7e7a687651e2608eb019350cce5f4c6f1af79949b1e64c75655edd0bf14b373df9f96b8e9f292476f37d89b5478773d973ba945d5b2375f938fb34ed9fbaaf210ed073cde143955ec30e9e33a0ad70e61a4bb5991c7a81bf36e93a767129d63877f02598d65d8019c9cdffd3732f41fe02b68a199c9e09926039daba21d8f2f37c627c8d429815d2d13e89cba7dac9bbf81b8c94a0c7ef3deaf36580236ed3f9b23ee71c6487213e68b3a9ace5d34871d85a31fb6a1cc9f26beb30354bbd00ce3f2a8f59d115616f2366813517a5b3b01ba9f5d583bbe70fd015b3d2ecf07d3d01c4737b40dcbf72a2d16b76e048e76cffdd289578b5b34915e5188b2f350b1609c3317ec2bf704e020e3f2f5e5dea8184c4191a8fd64fc68d9df26ef2436774caf8ae924c7c3ae91645a6281f837f60a5de5255e57adf78f56a42378632251e2601f4973403db830ce329db8ba9c020dd3c59422614251cba8f8501d6f9b48dc9b49a3d6fbdd6c238a11e485cfa73c59ad1a043e363f02cc0f4a364ef19fecb46228509992425f539061efc6e9435a0c2649189655aac56ad263bef94d79f0a86d6bc19b5801b307f9e36448ec6caca165709669a4fa81e8f2a690656c382c8bb50cd523f1772ca0ec1cb28e43f55b6eb33905127d7e1c52c9fcf722702a1f3add3f7bc4bd7baf59a6d676982d88d8c011f195dc7ebf478fda98d32c3155faa72beb4e57b7291f38bccca653a8820744183f555725a9a739c2a0e8ca55746b7db11527773830d8e0913ad5d6a472a6b16bbf145bcf358f6eda85d01fcf64d893194b9c8a13b0b85ea2a178d940478038817c0296a8aa5cdc3d27f4603784ee850602a4e6522eb14a7270831b234b9d04091358ed455d6f7326d15834279d0a6cd5c932612d80f81199924eac74f17a812ce39734427ca80e90d1beb780a23fd461574dae6cab7ea4b50022f0ca76cdc5dc5ef6c5cab587aa4c6dd96b029ef44ffae4cc8227eab379aeb47ab9750a5bc4544d4b62498336baa106360eba5f7c6c6aafe1761b2cbb049a81e255afa3118a55832e3b45f5deb79f75b5e3553b429c3004e21b0a0f374cb4dd65fa9e6bb1a7dd4ab6aa80ae8003559c3ddcb110747f0a29008a1118f3b6a015cf038deb4204124d381624660ac1318548f61ee486d4ab53d83f8ea77ea6d04445531fff96b77dcc10ce52456511ed4d8dbafa73cf2770f2f11f3243e90438ec</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>面试经历</category>
      </categories>
      <tags>
        <tag>面试总结</tag>
      </tags>
  </entry>
  <entry>
    <title>算法时间复杂度和五大经典排序算法</title>
    <url>/2023/02/06/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E4%BA%94%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1>渐进时间度表</h1>
<ul>
<li>
<p><code>O</code>记法所代表的是渐进上界限，<code>Ω</code>记法代表的是渐进下界</p>
</li>
<li>
<p>Θ代表的集合是上述符号的交集，Θ(g) = O(g)</p>
</li>
<li>
<p>常见的渐进运行时间实例</p>
</li>
<li>
<table>
<thead>
<tr>
<th>时间复杂度</th>
<th>相关名称</th>
<th>相关实例及说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Θ（1）</td>
<td>常数级</td>
<td>哈希表的查询和修改</td>
</tr>
<tr>
<td>Θ（lg n）</td>
<td>对数级</td>
<td>二分搜索，其对数基数并不重要</td>
</tr>
<tr>
<td>Θ（n）</td>
<td>线性级</td>
<td>列表的遍历</td>
</tr>
<tr>
<td>Θ(nlgn)</td>
<td>线性对数级</td>
<td>任意值序列的最优化排序，其复杂度等同于Θ(lg n!)</td>
</tr>
<tr>
<td>Θ(n^2)</td>
<td>平方级</td>
<td>拿n个对象进行互相比对</td>
</tr>
<tr>
<td>Θ(n^3)</td>
<td>立方级</td>
<td>Floyd-Warshall算法</td>
</tr>
<tr>
<td>O(n^k)</td>
<td>多项式级</td>
<td>基于n的k层嵌套循环（k为整数），且必须满足K &gt; 0</td>
</tr>
<tr>
<td>Ω(K^n)</td>
<td>指数级</td>
<td>每n项产生一个子集（其中k = 2），且必须满足K &gt; 1</td>
</tr>
<tr>
<td>Θ(n!)</td>
<td>阶乘级</td>
<td>对n个值执行全排列操作</td>
</tr>
</tbody>
</table>
</li>
</ul>
<span id="more"></span>
<h1>冒泡排序</h1>
<ul>
<li>冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 冒泡排序算法的运作如下： 1、比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。 2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 3、针对所有的元素重复以上的步骤，除了最后一个。 4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 ‘’’</li>
<li>冒泡排序的时间复杂度为O(n^2)。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;冒泡排序算法实现&#x27;&#x27;&#x27;</span></span><br><span class="line">    f=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> f &lt; <span class="built_in">len</span>(x):</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(x):</span><br><span class="line">            <span class="keyword">if</span> x[i] &lt;= x[j]:</span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">                j = j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> x[i] &gt; x[j]:</span><br><span class="line">                var1 = x[i]</span><br><span class="line">                var2 = x[j]</span><br><span class="line">                x[j] = var1</span><br><span class="line">                x[i] = var2</span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">                j = j + <span class="number">1</span></span><br><span class="line">        f = f + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(store(test))</span><br></pre></td></tr></table></figure>
<h1>归并排序</h1>
<ul>
<li>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表， 即把待排序序列分为若干个子序列，每个子序列是有序的。 然后再把有序子序列合并为整体有序序列。</li>
<li>空间复杂度为O(n)，时间复杂度为O(nlogn)。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_extend</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;归并排序算法&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 拆分列表</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(x) &lt;= <span class="number">1</span>:</span><br><span class="line">         <span class="comment"># 向下取整数</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    mid = <span class="built_in">len</span>(x)//<span class="number">2</span></span><br><span class="line">    left = merge_extend(x[:mid])</span><br><span class="line">    right = merge_extend(x[mid:])</span><br><span class="line">    <span class="built_in">print</span>(left,right)</span><br><span class="line">    <span class="keyword">return</span> merge_add(left, right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;和并列表&#x27;&#x27;&#x27;</span></span><br><span class="line">    result = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(a) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(b):</span><br><span class="line">        <span class="keyword">if</span> a[i] &lt; b[j]:</span><br><span class="line">            result.append(a[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(b[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="comment">#print(&quot;a&quot;,a[i:])</span></span><br><span class="line">    <span class="comment">#print(&quot;b&quot;,b[j:])</span></span><br><span class="line">    result.extend(a[i:])</span><br><span class="line">    result.extend(b[j:])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test=[<span class="number">11</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">    <span class="built_in">print</span>(merge_extend(test))</span><br></pre></td></tr></table></figure>
<h1>插入排序</h1>
<ul>
<li>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列， 对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</li>
<li>简单插入排序的时间复杂度也是O(n^2)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert_sort</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="comment"># 取列表的第一个元素为单独的一个，已经排好序的列表</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(x)):</span><br><span class="line">        <span class="comment"># 要排序的的牌</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">            <span class="keyword">if</span> x[i] &lt; x[j]:</span><br><span class="line">                x[i], x[j] = x[j], x[i]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">20</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">19</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(insert_sort(test))</span><br></pre></td></tr></table></figure>
<h1>选择排序</h1>
<ul>
<li>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置， 然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。 选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上， 因此对n个元素的表进行排序总共进行至多n-1次交换。 在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</li>
<li>选择排序的时间复杂度为O(n^2)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">select_sort</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;选择排序&#x27;&#x27;&#x27;</span></span><br><span class="line">    new = []</span><br><span class="line">    <span class="keyword">while</span> x:</span><br><span class="line">        new.append(<span class="built_in">min</span>(x))</span><br><span class="line">        x.remove(<span class="built_in">min</span>(x))</span><br><span class="line">    <span class="keyword">return</span> new</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">20</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">19</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(select_sort(test))</span><br></pre></td></tr></table></figure>
<h1>快速排序</h1>
<ul>
<li>1.先从待排序的数组中找出一个数作为基准数（取第一个数即可）， 2.然后将原来的数组划分成两部分：小于基准数的左子数组和大于等于基准数的右子数组。 3.然后对这两个子数组再递归重复上述过程，直到两个子数组的所有数都分别有序。 4.最后返回“左子数组” + “基准数” + “右子数组”，即是最终排序好的数组。</li>
<li>快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;快速排序&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(x) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    base = x[<span class="number">0</span>]</span><br><span class="line">    left = []</span><br><span class="line">    right = []</span><br><span class="line">    <span class="keyword">for</span> var <span class="keyword">in</span> x:</span><br><span class="line">        <span class="keyword">if</span> var &gt; base:</span><br><span class="line">            right.append(var)</span><br><span class="line">        <span class="keyword">elif</span> var &lt; base:</span><br><span class="line">            left.append(var)</span><br><span class="line">    <span class="keyword">return</span> quick_sort(left) + [base] + quick_sort(right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 存在重复值被覆盖</span></span><br><span class="line">    test = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">56</span>,<span class="number">36</span>,<span class="number">89</span>,<span class="number">45</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>五大经典排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引和事务</title>
    <url>/2023/02/06/%E7%B4%A2%E5%BC%95%E5%92%8C%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1>索引</h1>
<ul>
<li>
<p>索引特点：创建与维护索引会消耗很多时间与磁盘空间，但查询速度大大提高！</p>
</li>
<li>
<p>在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。</p>
</li>
<li>
<p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。</p>
</li>
</ul>
<p>例如，对于<code>students</code>表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">class_id</th>
<th style="text-align:left">name</th>
<th style="text-align:left">gender</th>
<th style="text-align:left">score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">小明</td>
<td style="text-align:left">M</td>
<td style="text-align:left">90</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">小红</td>
<td style="text-align:left">F</td>
<td style="text-align:left">95</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">1</td>
<td style="text-align:left">小军</td>
<td style="text-align:left">M</td>
<td style="text-align:left">88</td>
</tr>
</tbody>
</table>
<p>如果要经常根据<code>score</code>列进行查询，就可以对<code>score</code>列创建索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD INDEX idx_score (score);</span><br></pre></td></tr></table></figure>
<p>使用<code>ADD INDEX idx_score (score)</code>就创建了一个名称为<code>idx_score</code>，使用列<code>score</code>的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD INDEX idx_name_score (name, score);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如<code>gender</code>列，大约一半的记录值是<code>M</code>，另一半是<code>F</code>，因此，对该列创建索引就没有意义。</p>
</li>
<li>
<p>可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。</p>
</li>
</ul>
<blockquote>
<p><strong>对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。</strong></p>
</blockquote>
<h2 id="MySQL索引的类型">MySQL索引的类型</h2>
<h3 id="1-普通索引">1. 普通索引</h3>
<ul>
<li>这是最基本的索引，它没有任何限制，比如上文中为title字段创建的索引就是一个普通索引，<code>MyIASM</code>中默认的<code>BTREE</code>类型的索引，也是我们大多数情况下用到的索引。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">01  –直接创建索引</span><br><span class="line">02  CREATE INDEX index_name ON table(column(length))</span><br><span class="line"></span><br><span class="line">03  –修改表结构的方式添加索引</span><br><span class="line">04  ALTER TABLE table_name ADD INDEX index_name ON (column(length))</span><br><span class="line"></span><br><span class="line">05  –创建表的时候同时创建索引</span><br><span class="line">06  CREATE TABLE `table` (</span><br><span class="line">07      `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">08      `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,</span><br><span class="line">09      `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,</span><br><span class="line">10      `time` int(10) NULL DEFAULT NULL ,</span><br><span class="line">11       PRIMARY KEY (`id`),</span><br><span class="line">12       INDEX index_name (title(length))</span><br><span class="line">13  )</span><br><span class="line"></span><br><span class="line">14  –删除索引</span><br><span class="line">15  DROP INDEX index_name ON table</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="2-唯一索引">2. 唯一索引</h3>
<ul>
<li>与普通索引类似，不同的就是：索引列的值必须唯一，<strong>但允许有空值（注意和主键不同）</strong>。</li>
<li>如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">01  –创建唯一索引</span><br><span class="line">02  CREATE UNIQUE INDEX indexName ON table(column(length))</span><br><span class="line"></span><br><span class="line">03  –修改表结构</span><br><span class="line">04  ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))</span><br><span class="line"></span><br><span class="line">05  –创建表的时候直接指定</span><br><span class="line">06  CREATE TABLE `table` (</span><br><span class="line">07      `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">08      `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,</span><br><span class="line">09      `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,</span><br><span class="line">10      `time` int(10) NULL DEFAULT NULL ,</span><br><span class="line">11      PRIMARY KEY (`id`),</span><br><span class="line">12      UNIQUE indexName (title(length))</span><br><span class="line">13  );</span><br></pre></td></tr></table></figure>
<h3 id="3-全文索引（FULLTEXT）">3. 全文索引（<code>FULLTEXT</code>）</h3>
<ul>
<li>MySQL从3.23.23版开始支持全文索引和全文检索，<code>FULLTEXT</code>索引仅可用于 <code>MyISAM </code>表；</li>
<li>他们可以从<code>CHAR</code>、<code>VARCHAR</code>或<code>TEXT</code>列中作为<code>CREATE TABLE</code>语句的一部分被创建，或是随后使用<code>ALTER TABLE </code>或<code>CREATE INDEX</code>被添加。</li>
<li>对于较大的数据集，将你的资料输入一个没有<code>FULLTEXT</code>索引的表中，然后创建索引，其速度比把资料输入现有<code>FULLTEXT</code>索引的中速度更为快。</li>
<li>不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">01  –创建表的适合添加全文索引</span><br><span class="line">02  CREATE TABLE `table` (</span><br><span class="line">03    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">04    `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,</span><br><span class="line">05    `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,</span><br><span class="line">06    `time` int(10) NULL DEFAULT NULL ,</span><br><span class="line">07    PRIMARY KEY (`id`),</span><br><span class="line">08    FULLTEXT (content)</span><br><span class="line">09  );</span><br><span class="line"></span><br><span class="line">10  –修改表结构添加全文索引</span><br><span class="line">11  ALTER TABLE article ADD FULLTEXT index_content(content)</span><br><span class="line"></span><br><span class="line">12  –直接创建索引</span><br><span class="line">13  CREATE FULLTEXT INDEX index_content ON article(content)</span><br></pre></td></tr></table></figure>
<h3 id="4-单列索引、多列索引">4. 单列索引、多列索引</h3>
<ul>
<li>多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。</li>
</ul>
<h3 id="5-组合索引（最左前缀）">5. 组合索引（最左前缀）</h3>
<ul>
<li>平时用的SQL查询语句一般都有比较多的限制条件，所以为了进一步榨取MySQL的效率，就要考虑建立组合索引。例如上表中针对title和time建立一个组合索引：<code>ALTER TABLE article ADD INDEX index_titme_time (title(50),time(10))</code>。</li>
<li>建立这样的组合索引，其实是相当于分别建立了下面两组组合索引：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">–title,time</span><br><span class="line">–title</span><br></pre></td></tr></table></figure>
<p>为什么没有time这样的组合索引呢？这是因为MySQL组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这两列的查询都会用到该组合索引，如下面的几个SQL所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1   –使用到上面的索引</span><br><span class="line">2   SELECT * FROM article WHREE title=&#x27;测试&#x27; AND time=1234567890;</span><br><span class="line">3   SELECT * FROM article WHREE utitle=&#x27;测试&#x27;;</span><br><span class="line"></span><br><span class="line">4   –不使用上面的索引</span><br><span class="line">5   SELECT * FROM article WHREE time=1234567890;</span><br></pre></td></tr></table></figure>
<h3 id="小结">小结</h3>
<ul>
<li>
<p>通过对数据库表创建索引，可以提高查询速度。</p>
</li>
<li>
<p>通过创建唯一索引，可以保证某一列的值具有唯一性。</p>
</li>
<li>
<p>数据库索引对于用户和应用程序来说都是透明的。</p>
</li>
</ul>
<blockquote>
<p>有几个索引就有几组排序，索引越多占用空间越大，插入速度越慢查询的时候数据库自动分析然后挑一个最合适的索引</p>
</blockquote>
<h1>MySQL 事务</h1>
<blockquote>
<p><strong>事务指逻辑上的一组操作，组成这个操作的各个单元，要么都成功，要么都不成功</strong></p>
</blockquote>
<p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p>
<ul>
<li>在 MySQL 中只有使用了 <code>Innodb</code> 数据库引擎的数据库或表才支持事务。</li>
<li>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li>
<li>事务用来管理 <code>insert</code>,<code>update</code>,<code>delete</code> 语句</li>
</ul>
<p>一般来说，事务是必须满足4个条件（ACID）：：原子性（<strong>A</strong>tomicity，或称不可分割性）、一致性（<strong>C</strong>onsistency）、隔离性（<strong>I</strong>solation，又称独立性）、持久性（<strong>D</strong>urability）。</p>
<ul>
<li>**原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li>**一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>
<li>**隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（<code>Read uncommitted</code>）、读提交（<code>read committed</code>）、可重复读（<code>repeatable read</code>）和串行化（<code>Serializable</code>）。</li>
<li>**持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<blockquote>
<p>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 <code>BEGIN </code>或 <code>START TRANSACTION</code>，或者执行命令 <code>SET AUTOCOMMIT=0</code>，用来禁止使用当前会话的自动提交。</p>
</blockquote>
<h2 id="事务控制语句">事务控制语句</h2>
<ul>
<li><code>BEGIN</code> 或 <code>START TRANSACTION </code>显式地开启一个事务；</li>
<li><code>COMMIT</code> 也可以使用<code> COMMIT WORK</code>，不过二者是等价的。<code>COMMIT </code>会提交事务，并使已对数据库进行的所有修改成为永久性的；</li>
<li><code>ROLLBACK</code> 也可以使用 <code>ROLLBACK WORK</code>，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</li>
<li><code>SAVEPOINT identifier</code>，<code>SAVEPOINT</code> 允许在事务中创建一个保存点，一个事务中可以有多个<code> SAVEPOINT</code>；</li>
<li><code>RELEASE SAVEPOINT identifier</code> 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</li>
<li><code>ROLLBACK TO identifier</code> 把事务回滚到标记点；</li>
<li><code>SET TRANSACTION</code> 用来设置事务的隔离级别。<code>InnoDB</code> 存储引擎提供事务的隔离级别有<code>READ UNCOMMITTED</code>、<code>READ COMMITTED</code>、<code>REPEATABLE READ</code> 和<code> SERIALIZABLE</code>。</li>
</ul>
<h2 id="MYSQL-事务处理方法">MYSQL 事务处理方法</h2>
<p>1、用 BEGIN, ROLLBACK, COMMIT来实现</p>
<ul>
<li><strong>BEGIN</strong> 开始一个事务</li>
<li><strong>ROLLBACK</strong> 事务回滚</li>
<li><strong>COMMIT</strong> 事务确认</li>
</ul>
<p>2、直接用 SET 来改变 MySQL 的自动提交模式:</p>
<ul>
<li><code>SET AUTOCOMMIT=0</code> 禁止自动提交</li>
<li><code>SET AUTOCOMMIT=1</code> 开启自动提交</li>
</ul>
]]></content>
      <categories>
        <category>SQL知识</category>
      </categories>
      <tags>
        <tag>SQL概念</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Python语言的IP代理池</title>
    <url>/2023/02/06/IP%E4%BB%A3%E7%90%86%E6%B1%A0/</url>
    <content><![CDATA[<p>环境：python3.6</p>
<p>MongoDB</p>
<p>flask</p>
<p>requests等第三方库</p>
<p>完整代码见： <a href="https://github.com/Lucareful/IPProxyPool">https://github.com/Lucareful/IPProxyPool</a></p>
<h1>代理池概述</h1>
<h2 id="什么是代理池">什么是代理池</h2>
<ul>
<li>代理池就是有代理IP组成的池子，它可以提供多个稳定可用的代理IP</li>
</ul>
<h2 id="为什么要实现代理池">为什么要实现代理池</h2>
<p>我们在做爬虫的时候，最常见的一种反爬虫手段就是：IP反爬；也就是当同一个IP访问这个网站的次数过多，频率过高，就会限制这个IP的访问。就是需要经常换IP；</p>
<ul>
<li>使用IP代理池是其中一个比较常用的方案</li>
<li>免费代理都是非常不稳定的，有10%是可用就很不错了</li>
<li>一些收费代理稳定性也不好</li>
</ul>
<p>目的：从一堆不稳定的代理IP中，抽取高可用代理IP，给爬虫使用</p>
<h1>代理池开发环境</h1>
<ul>
<li>
<p>python3开发语言</p>
</li>
<li>
<p>requests：发送请求，获取页面数据</p>
</li>
<li>
<p>lxml：使用XPATH从页面提取我们想要的书籍</p>
</li>
<li>
<p>pymonge：把提取到代理IP存储到MongoDB数据库中和MongoDB数据库中读取代理IP，给爬虫使用</p>
</li>
<li>
<p>Flask：用于提供WEB服务</p>
</li>
</ul>
<h1>代理池工作流程</h1>
<p><img src="https://i.ibb.co/b7YyrM5/image-20191024195902163.png" alt="image-20191024195902163"></p>
<p>1.代理池工作渡程描述：</p>
<ul>
<li>代理IP采集模块-&gt;采集代理IP-&gt;检测代理IP-&gt;如果不可用用，直接过滤掉，如果可用，指定默认分数-&gt;存入数据库中</li>
<li>代理IP检测模块-&gt;从数据库中获取所有代理IP-&gt;检测代理IP-&gt;如果代理IP不可用用，就把分数-1，如果分数为0从数据库中删除，否则更新数据库，如果代理IP可用，恢复为默认分值，更新数据库</li>
<li>代理API模块-&gt;从数据库中高可用的代理IP给爬虫使用；</li>
</ul>
<span id="more"></span>
<h2 id="代理池的模块及其作用">代理池的模块及其作用</h2>
<p>五大核心模块</p>
<ul>
<li>爬虫模块
<ul>
<li>从代理IP网站上采集代理IP</li>
<li>进行校验（获取代理响应速度，协议类型，匿名类型）</li>
<li>把可用代理IP存储到数据库中</li>
<li></li>
</ul>
</li>
<li>代理IP的校验模块：获取指定代理的响应速度，支持的协议以及匿名程度
<ul>
<li>原因：网站上所标注的响应速度，协议类型和匿名类型是不准确的</li>
<li>这里使用<strong><a href="http://httpbin.org">httpbin.org</a></strong>进行检测</li>
</ul>
</li>
<li>数据库模块：实现对代理IP的增删改查操作
<ul>
<li>这里使用MongoDB来存储代理IP</li>
</ul>
</li>
<li>检测模块：定时的对代理池中代理进行检测，保证代理池中代理的可用性.
<ul>
<li>从数据库读取所有的代理IP</li>
<li>对代理IP进行逐一检测，可用开启多个协程，以提高检测速度</li>
<li>如果该代理不可用，就让这个代理分数-1，当代理的分数到0了，就删除该代理；如果检测到代理可用就恢复为满分.</li>
</ul>
</li>
<li>代理IP服务接口：提供高可用的代理IP给爬虫使用
<ul>
<li>根据协议类型和域名获取随机一个高质量代理IP</li>
<li>根据协议类型和域名获取多个高质量代理IP</li>
<li>根据代理IP不可用域名，告诉代理池这个代理IP在该域名下不可用，下次获取这个域名的代理IP时候，就不会再获取这个代理IP了，从而保证代理IP高可用性.</li>
</ul>
</li>
</ul>
<p>代理池的其它模块</p>
<ul>
<li>数据模型：<a href="http://domain.py">domain.py</a>
<ul>
<li>代理IP的数据模型，用于封装代理IP相关信息，比如ip，端口号，响应速度，协议类型，匿名类型，分数等</li>
</ul>
</li>
<li>程序启动入口：<a href="http://main.py">main.py</a>·代理池提供一个统一的启动入口</li>
<li>工具模块：、</li>
<li>日志模块：用于记录日志信息</li>
<li>http模块：用于获取随机User-Agent的请求头</li>
<li>配置文件：<a href="http://settings.py">settings.py</a>
<ul>
<li>用于默认代理的分数，配置日志格式，文件，启动的爬虫，检验的间隔时间等.</li>
</ul>
</li>
</ul>
<h1>代理池的项目结构</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">--IPProxyPoo1</span><br><span class="line">  --core</span><br><span class="line">    --db</span><br><span class="line">      --__init__.py</span><br><span class="line">      --mongo_pool.py</span><br><span class="line">    --proxy_validate</span><br><span class="line">      --__init__.py</span><br><span class="line">      --httpbin_validator.py</span><br><span class="line">    --proxy_spider</span><br><span class="line">      --__init__.py</span><br><span class="line">      --base_spider.py</span><br><span class="line">      --proxy_kpiders.py</span><br><span class="line">      --run_spiders.py</span><br><span class="line">    --proxy_test.py</span><br><span class="line">    --proxy_api.py</span><br><span class="line">  --domain.py</span><br><span class="line">  --utils</span><br><span class="line">        --__init__.py</span><br><span class="line">        --http.py</span><br><span class="line">        --log.py</span><br><span class="line">  --main.py</span><br><span class="line">  --settings.py</span><br></pre></td></tr></table></figure>
<h1>定义代理IP的数据模型类</h1>
<ul>
<li>定义Proxy类，继承object</li>
<li>实现_init_方法，负责初始化，包含如下字段：
<ul>
<li>ip：代理的IP地址</li>
<li>port：代理IP的端口号</li>
<li>protocol：代理IP支持的协议类型，http是0，https是1，https和http都支持是2</li>
<li>nick_type：代理IP的匿名程度，高匿：0，匿名：1，透明：2</li>
<li>speed：代理IP的响应速度，单位s</li>
<li>area：代理IP所在地区</li>
<li>score：代理IP的评分，用于衡量代理的可用性；默认分值可以通过配置文件进行配置.在进行代理可用性检查的时候，每遇到一次请求失败就减1份，减到0的时候从池中删除.如果检查代理可用，就恢复默认分值</li>
<li>disable_domains：不可用域名列表，有些代理IP在某些域名下不可用，但是在其他域名下可用</li>
<li>在配置文件：settings.py中定义MAX_SCORE=50，表示代理IP的默认最高分数</li>
</ul>
</li>
<li>提供_str方法，返回数据字符串</li>
</ul>
<h1>代理池的工具模块</h1>
<p>日志模块</p>
<p>http模块</p>
<h2 id="日志模块">日志模块</h2>
<ul>
<li>
<p>能够方便的对程序进行调试</p>
</li>
<li>
<p>能够方便记录程序的运行状态</p>
</li>
<li>
<p>能够方便记录错误信息</p>
</li>
<li>
<p>日志的实现</p>
<ul>
<li>目标：实现日志模块，用于记录日志</li>
<li>把日志相关配置信息放到配置文件中</li>
<li>修改日志代码，使用配置文件中的配置信息</li>
</ul>
</li>
</ul>
<h2 id="Http模块">Http模块</h2>
<ul>
<li>我在从代理IP网站上抓取代理IP和检验代理IP时候，为了不容易不服务器识别为是一个爬虫，我们最好提供随机的User-Agent请求头.</li>
<li>目标：获取随机User-Agent的请求头<br>
步骤：<br>
1.准备User-Agent的列表<br>
2.实现一个方法，获取随机User-Agent的请求头</li>
</ul>
<h1>代理池的检验模块</h1>
<ul>
<li>
<p>目标：检查代理IP速度，匿名程度以及支持的协议类型.</p>
</li>
<li>
<p>步骤：</p>
</li>
<li>
<p>检查代理IP速度和匿名程度；</p>
<ul>
<li>
<p>代理IP速度：就是从发送请求到获取响应的时间间隔</p>
</li>
<li>
<p>匿名程度检查：</p>
<ul>
<li>
<p>对http://httpbin.org/get 或https://httpbin.org/get 发送请求</p>
</li>
<li>
<p>如果响应的origin中有 ***，***分割的两个IP就是透明代理IP</p>
</li>
<li>
<p>如果响应的headers 中包含Proxy-Connection 说明是匿名代理IP</p>
</li>
<li>
<p>否则就是高匿代理IP。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>检查代理IP协议类型</p>
<ul>
<li>如果http://httpbin.org/get 发送请求可以成功，说明支持http协议</li>
</ul>
</li>
<li>
<p>如果https://httpbin.org/get 发送请求可以成功，说明支持https协议</p>
</li>
</ul>
<h1>代理池的数据库模块</h1>
<ul>
<li>作用：用于对proxies集合进行数据库的相关操作</li>
<li>目标：实现对数据库增删改查相关操作、</li>
<li>步骤：<br>
1.在<code>init</code>中，建立数据连接，获取要操作的集合，在<code>del</code>方法中关闭数据库连接<br>
2.提供基础的增删改查功能
<ul>
<li>实现插入功能</li>
<li>实现修改该功能</li>
<li>实现删除代理：根据代理的IP删除代理</li>
<li>查询所有代理IP的功能</li>
</ul>
</li>
<li>3.提供代理API模块使用的功能
<ul>
<li>实现查询功能：根据条件进行查询，可以指定查询数量，先分数降序，速度升序排，保证优质的代理IP在上面.</li>
<li>实现根据协议类型和要访问网站的域名，获取代理IP列表</li>
<li>实现根据协议类型和要访问完整的域名，随机获取一个代理IP</li>
<li>实现把指定域名添加到指定IP的disable_domain列表中.</li>
</ul>
</li>
</ul>
<h1>实现代理池的爬虫模块</h1>
<h2 id="爬虫模块的需求">爬虫模块的需求</h2>
<ul>
<li>需求：抓取各个代理IP网站上的免费代理IP进行检测，如果可用存储到数据库中</li>
<li>需要抓取代理IP的页面如下：
<ul>
<li>西刺代理：<a href="https://www.xicidaili.com/nn/1">https://www.xicidaili.com/nn/1</a></li>
<li>ip3366代理：<a href="http://www.ip3366.net/free/?stype=1&amp;page=1">http://www.ip3366.net/free/?stype=1&amp;page=1</a></li>
<li>快代理：<a href="https://www.kuaidaili.com/free/inha/1/">https://www.kuaidaili.com/free/inha/1/</a></li>
<li>oproxylistplus代理:<a href="https://list.proxylistplus.com/Fresh-HTTP-Proxy-List-1">https://list.proxylistplus.com/Fresh-HTTP-Proxy-List-1</a></li>
<li>66ip代理：<a href="http://www.66ip.cn/1.html">http://www.66ip.cn/1.html</a></li>
</ul>
</li>
</ul>
<h2 id="爬虫模块的设计">爬虫模块的设计</h2>
<ul>
<li>通用爬虫：通过指定URL列表，分组XPATH和组内XPATH，来提取不同网站的代理IP
<ul>
<li>原因代理IP网站的页面结构几乎都是Table，页面结构类似</li>
</ul>
</li>
<li>具体爬虫：用于抓取具体代理IP网站
<ul>
<li>通过继承通用爬虫实现具体网站的抓取，一般只需要指定爬取的URL列表，分组的XPATH和组内XPATH就可以了.</li>
<li>如果该网站有特殊反爬手段，可以通过重写某些方法实现反爬</li>
</ul>
</li>
<li>爬虫运行模块：启动爬虫，抓取代理IP进行检测，如果可用，就存储到数据库中；
<ul>
<li>通过配置文件来控制启动哪些爬虫，增加扩展性；如果将来我们遇到返回<code>json</code>格式的代理网站，单独写一个爬虫配置下就好了.</li>
</ul>
</li>
</ul>
<h2 id="实现通用爬虫">实现通用爬虫</h2>
<ul>
<li>
<p>目标：实现可以指定不同URL列表，分组的XPATH和详情的XPATH，从不同页面上提取代理的IP端口号和区域的通用爬虫；</p>
</li>
<li>
<p>步骤：<br>
1.在<code>base_spider.py</code>文件中，定义一个<code>BaseSpider</code>类，继承object<br>
2.提供三个类成员变量：</p>
<ul>
<li>
<p>urls：代理IP网址的URL的列表</p>
</li>
<li>
<p>group_xpath：分组XPATH，获取包含代理IP信息标签列表的XPATH</p>
</li>
<li>
<p>detail_xpath：组内XPATH，获取代理IP详情的信息XPATH，格式为：{&quot;ip’:‘xx’，‘port’：‘xx’，‘area’：‘xx’}</p>
</li>
</ul>
<p>3.提供初始方法，传入爬虫URL列表，分组XPATH，详情（组内）XPATH<br>
4.对外提供一个获取代理IP的方法</p>
<ul>
<li>遍历URL列表，获取URL</li>
<li>根据发送请求，获取页面数据</li>
<li>解析页面，提取数据，封装为Proxy对象</li>
<li>返回Proxy对象列表</li>
</ul>
</li>
</ul>
<h2 id="实现具体爬虫">实现具体爬虫</h2>
<ul>
<li>
<p>目标：通过继承通用爬虫，实现多个具体爬虫，分别从各个免费代理IP网站上抓取代理IP</p>
</li>
<li>
<p>1.实现西刺代理爬虫：<a href="http://www.xicidaili.com/nn/1">http://www.xicidaili.com/nn/1</a></p>
<ul>
<li>定义一个类，继承通用爬虫类（<code>BasicSpider</code>）</li>
<li>提供urls，group_xpath 和detail_xpath</li>
</ul>
</li>
<li>
<p>2.实现ip3366代理爬虫：<a href="http://www.ip3366.net/free/%EF%BC%9Fstype=1&amp;page=1">http://www.ip3366.net/free/？stype=1&amp;page=1</a></p>
<ul>
<li>定义一个类，继承通用爬虫类（BasicSpider）</li>
<li>提供urls，group_xpath 和detail_xpath</li>
</ul>
</li>
<li>
<p>3.实现快代理爬虫：<a href="https://www.kuaidaili.com/free/inha/1/">https://www.kuaidaili.com/free/inha/1/</a></p>
<ul>
<li>定义一个类，继承通用爬虫类（BasicSpider）</li>
<li>提供urls，group_xpath和detail_xpath</li>
</ul>
</li>
<li>
<p>4.实现 proxylistplus代理爬虫：<a href="https://list.proxylistplus.com/Fresh-HTTP-Proxy-List-1">https://list.proxylistplus.com/Fresh-HTTP-Proxy-List-1</a></p>
<ul>
<li>定义一个类，继承通用爬虫类（BasicSpider）</li>
<li>提供urls，group_xpath 和detail_xpath</li>
</ul>
</li>
<li>
<p>5.实现66ip爬虫：<a href="http://www.66ip.cn/1.html">http://www.66ip.cn/1.html</a></p>
<ul>
<li>定义一个类，继承通用爬虫类（BasicSpider）</li>
<li>提供urls，group_xpath和detail_xpath</li>
<li>由于66ip网页进行js+cookie反爬，需要重写父类的get_page_from_url 方法</li>
</ul>
<p>PS：实现66ip爬虫：<a href="http://www.66ip.cn/1.html%E6%A0%B8%E5%BF%83%EF%BC%9A">http://www.66ip.cn/1.html核心：</a></p>
<p>通过加密的js，生成需要cookie信息<br>
1.从响应页面中，提取：</p>
<p>​			1.执行生成真正js语句</p>
<p>​			2.生成真正js的函数.</p>
<p>2.网页中，是通过<code>eval</code>执行真正js，加载页面；而我们要获取真正的js；我们就需要把<code>eval</code>语句，替换为return，把真正js返回.</p>
<p>3.使用<code>js2py</code>，获取执行js的环境，使用js执行环境加载这个函数</p>
<p>4.使用这个执行环境，执行调用调用，生成真正js，赋值给一个变量</p>
<p>5.从真正的js代码中，提取我们需要cookie信息.</p>
</li>
</ul>
<h1>实现爬虫的运行模块</h1>
<ul>
<li>目标：根据配置文件信息，加载爬虫，抓取代理IP，进行校验，如果可用，写入到数据库中</li>
<li>思路：
<ul>
<li>在<code>run_spider.py</code>中，创建<code>RunSpider</code>类</li>
</ul>
</li>
<li>提供一个运行爬虫的run方法，作为运行爬虫的入口，实现核心的处理逻辑
<ul>
<li>根据配置文件信息，获取爬虫对象列表.</li>
<li>遍历爬虫对象列表，获取爬虫对象，遍历爬虫对象的get_proxies方法，获取代理IP</li>
<li>检测代理IP（代理IP检测模块）</li>
<li>如果可用，写入数据库（数据库模块）</li>
<li>处理异常，防止一个爬虫内部出错了，影响其他的爬虫.</li>
</ul>
</li>
<li>使用异步来执行每一个爬虫任务，以提高抓取代理IP效率
<ul>
<li>在init 方法中创建协程池对象</li>
<li>把处理一个代理爬虫的代码抽到一个方法</li>
<li>使用异步执行这个方法</li>
<li>调用协程的join方法，让当前线程等待队列任务的完成.</li>
</ul>
</li>
<li>使用<code>schedule</code>模块，实现每隔一定的时间，执行一次爬取任务
<ul>
<li>定义一个start的类方法</li>
<li>创建当前类的对象，调用run方法</li>
<li>使用schedule模块，每隔一定的时间，执行当前对象的run方法</li>
</ul>
</li>
</ul>
<h1>实现代理池的检测模块</h1>
<ul>
<li>
<p>目的：检查代理IP可用性，保证代理池中代理IP基本可用</p>
</li>
<li>
<p>思路</p>
<ul>
<li>
<p>1.在<code>proxy_test.py</code>中，创建<code>Proxy Tester</code>类</p>
</li>
<li>
<p>2.提供一个run 方法，用于处理检测代理命核心逻辑</p>
<ul>
<li>
<p>从数据库中获取所有代理IP</p>
</li>
<li>
<p>遍历代理IP列表</p>
</li>
<li>
<p>检查代理可用性</p>
<ul>
<li>
<p>如果代理不可用，让代理分数-1，如果代理分数等于0就从数据库中删除该代理，否则更新该代理IP</p>
</li>
<li>
<p>如果代理可用，就恢复该代理的分数，更新到数据库中</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>3.为了提高检查的速度，使用异步来执行检测任务</p>
<ul>
<li>
<p>在<code>init</code>方法中，创建队列和协程池</p>
<ul>
<li>把要检测的代理IP，放到队列中</li>
<li>i.把检查一个代理可用性的代码，抽取到一个方法中；从队列中获取代理IP，进行检查；检查完毕，调度队列的task_done方法</li>
<li>ii.通过异步回调，使用死循环不断执行这个方法，</li>
<li>iv.开启多个一个异步任务，来处理代理IP的检测；可以通过配置文件指定异步数量</li>
<li>调用队列的join方法，让当前线程等待队列任务完成</li>
</ul>
</li>
</ul>
<p>4.使用schedule模块，每隔一定的时间，执行一次检测任务</p>
<ul>
<li>定义类方法start，用于启动检测模块</li>
<li>在start方法中
<ul>
<li>i.创建本类对象</li>
<li>i.调用run方法</li>
<li>i.每间隔一定时间，执行一下，run方法</li>
</ul>
</li>
</ul>
<h1>实现代理池的API模块</h1>
<ul>
<li>
<p>目标：</p>
<ul>
<li>为爬虫提供高可用代理IP的服务接口</li>
</ul>
</li>
<li>
<p>步骤：</p>
<ul>
<li>
<p>实现根据协议类型和域名，提供随机的获取高可用代理IP的服务</p>
</li>
<li>
<p>实现根据协议类型和域名，提供获取多个高可用代理IP的服务</p>
</li>
<li>
<p>实现给指定的IP上追加不可用域名的服务</p>
</li>
</ul>
</li>
<li>
<p>实现</p>
<ul>
<li>在<code>proxy_api.py</code>中，创建<code>ProxyApi</code>类</li>
</ul>
</li>
<li>
<p>实现初始方法s</p>
<ul>
<li>
<p>初始一个Flask的Web服务</p>
</li>
<li>
<p>实现根据协议类型和域名，提供随机的获取高可用代理IP的服务</p>
<ul>
<li>
<p>可用通过protocol和domain参数对IP进行过滤</p>
</li>
<li>
<p>protocol：当前请求的协议类型</p>
</li>
<li>
<p>domain：当前请求域名</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>实现根据协议类型和域名，提供获取多个高可用代理IP的服务·</p>
<ul>
<li>可用通过protocol和domain参数对IP进行过滤</li>
</ul>
</li>
<li>
<p>实现给指定的IP上追加不可用域名的服务</p>
<ul>
<li>如果在获取IP的时候，有指定域名参数，将不在获取该IP从而进一步提高代理IP的可用性.</li>
</ul>
</li>
<li>
<p>实现run方法，用于启动Flask的WEB服务</p>
</li>
<li>
<p>实现start的类方法，用于通过类名，启动服务</p>
</li>
</ul>
<h1>实现代理池的程序入口</h1>
<ul>
<li>目标：把<code>启动爬虫</code>，<code>启动检测代理IP</code>，<code>启动WEB服务</code>统一到一起</li>
<li>思路：
<ul>
<li>开启三个进程，分别用于启动爬虫，检测代理IP，WEB服务</li>
</ul>
</li>
<li>步骤：</li>
<li>定义一个run方法用于启动动代理池
<ul>
<li>定义一个列表，用于存储要启动的进程</li>
<li>创建<code>启动爬虫</code>的进程，添加到列表中</li>
<li>创建<code>启动检测</code>的进程，添加到列表中</li>
<li>创建<code>启动提供API</code>服务的进程，添加到列表中</li>
<li>遍历进程列表，启动所有进程</li>
<li>遍历进程列表，让主进程等待子进程的完成</li>
</ul>
</li>
<li>在<code>if__name__=='__main__'：</code>中调用run方法</li>
</ul>
]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>爬虫实践</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基本知识</title>
    <url>/2023/02/06/JavaScript%E7%9A%84%E7%AE%80%E4%BB%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1>JavaScript作用</h1>
<ul>
<li>表单动态检验（密码强度检测）</li>
<li>网页特效</li>
<li>服务端开发（Node.js）</li>
<li>桌面程序（Electron）</li>
<li>APP（Cordova）</li>
<li>控制硬件 - 物联网（Ruff）</li>
<li>游戏小程序（cocos2d-js）</li>
</ul>
<h1>HTML/CSS/JS的关系</h1>
<ul>
<li>HTML/CSS标记语言–描述类语言
<ul>
<li>HTML决定网页结构和内容（决定看到什么），相当于人的身体</li>
<li>CSS决定网页呈现给用户的模样（决定好不好看），相当于给人穿衣服、化妆</li>
</ul>
</li>
<li>JS脚本语言-编程类语言
<ul>
<li>实现业务逻辑和页面控制（决定功能），相当于人的各种动作</li>
</ul>
</li>
</ul>
<h1>浏览器执行js</h1>
<p>浏览器分成两部分：渲染引擎和JS引擎</p>
<ul>
<li>
<p>渲染引擎：用来解析HTML与CSS，俗称内核，比如chrome浏览器的blink，老版本的webkit</p>
</li>
<li>
<p>JS引擎：也称为JS解释器。用来读取网页中的JavaScript代码，对其处理后运行，比如chrome浏览器的V8</p>
</li>
</ul>
<blockquote>
<p>浏览器本身并不会执行JS代码，而是通过内置JavaScript引擎（解释器）来执行JS代码。JS引擎执行代码时<em><strong>逐行解释每一句源码（转换为机器语言），然后由计算机去执行</strong></em>，所以JavaScript语言归为脚本语言，会逐行解释执行。</p>
</blockquote>
<h1>JS组成</h1>
<h2 id="1-ECMAScript">1.ECMAScript</h2>
<ul>
<li>ECMAScript是由ECMA国际（原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMAScript语言的实现和扩展。</li>
</ul>
<blockquote>
<p>ECMAScript:ECMAScript规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。</p>
</blockquote>
<h2 id="2-DOM——文档对象模型">2.DOM——文档对象模型</h2>
<ul>
<li>文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。</li>
<li>通过DOM提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）。</li>
</ul>
<h2 id="3-BOM——浏览器对象模型">3.BOM——浏览器对象模型</h2>
<ul>
<li>BOM（Browser Object Model，简称BOM）是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。</li>
<li>通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</li>
</ul>
<span id="more"></span>
<h1>JS有3种书写</h1>
<h2 id="1-行内式JS">1.行内式JS</h2>
<ul>
<li>可以将单行或少量JS代码写在HTML标签的事件属性中（以on开头的属性），如：onclick</li>
<li>注意单双引号的使用：在HTML中我们推荐使用双引号，JS中我们推荐使用<em><strong>单引号</strong></em></li>
<li>可读性差，在html中编写JS大量代码时，不方便阅读；</li>
<li>引号易错，引号多层嵌套匹配时，非常容易弄混；</li>
<li>特殊情况下使用</li>
</ul>
<h2 id="2-内嵌JS">2.内嵌JS</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  alert（<span class="string">&#x27;Hello World~！&#x27;</span>）；</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以将多行JS代码写到<code>&lt;script&gt;</code>标签中</li>
<li>内嵌JS是学</li>
<li>习时常用的方式</li>
</ul>
<h2 id="3-外部JS文件">3.外部JS文件</h2>
<ul>
<li>利于HTML页面代码结构化，把大段JS代码独立到HTML页面之外，既美观，也方便文件级别的复用</li>
<li>引用外部JS文件的script标签中间不可以写代码</li>
<li>适合于JS代码量比较大的情况</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2. 内嵌式的js --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//alert(&#x27;Hello&#x27;)</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;my.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 行内式的JS 直接写到元素内部 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;input type=&quot;button&quot; value=&quot;Luenci&quot; onclick=&quot;alert(&#x27;hello world&#x27;)&quot;&gt;  --&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1>JavaScript注释</h1>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//1.单行注释 ctrl + /</span><br><span class="line">/*2.多行注释默认的快捷键 shift + alt + a */</span><br><span class="line">2.多行注释vscode中修改多行注释的快捷键：ctrl + shift + /</span><br></pre></td></tr></table></figure>
<h1>JavaScript输入输出语句</h1>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 这是一个输入框</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">prompt</span>(<span class="string">&#x27;请输入您的年龄&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//alert 弹出警示框</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;计算的结果是：&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// console 控制台输出 给程序员测试用</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是程序员&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1>变量</h1>
<h2 id="声明变量">声明变量</h2>
<ul>
<li>//声明变量<br>
var age；//声明一个名称为age的变量</li>
<li><code>var</code>是一个JS<strong>关键字</strong>，用来声明变量（variable变量的意思）。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序最管</li>
<li>age是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间</li>
</ul>
<h2 id="变量命名规范">变量命名规范</h2>
<ul>
<li>由字母（A-Za-z）、数字（0-9）、下划线（）、美元符号（$）组
<ul>
<li>如：usrAge，num01，_name</li>
</ul>
</li>
<li>严格区分大小写。
<ul>
<li>var app；和var App；是两个变量</li>
</ul>
</li>
<li>不能以数字开头。
<ul>
<li>18age是错误的</li>
</ul>
</li>
<li>不能是关键字、保留字。
<ul>
<li>例如：var、for、while</li>
</ul>
</li>
<li>变量名必须有意义。
<ul>
<li>MMDBBD nl → age</li>
</ul>
</li>
<li>遵守驼峰命名法。
<ul>
<li>首字母小写，后面单词的首字母需要大写。myFirstName</li>
</ul>
</li>
</ul>
<h1>数据类型</h1>
<blockquote>
<p>JavaScript是一种弱类型或者说动态语言。</p>
</blockquote>
<p>JS把数据类型分为两类</p>
<ul>
<li>简单数据类型（Number，string，Boolean，Undefined，Null）</li>
<li>复杂数据类型（object）</li>
</ul>
<p>###　数字型</p>
<blockquote>
<ul>
<li>Infinity，代表无穷大，大于任何数值</li>
<li>Infinity，代表无穷小，小于任何数值</li>
<li>NaN，Not a number，代表一个非数值</li>
<li>isNaN（）这个方法用来判断非数字并且返回一个值如果是数字返回的是false如果不是数字返Turn</li>
</ul>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> num=1e；<span class="comment">//num 数字型</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> <span class="variable constant_">PI</span>=<span class="number">3.14</span><span class="comment">//PI数字型</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//1.八进制0~7我们程序里面数字前面加0表示八进制</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> numl=<span class="number">010</span>；</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.1og（num1）；<span class="comment">// 010八进制转换为10进制就是8</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> num2=<span class="number">012</span>；</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.1og（num2）；</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//2.十六进制e～9a~f#ffffff数字的前面加0x表示十六进制</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> num3=<span class="number">0x9</span>；</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.1og（num3）；</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> num4=<span class="number">0xa</span>；</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.1og（num4）；</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 数字型的最大值</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 数字型的最小值</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="property">MIN_VALUE</span>);  </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    8</span><br><span class="line">    10</span><br><span class="line">    9</span><br><span class="line">    10</span><br><span class="line">    1.7976931348623157e+308</span><br><span class="line">    5e-324</span><br></pre></td></tr></table></figure>
<h3 id="字符串型String">字符串型String</h3>
<ul>
<li>
<p>1.字符串引号嵌套</p>
<blockquote>
<p>JS可以用单引号嵌套双引号，或者用双引号嵌套单引号（外双内单，外单内双)</p>
</blockquote>
</li>
<li>
<p>2.字符串转义符</p>
</li>
<li>
<p>类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。</p>
</li>
<li>
<p>转义符都是<code>\</code>头的，常用的转义符及其说明如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>转义符</th>
<th>解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\n</td>
<td>换行符，n是newline的意思</td>
</tr>
<tr>
<td>\</td>
<td>斜杠 \</td>
</tr>
<tr>
<td><code>\'</code></td>
<td>单引号</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号</td>
</tr>
<tr>
<td>\t</td>
<td>tab缩进</td>
</tr>
<tr>
<td>\b</td>
<td>空格，b是blank的意思</td>
</tr>
</tbody>
</table>
<h3 id="布尔型">布尔型</h3>
<ul>
<li>布尔类型有两个值：true和false，其中true表示真（对），而false表示假（错）。</li>
<li>布尔型和数字型相加的时候，true的值为1，false的值为0。</li>
</ul>
<h3 id="Undefined-和Null">Undefined 和Null</h3>
<ul>
<li>一个声明后没有被赋值的变量会有一个默认值undefined（如果进行相连或者相加时，注意结果）</li>
</ul>
<h2 id="数据类型的转换">数据类型的转换</h2>
<ul>
<li>转换为字符串类型</li>
</ul>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody>
<tr>
<td>toString()</td>
<td>转成字符串</td>
<td>var num=1; alert(num.toString()）</td>
</tr>
<tr>
<td>String()强制转换</td>
<td>转成字符串</td>
<td>var num=1；alert(String(num))；</td>
</tr>
<tr>
<td>加号拼接字符串</td>
<td>和字符串拼接的结果都是字符串</td>
<td>var num=1；alert(num+&quot;我是字符串”)；</td>
</tr>
</tbody>
</table>
<blockquote>
<p>toString()和String()使用方式不一样。<br>
三种转换方式，我们更喜欢用第三种加号拼接字符串转换方式，这一种方式也称之为隐式转换。</p>
</blockquote>
<ul>
<li>转换为数字型</li>
</ul>
<table>
<thead>
<tr>
<th>方式</th>
<th>方式</th>
<th>案例</th>
</tr>
</thead>
<tbody>
<tr>
<td>parselnt(string)函数</td>
<td>将string类型转成整数数值型</td>
<td>parselnt(‘78’)</td>
</tr>
<tr>
<td>parseFloat（string）函数</td>
<td>将string类型转成浮点数数值型</td>
<td>parseFloat（“78.21”）</td>
</tr>
<tr>
<td>Number（）强制转换函数</td>
<td>将string类型转换为数值型</td>
<td>Number(‘12’)</td>
</tr>
<tr>
<td>js隐式转换（- * / ）</td>
<td>利用算术运算隐式转换为数值型</td>
<td>‘12’ - 0</td>
</tr>
</tbody>
</table>
<ul>
<li>转换为布尔型</li>
</ul>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean()函数</td>
<td>其他类型转成布尔值</td>
<td>Boolean(‘var’);</td>
</tr>
</tbody>
</table>
<ul>
<li>代表空、否定的值会被转换为false
<ul>
<li>如”、0、NaN、null、undefined</li>
</ul>
</li>
<li>其余值都会被转换为true</li>
</ul>
<h1>编译型语言和解释型语言</h1>
<ul>
<li>编译器
<ul>
<li>在代码执行之前进行编译，生成中间代码文件</li>
</ul>
</li>
<li>解释器
<ul>
<li>在运行时进行及时解释，并立即执行（当编译器以解释方式运行的时候，也称之为解释器）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象</title>
    <url>/2023/02/06/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1>面向对象</h1>
<ul>
<li>三大特征：封装性，继承性，多态性。</li>
<li>继承是多态的前提，如果没有继承，就没有多态</li>
<li>继承主要解决的问题是：<strong>共性抽取</strong></li>
</ul>
<h2 id="继承">继承</h2>
<ul>
<li>
<p>父类也可以叫基类，超类</p>
</li>
<li>
<p>子类也可以叫派生类</p>
</li>
<li>
<p>子类可以访问父类的属性和方法，反之父类不能访问子类的属性和方法</p>
</li>
</ul>
<p>直接通过子类对象访问成员变量：</p>
<ul>
<li>等号左边是谁，就优先用谁，没有则向上找。</li>
</ul>
<p>间接通过成员方法访问成员变量：</p>
<ul>
<li>该方法属于谁，就优先用谁，没有则向上找。</li>
</ul>
<h2 id="成员变量方法">成员变量方法</h2>
<ul>
<li>局部变量：直接写成员变量名</li>
<li>本类的成员变量：this.成员变量名</li>
<li>父类的成员变量：super.成员变量名</li>
</ul>
<h2 id="成员方法的访问">成员方法的访问</h2>
<ul>
<li>在父子类的继承关系当中，创建子类对象，访问成员方法的规则：</li>
<li>创建的对象是谁，就优先用谁，如果没有则向上找。</li>
</ul>
<blockquote>
<p>注意事项：<br>
无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类。</p>
</blockquote>
<h2 id="方法的重载和重写">方法的重载和重写</h2>
<ul>
<li>重写（Override）概念：在继承关系当中，方法的名称一样，参数列表也一样。</li>
</ul>
<h3 id="对比">对比</h3>
<ul>
<li>
<p>重写（Override）：方法的名称一样，参数列表<code>【也一样】</code>。也称覆盖、覆写。</p>
</li>
<li>
<p>重载（Overload）：方法的名称一样，参数列表<code>【不一样】</code>。</p>
</li>
<li>
<p>方法的覆盖重写特点：创建的是子类对象，则优先用子类方法。</p>
</li>
</ul>
<p>方法覆盖重写的注意事项：</p>
<ul>
<li>
<p>1.必须保证父子类之间方法的名称相同，参数列表也相同。</p>
<blockquote>
<p>@Override：写在方法前面，用来检测是不是有效的正确覆盖重写。<br>
这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。</p>
</blockquote>
</li>
<li>
<p>2.子类方法的返回值必须【小于等于】父类方法的返回值范围。</p>
</li>
<li>
<blockquote>
<p>提示：<code>java.Lang.Object</code>类是所有类的公共最高父类（祖宗类），<code>java.Lang.String</code>就是<code>object</code>的子类。</p>
</blockquote>
</li>
<li>
<p>3.子类方法的权限必须【大于等于】父类方法的权限修饰符。</p>
<blockquote>
<p>提示：<code>public &gt; protected &gt;（default）&gt; private</code>备注：<code>（default）</code>不是关键字<code>default</code>，而是什么都不写，留空</p>
</blockquote>
</li>
</ul>
<h3 id="例子图">例子图</h3>
<p><img src="https://upload.cc/i1/2019/12/14/kIQvGN.png" alt="image-20191214160412148"></p>
<h2 id="继承关系中，父子类构造方法的访问特点">继承关系中，父子类构造方法的访问特点</h2>
<ul>
<li>1.子类构造方法当中有一个默认隐含的“<code>super（）</code>”调用，所以一定是先调用的父类构造，后执行的子类构造。</li>
<li>2.子类构造可以通过<code>super</code>关键字来调用父类重载构造。</li>
<li>3.<code>supe</code>r的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。</li>
<li>总结：<br>
子类必须调用父类构造方法，不写则系统会自动分配一个<code>super（）</code>；写了则用写的指定的<code>super</code>调用，<code>super</code>只能有一个，还必须是第一个。</li>
</ul>
<h2 id="super关键字的用法">super关键字的用法</h2>
<ul>
<li>1.在子类的成员方法中，访问父类的成员变量。</li>
<li>2.在子类的成员方法中，访问父类的成员方法。</li>
<li>3.在子类的构造方法中，访问父类的构造方法。</li>
</ul>
<h2 id="This关键字的用法">This关键字的用法</h2>
<ul>
<li>
<p>1.在本类的成员方法中，访问本类的成员变量。</p>
</li>
<li>
<p>2.在本类的成员方法中，访问本类的另一个成员方法。</p>
</li>
<li>
<p>3.在本类的构造方法中，访问本类的另一个构造方法。</p>
</li>
</ul>
<blockquote>
<p>在第三种用法当中要注意：<br>
A.<code>this（…）</code>调用也必须是构造方法的第一个语句，唯一一个。<br>
B.<code>super</code>和<code>this</code>两种构造调用，不能同时使用。</p>
</blockquote>
<h2 id="关键字图解">关键字图解</h2>
<p><img src="https://upload.cc/i1/2019/12/14/wbWsh2.png" alt="image-20191214175159192"></p>
<h2 id="Java继承的特点">Java继承的特点</h2>
<ul>
<li>单继承：一个类的直接父类只能有唯一个</li>
<li>多级继承</li>
</ul>
<p><img src="https://upload.cc/i1/2019/12/15/VDmdbk.png" alt="image-20191215121245751"></p>
<h1>抽象方法</h1>
<ul>
<li>抽象方法：就是加上<code>abstract</code>关键字，然后去掉大括号，直接分号结束。</li>
<li>抽象类：抽象方法所在的类，必须是抽象类才行。在<code>class</code>之前写上<code>abstract</code>即可。</li>
</ul>
<p>使用抽象类和抽象方法：</p>
<ul>
<li>
<p>1.不能直接创建<code>new</code>抽象类对象。</p>
</li>
<li>
<p>2.必须用一个子类来继承抽象父类。</p>
</li>
<li>
<p>3.子类必须覆盖重写抽象父类当中所有的抽象方法。</p>
<blockquote>
<p>覆盖重写（实现）：子类去掉抽象方法的<code>abstract</code>关键字，然后补上厉法体大括号了</p>
</blockquote>
</li>
<li>
<p>4.创建子类对象进行使用。</p>
</li>
</ul>
<h2 id="注意事项">注意事项</h2>
<ul>
<li>1.抽象类不能创建对象，如果创建，偏译无法通过而报错。只能创建其非抽象子类的对象。</li>
</ul>
<blockquote>
<p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p>
</blockquote>
<ul>
<li>2.抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</li>
</ul>
<blockquote>
<p>理解：子类的构造方法中，有默认的super（），需要访问父类构造方法。</p>
</blockquote>
<ul>
<li>3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
</ul>
<blockquote>
<p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p>
</blockquote>
<ul>
<li>4.抽象类的子类，必须<strong>重写抽象父类中所有的抽象方法</strong>，否则，编译无法通过而报错。除非该子类也是抽象类。</li>
</ul>
<blockquote>
<p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p>
</blockquote>
<h1>接口</h1>
<ul>
<li><strong>接口就是一种公共的规范标准</strong></li>
</ul>
<h2 id="基本定义格式">基本定义格式</h2>
<ul>
<li>接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。</li>
<li><code>public interface 接口名称&#123;  //接口内容    &#125;</code></li>
<li>备注：换成了关键字<code>interface</code>之后，编译生成的字节码文件仍然是：<code>Java--&gt;.class</code>。</li>
<li>如果是<code>Java 7</code>，那么接口中可以包含的内容有：
<ul>
<li>1.常量</li>
<li>2.抽象方法</li>
</ul>
</li>
<li>如果是<code>Java 8</code>，还可以额外包含有：
<ul>
<li>3.默认方法</li>
<li>4.静态方法</li>
</ul>
</li>
<li>如果是<code>Java 9</code>，还可以额外包含有：
<ul>
<li>5.私有方法</li>
</ul>
</li>
</ul>
<h2 id="接口使用步骤">接口使用步骤</h2>
<ul>
<li>
<p>1.接口不能直接使用，必须有一个&quot;<strong>实现类</strong>”来实现该接口。<br>
格式：<br>
<code>public class 实现类名称 implements 接口名称&#123;//…&#125;</code></p>
</li>
<li>
<p>2.接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。<br>
实现：去掉abstract关键字，加上方法体大括号.</p>
</li>
<li>
<p>3.创建实现类的对象，进行使用。</p>
<blockquote>
<p>注意事项：<br>
如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。</p>
</blockquote>
</li>
</ul>
<h2 id="接口的默认方法">接口的默认方法</h2>
<ul>
<li>
<p>从<code>Java 8</code>开始，接口里允许定义默认方法。<br>
格式：<code>public default 返回值类型 方法名称（参数列表）&#123;方法体....&#125;</code></p>
<blockquote>
<p>备注：接口当中的默认方法，可以解决接口升级的问题。</p>
</blockquote>
</li>
<li>
<p>1.接口的默认方法，可以通过接口实现类对象，直接调用。</p>
</li>
<li>
<p>2.接口的默认方法，也可以被接口实现类进行覆盖重写。</p>
</li>
</ul>
<h2 id="接口的私有方法">接口的私有方法</h2>
<ul>
<li>从<code>Java 9</code>开始，接口当中允许定义私有方法。</li>
<li>1.普通私有方法，解决多个默认方法之间重复代码问题格式：<br>
<code>private 返回值类型 方法名称（参数列表）&#123;方法体....&#125;</code></li>
<li>2.静态私有方法，解决多个静态方法之间重复代码问题格式：<br>
<code>private static 返回值类型 方法名称（参数列表）&#123;方法体&#125;</code></li>
</ul>
<h2 id="接口的常量定义和使用">接口的常量定义和使用</h2>
<ul>
<li>
<p>接口当中也可以定义**“成员变量**”，但是必须使用<code>public static final</code>三个关键字进行修饰。<br>
从效果上看，这其实就是接口的<code>【常量】</code>。<br>
格式：<br>
<code>public static final 数据类型 常量名称 = 数据值；</code></p>
</li>
<li>
<p>备注：一旦使用final关键字进行修饰，说明不可改变。</p>
</li>
</ul>
<blockquote>
<p>注意事项：<br>
1.接口当中的常量，可以省略<code>public static final</code>，注意：不写也照样是这样。<br>
2.接口当中的常量，必须进行赋值；不能不赋值。<br>
3.接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则则</p>
</blockquote>
<h2 id="注意事项-2">注意事项</h2>
<p>使用接囗的时候，需要注意：</p>
<ul>
<li>1.接口是没有静态代码块或者构造方法的。</li>
<li>2.一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。<br>
格式：<br>
<code>public class MyInterfaceImpl implements MyInterfaceA，MyInterfaceBf&#123;//覆盖重写所有抽象方法&#125;</code></li>
<li>3.如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。</li>
<li>4.如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。</li>
<li>5.如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</li>
<li>6.一个类如果父类当中的方法和接口当中的默认方法产生了冲突，优先用父类当中的方法。</li>
</ul>
<h2 id="接口间的多继承">接口间的多继承</h2>
<ul>
<li>
<p>1.类与类之间是单继承的。直接父类只有一个。</p>
</li>
<li>
<p>2.类与接口之间是多实现的。一个类可以实现多个接口。</p>
</li>
<li>
<p>3.接口与接口之间是多继承的。</p>
</li>
</ul>
<blockquote>
<p>注意事项：<br>
1.多个父接口当中的抽象方法如果重复，没关系。<br>
2.多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着<code>default</code>关键字】</p>
</blockquote>
<h1>多态</h1>
<h2 id="多态格式">多态格式</h2>
<ul>
<li>代码当中体现多态性，其实就是一句话：父类引用指向子类对象。</li>
<li>格式：</li>
<li><code>父类名称 对象名 = new 子类名称();</code></li>
<li><code>接口名称 对象名 = new 实现类名称();</code></li>
</ul>
<h2 id="多态中的成员变量">多态中的成员变量</h2>
<ul>
<li>1.直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。</li>
<li>2.间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。</li>
</ul>
<h2 id="多态中的成员方法">多态中的成员方法</h2>
<ul>
<li>
<p>在多态的代码当中，成员方法的访问规则是：看<code>new</code>的是谁，就优先用谁，没有则向上找。</p>
<blockquote>
<p>口诀：编译看左边，运行看右边。<br>
成员变量：编译看左边，运行还看左边。</p>
<p>成员方法：编译看左边，运行看右边。</p>
</blockquote>
</li>
</ul>
<h2 id="对象的向上和向下转型">对象的向上和向下转型</h2>
<p><img src="https://upload.cc/i1/2019/12/17/Dw7Fh3.png" alt="image-20191217152136035"></p>
<blockquote>
<p>说明：如何才能知道一个父类引用的对象，本来是什么子类<br>
格式：<br>
<code>对象 instanceof 类名称</code><br>
这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2023/02/06/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Linux管理文件和目录的命令">Linux管理文件和目录的命令</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>pwd</td>
<td>显示当前目录</td>
<td>ls</td>
<td>查看目录下的内容</td>
</tr>
<tr>
<td>cd</td>
<td>改变所在目录</td>
<td>cat</td>
<td>显示文件的内容</td>
</tr>
<tr>
<td>grep</td>
<td>在文件中查找某字符</td>
<td>cp</td>
<td>复制文件</td>
</tr>
<tr>
<td>touch</td>
<td>创建文件</td>
<td>mv</td>
<td>移动文件</td>
</tr>
<tr>
<td>rm</td>
<td>删除文件</td>
<td>rmdir</td>
<td>删除目录</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>pwd命令</p>
<p>该命令的英文解释为print working directory(打印工作目录)。输入pwd命令，Linux会输出当前目录。</p>
</li>
<li>
<p>cd命令</p>
<p>cd命令用来改变所在目录。</p>
<span id="more"></span>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /      转到根目录中 </span><br><span class="line">cd ~     转到/home/user用户目录下 </span><br><span class="line">cd /usr 转到根目录下的usr目录中-------------绝对路径 </span><br><span class="line">cd test 转到当前目录下的test子目录中-------相对路径</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ls命令</p>
</blockquote>
<p>​	ls命令用来查看目录的内容。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>列举目录中的全部文件，包括隐藏文件</td>
</tr>
<tr>
<td>-l</td>
<td>列举目录中的细节，包括权限、所有者、组群、大小、创建日期、文件是否是链接等</td>
</tr>
<tr>
<td>-f</td>
<td>列举的文件显示文件类型</td>
</tr>
<tr>
<td>-r</td>
<td>逆向，从后向前地列举目录中内容</td>
</tr>
<tr>
<td>-R</td>
<td>递归，该选项递归地列举当前目录下所有子目录内的内容</td>
</tr>
<tr>
<td>-s</td>
<td>大小，按文件大小排序</td>
</tr>
<tr>
<td>-h</td>
<td>以人类可读的方式显示文件的大小，如用K、M、G作单位</td>
</tr>
<tr>
<td>ls -l examples.doc</td>
<td>列举文件examples.doc的所有信息</td>
</tr>
</tbody>
</table>
<h2 id="cat命令">cat命令</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat命令可以用来合并文件，也可以用来在屏幕上显示整个文件的内容。</span><br><span class="line"></span><br><span class="line">cat snow.txt 该命令显示文件snow.txt的内容，ctrl+D退出cat。</span><br></pre></td></tr></table></figure>
<h2 id="grep命令">grep命令</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep命令的最大功能是在一堆文件中查找一个特定的字符串。</span><br><span class="line"></span><br><span class="line">  grep money test.txt</span><br><span class="line"></span><br><span class="line">  以上命令在test.txt中查找money这个字符串，grep查找是区分大小写的</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h2 id="touch命令​">touch命令​</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch命令用来创建新文件，他可以创建一个空白的文件，可以在其中添加文本和数据。</span><br><span class="line"></span><br><span class="line">  touch newfile 该命令创建一个名为newfile的空白文件。</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h2 id="cp命令">cp命令</h2>
<p>​	cp命令用来拷贝文件，要复制文件，输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp &lt;source filename&gt; &lt;target filename&gt;</span><br><span class="line">cp t.txt Document/t    该命令将把文件t.txt复制到Document目录下，并命名为t。</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-i</td>
<td>互动：如果文件将覆盖目标中的文件，他会提示确认</td>
</tr>
<tr>
<td>-r</td>
<td>递归：这个选项会复制整个目录树、子目录以及其他</td>
</tr>
<tr>
<td>-v</td>
<td>详细：显示文件的复制进度</td>
</tr>
</tbody>
</table>
<h2 id="mv命令">mv命令</h2>
<p>​	mv命令用来移动文件。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-i</td>
<td>互动：如果选择的文件会覆盖目标中的文件，他会提示确认</td>
</tr>
<tr>
<td>-f</td>
<td>强制：它会超越互动模式，不提示地移动文件，属于很危险的选项</td>
</tr>
<tr>
<td>-v</td>
<td>详细：显示文件的移动进度</td>
</tr>
</tbody>
</table>
<p>​	mv t.txt Document    把文件t.txt 移动到目录Document中。</p>
<h2 id="rm命令">rm命令</h2>
<p>​	rm命令用来删除文件。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-i</td>
<td>互动：提示确认删除</td>
</tr>
<tr>
<td>-f</td>
<td>强制：代替互动模式，不提示确认删除</td>
</tr>
<tr>
<td>-v</td>
<td>详细：显示文件的删除进度</td>
</tr>
<tr>
<td>-r</td>
<td>递归：将删除某个目录以及其中所有的文件和子目录</td>
</tr>
</tbody>
</table>
<p>​	rm t.txt   该命令删除文件t.txt</p>
<blockquote>
<p>rmdir命令</p>
</blockquote>
<p>​	rmdir命令用来删除目录。</p>
<blockquote>
<p>mkdir 命令</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#单个文件夹创建</span><br><span class="line">mkdir 文件夹名称</span><br><span class="line">#例如：mkdir wenjianjia</span><br><span class="line"></span><br><span class="line">#多个文件夹创建</span><br><span class="line">mkdirs 文件夹1/文件夹2......</span><br><span class="line">\#例如：mkdirs wenjianjia1/wenjianjia2</span><br></pre></td></tr></table></figure>
<h2 id="chmod命令详解">chmod命令详解</h2>
<p><strong>作用：</strong></p>
<blockquote>
<p>改变一个或多个文件的存取模式(mode)</p>
</blockquote>
<p><strong>格式：</strong></p>
<blockquote>
<p>chmod [options] mode files</p>
</blockquote>
<p>只能文件属主或特权用户才能使用该功能来改变文件存取模式。</p>
<p><strong>mode：</strong><br>
可以是数字形式或以who opcode permission形式表示。who是可选的，默认是a(所有用户)。只能选择一个opcode(操作码)。可指定多个mode，以逗号分开。</p>
<blockquote>
<p>综上，包含options、who、opcode、permission等选项，下面分别进行介绍</p>
</blockquote>
<p><strong>options：</strong></p>
<table>
<thead>
<tr>
<th>标识</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c，–changes</td>
<td>只输出被改变文件的信息</td>
</tr>
<tr>
<td>-f，–silent，–quiet</td>
<td>当chmod不能改变文件模式时，不通知文件的用户</td>
</tr>
<tr>
<td>–help</td>
<td>输出帮助信息。</td>
</tr>
<tr>
<td>-R，–recursive</td>
<td>可递归遍历子目录，把修改应到目录下所有文件和子目录</td>
</tr>
<tr>
<td>–reference=filename</td>
<td>参照filename的权限来设置权限</td>
</tr>
<tr>
<td>-v，–verbose</td>
<td>无论修改是否成功，输出每个文件的信息</td>
</tr>
<tr>
<td>–version</td>
<td>输出版本信息</td>
</tr>
</tbody>
</table>
<p><strong>who</strong></p>
<table>
<thead>
<tr>
<th>标识</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>用户</td>
</tr>
<tr>
<td>g</td>
<td>组</td>
</tr>
<tr>
<td>o</td>
<td>其它</td>
</tr>
<tr>
<td>a</td>
<td>所有用户(默认)</td>
</tr>
</tbody>
</table>
<p><strong>opcode</strong></p>
<table>
<thead>
<tr>
<th>标识</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>增加权限</td>
</tr>
<tr>
<td>-</td>
<td>删除权限</td>
</tr>
<tr>
<td>=</td>
<td>重新分配权限</td>
</tr>
</tbody>
</table>
<p><strong>permission</strong></p>
<table>
<thead>
<tr>
<th>标识</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>读</td>
</tr>
<tr>
<td>w</td>
<td>写</td>
</tr>
<tr>
<td>x</td>
<td>执行</td>
</tr>
<tr>
<td>s</td>
<td>设置用户(或组)的ID号</td>
</tr>
<tr>
<td>t</td>
<td>设置粘着位(sticky bit)，防止文件或目录被非属主删除</td>
</tr>
</tbody>
</table>
<p>作为选择，我们多数用三位八进制数字的形式来表示权限，第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限。如6(4+2)代表有读写权，7(4+2+1)有读、写和执行的权限。</p>
<p>还可设置第四位，它位于三位权限序列的前面，第四位数字取值是4，2，1，代表意思如下：</p>
<blockquote>
<p>4，执行时设置用户ID，用于授权给基于文件属主的进程，而不是给创建此进程的用户。<br>
2，执行时设置用户组ID，用于授权给基于文件所在组的进程，而不是基于创建此进程的用户。<br>
1，设置粘着位。</p>
</blockquote>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ chmod u+x file                　给file的属主增加执行权限</span><br><span class="line">$ chmod 751 file                　给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限</span><br><span class="line">$ chmod u=rwx,g=rx,o=x file      上例的另一种形式</span><br><span class="line">$ chmod =r file                  为所有用户分配读权限</span><br><span class="line">$ chmod 444 file              　 同上例</span><br><span class="line">$ chmod a-wx,a+r   file   　　 　 同上例</span><br><span class="line">$ chmod -R u+r directory       　递归地给directory目录下所有文件和子目录的属主分配读的权限</span><br><span class="line">$ chmod 4755                     设置用ID，给属主分配读、写和执行权限，给组和其他用户分配读、执行的权限。</span><br></pre></td></tr></table></figure>
<h2 id="linux下链接">linux下链接</h2>
<p>ln –s 源文件 目标文件</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>LinuxLiunx命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习（一）</title>
    <url>/2023/02/06/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1>Linux操作系统</h1>
<ul>
<li>“一切皆文件”</li>
</ul>
<h2 id="系统启动流程">系统启动流程</h2>
<p>引导图</p>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200502160423268.png" alt="引导图"></p>
<ul>
<li>
<p>最初始阶段<br>
当我们打开计算机电源，计算机会自动从主板的<code>BlOS</code>（Basic Input/output System）读取其中所存储的程序。这一程序通常知道一些直接连接在主板上的硬件（硬盘，网络接口，键盘，串口，并口）。现在大部分的BIOS允许你从软盘、光盘或者硬盘中选择一个来启动计算机。</p>
</li>
<li>
<p>下一步，计算机将从你所选择的存储设备中读取起始的512 bytes（比如光盘一开是的512 bytes，如果我们从光盘启动的话）。这<code>512bytes</code>叫做主引导记录<code>MBR</code>（master boot record）。<code>MBR</code>会告诉电脑从该设备的某一个分区（partition）来装载引导加载程序（boot loader）。<code>Boot loader</code>储存有操作系统（OS）的相关信息，比如操作系统名称，操作系统内核（kernel）所在位置等。常用的<code>boot loader</code>有<code>GRUB</code>和<code>LILO</code>。</p>
</li>
<li>
<p>随后，<code>boot loade</code>r会帮助我们加载<code>kernel</code>。<code>kernel</code>实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过<code>kernel</code>传达给硬件。<code>Windows</code>和<code>Linux</code>各自有自己<code>kernel</code>。</p>
</li>
<li>
<p>狭义的操作系统就是指<code>kernel</code>，广义的操作系统包括<code>kernel</code>以及<code>kernel</code>之上的各种应用。</p>
</li>
<li>
<p>（Linus Torvalds与其说是Linux之父，不如说是<code>Linux kernel</code>之父。他依然负责<code>Linux kernel</code>的开发和维护。至于<code>Ubuntu</code>，<code>Red Hat</code>，它们都是基于相同的<code>kernel</code>之上，囊括了不同的应用和界面构成的一个更加完整的操作系统版本。）实际上，我们可以在多个分区安装<code>boot loader</code>，每个<code>boot loader</code>对应不同的操作系统，在读取<code>MBR</code>的时候选择我们想要启动的boot loader。这就是多操作系统的原理。</p>
</li>
<li>
<p>小结：<code>BlOS -&gt; MBR -&gt; boot loader -&gt; kernel</code></p>
</li>
<li>
<p>kernel</p>
<ul>
<li>如果我们加载的是Linux kernel，Linux kernel开始工作。kernel会首先预留自己运行所需的内存空间，然后通过驱动程序（driver）检测计算机硬件。这样，操作系统就可以知道自己有哪些硬件可用。随后，kernel会启动一个init进程。它是Linux系统中的1号进程（Linux系统没有0号进程）。到此，kernel就完成了在计算机启动阶段的工作，交接给init来管理。</li>
<li>小结：<code>kernel -&gt; init process </code></li>
</ul>
</li>
<li>
<p><code>init process</code></p>
<p>（根据boot loader的选项，Linux此时可以进入单用户模式（single user mode））。在此模式下，初始脚本还没有开始执行，我们可以检测并修复计算机可能存在的错误）随后，init会运行一系列的初始脚本（startup scripts），这些脚本是Linux中常见的shell scripts。这些脚本执行如下功能：</p>
<ul>
<li>设置计算机名称，时区，检测文件系统，挂载硬盘，清空临时文件，设置网络等</li>
</ul>
<p>当这些初始脚本，操作系统已经完全准备好了，只是，还没有人可以登录！！！init会给出登录（login）对话框，或者是图形化的登录界面。</p>
</li>
<li>
<p>输入用户名（比如说luenci）和密码，DONE！</p>
</li>
<li>
<p>在此后的过程中，你将以用户（user）luenci的身份操作电脑。此外，根据你创建用户时的设定，Linux还会将你归到某个组（group）中，比如可以是stupid组，或者是luenci组。所以你将是用户luenci，同时是luenci组的组员。（注意，组luenci和用户luenci只是重名而已，就好想你可以叫Dell，同时还是Dell公司的老板一样。你完全也可以是用户luenci，同时为stupid组的组员）</p>
</li>
</ul>
<h3 id="启动级别">启动级别</h3>
<ul>
<li>
<p>7种运行级别</p>
<p>运行级别（<code>Runlevel</code>）指的是Unix或者Linux等类Unix操作系统的运行模式，不同的运行模式下系统的功能也有所有不同。Linux 系统下通常分为<code>7</code>种运行级别，分别是从<code>0</code>到<code>6</code>。各级别介绍如下：</p>
</li>
<li>
<p><code>0</code>–停机模式</p>
<ul>
<li>在这种模式下，系统处于停机状态，系统默认运行级别不能设为<code>0</code>，否则将不能正常启动。这个运行级别主要用于关闭任务，在<code>/etc/rc0.d</code>目录下的各个连接命令都是此级别的命令，在关闭系统时，这些命令将被逐个执行。它 们会杀掉所有进程、关闭虚拟内存和交换文件、卸载文件系统和交换分区。</li>
</ul>
</li>
<li>
<p><code>1</code>– 单用户模式。</p>
<ul>
<li>在这种运行模下，系统处于单用户工作状态，登录用户具有root权限，文件系统被加载但是网络却没有被加载，因此也无法远程登陆。这个运行级别，只允一个用户从本地计算机上登录，<code>/etc/rc1.d</code>目录下的所有文件与此运行级别相关连，这个运行级别一般用于系统管理与维护。</li>
</ul>
</li>
<li>
<p><code>2</code> - -多用户模式。</p>
<ul>
<li>用户可以通过网络进行登录，但没有<code>NFS</code>（Network File System），即网络文件统。<code>/etc/rc2.d</code>目录下所有文件与此级别相连。</li>
</ul>
</li>
<li>
<p><code>3</code> - -完全多用户模式。</p>
</li>
<li>
<p>用户可以通过网络进行登录，且有<code>NFS</code>，用户登陆后会进入控制台命令行模式。这也是缺省的运行模式，在这种运行级别下所有网络服务程序会一起运行。<code>/etc/rc2.d</code>录下的文件与此级别相连</p>
</li>
<li>
<p><code>4</code> - -自定义模式。</p>
<ul>
<li>这是一种系统未使用的保留模式，<code>/etc/rc4.d</code>目录与此级别相连。这一级别是用户自定义的运行级别，用户可以根自己的需要进行一些自定义设置。如果想要运行这一级别的话，必须在<code>rc3.d</code>目录下放入连接文件，就像其他<code>rc*.d</code>目录下的文件，并指明是启动还是终止进程。</li>
</ul>
</li>
<li>
<p><code>5</code> - -图形化模式。</p>
<ul>
<li>在 Linux 下运行<code>X Window</code>就是使用这一运行级别，用户登录后将进入图形化的GUI界面。在这一级别下除了DNS的<code>named</code>与级别<code>3</code>不同，其余的都相同。</li>
</ul>
</li>
<li>
<p><code>6</code> – 重启模式。</p>
<ul>
<li>系统正常关闭并重启，默认运行级别不能设为<code>5</code>，否则系统将不能正常启动。<code>/etc/rc6.d</code>目录与此级别相连。在这一运行级别下，不会关闭电源，<code>/etc/rc6.d</code>目录下的连接与<code>rc0.d</code>目录下的连接基本相同；不同之处在于，虽然它们都执行<code>halt</code>（关闭）命令，但是给<code>halt</code>传递的参数不同，所级别<code>6</code>会重新启动系统而<code>0</code>会关闭系统。</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h3 id="GRUB加密">GRUB加密</h3>
<ul>
<li><code>GRUB</code>程序和<code>grub.conf</code>文件</li>
<li>1）掌握GRUB的定义：<code>GRUB</code>是<code>Grand Unified Boot loader</code>（多重操作系统启动管理器）的缩写。<br>
心</li>
<li>2）掌握grub的配置文件为：<code>grub.conf</code>设置<code>grub Md5</code>加密命令<code>grub-md5-crypt </code>
<ul>
<li><code>Password=明文</code>或<code>password-md5密文</code>（编辑grub配置文件的密码）</li>
</ul>
</li>
<li>Title red hat 标题
<ul>
<li><code>Password=明文或password--md5密文</code>（加载内核系统引导必须的密码）</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200502155136848.png" alt="grub配置"></p>
<h3 id="BIOS加密">BIOS加密</h3>
<ul>
<li>设置BIOS密码来防止更改GRU配置文件</li>
<li>但是这种方法可将主板电池扣下，主板自动还原，密码也失效了</li>
</ul>
<p><em><code>没有绝对的安全，要不停的学习</code></em></p>
<h2 id="目录结构">目录结构</h2>
<ul>
<li>在Linux或UNIX操作系统中，所有的文件和目录都被组织成一个以根节点开始的倒置的<em><strong>树状结构</strong></em>。</li>
</ul>
<h3 id="顶层根目录的表示">顶层根目录的表示</h3>
<ul>
<li>使用<code>'/'</code>来表示根目录</li>
</ul>
<h3 id="文件系统中的特殊目录">文件系统中的特殊目录</h3>
<ul>
<li><code>.</code>表示当前目录，即用户所在的工作目录</li>
<li><code>..</code>表示父目录，即当前目录的上一层目录</li>
<li><code>~</code>代表当前用户的家目录（home）</li>
</ul>
<!-- more -->
<h3 id="一些重要目录">一些重要目录</h3>
<ol>
<li><code>bin</code>目录：用来存放常用的可执行文件</li>
<li><code>sbin</code>目录：用来存放系统的可执行文件</li>
<li><code>home</code>家目录：用来存放用户自己的文件或目录，其中，超级用户<code>root</code>的家目普通用户的家目录被存放在<code>/home</code>目录下，并使用用户名作为最后一级目的名称，如<code>luenci</code>用户的家目录为<code>/home/luenci</code></li>
<li><code>dev</code>目录：设备文件目录</li>
<li><code>etc</code>目录：配置文件目录</li>
<li>挂载点（目录）：通常可移除式硬件会被挂载在<code>/media</code>或<code>/mnt</code>目录之下</li>
</ol>
<h2 id="用户，群组，权限管理">用户，群组，权限管理</h2>
<ul>
<li><code>/etc/passed</code>文件中存放用户的信息</li>
<li>分别对应的是：<code>用户名：密码：user_id：group_id：描述名：家目录（home）：登录后执行的命令</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200501204906550.png" alt="1"></p>
<ul>
<li>如果执行的登录命令为：<code>/bin/bash</code>则可以登录</li>
<li>如果执行的登录命令为：<code>/sbin/nologin</code>则不可以登录</li>
<li><code>user_id</code>: 500以前id号为系统占用的</li>
</ul>
<h3 id="useradd命令的常用选项">useradd命令的常用选项</h3>
<ul>
<li><code>-u</code>：指定用户的UID</li>
<li><code>-g</code>：指定用户所属的群组</li>
<li><code>-d</code>：指定用户的家目录</li>
<li><code>-c</code>：指定用户的备注信息</li>
<li><code>-s</code>：指定用户所用的shell</li>
<li><code>-r</code>: 删除用户</li>
</ul>
<h2 id="文件的权限管理">文件的权限管理</h2>
<ul>
<li>权限信息(用户权限(u);组权限(g);其他用户权限(0))；硬链接数；用户；用户组；文件大小；文件创建日期</li>
<li>r-&gt;4</li>
<li>w-&gt;2</li>
<li>x-&gt;1</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200501215623758.png" alt="2"></p>
<ul>
<li>
<p><code>-</code>开头代表一个文件类型</p>
</li>
<li>
<p><code>d</code>开头代表一个目录类型</p>
</li>
<li>
<p><code>l</code>开头代表一个软链接</p>
</li>
<li>
<p><code>b（block）</code>开头代表设备文件</p>
</li>
<li>
<p><code>p</code>开头有代表管道文件</p>
</li>
</ul>
<h3 id="对于可执行文件的运行">对于可执行文件的运行</h3>
<ul>
<li><code>sh 可执行文件名</code></li>
<li><code>bash 可执行文件名</code></li>
<li><code>./可执行文件名</code></li>
<li><code>. 可执行文件名</code></li>
</ul>
<h2 id="目录的权限管理">目录的权限管理</h2>
<ul>
<li><code>ll -d 目录</code>查看目录的权限</li>
<li><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200502123137125.png" alt="3"></li>
</ul>
<h2 id="更改文件的用户和组">更改文件的用户和组</h2>
<ul>
<li><code>chown  用户.组别  文件名</code></li>
<li><code>chown -R</code>递归修改用户和组</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200502123543551.png" alt="4"></p>
<h2 id="文件合并">文件合并</h2>
<ul>
<li>
<p><code>wc -l 文件名</code>统计文件行数</p>
</li>
<li>
<p><code>&gt;</code>以覆盖的方式写入内容</p>
</li>
<li>
<p><code>&gt;&gt;</code>以追加的方式写入内容</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200502132024461.png" alt=""></p>
<h2 id="解压和压缩命令">解压和压缩命令</h2>
<p>1、.<code>tar </code></p>
<p>解包：<code>tar xvf FileName.tar</code><br>
打包：<code>tar cvf FileName.tar DirName</code><br>
（注：tar是打包，不是压缩！）</p>
<p>2、<code>.gz</code></p>
<p>解压1：<code>gunzip FileName.gz</code><br>
解压2：<code>gzip -d FileName.gz</code><br>
压缩：<code>gzip FileName</code></p>
<p>3、<code>.tar.gz</code> 和<code> .tgz</code></p>
<p>解压：<code>tar zxvf FileName.tar.gz</code><br>
压缩：<code>tar zcvf FileName.tar.gz DirName</code></p>
<p>4、<code>.bz2</code></p>
<p>解压1：<code>bzip2 -d FileName.bz2</code><br>
解压2：<code>bunzip2 FileName.bz2</code><br>
压缩：<code> bzip2 -z FileName</code></p>
<p>5、<code>.tar.bz2</code></p>
<p>解压：<code>tar jxvf FileName.tar.bz2</code><br>
压缩：<code>tar jcvf FileName.tar.bz2 DirName</code></p>
<p>6、<code>.bz</code></p>
<p>解压1：<code>bzip2 -d FileName.bz</code><br>
解压2：<code>bunzip2 FileName.bz</code></p>
<p>7、<code>.tar.bz</code></p>
<p>解压：<code>tar jxvf FileName.tar.bz</code></p>
<p>8、.Z</p>
<p>解压：<code>uncompress FileName.Z</code><br>
压缩：<code>compress FileName</code></p>
<p>9、<code>.tar.Z</code></p>
<p>解压：<code>tar Zxvf FileName.tar.Z</code><br>
压缩：<code>tar Zcvf FileName.tar.Z DirName</code></p>
<p>10、<code>.zip</code></p>
<p>解压：<code>unzip FileName.zip</code><br>
压缩：<code>zip FileName.zip DirName</code></p>
<p>11、<code>.rar</code></p>
<p>解压：<code>rar x FileName.rar</code><br>
压缩：<code>rar a FileName.rar DirName</code></p>
<p>12、<code>.lha</code></p>
<p>解压：<code>lha -e FileName.lha</code><br>
压缩：<code>lha -a FileName.lha FileName</code></p>
<p>13、<code>.rpm</code></p>
<p>解包：<code>rpm2cpio FileName.rpm | cpio -div</code></p>
<h2 id="vim一些常见指令">vim一些常见指令</h2>
<ul>
<li>
<p>快速在屏幕中移动光标的位置的命令</p>
<ul>
<li><code>H</code>光标移动到这个屏幕的最上方那一行的第一个字符</li>
<li><code>M</code>无标移动到这个屏幕的中央那一行的第一个字符</li>
<li><code>L</code>无标移动到这个屏幕的最下那一行的第一个字符</li>
</ul>
</li>
<li>
<p><code>G</code>移动到文件的最后一行</p>
</li>
<li>
<p><code>gg</code>移动到文件的第一行</p>
</li>
<li>
<p><code>ctrl+ r</code>恢复上一次操作</p>
</li>
<li>
<p><code>u</code>撤销上一个操作</p>
</li>
<li>
<p><code>ctrl+a</code>跳到文件的首部</p>
</li>
<li>
<p><code>ctrl+e</code>跳到文件的尾部</p>
</li>
<li>
<p><code>yy</code>复制</p>
</li>
<li>
<p><code>p</code>粘贴到行尾</p>
</li>
<li>
<p><code>P</code>站贴到行头</p>
</li>
</ul>
<h2 id="top命令">top命令</h2>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200502170646416.png" alt=""></p>
<h3 id="第一行">第一行</h3>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">top - 10:03:19</td>
<td style="text-align:center">当前系统时间</td>
</tr>
<tr>
<td style="text-align:center">up 137 days , 10:40</td>
<td style="text-align:center">系统已运行时间</td>
</tr>
<tr>
<td style="text-align:center">2 user</td>
<td style="text-align:center">在线用户</td>
</tr>
<tr>
<td style="text-align:center">load average: 0.00, 0.01, 0.05</td>
<td style="text-align:center">系统负载。三个数值分别为  1分钟、5分钟、15分钟前到现在的平均值。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>2 user，包含系统用户。</p>
</blockquote>
<hr>
<h3 id="第二行">第二行</h3>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Tasks : 92 total</td>
<td style="text-align:center">总进程数</td>
</tr>
<tr>
<td style="text-align:center">2 running</td>
<td style="text-align:center">正在运行的进程数</td>
</tr>
<tr>
<td style="text-align:center">90 sleeping</td>
<td style="text-align:center">正在睡眠的进程数</td>
</tr>
<tr>
<td style="text-align:center">0 stopped</td>
<td style="text-align:center">停止的进程数</td>
</tr>
<tr>
<td style="text-align:center">0 zombie</td>
<td style="text-align:center">僵尸进程数</td>
</tr>
</tbody>
</table>
<blockquote>
<p>僵尸进程:一个子进程在其父进程没有调用wait()或waitpid()的情况下退出。这个子进程就是僵尸进程。如果其父进程还存在而一直不调用wait，则该僵尸进程将无法回收，等到其父进程退出后该进程将被init回收。</p>
</blockquote>
<hr>
<h3 id="第三行">第三行</h3>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%Cpu(s): 0.3 us</td>
<td style="text-align:center">cpu占用率(%)，用户进程占用cpu百分率</td>
</tr>
<tr>
<td style="text-align:center">0.3 sy</td>
<td style="text-align:center">系统占用cpu百分率</td>
</tr>
<tr>
<td style="text-align:center">0.0 ni</td>
<td style="text-align:center">用户进程空间内改变过优先级的进程占用CPU百分比</td>
</tr>
<tr>
<td style="text-align:center">99.3 id</td>
<td style="text-align:center">cpu空闲率</td>
</tr>
<tr>
<td style="text-align:center">0.0 wa</td>
<td style="text-align:center">等待IO的CPU时间百分比</td>
</tr>
<tr>
<td style="text-align:center">0.0 hi</td>
<td style="text-align:center">硬中断（Hardware IRQ）占用CPU的百分比</td>
</tr>
<tr>
<td style="text-align:center">0.0 si</td>
<td style="text-align:center">软中断（Software Interrupts）占用CPU的百分比</td>
</tr>
</tbody>
</table>
<blockquote>
<p>cpu的使用情况</p>
</blockquote>
<hr>
<h3 id="第四行">第四行</h3>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">KiB Mem : 1016916 total</td>
<td style="text-align:center">内存总量（我这里是1G）</td>
</tr>
<tr>
<td style="text-align:center">82280 free</td>
<td style="text-align:center">内存空闲量</td>
</tr>
<tr>
<td style="text-align:center">233848 used</td>
<td style="text-align:center">内存使用量</td>
</tr>
<tr>
<td style="text-align:center">700788 buff/cache</td>
<td style="text-align:center">缓存的内存量</td>
</tr>
</tbody>
</table>
<blockquote>
<p>内存使用率</p>
</blockquote>
<hr>
<h3 id="第五行">第五行</h3>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">KiB Swap: 0 total</td>
<td style="text-align:center">交换区总量</td>
</tr>
<tr>
<td style="text-align:center">0 free</td>
<td style="text-align:center">交换区空闲量</td>
</tr>
<tr>
<td style="text-align:center">0 used</td>
<td style="text-align:center">交换区使用量</td>
</tr>
</tbody>
</table>
<blockquote>
<p>swap分区</p>
</blockquote>
<hr>
<h3 id="第六行">第六行</h3>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PID</td>
<td style="text-align:center">进程号</td>
</tr>
<tr>
<td style="text-align:center">USER</td>
<td style="text-align:center">进程创建者</td>
</tr>
<tr>
<td style="text-align:center">PR</td>
<td style="text-align:center">进程优先级</td>
</tr>
<tr>
<td style="text-align:center">NI</td>
<td style="text-align:center">nice值。越小优先级越高，最小-20，最大20（用户设置最大19）</td>
</tr>
<tr>
<td style="text-align:center">VIRT</td>
<td style="text-align:center">进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</td>
</tr>
<tr>
<td style="text-align:center">RES</td>
<td style="text-align:center">进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</td>
</tr>
<tr>
<td style="text-align:center">SHR</td>
<td style="text-align:center">共享内存大小，单位kb</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</td>
</tr>
<tr>
<td style="text-align:center">%CPU</td>
<td style="text-align:center">进程占用cpu百分比</td>
</tr>
<tr>
<td style="text-align:center">%MEM</td>
<td style="text-align:center">进程占用内存百分比</td>
</tr>
<tr>
<td style="text-align:center">TIME+</td>
<td style="text-align:center">进程运行时间</td>
</tr>
<tr>
<td style="text-align:center">COMMAND</td>
<td style="text-align:center">进程名称</td>
</tr>
</tbody>
</table>
<blockquote>
<p>PR 越低优先级 越高，PRI(new)=PRI(old)+nice<br>
PR中的rt为实时进程优先级即rt_priority，prio=MAX_RT_PRIO - 1- p-&gt;rt_priority<br>
MAX_RT_PRIO = 99，prio大小决定最终优先级。这样意味着rt_priority值越大，优先级越高而内核提供的修改优先级的函数，是修改rt_priority的值，所以越大，优先级越高。<br>
例：改变优先级：进入top后按“r”–&gt;输入进程PID–&gt;输入nice值</p>
</blockquote>
<h3 id="top命令（在进入top后使用）">top命令（在进入top后使用）</h3>
<blockquote>
<p>P：以占据CPU百分比排序<br>
M：以占据内存百分比排序<br>
T：以累积占用CPU时间排序<br>
q：退出命令：按q键退出top查看页面<br>
s：修改刷新时间间隔。按下s键，然后按下数字，即可修改刷新时间间隔为你输入的数字，单位为秒。例如：按下s键，在按数字1键，即可实现每秒刷新一次<br>
k：终止指定的进程。按下k键–&gt;再输入要杀死的进程的pid–&gt;按enter键–&gt;(选择信号类型，以数字标示，默认15为杀死)本步可省略按enter键（常用为-9）</p>
</blockquote>
<h2 id="free命令">free命令</h2>
<ul>
<li><code>free</code></li>
<li><code>free -m</code></li>
<li><code>free -h</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200502171251931.png" alt=""></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>核心知识</category>
      </categories>
      <tags>
        <tag>Linux知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习（二）</title>
    <url>/2023/02/06/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1>Linux操作系统（二）</h1>
<h2 id="进程命令">进程命令</h2>
<ul>
<li><code>ps aux</code>  显示所有进程</li>
<li><code>ps aux | grep ''</code> 筛选出相关进程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200502204505096.png" alt=""></p>
<ul>
<li><code>kill  pid</code> 杀死相关的pid进程</li>
<li><code>kill - 9 pid</code> 强制杀死进程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200502204832777.png" alt=""></p>
<ul>
<li><code>jobs</code>查看进程的工作号</li>
<li><code>fg %工作号</code>后台程序调到前台运行</li>
</ul>
<h2 id="硬盘分区">硬盘分区</h2>
<ul>
<li><code>fdisk -l /dev/磁盘名</code>查看对应磁盘名的详细信息</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200502212407780.png" alt=""></p>
<span id="more"></span>
<h2 id="文件系统">文件系统</h2>
<ul>
<li>
<p>磁盘分区完毕后还需要进行格式化（format），之后操作系统才能够使用这个文件系统。 为什么需要进行“格式化”呢？这是因为每种操作系统所设置的文件属性/权限并不相同， 为了存放这些文件所需的数据，因此就需要将分区进行格式化，以成为操作系统能够利用的“文件系统格式（filesystem）”。</p>
</li>
<li>
<p>由此我们也能够知道，每种操作系统能够使用的文件系统并不相同。 举例来说，windows 98 以前的微软操作系统主要利用的文件系统是 FAT （或 FAT16），windows 2000 以后的版本有所谓的 NTFS 文件系统，至于 Linux 的正统文件系统则为 Ext2 （Linux second extended file system, ext2fs）这一个。此外，在默认的情况下，windows 操作系统是不会认识 Linux 的 Ext2 的。</p>
</li>
<li>
<p>传统的磁盘与文件系统之应用中，一个分区就是只能够被格式化成为一个文件系统，所以我们可以说一个 filesystem 就是一个 partition。但是由于新技术的利用，例如我们常听到的LVM与软件磁盘阵列（software raid）， 这些技术可以将一个分区格式化为多个文件系统（例如LVM），也能够将多个分区合成一个文件系统（LVM, RAID）！ 所以说，目前我们在格式化时已经不再说成针对 partition 来格式化了， 通常我们可以称呼一个可被挂载的数据为一个文件系统而不是一个分区喔！</p>
</li>
<li>
<p>那么文件系统是如何运行的呢？这与操作系统的文件数据有关。较新的操作系统的文件数据除了文件实际内容外， 通常含有非常多的属性，例如 Linux 操作系统的文件权限（rwx）与文件属性（拥有者、群组、时间参数等）。 文件系统通常会将这两部份的数据分别存放在不同的区块，权限与属性放置到 inode 中，至于实际数据则放置到 data block 区块中。 另外，还有一个超级区块 （<code>superblock</code>） 会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等。</p>
</li>
</ul>
<p>每个 inode 与 block 都有编号，至于这三个数据的意义可以简略说明如下：</p>
<ul>
<li><code>superblock</code>：记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；</li>
<li>inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 block 号码；</li>
<li>block：实际记录文件的内容，若文件太大时，会占用多个 block 。</li>
</ul>
<p>由于每个 inode 与 block 都有编号，而每个文件都会占用一个 inode ，inode 内则有文件数据放置的 block 号码。 因此，我们可以知道的是，如果能够找到文件的 inode 的话，那么自然就会知道这个文件所放置数据的 block 号码， 当然也就能够读出该文件的实际数据了。这是个比较有效率的作法，因为如此一来我们的磁盘就能够在短时间内读取出全部的数据， 读写的性能比较好啰。</p>
<p>我们将 inode 与 block 区块用图解来说明一下，如下图所示，文件系统先格式化出 inode 与 block 的区块，假设某一个文件的属性与权限数据是放置到 inode 4 号（下图较小方格内），而这个 inode 记录了文件数据的实际放置点为 2, 7, 13, 15 这四个 block 号码，此时我们的操作系统就能够据此来排列磁盘的读取顺序，可以一口气将四个 block 内容读出来！ 那么数据的读取就如同下图中的箭头所指定的模样了。</p>
<p><img src="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/img/filesystem-1.jpg" alt="inode/block 数据存取示意图">图7.1.1、inode/block 数据存取示意图</p>
<p>这种数据存取的方法我们称为索引式文件系统（indexed allocation）。那有没有其他的惯用文件系统可以比较一下啊？ 有的，那就是我们惯用的U盘（闪存），U盘使用的文件系统一般为 FAT 格式。FAT 这种格式的文件系统并没有 inode 存在，所以 FAT 没有办法将这个文件的所有 block 在一开始就读取出来。每个 block 号码都记录在前一个 block 当中， 他的读取方式有点像下面这样：</p>
<p><img src="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/img/filesystem-2.jpg" alt="FAT文件系统数据存取示意图">图7.1.2、FAT文件系统数据存取示意图</p>
<p>​	上图中我们假设文件的数据依序写入1-&gt;7-&gt;4-&gt;15号这四个 block 号码中， 但这个文件系统没有办法一口气就知道四个 block 的号码，他得要一个一个的将 block 读出后，才会知道下一个 block 在何处。 如果同一个文件数据写入的 block 分散的太过厉害时，则我们的磁头将无法在磁盘转一圈就读到所有的数据， 因此磁盘就会多转好几圈才能完整的读取到这个文件的内容！</p>
<p>常常会听到所谓的“磁盘重组”吧？ 需要磁盘重组的原因就是文件写入的 block 太过于离散了，此时文件读取的性能将会变的很差所致。 这个时候可以通过磁盘重组将同一个文件所属的 blocks 汇整在一起，这样数据的读取会比较容易啊！ 想当然尔，FAT 的文件系统需要三不五时的磁盘重组一下，那么 Ext2 是否需要磁盘重整呢？</p>
<p>由于 Ext2 是索引式文件系统，基本上不太需要常常进行磁盘重组的。但是如果文件系统使用太久， 常常删除/编辑/新增文件时，那么还是可能会造成文件数据太过于离散的问题，此时或许会需要进行重整一下的。 不过，老实说，鸟哥倒是没有在 Linux 操作系统上面进行过 Ext2/Ext3 文件系统的磁盘重组.</p>
<ul>
<li>每个 <code>filesystem</code> 都有独立的<code>inode / block / superblock</code>等信息，这个文件系统要能够链接到目录树才能被我们使用。 将文件系统与目录树结合的动作我们称为“挂载”。</li>
<li>重点是：挂载点一定是目录，该目录为进入该文件系统的入口。 因此并不是你有任何文件系统都能使用，必须要“挂载”到目录树的某个目录后，才能够使用该文件系统的。</li>
</ul>
<h3 id="关于硬盘空间满">关于硬盘空间满</h3>
<ul>
<li>
<p>1.指硬盘存储空间满</p>
</li>
<li>
<p>2.<code>inode</code>节点数满了</p>
<ul>
<li>查看<code>inode</code>命令<code>ll -i 文件名</code></li>
<li><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200503212834594.png" alt=""></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200503212215228.png" alt=""></p>
<h2 id="硬链接和软链接">硬链接和软链接</h2>
<p>软链接</p>
<ul>
<li><code>ln -s 源路径 目标路径</code>
<ul>
<li>类似windows操作系统的快捷方式</li>
<li>删除链接文件，源文件不影响</li>
<li>删除源文件，链接文件失效</li>
<li>修改源文件/链接文件，内容都变</li>
<li>软链接可以跨分区</li>
</ul>
</li>
</ul>
<p>硬链接</p>
<ul>
<li>
<p><code>ln 源路径 目标路径</code></p>
<ul>
<li>删除链接文件，源文件无影响</li>
<li>删除源文件，链接文件无影响</li>
<li>修改源文件/链接文件，内容都变</li>
<li>硬链接不可以跨分区</li>
</ul>
</li>
</ul>
<h2 id="软件包管理">软件包管理</h2>
<ul>
<li><code>rpm</code>:readhat package manage</li>
<li><code>rpm -ivh 软件包名</code> 安装
<ul>
<li><code>rpm -qa</code>查看安装的软件包</li>
<li><code>rpm -e 软件包名</code>卸载软件包</li>
</ul>
</li>
<li><code>.tar.gz</code>这种软件包需要编译安装
<ul>
<li>1.解压 <code>tar xvf 压缩包名</code></li>
<li>运行<code>configure</code>指定参数，例如：<code>--prefix:安装路径</code></li>
<li>2.编译（<code>gcc glibc</code>） <code>make</code>   <code>make install</code></li>
</ul>
</li>
</ul>
<h2 id="yum软件包管理（Centos）">yum软件包管理（Centos）</h2>
<ul>
<li>
<p><code>yum install 软件包名</code></p>
</li>
<li>
<p>本地的yum仓库路径<code>/etc/yum.repos.d/</code></p>
</li>
<li>
<p>指定yum仓库的加载顺序</p>
<ul>
<li>安装完yum-priorities插件后需要设置<code>/etc/yum.repos.d/ </code>目录下的<code>.repo</code>相关文件（如<code>CentOS-Base.repo</code>），在这些文件中插入顺序指令：priority=N （N为1到99的正整数，数值越小越优先）</li>
<li>一般配置<code>[base], [addons], [updates], [extras] </code>的<code>priority=1，[CentOSplus], [contrib] 的priority=2，</code>其他第三的软件源为：<code>priority=N</code> （推荐N&gt;10）<br>
以<code>CentOS-Base.repo </code>为例：</li>
</ul>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">[base]</span><br><span class="line">name=CentOS-$releasever - Base</span><br><span class="line">#mirrorlist=http:<span class="comment">//mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os</span></span><br><span class="line">baseurl=http:<span class="comment">//ftp.sjtu.edu.cn/centos/$releasever/os/$basearch/</span></span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=file:<span class="comment">///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5</span></span><br><span class="line">priority=<span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>核心知识</category>
      </categories>
      <tags>
        <tag>Linux知识</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列笔记</title>
    <url>/2023/02/06/MQ%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>消息队列介绍</h1>
<h2 id="概念">概念</h2>
<ul>
<li>MQ（Message Queue，消息队列），是基础数据结构中“先进先出”的一种数据结构，是在消息的传输工程中保存消息的容器。多用于分布式系统之间进行通信等。</li>
</ul>
<h2 id="MQ优势">MQ优势</h2>
<h3 id="应用解耦">应用解耦</h3>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/20201201225748.png" alt="image-20201129132737572"></p>
<h3 id="异步提速">异步提速</h3>
<p><img src="https://b3logfile.com/file/2020/12/image-9d8dcb68.png?imageView2/2/interlace/1/format/webp" alt="image.png"></p>
<h3 id="削峰填谷">削峰填谷</h3>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/20201201225756.png" alt="image-20201129132952802"></p>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/20201201225806.png" alt="image-20201129133010842"></p>
<h2 id="MQ的带来的问题">MQ的带来的问题</h2>
<h4 id="系统的可用性降低">系统的可用性降低</h4>
<ul>
<li>系统引入的外部依赖越多，系统的稳定性就越差。如果MQ宕机，整个业务就会受到影响。如何保证MQ的高可用？</li>
</ul>
<h4 id="系统的复杂度提高">系统的复杂度提高</h4>
<ul>
<li>MQ的加入大大增加了系统的复杂度，以前系统间是同步调用的，现在通过MQ进行一步调用。如何保证消息没有被重复消费？怎么处理消息地丢失情况？怎么保证消息传递的顺序性</li>
</ul>
<h4 id="一致性问题">一致性问题</h4>
<ul>
<li>A系统处理完业务，通过MQ给B、C、D三个系统发消息，如果B、C系统成功，D系统处理失败。如何保证消息数据的一致性？</li>
</ul>
<h2 id="使用MQ的场景">使用MQ的场景</h2>
<ul>
<li>生产者不需要从消费者处获得反馈。
<ul>
<li>引入消息队列之前的直接调用，其接口的返回值应该为空，即上层的请求不依赖下层返回的结果，这样也才能使异步成为可能</li>
</ul>
</li>
<li>容许短暂的不一致性</li>
<li>收益性高
<ul>
<li>引入MQ后系统解耦、提速、削峰等方面的收益大于管理使用MQ的成本</li>
</ul>
</li>
</ul>
<h1>RabbitMQ介绍</h1>
<p><code>AMQP</code>，即（Advanced Message Queuing Protocal）（高级消息队列），是一个<code>网络协议</code>，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端和消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。</p>
<p><img src="https://www.rabbitmq.com/img/tutorials/intro/hello-world-example-routing.png" alt="Publish path from publisher to consumer via exchange and queue"></p>
<h2 id="RabbitMQ基础架构和组件信息">RabbitMQ基础架构和组件信息</h2>
<p><img src="https://gitee.com/luenci/RepoImg/raw/master/img/20201201225820.png" alt="image-20201129161016285"></p>
<ul>
<li>
<p>Broker：标识消息队列服务器实体.</p>
</li>
<li>
<p>Virtual Host：虚拟主机。标识一批交换机、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个vhost本质上就是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器、绑定和权限机制。vhost是AMQP概念的基础，必须在链接时指定，RabbitMQ默认的vhost是 /。</p>
</li>
<li>
<p>Exchange：交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</p>
</li>
<li>
<p>Queue：消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>
</li>
<li>
<p>Banding：绑定，用于消息队列和交换机之间的关联。一个绑定就是基于路由键将交换机和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p>
</li>
<li>
<p>Channel：信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟链接，AMQP命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说，建立和销毁TCP都是非常昂贵的开销，所以引入了信道的概念，以复用一条TCP连接。</p>
</li>
<li>
<p>Connection：网络连接，比如一个TCP连接。</p>
</li>
<li>
<p>Publisher：消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p>
</li>
<li>
<p>Consumer：消息的消费者，表示一个从一个消息队列中取得消息的客户端应用程序。</p>
</li>
<li>
<p>Message：消息，消息是不具名的，它是由消息头和消息体组成。消息体是不透明的，而消息头则是由一系列的可选属性组成，这些属性包括routing-key(路由键)、priority(优先级)、delivery-mode(消息可能需要持久性存储[消息的路由模式])等。</p>
</li>
</ul>
<h2 id="RabbitMQ的工作模式">RabbitMQ的工作模式</h2>
<blockquote>
<p>原文链接：<a href="https://www.cnblogs.com/Jeely/p/10784013.html">https://www.cnblogs.com/Jeely/p/10784013.html</a></p>
</blockquote>
<h3 id="1-1simple简单模式">1.1simple简单模式</h3>
<p><img src="https://img-blog.csdnimg.cn/20181221114009759.png" alt="在这里插入图片描述"></p>
<ol>
<li>消息产生着and将消息放入队列</li>
<li>消息的消费者(consumer) 监听(while) 消息队列,如果队列中有消息,就消费掉,消息被拿走后,自动从队列中删除(隐患 消息可能没有被消费者正确处理,已经从队列中消失了,造成消息的丢失)应用场景:聊天(中间有一个过度的服务器;p端,c端)</li>
</ol>
<h4 id="生产者代码样例">生产者代码样例</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">auth = pika.PlainCredentials(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;主机名&#x27;</span>, <span class="string">&#x27;5672&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, auth))</span><br><span class="line"></span><br><span class="line">channel = connection.channel()</span><br><span class="line"><span class="comment"># 设置消息队列</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;TEST01&#x27;</span>)</span><br><span class="line"><span class="comment"># 向消息队列中发消息</span></span><br><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                      routing_key=<span class="string">&#x27;TEST01&#x27;</span>,</span><br><span class="line">                      body=<span class="string">&#x27;Hello World I am Luenci&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; [x] Sent &#x27;Hello World!&#x27;&quot;</span>)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<h4 id="消费者代码样例">消费者代码样例</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">auth = pika.PlainCredentials(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;主机名&#x27;</span>, <span class="string">&#x27;5672&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, auth))</span><br><span class="line"></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;TEST01&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; [x] Received %r&quot;</span> % body)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(on_message_callback=callback,</span><br><span class="line">                      queue=<span class="string">&#x27;TEST01&#x27;</span>,</span><br><span class="line">                      auto_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;</span>)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<h3 id="1-2-work工作模式-资源的竞争">1.2 work工作模式(资源的竞争)</h3>
<p><img src="https://img-blog.csdnimg.cn/20181221114036231.png" alt="在这里插入图片描述"></p>
<ol>
<li>
<p>**说明：**一对多模式，一个生产者，多个消费者，一个队列，每个消费者从队列中获取唯一的消息。</p>
<p>有两种消息分发机制，轮询分发和公平分发：</p>
<p>轮询分发的特点是将消息轮流发送给每个消费者，在实际情况中，多个消费者，难免有的处理得快，有的处理得慢，如果都要等到一个消费者处理完，才把消息发送给下一个消费者，效率就大大降低了。</p>
<p>而公平分发的特点是，只要有消费者处理完，就会把消息发送给目前空闲的消费者，这样就提高消费效率了。</p>
</li>
<li>
<p>消息产生者将消息放入队列消费者可以有多个,消费者1,消费者2,同时监听同一个队列,消息被消费? C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费消息(隐患,高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize,与同步锁的性能不一样) 保证一条消息只能被一个消费者使用)</p>
</li>
<li>
<p>应用场景:红包;大项目中的资源调度(任务分配系统不需知道哪一个任务执行系统在空闲,直接将任务扔到消息队列中,空闲的系统自动争抢)</p>
</li>
</ol>
<h4 id="生产者">生产者</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">auth = pika.PlainCredentials(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;主机名&#x27;</span>, <span class="string">&#x27;5672&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, auth))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;task_queue&#x27;</span>, durable=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">message = <span class="string">&#x27; &#x27;</span>.join(sys.argv[<span class="number">1</span>:]) <span class="keyword">or</span> <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    channel.basic_publish(</span><br><span class="line">        exchange=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        routing_key=<span class="string">&#x27;task_queue&#x27;</span>,</span><br><span class="line">        body=message,</span><br><span class="line">        properties=pika.BasicProperties(</span><br><span class="line">            delivery_mode=<span class="number">2</span>,  <span class="comment"># make message persistent</span></span><br><span class="line">        ))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; [x] Sent %r&quot;</span> % message)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<h4 id="消费者">消费者</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">auth = pika.PlainCredentials(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;主机名&#x27;</span>, <span class="string">&#x27;5672&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, auth))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;task_queue&#x27;</span>, durable=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; [x] Received %r&quot;</span> % body)</span><br><span class="line">    time.sleep(body.count(<span class="string">b&#x27;.&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; [x] Done&quot;</span>)</span><br><span class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 公平分发</span></span><br><span class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</span><br><span class="line">channel.basic_consume(queue=<span class="string">&#x27;task_queue&#x27;</span>, on_message_callback=callback)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<h3 id="1-3-publish-subscribe发布订阅-共享资源">1.3 publish/subscribe发布订阅(共享资源)</h3>
<p><img src="https://img-blog.csdnimg.cn/20181221114050657.png" alt="在这里插入图片描述"></p>
<ol>
<li>X代表交换机rabbitMQ内部组件,erlang 消息产生者是代码完成,代码的执行效率不高,消息产生者将消息放入交换机,交换机发布订阅把消息发送到所有消息队列中,对应消息队列的消费者拿到消息进行消费</li>
<li>相关场景:邮件群发,群聊天,广播(广告)</li>
</ol>
<h4 id="生产者-2">生产者</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">auth = pika.PlainCredentials(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;主机名&#x27;</span>, <span class="string">&#x27;5672&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, auth))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;logs&#x27;</span>, exchange_type=<span class="string">&#x27;fanout&#x27;</span>)</span><br><span class="line"></span><br><span class="line">message = <span class="string">&#x27; &#x27;</span>.join(sys.argv[<span class="number">1</span>:]) <span class="keyword">or</span> <span class="string">&quot;info: Hello World!&quot;</span></span><br><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;logs&#x27;</span>, routing_key=<span class="string">&#x27;&#x27;</span>, body=message)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; [x] Sent %r&quot;</span> % message)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<h4 id="消费者-2">消费者</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">auth = pika.PlainCredentials(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;主机名&#x27;</span>, <span class="string">&#x27;5672&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, auth))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;logs&#x27;</span>, exchange_type=<span class="string">&#x27;fanout&#x27;</span>)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(queue=<span class="string">&#x27;&#x27;</span>, exclusive=<span class="literal">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=<span class="string">&#x27;logs&#x27;</span>, queue=queue_name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for logs. To exit press CTRL+C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; [x] %r&quot;</span> % body)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.basic_consume(</span><br><span class="line">    queue=queue_name, on_message_callback=callback, auto_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<h3 id="1-4-routing路由模式">1.4 routing路由模式</h3>
<p><img src="https://img-blog.csdnimg.cn/20181221114420299.png" alt="在这里插入图片描述"></p>
<ol>
<li>消息生产者将消息发送给交换机按照路由判断,路由是字符串(info) 当前产生的消息携带路由字符(对象的方法),交换机根据路由的key,只能匹配上路由key对应的消息队列,对应的消费者才能消费消息;</li>
<li>根据业务功能定义路由字符串</li>
<li>从系统的代码逻辑中获取对应的功能字符串,将消息任务扔到对应的队列中业务场景:error 通知;EXCEPTION;错误通知的功能;传统意义的错误通知;客户通知;利用key路由,可以将程序中的错误封装成消息传入到消息队列中,开发者可以自定义消费者,实时接收错误;</li>
</ol>
<h4 id="生产者-3">生产者</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">auth = pika.PlainCredentials(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;主机名&#x27;</span>, <span class="string">&#x27;5672&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, auth))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;direct_logs&#x27;</span>, exchange_type=<span class="string">&#x27;direct&#x27;</span>)</span><br><span class="line"></span><br><span class="line">severity = sys.argv[<span class="number">1</span>] <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="string">&#x27;info&#x27;</span></span><br><span class="line">message = <span class="string">&#x27; &#x27;</span>.join(sys.argv[<span class="number">2</span>:]) <span class="keyword">or</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line">channel.basic_publish(</span><br><span class="line">    exchange=<span class="string">&#x27;direct_logs&#x27;</span>, routing_key=severity, body=message)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; [x] Sent %r:%r&quot;</span> % (severity, message))</span><br><span class="line"></span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<h4 id="消费者-3">消费者</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">auth = pika.PlainCredentials(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;主机名&#x27;</span>, <span class="string">&#x27;5672&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, auth))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;logs&#x27;</span>, exchange_type=<span class="string">&#x27;fanout&#x27;</span>)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(queue=<span class="string">&#x27;&#x27;</span>, exclusive=<span class="literal">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=<span class="string">&#x27;logs&#x27;</span>, queue=queue_name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for logs. To exit press CTRL+C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; [x] %r&quot;</span> % body)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.basic_consume(</span><br><span class="line">    queue=queue_name, on_message_callback=callback, auto_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<h3 id="1-5-topic-主题模式-路由模式的一种">1.5 topic 主题模式(路由模式的一种)</h3>
<p><img src="https://img-blog.csdnimg.cn/20181221114208408.png" alt="在这里插入图片描述"></p>
<ol>
<li>星号井号代表通配符</li>
<li>星号代表多个单词,井号代表一个单词</li>
<li>路由功能添加模糊匹配</li>
<li>消息产生者产生消息,把消息交给交换机</li>
<li>交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消费</li>
</ol>
<h4 id="生产者-4">生产者</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">auth = pika.PlainCredentials(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;主机名&#x27;</span>, <span class="string">&#x27;5672&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, auth))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;topic_logs&#x27;</span>, exchange_type=<span class="string">&#x27;topic&#x27;</span>)</span><br><span class="line"></span><br><span class="line">routing_key = sys.argv[<span class="number">1</span>] <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">2</span> <span class="keyword">else</span> <span class="string">&#x27;anonymous.info&#x27;</span></span><br><span class="line">message = <span class="string">&#x27; &#x27;</span>.join(sys.argv[<span class="number">2</span>:]) <span class="keyword">or</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line">channel.basic_publish(</span><br><span class="line">    exchange=<span class="string">&#x27;topic_logs&#x27;</span>, routing_key=routing_key, body=message)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; [x] Sent %r:%r&quot;</span> % (routing_key, message))</span><br><span class="line"></span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<h4 id="消费者-4">消费者</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">auth = pika.PlainCredentials(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;主机名&#x27;</span>, <span class="string">&#x27;5672&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, auth))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;topic_logs&#x27;</span>, exchange_type=<span class="string">&#x27;topic&#x27;</span>)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(<span class="string">&#x27;&#x27;</span>, exclusive=<span class="literal">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">binding_keys = sys.argv[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> binding_keys:</span><br><span class="line">    sys.stderr.write(<span class="string">&quot;Usage: %s [binding_key]...\n&quot;</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> binding_key <span class="keyword">in</span> binding_keys:</span><br><span class="line">    channel.queue_bind(</span><br><span class="line">        exchange=<span class="string">&#x27;topic_logs&#x27;</span>, queue=queue_name, routing_key=binding_key)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for logs. To exit press CTRL+C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; [x] %r:%r&quot;</span> % (method.routing_key, body))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.basic_consume(</span><br><span class="line">    queue=queue_name, on_message_callback=callback, auto_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<h1>RabbitMQ速度提升</h1>
<ul>
<li>消息消费速度主要受到发送消息时间、消费者处理时间、消息Ack时间这几个时间的影响</li>
</ul>
<blockquote>
<p><a href="https://www.cnblogs.com/bossma/p/practices-on-improving-the-speed-of-rabbitmq-consumption.html">https://www.cnblogs.com/bossma/p/practices-on-improving-the-speed-of-rabbitmq-consumption.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>rabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库引擎和数据类型</title>
    <url>/2023/02/06/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="数据库引擎介绍"><strong>数据库引擎介绍</strong></h2>
<h3 id="前言">前言</h3>
<ul>
<li>1、存储引擎其实就是对于数据库文件的一种存取机制，如何实现存储数据，如何为存储的数据建立索引以及如何更新，查询数据等技术实现的方法。</li>
<li>2、MySQL中的数据用各种不同的技术存储在文件（或内存）中，这些技术中的每一种技术都使用不同的存储机制，索引技巧，锁定水平并且最终提供广泛的不同功能和能力。在MySQL中将这些不同的技术及配套的相关功能称为存储引擎。</li>
<li>3、根据需求可以在表中设置不同的存储引擎。</li>
</ul>
<h3 id="查看mysql中的引擎">查看mysql中的引擎</h3>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200605131656597.png" alt="查看引擎"></p>
<h3 id="MySQL中常用的几种存储引擎">MySQL中常用的几种存储引擎</h3>
<h3 id="1．MyISAM存储引擎">1．<code>MyISAM</code>存储引擎</h3>
<ul>
<li>
<p>存放的位置</p>
<ul>
<li>MySQL如果使用<code>MyISAM</code>存储引擎，数据库文件类型就包括<code>.frm</code>、<code>.MYD</code>、<code>.MYI</code>，默认存放位置是<code>C:\Documentsand Settings\All Users\Application Data\MySQL\MySQL Server 5.1\data</code></li>
</ul>
</li>
<li>
<p>存放的方式</p>
<ul>
<li><code>MyISAM</code> 这种存储引擎不支持事务，不支持行级锁，只支持并发插入的表锁，主要用于高负载的select。</li>
</ul>
</li>
<li>
<p>索引的方式</p>
<ul>
<li><code>MyISAM</code>也是使用B+tree索引但是和<code>Innodb</code>的在具体实现上有些不同。</li>
</ul>
</li>
</ul>
<p>该引擎基于<code>ISAM</code>数据库引擎，除了提供<code>ISAM</code>里所没有的索引和字段管理等大量功能，<code>MyISAM</code>还使用一种表格锁定的机制来优化多个并发的读写操作，但是需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间，否则碎片也会随之增加，最终影响数据访问性能。<code>MyISAM</code>还有一些有用的扩展，例如用来修复数据库文件的<code>MyISAMChk</code>工具和用来恢复浪费空间的 <code>MyISAMPack</code>工具。<code>MyISAM</code>强调了快速读取操作，主要用于高负载的select，这可能也是MySQL深受Web开发的主要原因：在Web开发中进行的大量数据操作都是读取操作，所以大多数虚拟主机提供商和Internet平台提供商（Internet Presence Provider, <code>IPP</code>）只允许使用<code>MyISAM</code>格式。</p>
<ul>
<li>
<p><code>MyISAM</code>类型的表支持三种不同的存储结构：静态型、动态型、压缩型。</p>
</li>
<li>
<p>静态型：指定义的表列的大小是固定（即不含有：<code>xblob</code>、<code>xtext</code>、<code>varchar</code>等长度可变的数据类型），这样MySQL就会自动使用静态<code>MyISAM</code>格式。使用静态格式的表的性能比较高，因为在维护和访问以预定格式存储数据时需要的开销很低；但这种高性能是以空间为代价换来的，因为在定义的时候是固定的，所以不管列中的值有多大，都会以最大值为准，占据了整个空间。</p>
</li>
<li>
<p>动态型：如果列（即使只有一列）定义为动态的（<code>xblob</code>, <code>xtext</code>, <code>varchar</code>等数据类型），这时<code>MyISAM</code>就自动使用动态型，虽然动态型的表占用了比静态型表较少的空间，但带来了性能的降低，因为如果某个字段的内容发生改变则其位置很可能需要移动，这样就会导致碎片的产生，随着数据变化的增多，碎片也随之增加，数据访问性能会随之降低。<br>
对于因碎片增加而降低数据访问性这个问题，有两种解决办法：</p>
<ul>
<li>a、尽可能使用静态数据类型；</li>
<li>b、经常使用<code>optimize table table_name</code>语句整理表的碎片，恢复由于表数据的更新和删除导致的空间丢失。如果存储引擎不支持<code> optimize table table_name</code>则可以转储并 重新加载数据，这样也可以减少碎片；</li>
</ul>
</li>
<li>
<p>压缩型：如果在数据库中创建在整个生命周期内只读的表，则应该使用<code>MyISAM</code>的压缩型表来减少空间的占用。</p>
</li>
</ul>
<blockquote>
<p>优缺点：<code>MyISAM</code>的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。</p>
</blockquote>
<h3 id="2．innoDB存储引擎">2．<code>innoDB</code>存储引擎</h3>
<ul>
<li>
<p>存储位置</p>
<ul>
<li>MySQL如果使用<code>InnoDB</code>存储引擎，数据库文件类型就包括<code>.frm</code>、<code>ibdata1</code>、<code>.ibd</code>，存放位置有两个，<code>.frm</code>文件默认存放位置是<code>C:\Documents and Settings\All Users\ApplicationData\MySQL\MySQL Server 5.1\data</code>，<code>ibdata1</code>、<code>.ibd</code>文件默认存放位置是MySQL安装目录下的data文件夹。</li>
</ul>
</li>
<li>
<p><code>innodb</code>存储引擎的mysql表提供了事务，回滚以及系统崩溃修复能力和多版本迸发控制的事务的安全。</p>
</li>
<li>
<p><code>innodb</code>支持自增长列（auto_increment）,自增长列的值不能为空，如果在使用的时候为空的话怎会进行自动存现有的值开始增值，如果有但是比现在的还大，则就保存这个值。</p>
</li>
<li>
<p><code>innodb</code>存储引擎支持外键（foreign key） ,外键所在的表称为子表而所依赖的表称为父表。</p>
</li>
<li>
<p><code>innodb</code>存储引擎最重要的是支持事务，以及事务相关联功能。</p>
</li>
<li>
<p><code>innodb</code>存储引擎支持<code>mvcc</code>的行级锁。</p>
</li>
<li>
<p><code>innodb</code>存储引擎索引使用的是B+Tree</p>
</li>
</ul>
<blockquote>
<p>优缺点：<code>InnoDB</code>的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。</p>
</blockquote>
<span id="more"></span>
<h3 id="3．MEMORY存储引擎">3．<code>MEMORY</code>存储引擎</h3>
<ul>
<li>
<p><code>memory</code>存储引擎相比前面的一些存储引擎，有点不一样，其使用存储在内从中的数据来创建表，而且所有的数据也都存储在内存中。</p>
</li>
<li>
<p>每个基于memory存储引擎的表实际对应一个磁盘文件，该文件的文件名和表名是相同的，类型为<code>.frm</code>。该文件只存储表的结构，而其数据文件，都是存储在内存中，这样有利于对数据的快速处理，提高整个表的处理能力。</p>
</li>
<li>
<p><code>memory</code>存储引擎默认使用哈希（HASH）索引，其速度比使用<code>B-+ Tree</code>型要快，如果读者希望使用B树型，则在创建的时候可以引用。</p>
</li>
<li>
<p><code>memory</code>存储引擎文件数据都存储在内存中，如果<code>mysqld</code>进程发生异常，重启或关闭机器这些数据都会消失。所以<code>memory</code>存储引擎中的表的生命周期很短，一般只使用一次。</p>
</li>
</ul>
<h3 id="4．ARCHIVE存储引擎">4．<code>ARCHIVE</code>存储引擎</h3>
<ul>
<li>该存储引擎非常适合存储大量独立的、作为历史记录的数据。</li>
<li>区别于<code>InnoDB</code>和<code>MyISAM</code>这两种引擎，ARCHIVE提供了压缩功能，拥有高效的插入速度，但是这种引擎不支持索引，所以查询性能较差一些。</li>
</ul>
<h2 id="四种存储引擎比较">四种存储引擎比较</h2>
<ul>
<li>
<p><code>InnoDB</code>：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择<code>InnoDB</code>有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择<code>InnoDB</code>，因为支持事务的提交（commit）和回滚（rollback）。</p>
</li>
<li>
<p><code>MyISAM</code>：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择<code>MyISAM</code>能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。如果数据表主要用来插入和查询记录，则<code>MyISAM</code>引擎能提供较高的处理效率</p>
</li>
<li>
<p><code>MEMORY</code>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择<code>MEMOEY</code>。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的<code>Memory</code>引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果</p>
</li>
<li>
<p>如果只有<code>INSERT</code>和<code>SELECT</code>操作，可以选择<code>Archive</code>，<code>Archive</code>支持高并发的插入操作，但是本身不是事务安全的。</p>
</li>
<li>
<p><code>Archive</code>非常适合存储归档数据，如记录日志信息可以使用<code>Archiv</code></p>
</li>
</ul>
<blockquote>
<p>注意，同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择<code>InnoDB</code>。这个数据库中可以将查询要求比较高的表选择<code>MyISAM</code>存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。</p>
</blockquote>
<h2 id="数据类型">数据类型</h2>
<h3 id="数值类型">数值类型</h3>
<p>MySQL支持所有标准SQL数值数据类型。</p>
<p>这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。</p>
<p>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</p>
<p>BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。</p>
<p>作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">范围（有符号）</th>
<th style="text-align:left">范围（无符号）</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">TINYINT</td>
<td style="text-align:left">1 byte</td>
<td style="text-align:left">(-128，127)</td>
<td style="text-align:left">(0，255)</td>
<td style="text-align:left">小整数值</td>
</tr>
<tr>
<td style="text-align:left">SMALLINT</td>
<td style="text-align:left">2 bytes</td>
<td style="text-align:left">(-32 768，32 767)</td>
<td style="text-align:left">(0，65 535)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMINT</td>
<td style="text-align:left">3 bytes</td>
<td style="text-align:left">(-8 388 608，8 388 607)</td>
<td style="text-align:left">(0，16 777 215)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">INT或INTEGER</td>
<td style="text-align:left">4 bytes</td>
<td style="text-align:left">(-2 147 483 648，2 147 483 647)</td>
<td style="text-align:left">(0，4 294 967 295)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">BIGINT</td>
<td style="text-align:left">8 bytes</td>
<td style="text-align:left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td>
<td style="text-align:left">(0，18 446 744 073 709 551 615)</td>
<td style="text-align:left">极大整数值</td>
</tr>
<tr>
<td style="text-align:left">FLOAT</td>
<td style="text-align:left">4 bytes</td>
<td style="text-align:left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td style="text-align:left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td style="text-align:left">单精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:left">DOUBLE</td>
<td style="text-align:left">8 bytes</td>
<td style="text-align:left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:left">双精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:left">DECIMAL</td>
<td style="text-align:left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">小数值</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="日期和时间类型">日期和时间类型</h3>
<p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p>
<p>每个时间类型有一个有效值范围和一个&quot;零&quot;值，当指定不合法的MySQL不能表示的值时使用&quot;零&quot;值。</p>
<p>TIMESTAMP类型有专有的自动更新特性，将在后面描述。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小 ( bytes)</th>
<th style="text-align:left">范围</th>
<th style="text-align:left">格式</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DATE</td>
<td style="text-align:left">3</td>
<td style="text-align:left">1000-01-01/9999-12-31</td>
<td style="text-align:left">YYYY-MM-DD</td>
<td style="text-align:left">日期值</td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">3</td>
<td style="text-align:left">‘-838:59:59’/‘838:59:59’</td>
<td style="text-align:left">HH:MM:SS</td>
<td style="text-align:left">时间值或持续时间</td>
</tr>
<tr>
<td style="text-align:left">YEAR</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1901/2155</td>
<td style="text-align:left">YYYY</td>
<td style="text-align:left">年份值</td>
</tr>
<tr>
<td style="text-align:left">DATETIME</td>
<td style="text-align:left">8</td>
<td style="text-align:left">1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td style="text-align:left">YYYY-MM-DD HH:MM:SS</td>
<td style="text-align:left">混合日期和时间值</td>
</tr>
<tr>
<td style="text-align:left">TIMESTAMP</td>
<td style="text-align:left">4</td>
<td style="text-align:left">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td>
<td style="text-align:left">YYYYMMDD HHMMSS</td>
<td style="text-align:left">混合日期和时间值，时间戳</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="字符串类型">字符串类型</h3>
<p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CHAR</td>
<td style="text-align:left">0-255 bytes</td>
<td style="text-align:left">定长字符串</td>
</tr>
<tr>
<td style="text-align:left">VARCHAR</td>
<td style="text-align:left">0-65535 bytes</td>
<td style="text-align:left">变长字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYBLOB</td>
<td style="text-align:left">0-255 bytes</td>
<td style="text-align:left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYTEXT</td>
<td style="text-align:left">0-255 bytes</td>
<td style="text-align:left">短文本字符串</td>
</tr>
<tr>
<td style="text-align:left">BLOB</td>
<td style="text-align:left">0-65 535 bytes</td>
<td style="text-align:left">二进制形式的长文本数据</td>
</tr>
<tr>
<td style="text-align:left">TEXT</td>
<td style="text-align:left">0-65 535 bytes</td>
<td style="text-align:left">长文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMBLOB</td>
<td style="text-align:left">0-16 777 215 bytes</td>
<td style="text-align:left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMTEXT</td>
<td style="text-align:left">0-16 777 215 bytes</td>
<td style="text-align:left">中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">LONGBLOB</td>
<td style="text-align:left">0-4 294 967 295 bytes</td>
<td style="text-align:left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td style="text-align:left">LONGTEXT</td>
<td style="text-align:left">0-4 294 967 295 bytes</td>
<td style="text-align:left">极大文本数据</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</p>
<p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p>
<p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p>
<p>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</p>
<p>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</p>
]]></content>
      <categories>
        <category>SQL知识</category>
      </categories>
      <tags>
        <tag>SQL概念</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库函数</title>
    <url>/2023/02/06/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1>MySQL数据库函数</h1>
<ul>
<li>MySQL函数是数据库提供的内置函数，可以帮助用户更加方便地处理表中的数据。MySQL的内置函数，不但可以在SELECT查询语句中使用，同样可以在INSERT、UPDATE、DELETE等语句中使用。</li>
</ul>
<h2 id="1-数学函数："><strong>1.数学函数：</strong></h2>
<p>MySQL中内置的数学函数见下表：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ABS(x)</td>
<td>返回x的绝对值</td>
</tr>
<tr>
<td>CEIL9x),CEILIN(x)</td>
<td>返回不小于x的最小整数值</td>
</tr>
<tr>
<td>FLOOR(x)</td>
<td>返回不大于x的最大整数值</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回0~1的随机数</td>
</tr>
<tr>
<td>RAND(x)</td>
<td>返回0~1的随机数，x值相同时返回的随机数相同</td>
</tr>
<tr>
<td>SIGN(x)</td>
<td>返回参数作为-1、0、1的符号，该符号取决于x值的负、零、正</td>
</tr>
<tr>
<td>PI()</td>
<td>返回圆周率的值，默认是7位，内部使用完全双精度值</td>
</tr>
<tr>
<td>TRUNCATE(x,y)</td>
<td>返回数值x保留到小数点y位的值</td>
</tr>
<tr>
<td>ROUND(x)</td>
<td>返回离x最近的整数</td>
</tr>
<tr>
<td>ROUND(x,y)</td>
<td>保留x小数点后y位的值，但截断时要进行四舍五入</td>
</tr>
<tr>
<td>POW(x,y),POWER(x,y)</td>
<td>返回x的y乘方的结果值</td>
</tr>
<tr>
<td>SQRT(x)</td>
<td>返回非负数x的二次方根</td>
</tr>
<tr>
<td>EXP(x)</td>
<td>返回e的x乘方后的值（自然对数的底）</td>
</tr>
<tr>
<td>MOD(x,y)</td>
<td>返回x除以y后的余数</td>
</tr>
<tr>
<td>LOG(x)</td>
<td>返回x的基数为2的对数</td>
</tr>
<tr>
<td>LOG10(x)</td>
<td>返回x的基数为10的对数</td>
</tr>
<tr>
<td>RADIANS(x)</td>
<td>将角度转换为弧度</td>
</tr>
<tr>
<td>DEGREES(x)</td>
<td>将弧度转化为角度</td>
</tr>
<tr>
<td>SIN(x)</td>
<td>返回x的正弦，其中x使用弧度</td>
</tr>
<tr>
<td>ASIN(x,y)</td>
<td>返回x的反正弦，若x不在-1到1范围内则返回NULL</td>
</tr>
<tr>
<td>COS(x)</td>
<td>返回x的余弦，其中x为弧度</td>
</tr>
<tr>
<td>ACOS(x,y)</td>
<td>返回x的反余弦，若x不在-1到1范围内则返回NULL</td>
</tr>
<tr>
<td>TAN(x,y)</td>
<td>返回x的正切，其中x为弧度</td>
</tr>
<tr>
<td>ATAN(x),ATAN2(x)</td>
<td>返回x的反正切，y确定结果所在象限</td>
</tr>
<tr>
<td>COT(x,y)</td>
<td>返回x的余切</td>
</tr>
</tbody>
</table>
<h2 id="2-字符串函数："><strong>2.字符串函数：</strong></h2>
<p>字符串函数是MySQL中最常用的的一类函数，主要用于处理表中的字符串。见下表：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR_LENGTH(s)</td>
<td>返回字符串s的字符数</td>
</tr>
<tr>
<td>LENGTH(s)</td>
<td>返回字符串的字节长度，一个多字节字符算作多字节</td>
</tr>
<tr>
<td>CONCAT(s)</td>
<td>返回结果为连接参数产生的字符串。为了避免将数字参数转化为二进制字符串使用SELECT CONCAT(CAST(int_col AS CHAR),char_col)</td>
</tr>
<tr>
<td>CONCAT_WS(x,s1,s2,…)</td>
<td>同CONCAT()函数，但每个字符串都要加上x</td>
</tr>
<tr>
<td>INSERT(s1,x,len,s2)</td>
<td>将字符串s2替换为s1的x位置开始长度为len的字符串</td>
</tr>
<tr>
<td>UPPER(s),UCASE(s)</td>
<td>将字符串s的所有字母都变成大写字母</td>
</tr>
<tr>
<td>LOWER(s),LCASE(s)</td>
<td>将字符串s的所有字母都变成小写字母</td>
</tr>
<tr>
<td>LEFT(s,n)</td>
<td>返回从字符串s开始的最左边n个字符</td>
</tr>
<tr>
<td>RIGHT(s,n)</td>
<td>返回从字符串s开始的最右边n个字符</td>
</tr>
<tr>
<td>LPAD(s1,len,s2)</td>
<td>返回字符串s1，其左边由字符串s2填补到len字符长度</td>
</tr>
<tr>
<td>RPAD(s1,len,s2)</td>
<td>返回字符串s1，其右边被字符串s2填补至len字符长度</td>
</tr>
<tr>
<td>LTRIM(s)</td>
<td>返回字符串s，其引导空格字符被删除</td>
</tr>
<tr>
<td>RTRIM(s)</td>
<td>返回字符串s，结尾空格字符被删去</td>
</tr>
<tr>
<td>TRIM(s)</td>
<td>去掉字符串s开始和结尾处的空格</td>
</tr>
<tr>
<td>TRIM(s1 FROM s)</td>
<td>去掉字符串s中开始处和结尾处的字符串s1</td>
</tr>
<tr>
<td>REPEAT(s,n)</td>
<td>将字符串s重复n次</td>
</tr>
<tr>
<td>SPACE(n)</td>
<td>返回n个空格</td>
</tr>
<tr>
<td>REPLACE(s,s1,s2)</td>
<td>用字符串s2替代字符串s中的字符串s1</td>
</tr>
<tr>
<td>STRCMP(s1,s2)</td>
<td>比较字符串s1和s2</td>
</tr>
<tr>
<td>SUBSTRING(s,n,len)</td>
<td>获取从字符串s第n个位置开始长度为len的字符串</td>
</tr>
<tr>
<td>MID(s,n,len)</td>
<td>同SUBSTRING()</td>
</tr>
<tr>
<td>LOCATE(s1,s) POSITION(s1 IN s)</td>
<td>从字符串s中获取s1的开始位置</td>
</tr>
<tr>
<td>INSTR(s,s1)</td>
<td>从字符串s中获取s1的开始位置</td>
</tr>
<tr>
<td>REVERSE(s)</td>
<td>将字符串s的顺序反过来</td>
</tr>
<tr>
<td>ELT(n,s1,s2)</td>
<td>返回第n个字符串</td>
</tr>
<tr>
<td>EXPORT_SET(bits,on,off[, separator[,number_of_bits]])</td>
<td>返回一个字符串，生成规则为：针对bits的二进制格式，如果位为1则返回一个on值，如果为0则返回一个off值。每个字符串用separator分隔，默认逗号；number_of_bits指定bits的可用位数，默认64位。示例 selectEXPORT_SET(182,‘Y’,‘N’,‘@’,6);</td>
</tr>
<tr>
<td>FIELD(s,s1,s2)</td>
<td>返回第一个与字符串s匹配的字符串的位置</td>
</tr>
<tr>
<td>FIND_IN_SET(s,s2)</td>
<td>返回在字符串s2中与s1匹配的字符串的位置</td>
</tr>
<tr>
<td>MAKE_SET(x,s1,s2,…)</td>
<td>按x的二进制数从s1,s2,…,sn中选取字符串</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h2 id="3-日期和时间函数："><strong>3.日期和时间函数：</strong></h2>
<p>日期和时间函数主要用于对表中的日期和时间数据的处理。见下表：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>CURDATE(),CURRENT_DATE()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CURTIME(),CURRENT_TIME()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>NOW(),CURRENT_TIMESTAMP(), LOCALTIME(),SYSDATE(),LOCALTIMESTAMP()</td>
<td>返回当前日期时间</td>
</tr>
<tr>
<td>UNIX_TIMESTAMP()</td>
<td>以UNIX时间戳的形式返回当前时间</td>
</tr>
<tr>
<td>UNIX_TIMESTAMP(d)</td>
<td>将时间d以UNIX时间戳的形式返回</td>
</tr>
<tr>
<td>FROM_UNIXTIME(d)</td>
<td>把UNIX时间戳的时间转换为普通格式的时间</td>
</tr>
<tr>
<td>UTC_DATE()</td>
<td>返回UTC（Universal Coordinated Time，国际协调时间）日期</td>
</tr>
<tr>
<td>UTC_TIME()</td>
<td>返回UTC时间</td>
</tr>
<tr>
<td>MONTH(d)</td>
<td>返回日期d中的月份值，范围1~12</td>
</tr>
<tr>
<td>MONTHNAME(d)</td>
<td>返回日期d中的月份名称，如January</td>
</tr>
<tr>
<td>DAYNAME(d)</td>
<td>返回日期d是星期几，如Monday</td>
</tr>
<tr>
<td>DAYOFWEEK(d)</td>
<td>返回日期d是星期几，范围1~7，1表示星期日</td>
</tr>
<tr>
<td>WEEKDAY(d)</td>
<td>返回日期d是星期几，范围0~6，0表示星期一</td>
</tr>
<tr>
<td>WEEK(d)</td>
<td>计算日期d是本年的第几个星期，范围0~53</td>
</tr>
<tr>
<td>WEEKOFYEAR(d)</td>
<td>计算日期d是本年的第几个星期，范围1~54</td>
</tr>
<tr>
<td>DAYOFYEAR(d)</td>
<td>计算日期d是本年的第几天</td>
</tr>
<tr>
<td>DAYOFMONTH(d)</td>
<td>计算日期d是本月的第几天</td>
</tr>
<tr>
<td>YEAR(d)</td>
<td>返回日期d中的年份值</td>
</tr>
<tr>
<td>QUARTER(d)</td>
<td>返回日期d是第几季度，范围1~4</td>
</tr>
<tr>
<td>HOUR(t)</td>
<td>返回时间t中的小时数</td>
</tr>
<tr>
<td>MINUTE(t)</td>
<td>返回时间t中的分钟数</td>
</tr>
<tr>
<td>SECOND(t)</td>
<td>返回时间t中的秒数</td>
</tr>
<tr>
<td>EXTRACT(type FROM d)</td>
<td>从日期d中获取指定值，type指定返回的值，如YERR HOUR等</td>
</tr>
<tr>
<td>TIME_TO_SEC(t)</td>
<td>将时间t转换为秒</td>
</tr>
<tr>
<td>SEC_TO_TIME(t)</td>
<td>将以秒为单位的时间s转换为时分秒的格式</td>
</tr>
<tr>
<td>TO_DAYS(d)</td>
<td>计算日期d~0000年1月1日的天数</td>
</tr>
<tr>
<td>FROM_DAYS(d)</td>
<td>计算从0000年1月1日开始n天后的日期</td>
</tr>
<tr>
<td>DATEDIFF(d1,d2)</td>
<td>计算日期d1~d2之间间隔的天数</td>
</tr>
<tr>
<td>ADDDATE(d,n)</td>
<td>计算起始日期d加上n天的日期</td>
</tr>
<tr>
<td>ADDDATE(d,INTERVAL expr type)</td>
<td>计算起始日期d加上一个时段后的日期</td>
</tr>
<tr>
<td>DATE_ADD(d,INTERVAL expr type)</td>
<td>同ADDDATE(d,INTERVAL expr type)</td>
</tr>
<tr>
<td>SUBDATE(d,n)</td>
<td>计算起始日期d减去n天后的日期</td>
</tr>
<tr>
<td>SUBDATE(d,INTERVAL expr type)</td>
<td>计算起始日期d减去一个时段后的日期</td>
</tr>
<tr>
<td>ADDTIME(t,n)</td>
<td>计算起始时间t加上n秒的时间</td>
</tr>
<tr>
<td>SUBTIME(t,n)</td>
<td>计算起始时间t减去n秒的时间</td>
</tr>
<tr>
<td>DATE_FROMAT(d,f)</td>
<td>按照表达式f的要求显示日期d</td>
</tr>
<tr>
<td>TIME_FROMAT(t,f)</td>
<td>按照表达式f的要求显示时间t</td>
</tr>
<tr>
<td>GET_FORMAT(type,s)</td>
<td>根据字符串s获取type类型数据的显示格式</td>
</tr>
</tbody>
</table>
<h2 id="4-条件判断函数："><strong>4.条件判断函数：</strong></h2>
<p>条件函数用来在SQL语句中进行条件判断，根据不同的条件执行不同的SQL语句。见下表：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>IF(expr,v1,v2)</td>
<td>如果表达式expr成立，则执行v1；否则执行v2</td>
</tr>
<tr>
<td>IFNULL(v1,v2)</td>
<td>如果v1不为空，则显示v1的值；否则显示v2的值</td>
</tr>
<tr>
<td>CASE WHEN expr1 THEN v1 [WHEN expr2 THEN v2…][ELSE vn] END</td>
<td>case表示函数开始，end表示函数结束。如果表达式expr1成立，则返回v1的值；如果表达式expr2成立，则返回v2的值。依次类推，最后遇到else时，返回vn的值。</td>
</tr>
<tr>
<td>CASE expr WHEN e1 THEN v1 [WHEN e2 THEN v2…][ELSE vn] END</td>
<td>case表示函数开始，end表示函数结束。如果表达式expr取值为e1，则返回v1的值；如果表达式expr取值为e2，则返回v2的值。依次类推，最后遇到else，返回vn的值。</td>
</tr>
</tbody>
</table>
<p>示例：select id,grade, CASE WHEN grade&gt;1000000 THEN ‘Very Good’ WHEN grade&lt;1000000 and grade&gt;=100000 THEN ‘Popularly’ ELSE ‘Not Good’ END level from tb_bccd;</p>
<h2 id="5-系统信息函数："><strong>5.系统信息函数：</strong></h2>
<p>系统信息函数用来查询MySQL数据库的系统信息。见下表：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>VERSION()</td>
<td>获取数据库的版本号</td>
<td>select VERSION();</td>
</tr>
<tr>
<td>CONNECTION_ID()</td>
<td>获取数据库的连接数</td>
<td>select CONNECT_ID();</td>
</tr>
<tr>
<td>DATABASE(),SCHEMA()</td>
<td>获取当前数据库名</td>
<td>select DATABASE();</td>
</tr>
<tr>
<td>USER(),SYSTEM_USER(),SESSION_USER()</td>
<td>获取当前用户</td>
<td>select USER();</td>
</tr>
<tr>
<td>CURRENT_USER()</td>
<td>获取当前用户</td>
<td>select CURRENT-USER();</td>
</tr>
<tr>
<td>CHARSET(str)</td>
<td>获取字符串str的字符集</td>
<td>select CHARSET(‘mrsoft’);</td>
</tr>
<tr>
<td>COLLATION(str)</td>
<td>获取字符串str的字符排列方式</td>
<td>select COLLATION(‘mrsoft’);</td>
</tr>
<tr>
<td>LAST_INSERT_ID()</td>
<td>获取最近生成的AUTO_INCREMENT值</td>
<td>select LAST_INSERT_ID();</td>
</tr>
</tbody>
</table>
<h2 id="6-加密函数："><strong>6.加密函数：</strong></h2>
<p>数据库中有些敏感信息不希望被其他人看到，就可以用加密的方法使这些数据看似乱码。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>PASSWORD(str)</td>
<td>对字符串str加密，不可逆加密</td>
<td>select PASSWORD(‘mrsoft’);</td>
</tr>
<tr>
<td>MD5(str)</td>
<td>对字符串str进行加密，用于普通数据</td>
<td>select MD5(‘mrsoft’);</td>
</tr>
<tr>
<td>ENCODE(str,pswd_str)</td>
<td>使用字符串pswd_str来加密字符串str，结果是二进制数，用BLOB类型保存</td>
<td>select ENCODE(‘mrsoft’,‘mr’);</td>
</tr>
<tr>
<td>DECODE(crypt_str,pswd_str)</td>
<td>使用字符串pswd_str来解密字符串crypt_str，对ENCODE()解码</td>
<td>select DECODE (ENCODE(‘mrsoft’,‘mr’),‘mr’);</td>
</tr>
</tbody>
</table>
<h2 id="7-统计函数："><strong>7.统计函数：</strong></h2>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Avg(字段名)</td>
<td>获取指定列的平均值</td>
</tr>
<tr>
<td>Count(字段名)</td>
<td>如指定一个记录，会统计该字段中非空记录数，如前面使用DISTINCT，则会统计不同值的记录，相同的值当作一条记录。</td>
</tr>
<tr>
<td>Min(字段名)</td>
<td>获取指定字段的最小值</td>
</tr>
<tr>
<td>Max(字段名)</td>
<td>获取指定字段的最大值</td>
</tr>
<tr>
<td>Std(字段名)</td>
<td>指定字段的标准背离值</td>
</tr>
<tr>
<td>Stdtev(字段名)</td>
<td>与Std相同</td>
</tr>
<tr>
<td>Sum(字段名)</td>
<td>指定字段所有记录的总和</td>
</tr>
</tbody>
</table>
<h2 id="8-其他函数："><strong>8.其他函数：</strong></h2>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>FORMAT(x,n)</td>
<td>将数字x进行格式化，保留到小数点后n位，四舍五入</td>
</tr>
<tr>
<td>ASCII(x)</td>
<td>返回字符串s的第一个字符的ASCII码</td>
</tr>
<tr>
<td>BIN(x)</td>
<td>返回x的二进制编码</td>
</tr>
<tr>
<td>HEX(x)</td>
<td>返回x的十六进制编码</td>
</tr>
<tr>
<td>OCT(x)</td>
<td>返回x的八进制编码</td>
</tr>
<tr>
<td>CONV(x,f1,f2)</td>
<td>将x从f1进制数变成f2进制数</td>
</tr>
<tr>
<td>INET_ATON(IP)</td>
<td>将IP地址转换为数字表示</td>
</tr>
<tr>
<td>INET_NTOA(N)</td>
<td>将数字n转换成IP形式</td>
</tr>
<tr>
<td>GET_LOCT(name,time)</td>
<td>定义一个名称为name持续时长为time秒的锁。锁定成功返回1；如此尝试超时返回0；遇到错误返回NULL。</td>
</tr>
<tr>
<td>RELEASE_LOCK(name)</td>
<td>解除名称为name的锁。解锁成功返回1，尝试超时返回0，失败返回NULL。</td>
</tr>
<tr>
<td>IF_FREE_LOCK(name)</td>
<td>判断是否使用名为name的锁，成功返回0，否则返回1。</td>
</tr>
<tr>
<td>BENCHMARK(count,expr)</td>
<td>将表达式expr重复执行count次，然后返回执行时间</td>
</tr>
<tr>
<td>CONVERT(s USING cs)</td>
<td>将字符串s的字符集变成cs</td>
</tr>
<tr>
<td>CAST(x AS type), CONVERT(x,type)</td>
<td>将x变成type类型。这两个函数只对BINARY、CHAR、DATE、DATETIME、TIME、SIGNED INTEGER、UNSIGNED INTEGER类型起作用。只是改变了输出值的数据类型，并没有改变表中字段的类型。</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>SQL知识</category>
      </categories>
      <tags>
        <tag>SQL函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中的上下文管理器</title>
    <url>/2023/02/06/Python%20%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<ul>
<li><code>with</code> 这个关键字，对于每一学习Python的人，都不会陌生。</li>
</ul>
<p>操作文本对象的时候，我们用 <code>with open</code> ，这就是一个上下文管理的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span> f.readlines()</span><br></pre></td></tr></table></figure>
<h2 id="上下文管理器概念">上下文管理器概念</h2>
<p><strong>基本语法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> EXPR <span class="keyword">as</span> VAR:</span><br><span class="line">    BLOCK</span><br></pre></td></tr></table></figure>
<p>几个概念</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 上下文表达式：<span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="number">2.</span> 上下文管理器：<span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>)  </span><br><span class="line"><span class="number">3.</span> f不是上下文管理器，应该是资源对象。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="实现下文管理器">实现下文管理器</h2>
<p>要自己实现这样一个上下文管理，要先知道上下文管理协议。</p>
<ul>
<li>简单点说，就是在一个类里，实现了<code>__enter__</code>和<code>__exit__</code>的方法，这个类的实例就是一个上下文管理器。</li>
</ul>
<p>例如这个示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;===connect to resource===&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;===close resource connection===&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operate</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;===in operation===&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">with</span> Resource() <span class="keyword">as</span> res:</span><br><span class="line">    res.operate()</span><br></pre></td></tr></table></figure>
<p>我们执行一下，通过日志的打印顺序。可以知道其执行过程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">===connect to resource===</span><br><span class="line">===<span class="keyword">in</span> operation===</span><br><span class="line">===close resource connection===</span><br></pre></td></tr></table></figure>
<ul>
<li>从这个示例可以很明显的看出，在编写代码时，可以将资源的连接或者获取放在<code>__enter__</code>中，而将资源的关闭写在<code>__exit__</code> 中。</li>
</ul>
<h2 id="上下文管理器作用">上下文管理器作用</h2>
<ul>
<li>
<ol>
<li>可以以一种更加优雅的方式，操作（创建/获取/释放）资源，如文件操作、数据库连接；</li>
</ol>
</li>
<li>
<ol start="2">
<li>可以以一种更加优雅的方式，处理异常；</li>
</ol>
</li>
</ul>
<p>第一种，我们上面已经以资源的连接为例介绍了。</p>
<p>而第二种，会被大多数人所忽略。这里会重点讲一下。</p>
<p>大家都知道，处理异常，通常都是使用 <code>try...execept..</code> 来捕获处理的。这样做一个不好的地方是，在代码的主逻辑里，会有大量的异常处理代理，这会很大的影响我们的可读性。</p>
<p>好一点的做法呢，可以使用 <code>with</code> 将异常的处理隐藏起来。</p>
<p>仍然是以上面的代码为例，我们将<code>I/O</code> 这个一定会抛出异常的代码写在 <code>operate</code> 里</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;===connect to resource===&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;===close resource connection===&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operate</span>(<span class="params">self</span>):</span><br><span class="line">        I/O</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Resource() <span class="keyword">as</span> res:</span><br><span class="line">    res.operate()</span><br></pre></td></tr></table></figure>
<p>运行一下，惊奇地发现，居然不会报错。</p>
<p>这就是上下文管理协议的一个强大之处，异常可以在<code>__exit__</code> 进行捕获并由你自己决定如何处理，是抛出呢还是在这里就解决了。在<code>__exit__</code> 里返回 <code>True</code>（没有return 就默认为 return False），就相当于告诉 Python解释器，这个异常我们已经捕获了，不需要再往外抛了。</p>
<p>在 写<code>__exit__</code> 函数时，需要注意的事，它必须要有这三个参数：</p>
<ul>
<li><code>exc_type</code>：异常类型</li>
<li><code>exc_val</code>：异常值</li>
<li><code>exc_tb</code>：异常的错误栈信息</li>
</ul>
<p>当主逻辑代码没有报异常时，这三个参数将都为None。</p>
<h2 id="常见的异常">常见的异常</h2>
<ul>
<li>异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。 一般情况下，在Python无法正常处理程序时就会发生一个异常。 异常是Python对象，表示一个错误。 当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。 python的标准异常可以在<a href="https://docs.python.org/3/library/exceptions.html?highlight=exception">官网文档</a>中查看,常用的如下:</li>
</ul>
<table>
<thead>
<tr>
<th>异常名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SystemExit</code></td>
<td>解释器请求退出</td>
</tr>
<tr>
<td><code>KeyboardInterrupt</code></td>
<td>用户中断执行(通常是输入^C)</td>
</tr>
<tr>
<td><code>Exception</code></td>
<td>常规错误的基类</td>
</tr>
<tr>
<td><code>StopIteration</code></td>
<td>迭代器没有更多的值</td>
</tr>
<tr>
<td><code>GeneratorExit</code></td>
<td>生成器(generator)发生异常来通知退出</td>
</tr>
<tr>
<td><code>StandardError</code></td>
<td>所有的内建标准异常的基类</td>
</tr>
<tr>
<td><code>ArithmeticError</code></td>
<td>所有数值计算错误的基类</td>
</tr>
<tr>
<td><code>FloatingPointError</code></td>
<td>浮点计算错误</td>
</tr>
<tr>
<td><code>OverflowError</code></td>
<td>数值运算超出最大限制</td>
</tr>
<tr>
<td><code>ZeroDivisionError</code></td>
<td>除(或取模)零 (所有数据类型)</td>
</tr>
<tr>
<td><code>AssertionError</code></td>
<td>断言语句失败</td>
</tr>
<tr>
<td><code>AttributeError</code></td>
<td>对象没有这个属性</td>
</tr>
<tr>
<td><code>EOFError</code></td>
<td>没有内建输入,到达EOF 标记</td>
</tr>
<tr>
<td><code>EnvironmentError</code></td>
<td>操作系统错误的基类</td>
</tr>
<tr>
<td><code>IOError</code></td>
<td>输入/输出操作失败</td>
</tr>
<tr>
<td><code>OSError</code></td>
<td>操作系统错误</td>
</tr>
<tr>
<td><code>WindowsError</code></td>
<td>系统调用失败</td>
</tr>
<tr>
<td><code>ImportError</code></td>
<td>导入模块/对象失败</td>
</tr>
<tr>
<td><code>LookupError</code></td>
<td>无效数据查询的基类</td>
</tr>
<tr>
<td><code>IndexError</code></td>
<td>序列中没有此索引(index)</td>
</tr>
<tr>
<td><code>KeyError</code></td>
<td>映射中没有这个键</td>
</tr>
<tr>
<td><code>MemoryError</code></td>
<td>内存溢出错误(对于Python 解释器不是致命的)</td>
</tr>
<tr>
<td><code>NameError</code></td>
<td>未声明/初始化对象 (没有属性)</td>
</tr>
<tr>
<td><code>UnboundLocalError</code></td>
<td>访问未初始化的本地变量</td>
</tr>
<tr>
<td><code>ReferenceError</code></td>
<td>弱引用(Weak reference)试图访问已经垃圾回收了的对象</td>
</tr>
<tr>
<td><code>RuntimeError</code></td>
<td>一般的运行时错误</td>
</tr>
<tr>
<td><code>NotImplementedError</code></td>
<td>尚未实现的方法</td>
</tr>
<tr>
<td><code>SyntaxError</code></td>
<td>Python 语法错误</td>
</tr>
<tr>
<td><code>IndentationError</code></td>
<td>缩进错误</td>
</tr>
<tr>
<td><code>TabError</code></td>
<td>Tab 和空格混用</td>
</tr>
<tr>
<td><code>SystemError</code></td>
<td>一般的解释器系统错误</td>
</tr>
<tr>
<td><code>TypeError</code></td>
<td>对类型无效的操作</td>
</tr>
<tr>
<td><code>ValueError</code></td>
<td>传入无效的参数</td>
</tr>
<tr>
<td><code>UnicodeError</code></td>
<td>Unicode 相关的错误</td>
</tr>
<tr>
<td><code>UnicodeDecodeError</code></td>
<td>Unicode 解码时的错误</td>
</tr>
<tr>
<td><code>UnicodeEncodeError</code></td>
<td>Unicode 编码时错误</td>
</tr>
<tr>
<td><code>UnicodeTranslateError</code></td>
<td>Unicode 转换时错误</td>
</tr>
<tr>
<td><code>Warning</code></td>
<td>警告的基类</td>
</tr>
<tr>
<td><code>DeprecationWarning</code></td>
<td>关于被弃用警告</td>
</tr>
<tr>
<td><code>FutureWarning</code></td>
<td>关于构造将来语义会有改变的警告</td>
</tr>
<tr>
<td><code>OverflowWarning</code></td>
<td>旧的关于自动提升为长整型(long)的警告</td>
</tr>
<tr>
<td><code>PendingDeprecationWarning</code></td>
<td>关于特性将会被废弃的警告</td>
</tr>
<tr>
<td><code>RuntimeWarning</code></td>
<td>可疑的运行时行为(runtime behavior)的警告</td>
</tr>
<tr>
<td><code>SyntaxWarning</code></td>
<td>可疑的语法的警告</td>
</tr>
<tr>
<td><code>UserWarning</code></td>
<td>用户代码生成的警告</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>上下文管理器</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的模块和类</title>
    <url>/2023/02/06/Python%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E7%B1%BB/</url>
    <content><![CDATA[<h1>import导入模块路径问题</h1>
<ul>
<li>
<p>存在的问题：当我们把模块文件放到工程文件夹的外部的文件，发现无法正常引入模块</p>
</li>
<li>
<p>原因：外部的文件夹的路径，没有放到环境变量中。</p>
</li>
<li>
<p>查看环境变量</p>
<ul>
<li>1.导入<code>sys</code>模块</li>
<li>2.<code>sys.path </code>查看环境变量返回值是列表</li>
</ul>
</li>
<li>
<p>把自己写的模块的路径加入到环境变量中</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将模块路径追加到末尾 </span></span><br><span class="line">sys.path.append(<span class="string">r&quot;模块的路径&quot;</span>)</span><br><span class="line"><span class="comment"># 将模块路径追加到开头</span></span><br><span class="line">sys.path.insert(<span class="number">0</span>,<span class="string">r&quot;模块的路径&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import module</span></span><br><span class="line"><span class="comment"># # module -- 模块名</span></span><br><span class="line"><span class="comment"># # name 模块 modele 中的变量</span></span><br><span class="line"><span class="comment"># print(module.name)</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看python解释器搜索的环境变量</span></span><br><span class="line"><span class="comment"># 将模块路径追加到末尾</span></span><br><span class="line"><span class="comment"># sys.path.append(r&quot;C:\Users\Luenci\Desktop&quot;)</span></span><br><span class="line"><span class="comment"># 将模块路径追加到开头有</span></span><br><span class="line"></span><br><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">r&quot;C:\Users\Luenci\Desktop&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.path:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(app.name)</span><br></pre></td></tr></table></figure>
<h1>import导入模块</h1>
<ul>
<li><code>import</code>会防止重复导入
<ul>
<li>在同一个程序中多次<code>import</code>同一个模块，只会执行一次</li>
</ul>
</li>
<li>重新导入模块</li>
</ul>
<blockquote>
<p>为什么需要重新导入模块?</p>
<p>模块被导入后，import module不能重新导入模块，重新导入需用reload重新加载模块代码创建模块对象</p>
</blockquote>
<p>准备一个模块 reload_test 并定义一个函数 test 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def demo():</span><br><span class="line">    print(&quot;---------- 111 -----------&quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 ipython 的交互模式下</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: <span class="keyword">import</span> reload_test</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: reload_test.demo()</span><br><span class="line">---------- <span class="number">111</span> -----------</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: reload_test.demo()</span><br><span class="line">---------- <span class="number">111</span> -----------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载之后，改变的内容就可以显示</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: <span class="keyword">from</span> imp <span class="keyword">import</span> reload</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: reload(reload_test)</span><br><span class="line">Out[<span class="number">15</span>]: &lt;module <span class="string">&#x27;reload_test&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;D:\\pythonStudy\\import笔记\\reload_test.py&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: reload_test.demo()</span><br><span class="line">---------- <span class="number">222</span> -----------</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<!-- more 	-->
<h1><code>from XX import XX</code>的私有化问题</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># modele.py内容</span></span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;Luenci&quot;</span></span><br><span class="line"><span class="comment"># 类中定义私有属性</span></span><br><span class="line"><span class="comment"># self._name = XXX</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 私有化处理</span></span><br><span class="line"><span class="comment"># 如果模块中的变量不希望以 from .. import .. 导入</span></span><br><span class="line">_age = <span class="number">12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import module</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># print(module.name)</span></span><br><span class="line"><span class="comment"># 私有化有效</span></span><br><span class="line"><span class="keyword">from</span> module <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 私有化无效</span></span><br><span class="line"><span class="keyword">from</span> module <span class="keyword">import</span> _age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(_age)</span><br></pre></td></tr></table></figure>
<h1>import 和from……import的区别</h1>
<ul>
<li>import XXX
<ul>
<li>此种方式是直接引用</li>
</ul>
</li>
<li>from XXX import xxx
<ul>
<li>此种方式是把XXX的内容复制一份到程序中，若修改不应用到原来的模块</li>
</ul>
</li>
</ul>
<p><img src="https://i.ibb.co/XsN1vkh/image-20191118122613064.png" alt="image-20191118122613064"></p>
<h1>可变参数的拆包</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---- func1 ----&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;args:&quot;</span>, args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kwargs:&quot;</span>, kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;args:&quot;</span>, args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kwargs:&quot;</span>, kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用func1</span></span><br><span class="line">    <span class="comment"># 此处没有进行拆包，导致参数传递不过去不符合要求</span></span><br><span class="line">    <span class="comment"># func1(args, kwargs)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 此处进行了拆包，阐述传递正确</span></span><br><span class="line">    func1(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    func2(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, a=<span class="number">10</span>, b=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  args: (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">    kwargs: &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line">    ---- func1 ----</span><br><span class="line">    args: (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">    kwargs: &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>
<h1>新式类的属性和一些概念</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    我是一个新式类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,sex,eat</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.eat = eat</span><br><span class="line">        self.__date = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__test</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我是个私有方法&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sleep</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s正在睡觉&quot;</span>%self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = People(<span class="string">&#x27;luenci&#x27;</span>,<span class="string">&#x27;man&#x27;</span>,<span class="string">&#x27;rice&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(People.__doc__)</span><br><span class="line"><span class="built_in">print</span>(People.__bases__)</span><br><span class="line"><span class="built_in">print</span>(People.__mro__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印类的数据属性字典</span></span><br><span class="line"><span class="built_in">print</span>(People.__dict__)</span><br><span class="line"><span class="comment"># &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: &#x27;\n    我是一个新式类\n    &#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__init__&#x27;: &lt;function People.__init__ at 0x0000017408AC1D90&gt;,</span></span><br><span class="line"><span class="comment"># &#x27;_People__test&#x27;: &lt;function People.__test at 0x0000017408AC1A60&gt;,</span></span><br><span class="line"><span class="comment"># &#x27;sleep&#x27;: &lt;function People.sleep at 0x0000017408AC1E18&gt;,</span></span><br><span class="line"><span class="comment"># &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;People&#x27; objects&gt;,</span></span><br><span class="line"><span class="comment"># &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;People&#x27; objects&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印对象的数据属性字典</span></span><br><span class="line"><span class="built_in">print</span>(p1.__dict__)</span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;luenci&#x27;, &#x27;sex&#x27;: &#x27;man&#x27;, &#x27;eat&#x27;: &#x27;rice&#x27;, &#x27;_People__date&#x27;: []&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p1.__dir__())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;[&#x27;name&#x27;, &#x27;sex&#x27;, &#x27;eat&#x27;, &#x27;_People__date&#x27;, &#x27;__module__&#x27;, &#x27;__doc__&#x27;, &#x27;__init__&#x27;, </span></span><br><span class="line"><span class="string"> &#x27;_People__test&#x27;, &#x27;__dict__&#x27;, &#x27;__weakref__&#x27;, &#x27;__repr__&#x27;, &#x27;__hash__&#x27;, &#x27;__str__&#x27;, </span></span><br><span class="line"><span class="string"> &#x27;__getattribute__&#x27;, &#x27;__setattr__&#x27;, &#x27;__delattr__&#x27;, &#x27;__lt__&#x27;, &#x27;__le__&#x27;, &#x27;__eq__&#x27;, </span></span><br><span class="line"><span class="string"> &#x27;__ne__&#x27;, &#x27;__gt__&#x27;, &#x27;__ge__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce_ex__&#x27;, </span></span><br><span class="line"><span class="string"> &#x27;__reduce__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__format__&#x27;, &#x27;__sizeof__&#x27;, </span></span><br><span class="line"><span class="string"> &#x27;__dir__&#x27;, &#x27;__class__&#x27;]&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 私有方法的访问</span></span><br><span class="line">p1._People__test()</span><br><span class="line"><span class="comment"># 私有变量的访问</span></span><br><span class="line"><span class="built_in">print</span>(p1._People__date)</span><br><span class="line">p1.sleep()</span><br></pre></td></tr></table></figure>
<h1>类属性的增加和修改</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    我是一个Dog类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    master = <span class="string">&quot;luenci&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">action</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;汪汪汪.&quot;</span>)</span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="string">&#x27;小白&#x27;</span>)</span><br><span class="line"><span class="comment"># 增加类的属性</span></span><br><span class="line">Dog.sex = <span class="string">&#x27;公&#x27;</span></span><br><span class="line"><span class="comment"># 实例可以访问到</span></span><br><span class="line"><span class="built_in">print</span>(dog.sex)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加类方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self,name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s在奔跑&quot;</span>%self.name)</span><br><span class="line"></span><br><span class="line">Dog.run = run</span><br><span class="line"><span class="comment"># 实例中可以访问</span></span><br><span class="line">dog.run(<span class="string">&#x27;小白&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加私有属性</span></span><br><span class="line">Dog.__age = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(Dog.__dict__)</span><br><span class="line"><span class="built_in">print</span>(Dog.__age)</span><br><span class="line"></span><br><span class="line">out</span><br><span class="line">公</span><br><span class="line">小白在奔跑</span><br><span class="line">&#123;<span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>: <span class="string">&#x27;\n    我是一个Dog类\n    &#x27;</span>, <span class="string">&#x27;master&#x27;</span>: <span class="string">&#x27;luenci&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>: &lt;function Dog.__init__ at <span class="number">0x000001E16328D048</span>&gt;, <span class="string">&#x27;action&#x27;</span>: &lt;function Dog.action at <span class="number">0x000001E16328D0D0</span>&gt;, <span class="string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="string">&#x27;__dict__&#x27;</span> of <span class="string">&#x27;Dog&#x27;</span> objects&gt;, <span class="string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="string">&#x27;__weakref__&#x27;</span> of <span class="string">&#x27;Dog&#x27;</span> objects&gt;, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;公&#x27;</span>, <span class="string">&#x27;run&#x27;</span>: &lt;function run at <span class="number">0x000001E163271F28</span>&gt;, <span class="string">&#x27;__age&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h1>单继承的<code>super</code></h1>
<ul>
<li><code>super（）</code>使用的时候，传递参数的时候，<code>self</code>不用传递</li>
<li><code>super（）</code>调用顺序，按照<code>__mro__</code>顺序来完成<code>Grandson.mro</code>是一个元组当在类中使用<code>super</code>在<code>__mro__</code>列表中找到当前类的下一个元素，调用该元素的方法。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;parent的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line"></span><br><span class="line">        self.age = age</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son1的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grandson</span>(<span class="title class_ inherited__">Son1</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, gender</span>):</span><br><span class="line">        self.gender = <span class="string">&quot;男&quot;</span></span><br><span class="line">        <span class="comment"># 单继承不能提供全部参数</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Grandson的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gs=Grandson(<span class="string">&#x27;grandson&#x27;</span>, <span class="number">12</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(Grandson.__mro__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;姓名:&#x27;</span>, gs.name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;年龄:&#x27;</span>, gs.age)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;性别:&#x27;</span>, gs.gender)</span><br><span class="line"></span><br><span class="line">out: </span><br><span class="line">    parent的init结束被调用</span><br><span class="line">    Son1的init结束被调用</span><br><span class="line">    Grandson的init结束被调用</span><br><span class="line">    (&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Grandson&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Son1&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Parent&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;)</span><br><span class="line">    姓名: grandson</span><br><span class="line">    年龄: <span class="number">12</span></span><br><span class="line">    性别: 男</span><br></pre></td></tr></table></figure>
<h1>多继承和MRO顺序</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;parent的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类--》继承父类的 name属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="comment"># 定义age属性</span></span><br><span class="line">        self.age = age</span><br><span class="line">        Parent.__init__(self, name)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son1的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类--》继承父类的 name属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender</span>):</span><br><span class="line">        <span class="comment"># 定义 gender 属性</span></span><br><span class="line">        self.gender = gender</span><br><span class="line">        Parent.__init__(self, name)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son2的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grandson</span>(Son1, Son2):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, gender</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用父类的初始化方法</span></span><br><span class="line">        Son1.__init__(self, name, age)</span><br><span class="line">        Son2.__init__(self, name, gender)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Grandson的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gs = Grandson(<span class="string">&#x27;grandson&#x27;</span>, <span class="number">12</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(Grandson.__mro__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;姓名:&#x27;</span>, gs.name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;年龄:&#x27;</span>, gs.age)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;性别:&#x27;</span>, gs.gender)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  parent的init结束被调用</span><br><span class="line">    Son1的init结束被调用</span><br><span class="line">    parent的init结束被调用</span><br><span class="line">    Son2的init结束被调用</span><br><span class="line">    Grandson的init结束被调用</span><br><span class="line">    (&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Grandson&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Son1&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Son2&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Parent&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;)</span><br><span class="line">    姓名: grandson</span><br><span class="line">    年龄: <span class="number">12</span></span><br><span class="line">    性别: 男</span><br></pre></td></tr></table></figure>
<h2 id="使用super-调用父类">使用<code>super()</code>调用父类</h2>
<h3 id="MRO顺序">MRO顺序</h3>
<blockquote>
<p>通过上述代码，我们发现由于多继承情况，parent类被的属性被构造了两次，如果在更加复杂的结构下可能更加严重。为了解决这个问题，Python官方采用了一个算法将复杂结构上所有的类全部都映射到一个线性顺序上，而搜索的顺序就是所谓的「方法解析顺序」（Method Resolution Order，或MRO),根据这个顺序就能够保证所有的类都会被构造一次。</p>
</blockquote>
<h3 id="MRO查看">MRO查看</h3>
<ul>
<li>
<p><code>类名.mro()</code></p>
</li>
<li>
<p><code>类名.__mro__</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, *args, **kwargs</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;parent的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类--》继承父类的 name属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 定义age属性</span></span><br><span class="line">        self.age = age</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, *args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son1的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类--》继承父类的 name属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 定义 gender 属性</span></span><br><span class="line">        self.gender = gender</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, *args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son2的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grandson</span>(Son1, Son2):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, gender</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用父类的初始化方法</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age, gender)</span><br><span class="line">        <span class="comment"># Son1.__init__(self, name, age)</span></span><br><span class="line">        <span class="comment"># Son2.__init__(self, name, gender)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Grandson的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gs = Grandson(<span class="string">&#x27;grandson&#x27;</span>, <span class="number">12</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(Grandson.__mro__)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  parent的init结束被调用</span><br><span class="line">    Son2的init结束被调用</span><br><span class="line">    Son1的init结束被调用</span><br><span class="line">    Grandson的init结束被调用</span><br><span class="line">    (&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Grandson&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Son1&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Son2&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Parent&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;)</span><br></pre></td></tr></table></figure>
<h3 id="注意">注意</h3>
<blockquote>
<p>当在类中使用super（）在 mro列表中找到当前类的下一个元素，调用该元素的方法</p>
<p>多继承中，不建议使用类名直接调用父类的方法</p>
</blockquote>
<h1>类的<code>@classmethod</code>、<code>@staticmethod</code>装饰方法</h1>
<ul>
<li><code>@classmethod</code> 用来修饰方法。使用在实例化前与类进行交互，但不和其实例进行交互的函数方法上。</li>
<li><code>@staticmethod</code> 用来修饰类的静态方法。使用在有些与类相关函数，但不使用该类或该类的实例。如更改环境变量、修改其他类的属性等。</li>
</ul>
<p>两者最明显的区别，<code>classmethod</code> 必须使用类的对象作为第一个参数，而<code>staticmethod</code>则可以不传递任何参数</p>
<p>1、<code>@classmethod</code> 类方法</p>
<p>类方法，我们不用通过实例化类就能访问的方法。而且@classmethod 装饰的方法不能使用实例属性，只能是类属性。它主要使用在和类进行交互，但不和其实例进行交互的函数方法上。</p>
<p>下面，我们要写一个只在类中运行而不在实例中运行的方法。</p>
<p>简单示例，读取私有化类属性数据，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">   __pi = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, r</span>):</span><br><span class="line">       self.r = r</span><br><span class="line"></span><br><span class="line"><span class="meta">   @classmethod</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">pi</span>(<span class="params">cls</span>):</span><br><span class="line">       <span class="keyword">return</span> cls.__pi</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">圆的面积</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">return</span> self.r ** <span class="number">2</span> * self.__pi</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Circle.pi())  <span class="comment"># 没有实例化 能直接访问pi() 方法</span></span><br><span class="line">circle1 = Circle(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(circle1.pi()) <span class="comment"># 也可以通过实例访问pi()方法</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Circle</code>类下的<code>pi()</code>方法被 <code>@classmethod</code> 装饰后，我们能通过<code>Circle.pi()</code> 直接运行方法，不用实例化类。</p>
</blockquote>
<p>示例：重构构造<code>__init__() </code>方法应用, 格式化创建时间实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">   day = <span class="number">0</span></span><br><span class="line">   month = <span class="number">0</span></span><br><span class="line">   year = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, year=<span class="number">0</span>, month=<span class="number">0</span>, day=<span class="number">0</span></span>):</span><br><span class="line">       self.day = day</span><br><span class="line">       self.month = month</span><br><span class="line">       self.year = year</span><br><span class="line"></span><br><span class="line"><span class="meta">   @classmethod</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">from_string</span>(<span class="params">cls, date_as_string</span>):</span><br><span class="line">       year, month, day = date_as_string.split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">       date = cls(year, month, day)</span><br><span class="line">       <span class="keyword">return</span> date</span><br><span class="line"></span><br><span class="line">date1 = Date.from_string(<span class="string">&#x27;2017-10-17&#x27;</span>)  <span class="comment">#  直接使用固定格式的字符串就能创建Date的实例</span></span><br><span class="line"><span class="built_in">print</span>(date1.year, date1.month, date1.day)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>from_string 返回的是Date类的实例，所以我们可以通过from_string 实例化类。<br>
<strong>注意：</strong><code>from_string(cls, date_as_string)</code>中<code>cls</code>表示的是类，它和<code>self</code>类实例有一定的差别。类方法中都是使用<code>cls</code>，实例方法中使用<code>self</code>。</p>
</blockquote>
<p>2、<code>@staticmethod </code>静态方法</p>
<ul>
<li>
<p><code>@staticmethod</code> 和<code>@classmethod</code>非常的相似，但是<code>@staticmethod </code>不强制要求传递参数（它做的事与类方法或实例方法一样）。</p>
</li>
<li>
<p><code>@staticmethod</code>使用在有些和类相关函数，但不使用该类或者该类的实例。如更改环境变量、修改其他类的属性等。</p>
</li>
</ul>
<p>一句话<code>@staticmethod</code> 修饰的方法是放在类外的函数，我们为了方便将他移动到了类里面，它对类的运行无影响。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">   day = <span class="number">0</span></span><br><span class="line">   month = <span class="number">0</span></span><br><span class="line">   year = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, year=<span class="number">0</span>, month=<span class="number">0</span>, day=<span class="number">0</span></span>):</span><br><span class="line">       self.day = day</span><br><span class="line">       self.month = month</span><br><span class="line">       self.year = year</span><br><span class="line"></span><br><span class="line"><span class="meta">   @classmethod</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">from_string</span>(<span class="params">cls, date_as_string</span>):</span><br><span class="line">       year, month, day = date_as_string.split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">       date = cls(year, month, day)</span><br><span class="line">       <span class="keyword">return</span> date</span><br><span class="line"></span><br><span class="line"><span class="meta">   @staticmethod</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">is_date_valid</span>(<span class="params">date_as_string</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      用来校验日期的格式是否正确</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       year, month, day = date_as_string.split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">int</span>(year) &lt;= <span class="number">3999</span> <span class="keyword">and</span> <span class="built_in">int</span>(month) &lt;= <span class="number">12</span> <span class="keyword">and</span> <span class="built_in">int</span>(day) &lt;= <span class="number">31</span></span><br><span class="line"></span><br><span class="line">date1 = Date.from_string(<span class="string">&#x27;2012-05-10&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(date1.year, date1.month, date1.day)</span><br><span class="line">is_date = Date.is_date_valid(<span class="string">&#x27;2012-09-18&#x27;</span>) <span class="comment"># 格式正确 返回True</span></span><br></pre></td></tr></table></figure>
<p><code>is_date_valid(date_as_string)</code> 只有一个参数，它的运行不会影响类的属性，</p>
<blockquote>
<p><strong>注意：</strong><code>@staticmethod</code>修饰方法 <code>is_date_valid(date_as_string)</code>中无实例化参数<code>self</code>或者<code>cls</code>；而<code>@classmethod</code>修饰的方法中有<code>from_string(cls, date_as_string) </code>类参数<code>cls</code>。</p>
</blockquote>
<h1>@property装饰方法</h1>
<ul>
<li>
<p>定义时，在实例方法的基础上添加@property 装饰器；</p>
<ul>
<li>并且仅有一个self参数</li>
</ul>
</li>
<li>
<p>调用时，无需括号</p>
<blockquote>
<p>方法：<code>foo_obj.func()</code><br>
property属性：<code>foo_obj.prop</code></p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num</span>):</span><br><span class="line">        self.num = num</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取值得方法</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo = Foo(<span class="number">100</span>)</span><br><span class="line"><span class="comment"># print(foo.prop())</span></span><br><span class="line"><span class="comment"># @property 像使用属性一样获取值</span></span><br><span class="line"><span class="built_in">print</span>(foo.prop)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  <span class="number">100</span></span><br></pre></td></tr></table></figure>
<h2 id="property的其它功能">property的其它功能</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 初始化原价</span></span><br><span class="line">        self.org_price = <span class="number">1000</span></span><br><span class="line">        <span class="comment"># 初始化折扣</span></span><br><span class="line">        self.discount = <span class="number">0.7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取价格的方法</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.org_price * self.discount</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置价格的方法</span></span><br><span class="line"><span class="meta">    @price.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="keyword">if</span> val &gt; <span class="number">0</span>:</span><br><span class="line">            self.org_price = val</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除价格的方法</span></span><br><span class="line"><span class="meta">    @price.deleter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;执行了 deleter 方法&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">goods = Goods()</span><br><span class="line"><span class="built_in">print</span>(goods.price)</span><br><span class="line"></span><br><span class="line">goods.price = <span class="number">500</span></span><br><span class="line"><span class="built_in">print</span>(goods.price)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> goods.price</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="number">700.0</span></span><br><span class="line">    <span class="number">350.0</span></span><br><span class="line">    执行了 deleter 方法</span><br></pre></td></tr></table></figure>
<h2 id="property的另一种使用方法">property的另一种使用方法</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BAR = property（get_price, set_price, del_price, &quot;BAR是一个property对象&quot;）</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>property（第一个参数，第二个参数，第三个参数，第四个参数）</li>
<li>第一个参数，当我们foo.BAR自动调用第一个参数的方法</li>
<li>第二个参教，当我们foo.BAR=100，自动调用第二个参数的方法</li>
<li>第三个参数，当我们del foo.BAR，自动调用第三个参数的方法</li>
<li>第四个参数，当我们Foo.BAR.doc，自动获取第四个参数的内容</li>
</ul>
</blockquote>
<h2 id="property实现延迟计算">property实现延迟计算</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -- coding=utf-8 --</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@author:luenci</span></span><br><span class="line"><span class="string">@time:2020/6/2 12:12</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Delay</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;触发__get__方法&quot;</span>)</span><br><span class="line">        res = self.func(instance)</span><br><span class="line">        <span class="built_in">setattr</span>(instance, self.func.__name__, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Room</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, length, width</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.length = length</span><br><span class="line">        self.width = width</span><br><span class="line"></span><br><span class="line"><span class="meta">    @Delay</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.length * self.width</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r1 = Room(<span class="number">502</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(r1.area)</span><br><span class="line"><span class="built_in">print</span>(r1.area)</span><br><span class="line"><span class="built_in">print</span>(r1.area)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">触发__get__方法</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>类的魔法属性和方法</h1>
<h2 id="魔术属性">魔术属性</h2>
<ul>
<li><code>__doc__</code>  描述类的信息和类方法的信息
<ul>
<li>获取类名  <code>类名.__doc__</code></li>
<li>获取对象  <code>对象.方法名.__doc__</code></li>
</ul>
</li>
<li><code>__model__</code> 获取所属的模块（<code>对象名.__module__</code>）直接运行该文件 获取<code>main</code></li>
<li><code>__class__</code> 获取对象所属的类  <code>对象名.__class__</code></li>
<li><code>__dict__</code> 获取对象或类的信息
<ul>
<li>通过<code>__dict__</code>获取对象信息，<code>对象.__dict__ </code> 返回字典</li>
<li>通过<code>__dict__ </code>获取类信息   <code>类名.__dict__ </code>返回值是一个字典</li>
</ul>
</li>
</ul>
<h2 id="魔术方法">魔术方法</h2>
<ul>
<li><code>__init__</code>初始化方法  <code>类名（）</code>自动调用</li>
<li><code>__del__</code>删除对象的时候， 会调用<code>__del__方法</code></li>
<li><code>__call__()</code>  使用<code>对象名()</code>会调用该方法</li>
<li><code>__str__()</code> 打印对象的会调用<code>print(obj)</code>  <code>__str__</code>方法一定要<code>return</code>，而且必须<code>return</code>字符串内容</li>
<li>用字典的书写格式操作对象的方法
<ul>
<li><code>__getitem__</code> 对象[‘XX’]</li>
<li><code>__setitem__</code> 对象[‘XX’] = xx</li>
<li><code>__delitem__</code> del 对象[‘xx’]</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这是一个商品的类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 类属性</span></span><br><span class="line">    sell = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.price = <span class="number">100</span></span><br><span class="line">        self.category = <span class="string">&quot;吃的&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;设置价格方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__call__ 方法被调用&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是一个对象&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;key:&quot;</span>, item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;key:%s, value:%s&quot;</span> % (key, value))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;要删除key：&quot;</span>, key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__del__ 正在执行&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">goods = Goods()</span><br><span class="line"><span class="comment"># 对象名（）  会去调用对象的 __call__() 方法</span></span><br><span class="line">goods()</span><br><span class="line"><span class="comment"># print 打印对象的时候，默认输出 &lt;__main__.Goods object at 0x000002356857E080&gt;</span></span><br><span class="line"><span class="built_in">print</span>(goods)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过dict获取对象信息，对象.__dict__ 返回字典</span></span><br><span class="line"><span class="built_in">print</span>(goods.__dict__)</span><br><span class="line"><span class="comment"># 通过dict 获取类信息 类名.__dict__返回值是一个字典</span></span><br><span class="line"><span class="built_in">print</span>(Goods.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dict1=&#123;&#125;</span></span><br><span class="line"><span class="comment"># dictI[&#x27;a&#x27;]=10</span></span><br><span class="line"><span class="comment"># goods[&#x27;a&#x27;]调用 __getitem__ 方法</span></span><br><span class="line">goods[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># goods[&#x27;a&#x27;]=10用 __setitem__  key，value</span></span><br><span class="line">goods[<span class="string">&#x27;a&#x27;</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># del goods[&#x27;a&#x27;] 调用 __delitem__ key</span></span><br><span class="line"><span class="keyword">del</span> goods[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">out：</span><br><span class="line">  &#123;<span class="string">&#x27;price&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;category&#x27;</span>: <span class="string">&#x27;吃的&#x27;</span>&#125;</span><br><span class="line">    &#123;<span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>: <span class="string">&#x27;这是一个商品的类&#x27;</span>, <span class="string">&#x27;sell&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;__init__&#x27;</span>: &lt;function Goods.__init__ at <span class="number">0x00000238CE0F5598</span>&gt;, <span class="string">&#x27;set_price&#x27;</span>: &lt;function Goods.set_price at <span class="number">0x00000238CE0F5620</span>&gt;, <span class="string">&#x27;__call__&#x27;</span>: &lt;function Goods.__call__ at <span class="number">0x00000238CE0F56A8</span>&gt;, <span class="string">&#x27;__str__&#x27;</span>: &lt;function Goods.__str__ at <span class="number">0x00000238CE0F5730</span>&gt;, <span class="string">&#x27;__getitem__&#x27;</span>: &lt;function Goods.__getitem__ at <span class="number">0x00000238CE0F57B8</span>&gt;, <span class="string">&#x27;__setitem__&#x27;</span>: &lt;function Goods.__setitem__ at <span class="number">0x00000238CE0F5840</span>&gt;, <span class="string">&#x27;__delitem__&#x27;</span>: &lt;function Goods.__delitem__ at <span class="number">0x00000238CE0F58C8</span>&gt;, <span class="string">&#x27;__del__&#x27;</span>: &lt;function Goods.__del__ at <span class="number">0x00000238CE0F5950</span>&gt;, <span class="string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="string">&#x27;__dict__&#x27;</span> of <span class="string">&#x27;Goods&#x27;</span> objects&gt;, <span class="string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="string">&#x27;__weakref__&#x27;</span> of <span class="string">&#x27;Goods&#x27;</span> objects&gt;&#125;</span><br><span class="line">    key: a</span><br><span class="line">    key:a, value:<span class="number">10</span></span><br><span class="line">    要删除key： a</span><br><span class="line">    __del__ 正在执行  </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>类和模块</tag>
      </tags>
  </entry>
  <entry>
    <title>Python类补充</title>
    <url>/2023/02/06/Python%E7%B1%BB%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h2 id="item系列"><code>item</code>系列</h2>
<ul>
<li><code>__getitem__</code></li>
<li>以字典形式访问属性的时候触发</li>
<li><code>__setitem__</code>
<ul>
<li>以字典形式设置属性的时候触发</li>
</ul>
</li>
<li><code>__delitem__</code>
<ul>
<li>以字典形式删除属性的时候触发</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;触发__getitem__&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;触发__setitem__&quot;</span>)</span><br><span class="line">        self.__dict__[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;触发__delitem__&quot;</span>)</span><br><span class="line">        self.__dict__.pop(key)</span><br><span class="line"></span><br><span class="line">f = Demo()</span><br><span class="line"><span class="comment"># 以字典的方式来操作属性</span></span><br><span class="line"><span class="built_in">print</span>(f.__dict__)</span><br><span class="line">f[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;luenci&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(f.__dict__)</span><br><span class="line"><span class="built_in">print</span>(f[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> f[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(f.__dict__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">&#123;&#125;</span><br><span class="line">触发__setitem__</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;luenci&#x27;</span>&#125;</span><br><span class="line">触发__getitem__</span><br><span class="line"><span class="literal">None</span></span><br><span class="line">触发__delitem__</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="str-和-repr-控制输出"><code>__str__</code>和<code>__repr__</code>控制输出</h2>
<ul>
<li><code>__str__</code>会在<code>print()</code>打印时候调用，如果类中没重写则会调用默认的打印值，如果自定义了则会调用自定义的<code>__str__</code>方法</li>
<li><code>__repr__</code>这个实在控制台的时候输出，若一个类中没定义<code>__str__</code>但是定义了<code>__repr__</code>方法，则会调用<code>__repr__</code>的返回值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">bar</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># def __str__(self):</span></span><br><span class="line">    <span class="comment">#     return &#x27;__str__自定义返回值&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;__repr__自定义返回值&#x27;</span></span><br><span class="line"></span><br><span class="line">f = bar(<span class="string">&#x27;luenci&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment"># print() 函数触发__str__()函数</span></span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">__repr__自定义返回值</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="slots-属性"><code>__slots__</code>属性</h2>
<ul>
<li>
<p>1.<code>__slots__</code>是什么？</p>
</li>
<li>
<p>是一个类变量，变量值可以是列表，元祖，或者可迭代对象，也可以是一个字符串（意味看所有实例只有一个数据属性）</p>
</li>
<li>
<p>2.引子：使用点来访问属性本质就是在访问类或者对象的dict属性字典（类的字典是共享的，而每个实例的是独立的）</p>
</li>
<li>
<p>3.为何使用<code>__slots__</code>？</p>
<ul>
<li>字典会占用大量内存，如果你有一个属性很少的类，但是有很多实例，为了节省内存可以使用<code>__slots__</code>取代实例的dict当你定义<code>__slots__</code>后，<code>__slots__</code>就会为实例使用一种更加紧凑的内部表示。实例通过一个很小的固定大小的数组来构建，而不是为每个实例定义一字典，这跟元组或列表很类似。在<code>__slots__</code>中列出的属性名在内部被映射到这个数组的指定小标上。使用<code>__slots__</code>一个不好的地方就是我们不能再给实例添加新的属性了，只能使用在slots中定义的那些属性名。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意事项：<code>__slots__</code>的很多特性都依赖于普通的基于字典的实现。另外，定义了<code>__slots__</code>后的类不再支持一些普通类特性了，比如多继承。大多数情况下，你应该只在那些经常被使用到的用作数据结构的类上定义<code>__slots__</code>比如在程序中需要创建某个类的几百万个实例对象。<br>
关于<code>__slots__</code>的一个常见误区是它可以作为一个封装工具来防止用户给实例增加新的属性。尽管使用<code>__slots__</code>可以达到这样的目的，但是这个并不是它的初衷。更多的是用来作为一个内存优化工具。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __slots__ = [<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line"></span><br><span class="line">f1 = Demo()</span><br><span class="line">f1.name = <span class="string">&#x27;luenci&#x27;</span></span><br><span class="line"><span class="comment"># print(f1.__dict__)</span></span><br><span class="line"><span class="built_in">print</span>(f1.__slots__)</span><br><span class="line"><span class="comment"># print(Demo.__dict__)</span></span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>]</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="描述符">描述符</h2>
<h3 id="定义">定义</h3>
<ul>
<li>一个描述符是一个有“绑定行为”的对象属性(object attribute)，它的访问控制会被描述器协议方法重写。</li>
<li>任何定义了 <code>__get__</code>, <code>__set__</code> 或者 <code>__delete__</code> 任一方法的类称为描述符类，其实例对象便是一个描述符，这些方法称为描述符协议。</li>
<li>当对一个实例属性进行访问时，Python 会按 <code>obj.__dict__</code> → <code>type(obj).__dict__</code> → <code>type(obj)的父类.__dict__</code> 顺序进行查找，如果查找到目标属性并发现是一个描述符，Python 会调用描述符协议来改变默认的控制行为。</li>
<li>描述符是 <code>@property``@classmethod``@staticmethod</code> 和 <code>super</code> 的底层实现机制。</li>
</ul>
<h3 id="特性">特性</h3>
<ul>
<li>同时定义了 <code>__get__</code> 和 <code>__set__</code> 的描述符称为 数据描述符(data descriptor)；</li>
<li>仅定义了 <code>__get__ </code>的称为 非数据描述符(non-data descriptor) 。</li>
<li>两者区别在于：如果 <code>obj.__dict__</code> 中有与描述符同名的属性，若描述符是数据描述符，则优先调用描述符，若是非数据描述符，则优先使用 <code>obj.__dict__</code> 中属性。</li>
<li>描述符协议必须定义在类的层次上，否则无法被自动调用。</li>
</ul>
<h3 id="描述符协议">描述符协议</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__get__(self, instance, owner)</span><br><span class="line"></span><br><span class="line">:param self: 描述符对象本身</span><br><span class="line">:param instance: 使用描述符的对象的实例</span><br><span class="line">:param owner: 使用描述符的对象拥有者</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__set__(self, instance, value)</span><br><span class="line">:param value: 对描述符的赋值</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__delete__(self, instance)</span><br></pre></td></tr></table></figure>
<h3 id="描述符的应用">描述符的应用</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Type</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    属性检查</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key, types</span>):</span><br><span class="line">        self.key = key</span><br><span class="line">        self.types = types</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__get__执行&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.key]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__set__执行&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, self.types):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;%s不是要求的%s类型&quot;</span> % (self.key, self.types))</span><br><span class="line">        instance.__dict__[self.key] = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delete__</span>(<span class="params">self, instance</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__delete__执行&quot;</span>)</span><br><span class="line">        instance.__dict__.pop(self.key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Peopel</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="type">Type</span>(<span class="string">&#x27;name&#x27;</span>, <span class="built_in">str</span>)</span><br><span class="line">    age = <span class="type">Type</span>(<span class="string">&#x27;age&#x27;</span>, <span class="built_in">int</span>)</span><br><span class="line">    sex = <span class="type">Type</span>(<span class="string">&#x27;sex&#x27;</span>, <span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, sex</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># p1 = Peopel(&#x27;luenci&#x27;, &#x27;11&#x27;, &#x27;男&#x27;)</span></span><br><span class="line"><span class="comment"># p2 = Peopel(12, 11, &#x27;男&#x27;)</span></span><br><span class="line">p3 = Peopel(<span class="string">&#x27;luenci&#x27;</span>, <span class="number">11</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="描述符总结">描述符总结</h2>
<ul>
<li>描述符是可以实现大部分python类特性中的底层魔法，包括<code>@classmethod</code>.<code>@staticmethd</code>.<code>@property</code>甚至是<code>__slots__</code>属性</li>
<li>描述符是很多高级库和框架的重要工具之一，描述符通常是使用到装饰器或者元类的大型框架中的一个组件。</li>
</ul>
<h2 id="元类">元类</h2>
<ul>
<li>元类是类的类，是类的模板</li>
<li>元类是用来控制如何创建类的，正如类是创建对象的模板一样</li>
<li>元类的实例为类，正如类的实例为对象（<code>f1</code>对象是<code>Foo</code>类的一个实例，<code>Foo</code>类是<code>type</code>类的一个实例）</li>
<li><code>type</code>是<code>python</code>的一个内建元类，用来直接控制生成类，<code>python</code>中任何<code>class</code>定义的类其实都是<code>type</code>类实例化的对象</li>
</ul>
]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>类和模块</tag>
      </tags>
  </entry>
  <entry>
    <title>Python面向对象</title>
    <url>/2023/02/06/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="类的定义">类的定义</h2>
<ul>
<li>把一类事物的相同的特征和动作整合到一起就是类，类是一个抽象的概念</li>
</ul>
<h2 id="对象的定义">对象的定义</h2>
<ul>
<li>基于类而创建一个具体的事物，类的实例化</li>
</ul>
<h2 id="接口继承">接口继承</h2>
<ul>
<li>继承的第二种含义非常重要。它又叫“接口继承”。</li>
<li>接口继承实质上是要求“做出一个良好的抽象，这个抽象规定了一个兼容接口，使得外部调用者无需关心具体细节，可一视同仁的处理实现了特定接口的所有对象”——这在程序设计上，叫做归一化。</li>
<li>归一化使得高层的外部使用者可以不加区分的处理所有接口兼容的对象集合——就好象<code>linux</code>的泛文件概念一样，所有东西都可以当文件处理，不必关心它是内存、磁盘、网络还是屏幕（当然，对底层设计者，当然也可以区分出“字符设备”和“块设备”，然后做出针对性的设计：细致到什么程度，视需求而定）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入抽象基类模块</span></span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义接口（基类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span>(metaclass=abc.ABCMeta):</span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">disk</span>(<span class="title class_ inherited__">File</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;disk read&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;disk wirte&quot;</span>)</span><br><span class="line"></span><br><span class="line">ds = disk()</span><br><span class="line">ds.read()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="子类中调用父类的方法">子类中调用父类的方法</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grandfather</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.age = age</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">grandfather</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;grandfather method&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>(<span class="title class_ inherited__">Grandfather</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name,age)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">father_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;father method&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age,sex</span>):</span><br><span class="line">        <span class="comment"># 调用父类的构造方法</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name,age)</span><br><span class="line">        self.sex = sex</span><br><span class="line">    <span class="comment"># 子类中调用父类方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">son_method</span>(<span class="params">self</span>):</span><br><span class="line">        Father.father_method(self)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">son_method1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().grandfather()</span><br><span class="line"></span><br><span class="line">son1 = Son(<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">18</span>, <span class="string">&#x27;male&#x27;</span>)</span><br><span class="line">son1.son_method1()</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="组合">组合</h2>
<ul>
<li>1、组合指的是，在一个类中以另外一个类的对象作为数据属性，称为类的组合。</li>
<li>2、作用是可以将两个本来不相关的类联系起来。一般是两个类之间有显著的不同，很多时候还要附属关系(有相同的属性也有不同的属性)。比如人和头，手机和电池等等。</li>
<li>3、无纵向关系时用组合，有纵向关系时用继承。</li>
<li>4、组合就是一个类中使用到另一个类，从而把几个类拼到一起。组合的功能也是为了减少重复代码</li>
</ul>
<h2 id="多态">多态</h2>
<ul>
<li>由不同的类实例化得到的对象，调用同一个方法，执行的逻辑不同</li>
<li>多态的概念指出了对象如何通过他们共同的属性和动作来操作及访问，而不需考虑他们具体类。</li>
<li>多态表明了动态（又名，运行时）绑定的存在，允计重载及运行时类型确定和验证。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generation</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.age &lt; <span class="number">18</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[%s]属于未成年人&quot;</span> % self.name)</span><br><span class="line">        <span class="keyword">elif</span> <span class="number">18</span> &lt; self.age &lt; <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[%s]属于青年人&quot;</span> % self.name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[%s]属于中老年人&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">minor</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">young</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">old</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">obj</span>):</span><br><span class="line">    obj.generation()</span><br><span class="line"></span><br><span class="line">w1 = young(<span class="string">&#x27;luenci&#x27;</span>,<span class="number">20</span>)</span><br><span class="line">w2 = minor(<span class="string">&#x27;xiaoming&#x27;</span>, <span class="number">16</span>)</span><br><span class="line">w3 = old(<span class="string">&#x27;jack&#x27;</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">func(w1)</span><br><span class="line">func(w3)</span><br><span class="line">func(w3)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[luenci]属于青年人</span><br><span class="line">[jack]属于中老年人</span><br><span class="line">[jack]属于中老年人</span><br></pre></td></tr></table></figure>
<h2 id="反射">反射</h2>
<ul>
<li><code>getattr(object, name)</code>
<ul>
<li>得到属性的值</li>
</ul>
</li>
<li><code>hasattr(object, name)</code>
<ul>
<li>说明：判断对象object是否包含名为name的特性（<code>hasattr</code>是通过调用<code>getattr(ojbect, name)</code>是否抛出异常来实现的</li>
</ul>
</li>
<li><code>setattr(object, name, value)</code>
<ul>
<li>这是相对应的<code>getattr()</code>。参数是一个对象,一个字符串和一个任意值。字符串可能会列出一个现有的属性或一个新的属性。这个函数将值赋给属性的。该对象允许它提供。例如,<code>setattr(x,“foobar”,123)</code>相当于<code>x.foobar= 123</code></li>
</ul>
</li>
<li><code>delattr(object, name)</code>
<ul>
<li>与<code>setattr()</code>相关的一组函数。参数是由一个对象(记住python中一切皆是对象)和一个字符串组成的。<code>string</code>参数必须是对象属性名之一。该函数删除该<code>obj</code>的一个由<code>string</code>指定的属性。<code>delattr(x, 'foobar')=del x.foobar</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>注：<code>getattr</code>,<code>hasattr</code>,<code>setattr</code>,<code>delattr</code>对模块的修改都在内存中进行，并不会影响文件中真实内容。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Demo(object):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line">    def method(self):</span><br><span class="line">        print(&quot;i am method&quot;)</span><br><span class="line"></span><br><span class="line">d = Demo(&#x27;luenci&#x27;)</span><br><span class="line"># 如果d 对象中有属性name则打印self.name的值，否则打印not find</span><br><span class="line">print(getattr(d,&#x27;name&#x27;,&#x27;not find&#x27;))</span><br><span class="line">print(getattr(d,&#x27;age&#x27;,&#x27;not find&#x27;))</span><br><span class="line"></span><br><span class="line">#如果有方法method，否则打印其地址，否则打印not find</span><br><span class="line">print(getattr(d, &#x27;method&#x27;, &#x27;not find&#x27;))</span><br><span class="line">print(getattr(d, &#x27;methods&#x27;, &#x27;not find&#x27;))</span><br><span class="line"></span><br><span class="line">#如果有方法method，运行函数并打印None否则打印not find</span><br><span class="line">print(getattr(d, &#x27;method&#x27;, &#x27;not find&#x27;)())</span><br><span class="line"></span><br><span class="line"># 说明：判断对象object是否包含名为name的特性（hasattr是通过调用getattr(ojbect, name)是否抛出异常来实现的）</span><br><span class="line">print(hasattr(d, &#x27;name&#x27;))</span><br><span class="line"></span><br><span class="line"># 增加和修改参数</span><br><span class="line"># d.age =  18</span><br><span class="line">setattr(d,&#x27;age&#x27;, 18)</span><br><span class="line">setattr(d,&#x27;name&#x27;,&#x27;jack&#x27;)</span><br><span class="line">print(d.__dict__)</span><br><span class="line"></span><br><span class="line"># 删除 属性 不能删除属性对应的值， 但是可以使用setattr来修改</span><br><span class="line">delattr(d,&#x27;age&#x27;)</span><br><span class="line">print(d.__dict__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">luenci</span><br><span class="line">not find</span><br><span class="line">&lt;bound method Demo.method of &lt;__main__.Demo object at 0x000001710E9359B0&gt;&gt;</span><br><span class="line">not find</span><br><span class="line">i am method</span><br><span class="line">None</span><br><span class="line">True</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;jack&#x27;, &#x27;age&#x27;: 18&#125;</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;jack&#x27;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态导入模块">动态导入模块</h3>
<p>问题：</p>
<ul>
<li>我们要导入一个模块,可以使用<code>import</code>.现在有这样的需求,我动态输入一个模块名，可以随时访问到导入模块中的方法或者变量，怎么做呢？</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;t.py&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am test&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model_name = <span class="built_in">input</span>(<span class="string">&quot;请输入您要导入的模块名称：&quot;</span>)</span><br><span class="line">imp = <span class="built_in">__import__</span>(model_name)</span><br><span class="line"><span class="comment"># 判断是否有test函数，有就执行test函数内容</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">getattr</span>(imp,<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;not find&#x27;</span>):</span><br><span class="line">    imp.test()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(imp)</span><br><span class="line">    imp.test()</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    请输入您要导入的模块名称：t</span><br><span class="line">    i am test</span><br><span class="line">    &lt;module <span class="string">&#x27;t&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;E:\\python进阶练习\\面向对象\\t.py&#x27;</span>&gt;</span><br><span class="line">    i am test</span><br></pre></td></tr></table></figure>
<h2 id="包装">包装</h2>
<ul>
<li>对一个已存在的对象进行包装，可以是对一个已存在的对象，增加，删除，或者修改功能。可以包装任何类型（type）作为一个类（class）的核心成员（如<code>list</code>,<code>dict</code>等），以使新对象的行为模仿你想要的数据类型中已存在的行为，并且去掉你不希望存在的行为。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">List</span>(<span class="title class_ inherited__">list</span>):</span><br><span class="line">    <span class="comment"># 重写list的append方法,让其只能添加字符类型的数据</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, p_object</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(p_object) <span class="keyword">is</span> <span class="built_in">str</span>:</span><br><span class="line">            <span class="comment"># self.append(self, p_object)</span></span><br><span class="line">            <span class="built_in">super</span>().append(p_object)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;只有字符类型才可以允许添加&quot;</span>)</span><br><span class="line"></span><br><span class="line">a = <span class="type">List</span>(<span class="string">&#x27;hello Luenci&#x27;</span>)</span><br><span class="line">a.append(<span class="number">123</span>)</span><br><span class="line">a.append(<span class="string">&quot;haha&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">只有字符类型才可以允许添加</span><br><span class="line">[<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;haha&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h2 id="授权">授权</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合的方式完成授权</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandle</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, filename, mode=<span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span></span>):</span><br><span class="line">        self.file = <span class="built_in">open</span>(filename,mode=mode,encoding=encoding)</span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.encoding = encoding</span><br><span class="line">    <span class="comment"># 个性化定制write方法，比如不允许写，去除敏感词汇，给内容加上时间戳</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">self,content</span>):</span><br><span class="line">        t = time.strftime(<span class="string">&#x27;%Y-%m-%d %X&#x27;</span>)</span><br><span class="line">        self.file.write(<span class="string">&#x27;%s %s&#x27;</span>%(t,content))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self.file, item)</span><br><span class="line"></span><br><span class="line">f = FileHandle(<span class="string">&#x27;a.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&#x27;Hello\n&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&#x27;luenci\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a.txt----&gt;</span><br><span class="line"><span class="number">2020</span>-05-<span class="number">29</span> <span class="number">11</span>:<span class="number">23</span>:<span class="number">38</span> Hello</span><br><span class="line"><span class="number">2020</span>-05-<span class="number">29</span> <span class="number">11</span>:<span class="number">23</span>:<span class="number">38</span> luenci</span><br></pre></td></tr></table></figure>
<h2 id="函数补充">函数补充</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Too</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">Foo</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1 = Foo()</span><br><span class="line"><span class="comment"># 判断实例化对象是不是属于此类 结果是boolean</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(f1, Too))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(f1, Foo))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断Bar类是不是Foo的子类 结果是boolean</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Bar, Foo))</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>类的知识</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL性能调优</title>
    <url>/2023/02/06/SQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<p><em><strong>原文链接：<a href="https://blog.csdn.net/u010520146/article/details/81161762">https://blog.csdn.net/u010520146/article/details/81161762</a></strong></em></p>
<h1>一.创建索引</h1>
<ul>
<li>1.要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引</li>
<li>2.1在经常需要进行检索的字段上创建索引，比如要按照表字段<code>username</code>进行检索，那么就应该在姓名字段上创建索引，如果经常要按照员工部门和员工岗位级别进行检索，那么就应该在员工部门和员工岗位级别这两个字段上创建索引。</li>
<li>2.2创建索引给检索带来的性能提升往往是巨大的，因此在发现检索速度过慢的时候应该首先想到的就是创建索引。</li>
<li>2.3一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。</li>
</ul>
<h1>二.避免在索引上使用计算</h1>
<ul>
<li>在where字句中，如果索引列是计算或者函数的一部分，DBMS的优化器将不会使用索引而使用全表查询,函数<br>
属于计算的一种,同时在in和exists中通常情况下使用EXISTS，因为in不走索引。</li>
<li>效率低：</li>
</ul>
<p><code> select * from user where salary*22 &gt; 11000 (salary是索引列)</code></p>
<ul>
<li>效率高：</li>
</ul>
<p><code>select * from user where salary &gt; 11000/22 (salary是索引列)</code></p>
<h1>三.使用预编译查询</h1>
<ul>
<li>程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞<br>
攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。</li>
</ul>
<h1>四.调整Where字句中的连接顺序</h1>
<ul>
<li>DBMS一般采用自下而上的顺序解析where字句，根据这个原理表连接最好写在其他where条件之前，那些可以过滤掉最大数量记录。</li>
</ul>
<span id="more"></span>
<h1>五.尽量将多条SQL语句压缩到一句SQL中</h1>
<ul>
<li>每次执行SQL的时候都要建立网络连接、进行权限校验、进行SQL语句的查询优化、发送执行结果，这个过程<br>
是非常耗时的，因此应该尽量避免过多的执行SQL语句，能够压缩到一句SQL执行的语句就不要用多条来执行。</li>
</ul>
<h1>六.用where子句替换HAVING字句</h1>
<ul>
<li>避免使用<code>HAVING</code>字句，因为<code>HAVING</code>只会在检索出所有记录之后才对结果集进行过滤，而<code>where</code>则是在聚合前<br>
刷选记录，如果能通过<code>where</code>字句限制记录的数目，那就能减少这方面的开销。<code>HAVING</code>中的条件一般用于聚合函数<br>
的过滤，除此之外，应该将条件写在<code>where</code>字句中。</li>
</ul>
<h1>七.使用表的别名</h1>
<ul>
<li>当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减<br>
少哪些友列名歧义引起的语法错误。</li>
</ul>
<h1>八.用union all替换union</h1>
<ul>
<li>当SQL语句需要<code>union</code>两个查询结果集合时，即使检索结果中不会有重复的记录，如果使用<code>union</code>这两个结果集同样会尝试进行合并，然后在输出最终结果前进行排序，因此如果可以判断检索结果中不会有重复的记录时候，应该用union all，这样效率就会因此得到提高。</li>
</ul>
<h1>九.考虑使用“临时表”暂存中间结果</h1>
<ul>
<li>简化SQL语句的重要方法就是采用临时表暂存中间结果，但是，临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在<code>tempdb</code>中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。但是也得避免频繁创建和删除临时表，以减少系统表资源的消耗。</li>
</ul>
<h1>十.只在必要的情况下才使用事务begin translation</h1>
<ul>
<li>SQL Server中一句SQL语句默认就是一个事务，在该语句执行完成后也是默认<code>commit</code>的。其实，这就是<code>begin tran</code>的一个最小化的形式，好比在每句语句开头隐含了一个<code>begin tran</code>，结束时隐含了一个commit。</li>
<li>有些情况下，我们需要显式声明<code>begin tran</code>，比如做“插、删、改”操作需要同时修改几个表，要求要么几个表都修改成功，要么都不成功。<code>begin tran</code> 可以起到这样的作用，它可以把若干SQL语句套在一起执行，最后再一起<code>commit</code>。 好处是保证了数据的一致性，但任何事情都不是完美无缺的。<code>Begin tran</code>付出的代价是在提交之前，所有SQL语句锁住的资源都不能释放，直到<code>commit</code>掉。<br>
可见，如果<code>Begin tran</code>套住的SQL语句太多，那数据库的性能就糟糕了。在该大事务提交之前，必然会阻塞别的语句，造成<code>block</code>很多。</li>
<li><code>Begin tran</code>使用的原则是，在保证数据一致性的前提下，<code>begin tran </code>套住的SQL语句越少越好！有些情况下可以采用触发器同步数据，不一定要用<code>begin tran</code>。</li>
</ul>
<h1>十一.尽量避免使用游标</h1>
<ul>
<li>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</li>
</ul>
<h1>十二.用<code>varchar</code>/<code>nvarchar </code>代替 <code>char</code>/<code>nchar</code></h1>
<ul>
<li>尽可能的使用 <code>varchar/nvarchar </code>代替<code> char/nchar</code> ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</li>
<li>不要以为 <code>NULL </code>不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是<code>varchar</code>这样的变长字段， <code>null </code>不占用空间。</li>
</ul>
<h1>十三.查询select语句优化</h1>
<ul>
<li>1.任何地方都不要使用 <code>select * from T </code>，用具体的字段列表代替“*”，不要返回用不到的任何字段</li>
<li>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，<br>
如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">is</span> <span class="keyword">null</span>           </span><br></pre></td></tr></table></figure>
<ul>
<li>可以在num上设置默认值0，确保表中num列没有null值，<br>
然后这样查询：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">or</span> num<span class="operator">=</span><span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以这样查询：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">10</span></span><br><span class="line"> <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>4.不能前置百分</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="keyword">like</span> ‘<span class="operator">%</span>abc<span class="operator">%</span>’</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>若要提高效率，可以考虑全文检索。</p>
<p>select id from t where num in(1,2,3)</p>
</li>
<li>
<p>对于连续的数值，能用 between 就不要用 in 了：</p>
<p>select id from t where num between 1 and 3<br>
6.如果查询的两个表大小相当，那么用in和exists差别不大。<br>
in：<br>
例如：表A（小表），表B（大表）</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> cc <span class="keyword">in</span> (<span class="keyword">select</span> cc <span class="keyword">from</span> B)       效率低，用到了A表上cc列的索引；     </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> cc <span class="keyword">from</span> B <span class="keyword">where</span> cc<span class="operator">=</span>A.cc)   效率高，用到了B表上cc列的索引。   </span><br></pre></td></tr></table></figure>
<p>相反的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> B <span class="keyword">where</span> cc <span class="keyword">in</span> (<span class="keyword">select</span> cc <span class="keyword">from</span> A)        效率高，用到了B表上cc列的索引；</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> B <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> cc <span class="keyword">from</span> A <span class="keyword">where</span> cc<span class="operator">=</span>B.cc)  效率低，用到了A表上cc列的索引。</span><br></pre></td></tr></table></figure>
<h1>十四.更新Update语句优化</h1>
<ul>
<li>1.如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志</li>
</ul>
<h1>十五. 删除Delete语句优化语句</h1>
<p>1.最高效的删除重复记录方法 ( 因为使用了ROWID)例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> EMP E <span class="keyword">WHERE</span> E.ROWID <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(X.ROWID) <span class="keyword">FROM</span> EMP X <span class="keyword">WHERE</span> X.EMP_NO <span class="operator">=</span> E.EMP_NO);</span><br></pre></td></tr></table></figure>
<h1>十六.插入Insert语句优化</h1>
<ul>
<li>在新建临时表时，如果一次性插入数据量很大，那么可以使用 <code>select into</code> 代替 <code>create table</code>，避免造成大量<code>log</code>，以提高速度；如果数据量不大，为了缓和系统表的资源，应先<code>create table</code>，然后<code>insert</code>。</li>
</ul>
]]></content>
      <categories>
        <category>SQL知识</category>
      </categories>
      <tags>
        <tag>SQL调优</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言笔记（3）</title>
    <url>/2023/02/06/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h1>结构体</h1>
<ul>
<li>结构体声明</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  结构体成员<span class="number">1</span>;</span><br><span class="line">  结构体成员<span class="number">2</span>;</span><br><span class="line">  结构体成员<span class="number">3</span>;</span><br><span class="line">  ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>定义结构体类型变量</p>
<ul>
<li>struct 结构体名称 结构体变量名</li>
</ul>
</li>
<li>
<p>访问结构体变量</p>
<ul>
<li>要访问结构体成员，我们需要引入一个新的运算符——点号(.)运算符。比如book.title就是引用book结构体的title成员，它是一个字符数组。</li>
</ul>
</li>
<li>
<p>初始结构体的指定成员值</p>
<ul>
<li>其语法和数组指定初始化元素类似，不过结构体指定初始化成员使用点号（.）运算符和成员名</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> author[<span class="number">40</span>];</span><br><span class="line">    <span class="type">float</span> price;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="type">char</span> publisher[<span class="number">40</span>];</span><br><span class="line">&#125;book;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="comment">//    struct Book book1;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入书名：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, book.title);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入作者：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, book.author);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入售价：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;book.price);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入出版日期：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;book.data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入出版社：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, book.publisher);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n====数据录入完毕====\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;书名：%s\n&quot;</span>, book.title);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;作者：%s\n&quot;</span>, book.author);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;售价：%.2f\n&quot;</span>, book.price);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出版日期：%d\n&quot;</span>, book.data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出版社：%s\n&quot;</span>, book.publisher);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="结构体嵌套">结构体嵌套</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> author[<span class="number">40</span>];</span><br><span class="line">    <span class="type">float</span> price;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br><span class="line">    <span class="type">char</span> publisher[<span class="number">40</span>];</span><br><span class="line">&#125;book = &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="string">&quot;c学习&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Luenci&quot;</span>,</span><br><span class="line">        <span class="number">48.8</span>,</span><br><span class="line">        &#123;<span class="number">2019</span>,<span class="number">11</span>,<span class="number">13</span>&#125;,</span><br><span class="line">        <span class="string">&quot;文华出版社&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n====数据录入为====\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;书名：%s\n&quot;</span>, book.title);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;作者：%s\n&quot;</span>, book.author);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;售价：%.2f\n&quot;</span>, book.price);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出版日期：%d%d%d\n&quot;</span>, book.data.year, book.data.month, book.data.day);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出版社：%s\n&quot;</span>, book.publisher);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out</span><br><span class="line">书名：c学习</span><br><span class="line">作者：Luenci</span><br><span class="line">售价：<span class="number">48.80</span></span><br><span class="line">出版日期：<span class="number">20191113</span></span><br><span class="line">出版社：文华出版社</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="结构体数组">结构体数组</h2>
<ul>
<li>第二种方法是先声明一个结构体类型（如上例子中Book），再用此类型定义一个结构体数组：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名称</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  结构体成员;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名称 数组名[长度];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化结构体数组</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span> <span class="title">book</span>[3] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;《零基础学c》&quot;</span>, <span class="string">&quot;Luenci&quot;</span>, <span class="number">49.5</span>, &#123;<span class="number">2016</span>, <span class="number">11</span>, <span class="number">22</span>&#125;, <span class="string">&quot;清华大学出版社&quot;</span>&#125;， </span><br><span class="line">    &#123;<span class="string">&quot;《零基础学c》&quot;</span>, <span class="string">&quot;Luenci&quot;</span>, <span class="number">49.5</span>, &#123;<span class="number">2016</span>, <span class="number">11</span>, <span class="number">22</span>&#125;, <span class="string">&quot;清华大学出版社&quot;</span>&#125;， </span><br><span class="line">    &#123;<span class="string">&quot;《零基础学c》&quot;</span>, <span class="string">&quot;Luenci&quot;</span>, <span class="number">49.5</span>, &#123;<span class="number">2016</span>, <span class="number">11</span>, <span class="number">22</span>&#125;, <span class="string">&quot;清华大学出版社&quot;</span>&#125;，  </span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<h2 id="结构体指针">结构体指针</h2>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">ptr</span>；</span></span><br><span class="line"><span class="class"><span class="title">ptr</span> =</span> &amp;book；</span><br></pre></td></tr></table></figure>
<ul>
<li>通过结构体指针访问结构体成员
<ul>
<li>(*结构体指针).成员名</li>
<li>结构体指针-&gt;成员名</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> author[<span class="number">40</span>];</span><br><span class="line">    <span class="type">float</span> price;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br><span class="line">    <span class="type">char</span> publisher[<span class="number">40</span>];</span><br><span class="line">&#125;book = &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="string">&quot;c学习&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Luenci&quot;</span>,</span><br><span class="line">        <span class="number">48.8</span>,</span><br><span class="line">        &#123;<span class="number">2019</span>,<span class="number">11</span>,<span class="number">13</span>&#125;,</span><br><span class="line">        <span class="string">&quot;文华出版社&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">ptr</span>;</span></span><br><span class="line">    ptr = &amp;book;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n====数据录入为====\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;书名：%s\n&quot;</span>, (*ptr).title);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;作者：%s\n&quot;</span>, (*ptr).author);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;售价：%.2f\n&quot;</span>, (*ptr).price);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出版日期：%d%d%d\n&quot;</span>, (*ptr).data.year, (*ptr).data.month, (*ptr).data.day);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出版社：%s\n&quot;</span>, (*ptr).publisher);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;书名：%s\n&quot;</span>, ptr-&gt;title);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;作者：%s\n&quot;</span>, ptr-&gt;author);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;售价：%.2f\n&quot;</span>, ptr-&gt;price);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出版日期：%d%d%d\n&quot;</span>, ptr-&gt;data.year, ptr-&gt;data.month, ptr-&gt;data.day);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出版社：%s\n&quot;</span>, ptr-&gt;publisher);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line">====数据录入为====</span><br><span class="line"></span><br><span class="line">书名：c学习</span><br><span class="line">作者：Luenci</span><br><span class="line">售价：<span class="number">48.80</span></span><br><span class="line">出版日期：<span class="number">20191113</span></span><br><span class="line">出版社：文华出版社</span><br></pre></td></tr></table></figure>
<h1>链表</h1>
<h2 id="单链表">单链表</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">head --&gt; A</span><br><span class="line">A[信息域- 指针] --&gt; B[信息域- 指针]</span><br><span class="line">B[信息域- 指针] --&gt; c[信息域- 指针]</span><br><span class="line">c[信息域- 指针] --&gt; NULL</span><br></pre></td></tr></table></figure>
<h3 id="头插法">头插法</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ------------ 头插法实现链表的插入 ---------------</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/14.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> author[<span class="number">40</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getInput</span><span class="params">(<span class="keyword">struct</span> Book *book)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入书名：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, book-&gt;title);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入作者：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, book-&gt;author);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_book</span><span class="params">(<span class="keyword">struct</span> Book **library)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">book</span>, *<span class="title">temp</span>;</span></span><br><span class="line"></span><br><span class="line">    book = (<span class="keyword">struct</span> Book *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Book));</span><br><span class="line">    <span class="keyword">if</span>(book == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配内存失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getInput(book);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*library != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp = *library;</span><br><span class="line">        *library = book;</span><br><span class="line">        book-&gt;next = temp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        *library = book;</span><br><span class="line">        book-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printLibrary</span><span class="params">(<span class="keyword">struct</span> Book *library)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">book</span>;</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    book = library;</span><br><span class="line">    <span class="keyword">while</span>(book != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Book%d: &quot;</span>, count);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;书名：%s&quot;</span>, book-&gt;title);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;作者:%s&quot;</span>, book-&gt;author);</span><br><span class="line">        book = book-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">releaseLibrary</span><span class="params">(<span class="keyword">struct</span> Book *library)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(library != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        library = library-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(library);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">library</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请问你是否需要录入书籍信息（Y/N）:&quot;</span>);</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;<span class="keyword">while</span> (ch != <span class="string">&#x27;Y&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;N&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;Y&#x27;</span>)&#123;</span><br><span class="line">            add_book(&amp;library);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请问你是否需要打印书籍信息（Y/N）:&quot;</span>);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;<span class="keyword">while</span> (ch != <span class="string">&#x27;Y&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;N&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;Y&#x27;</span>)&#123;</span><br><span class="line">        printLibrary(library);</span><br><span class="line">    &#125;</span><br><span class="line">    releaseLibrary(library);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="尾插法">尾插法</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/14.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> title[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> author[<span class="number">40</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getInput</span><span class="params">(<span class="keyword">struct</span> Book *book)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入书名：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, book-&gt;title);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入作者：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, book-&gt;author);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_book2</span><span class="params">(<span class="keyword">struct</span> Book **library)</span>&#123;</span><br><span class="line">    <span class="comment">/* ------------ 尾插法 ------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">book</span>,*<span class="title">temp</span>;</span></span><br><span class="line"></span><br><span class="line">    book = (<span class="keyword">struct</span> Book *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Book));</span><br><span class="line">    <span class="keyword">if</span>(book == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配内存失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getInput(book);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*library != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp = *library;</span><br><span class="line">        <span class="comment">// 定位单链表的尾部位置</span></span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入数据</span></span><br><span class="line">        temp-&gt;next = book;</span><br><span class="line">        book-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        *library = book;</span><br><span class="line">        book-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printLibrary</span><span class="params">(<span class="keyword">struct</span> Book *library)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">book</span>;</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    book = library;</span><br><span class="line">    <span class="keyword">while</span>(book != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Book%d: &quot;</span>, count);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;书名：%s&quot;</span>, book-&gt;title);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;作者:%s&quot;</span>, book-&gt;author);</span><br><span class="line">        book = book-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">releaseLibrary</span><span class="params">(<span class="keyword">struct</span> Book **library)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">temp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(library != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp = *library;</span><br><span class="line">        *library = (*library)-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">library</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请问你是否需要录入书籍信息（Y/N）:&quot;</span>);</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;<span class="keyword">while</span> (ch != <span class="string">&#x27;Y&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;N&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;Y&#x27;</span>)&#123;</span><br><span class="line">            add_book2(&amp;library);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请问你是否需要打印书籍信息（Y/N）:&quot;</span>);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;<span class="keyword">while</span> (ch != <span class="string">&#x27;Y&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;N&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;Y&#x27;</span>)&#123;</span><br><span class="line">        printLibrary(library);</span><br><span class="line">    &#125;</span><br><span class="line">    releaseLibrary(&amp;library);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="尾插法改进">尾插法改进</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/14.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> title[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> author[<span class="number">40</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getInput</span><span class="params">(<span class="keyword">struct</span> Book *book)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add_book</span><span class="params">(<span class="keyword">struct</span> Book **library)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getInput</span><span class="params">(<span class="keyword">struct</span> Book *book)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add_book2</span><span class="params">(<span class="keyword">struct</span> Book **library)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printLibrary</span><span class="params">(<span class="keyword">struct</span> Book *library)</span>;</span><br><span class="line"><span class="keyword">struct</span> Book *<span class="title function_">searchBook</span><span class="params">(<span class="keyword">struct</span> Book *library, <span class="type">char</span> *target)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">releaseLibrary</span><span class="params">(<span class="keyword">struct</span> Book **library)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printBook</span><span class="params">(<span class="keyword">struct</span> Book *book)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getInput</span><span class="params">(<span class="keyword">struct</span> Book *book)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入书名：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, book-&gt;title);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入作者：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, book-&gt;author);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_book</span><span class="params">(<span class="keyword">struct</span> Book **library)</span>&#123;</span><br><span class="line">    <span class="comment">/* ----------- 头插法 ------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">book</span>, *<span class="title">temp</span>;</span></span><br><span class="line"></span><br><span class="line">    book = (<span class="keyword">struct</span> Book *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Book));</span><br><span class="line">    <span class="keyword">if</span>(book == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配内存失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getInput(book);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*library != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp = *library;</span><br><span class="line">        *library = book;</span><br><span class="line">        book-&gt;next = temp;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        *library = book;</span><br><span class="line">        book-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_book2</span><span class="params">(<span class="keyword">struct</span> Book **library)</span>&#123;</span><br><span class="line">    <span class="comment">/* ------------ 尾插法 ------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">book</span>;</span></span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">tail</span>;</span></span><br><span class="line"></span><br><span class="line">    book = (<span class="keyword">struct</span> Book *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Book));</span><br><span class="line">    <span class="keyword">if</span>(book == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配内存失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getInput(book);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*library != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        tail-&gt;next = book;</span><br><span class="line">        book-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        *library = book;</span><br><span class="line">        book-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tail = book;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printLibrary</span><span class="params">(<span class="keyword">struct</span> Book *library)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">book</span>;</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    book = library;</span><br><span class="line">    <span class="keyword">while</span>(book != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Book%d: &quot;</span>, count);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;书名：%s&quot;</span>, book-&gt;title);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;作者:%s&quot;</span>, book-&gt;author);</span><br><span class="line">        book = book-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">releaseLibrary</span><span class="params">(<span class="keyword">struct</span> Book **library)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">temp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(library != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp = *library;</span><br><span class="line">        *library = (*library)-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Book *<span class="title function_">searchBook</span><span class="params">(<span class="keyword">struct</span> Book *library, <span class="type">char</span> *target)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">book</span>;</span></span><br><span class="line"></span><br><span class="line">    book = library;</span><br><span class="line">    <span class="keyword">while</span> (book != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(book-&gt;title, target) || !<span class="built_in">strcmp</span>(book-&gt;author, target))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        book = book-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printBook</span><span class="params">(<span class="keyword">struct</span> Book *book)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;书名: %s\n&quot;</span>, book-&gt;title);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;作者: %s\n&quot;</span>, book-&gt;author);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">library</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">book</span>;</span></span><br><span class="line">    <span class="type">char</span> *input[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请问你是否需要录入书籍信息（Y/N）:&quot;</span>);</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;<span class="keyword">while</span> (ch != <span class="string">&#x27;Y&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;N&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;Y&#x27;</span>)&#123;</span><br><span class="line">            add_book2(&amp;library);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请问你是否需要打印书籍信息（Y/N）:&quot;</span>);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;<span class="keyword">while</span> (ch != <span class="string">&#x27;Y&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;N&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;Y&#x27;</span>)&#123;</span><br><span class="line">        printLibrary(library);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n请输入书名或作者：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line"></span><br><span class="line">    book = searchBook(library, input);</span><br><span class="line">    <span class="keyword">if</span>(book == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;很抱歉没能找到！\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;已找到符合条件的书籍...\n&quot;</span>);</span><br><span class="line">            printBook(book);</span><br><span class="line">        &#125; <span class="keyword">while</span> ((book = searchBook(book-&gt;next, input)) != <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    releaseLibrary(&amp;library);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表的插入">链表的插入</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/16.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertNode</span><span class="params">(<span class="keyword">struct</span> Node **head, <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printNode</span><span class="params">(<span class="keyword">struct</span> Node *head)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertNode</span><span class="params">(<span class="keyword">struct</span> Node **head, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">previous</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">current</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    current = *head;</span><br><span class="line">    previous = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;value &lt; value)&#123;</span><br><span class="line">        previous = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    new = (<span class="keyword">struct</span> Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    <span class="keyword">if</span> (new == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配内存失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    new-&gt;value = value;</span><br><span class="line">    new-&gt;next = current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        *head = new;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        previous-&gt;next = new;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printNode</span><span class="params">(<span class="keyword">struct</span> Node *head)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">current</span>;</span></span><br><span class="line"></span><br><span class="line">    current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;value);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> input;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数（-1结束）：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">if</span>(input == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        insertNode(&amp;head, input);</span><br><span class="line">        printNode(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表的删除">链表的删除</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/16.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertNode</span><span class="params">(<span class="keyword">struct</span> Node **head, <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printNode</span><span class="params">(<span class="keyword">struct</span> Node *head)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delectNode</span><span class="params">(<span class="keyword">struct</span> Node **head, <span class="type">int</span> value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertNode</span><span class="params">(<span class="keyword">struct</span> Node **head, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">previous</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">current</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    current = *head;</span><br><span class="line">    previous = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;value &lt; value)&#123;</span><br><span class="line">        previous = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    new = (<span class="keyword">struct</span> Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    <span class="keyword">if</span> (new == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配内存失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    new-&gt;value = value;</span><br><span class="line">    new-&gt;next = current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        *head = new;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        previous-&gt;next = new;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delectNode</span><span class="params">(<span class="keyword">struct</span> Node **head, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">previous</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">current</span>;</span></span><br><span class="line"></span><br><span class="line">    current = *head;</span><br><span class="line">    previous = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;value != value)&#123;</span><br><span class="line">        previous = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找不到匹配的节点&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(previous == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            *head = current-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            previous-&gt;next = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printNode</span><span class="params">(<span class="keyword">struct</span> Node *head)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">current</span>;</span></span><br><span class="line"></span><br><span class="line">    current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;value);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> input;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始测试插入整数...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数（-1结束）：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">if</span>(input == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        insertNode(&amp;head, input);</span><br><span class="line">        printNode(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始测试删除整数...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数（-1结束）：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">if</span>(input == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        delectNode(&amp;head, input);</span><br><span class="line">        printNode(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>内存池</h1>
<p>优点：</p>
<ul>
<li>设计内存池的目标是为了保证服务器长时间高效的运行，通过对申请空间小而申请频繁的对象进行有效管理，减少内存碎片的产生，合理分配管理用户内存，从而减少系统中出现有效空间足够，而无法分配大块连续内存的情况。</li>
</ul>
<p>结论：</p>
<ul>
<li>内存池基本上满足初期设计目标，但是她并不是完美的，有缺陷，比如,不能申请大于256字节的内存空间，无内存越界检查，无内存自动回缩功能等。只是这些对我们的影响还不是那么重要。</li>
</ul>
<h1>typedef基础</h1>
<ul>
<li>相比起宏定义的直接替换， typedef是对类型的封装。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/16.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> integer;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    integer a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %u\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of a  = %d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/16.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> mouth;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125; DATA, *PDATA;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> *<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">    data = (PDATA)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DATA));</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    data-&gt;year = <span class="number">2019</span>;</span><br><span class="line">    data-&gt;mouth = <span class="number">10</span>;</span><br><span class="line">    data-&gt;day = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d-%d-%d\n&quot;</span>, data-&gt;year, data-&gt;mouth, data-&gt;day);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>进阶Typedef</h1>
<ul>
<li>在变成中使用<strong>typedef</strong>目的一般有两个：
<ul>
<li>一个是给变量起一个容易记住且意义明确的别名</li>
<li>另一个是简化一些比较复杂的类型声明</li>
</ul>
</li>
</ul>
<h1>共用体</h1>
<ul>
<li>共用体的所有成员共享同一个内存地址。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 共用体名称</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  共用成员<span class="number">1</span>；</span><br><span class="line">  共用成员<span class="number">2</span>；</span><br><span class="line">  共用成员<span class="number">3</span>；</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> pi;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">6</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">Test</span> <span class="title">test</span>;</span></span><br><span class="line"></span><br><span class="line">    test.i = <span class="number">50</span>;</span><br><span class="line">    test.pi = <span class="number">1.2</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(test.str, <span class="string">&quot;Luenci&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr of test.i:%p\n&quot;</span>, &amp;test.i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr of test.pi:%p\n&quot;</span>, &amp;test.pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr of test.str:%p\n&quot;</span>, &amp;test.str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value of test.i:%d\n&quot;</span>, test.i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value of test.i:%.2f\n&quot;</span>, test.pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value of test.i:%s\n&quot;</span>, test.str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out：</span><br><span class="line">addr of test.i:<span class="number">0061F</span>F18</span><br><span class="line">addr of test.pi:<span class="number">0061F</span>F18</span><br><span class="line">addr of test.str:<span class="number">0061F</span>F18</span><br><span class="line">value of test.i:<span class="number">1852142924</span></span><br><span class="line">value of test.i:<span class="number">0.00</span></span><br><span class="line">value of test.i:Luenci</span><br></pre></td></tr></table></figure>
<p>​</p>
<h1>枚举类型</h1>
<ul>
<li>如果一个变量只有几种可能的值，那么就可以将其定义为枚举（enumeration）类型。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> 枚举类型名称 &#123;</span>枚举值名称, 枚举值名称...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> 枚举类型名称 枚举变量1, 枚举变量;</span></span><br></pre></td></tr></table></figure>
<p>​</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span>  <span class="title">Week</span> &#123;</span>sun, mon, tue, wed, thu, fri, sat&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span>  <span class="title">Week</span> <span class="title">today</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line"></span><br><span class="line">    time(&amp;t);</span><br><span class="line">    p = localtime(&amp;t);</span><br><span class="line"></span><br><span class="line">    today = p-&gt;tm_wday;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (today)&#123;</span><br><span class="line">        <span class="keyword">case</span> mon:</span><br><span class="line">        <span class="keyword">case</span> tue:</span><br><span class="line">        <span class="keyword">case</span> wed:</span><br><span class="line">        <span class="keyword">case</span> thu:</span><br><span class="line">        <span class="keyword">case</span> fri:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;学习！！！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> sat:</span><br><span class="line">        <span class="keyword">case</span> sun:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;放假！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>位域</h1>
<ul>
<li>使用位域的做法是在结构体定义时，在结构体成员后面使用冒号（：）和数字来表示该成员所占的位数。</li>
</ul>
<h2 id="无名位域">无名位域</h2>
<ul>
<li>位域成员可以没有名称，只要给出数据类型和位宽即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> x:<span class="number">100</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> y:<span class="number">200</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> z:<span class="number">300</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> :<span class="number">424</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="单片机">单片机</h2>
<ul>
<li>单片机（Microcontrollers）是一种集成电路芯片，是采用超大规模集成电路技术把具有数据处理能力的中央处理器CPU、随机存储器RAM、只读存储器ROM、多种I/0口和中新系统、定时器/计数器等功能（可能还包括显示驱动电路、脉宽调制电路、模拟多路转换器、A/D转换器等电路）集成到一块硅片上构成的一个小而完善的微型计算机条统，在工业控制领域广泛应用。</li>
</ul>
<h1>位操作</h1>
<h2 id="逻辑位运算符">逻辑位运算符</h2>
<ul>
<li>按位取反（<strong>~</strong>）
<ul>
<li>逻辑位运算符中优先级最高的是按位取反运算符，它的运算符是一个~符号，作用是将1变成0，将0变成1：</li>
</ul>
</li>
<li>按位与（<strong>&amp;</strong>）
<ul>
<li>优先级第二高的是按位与运算符，它的运算符是一个&amp;符号（而逻辑与是两个&amp;符号）</li>
</ul>
</li>
<li>按位异或（<strong>^</strong>）
<ul>
<li>优先级排第三的是按位异或运算符，它的运算符是一个个符号，只有当两个操作数对应的二进制位不同时，它的结果才为1，否则为0：</li>
</ul>
</li>
<li>按位或（<strong>|</strong>）
<ul>
<li>逻辑位运算符中优先级最低的是按位或运算符，它的运算符是一个|符号（而逻辑或是两个I符号）</li>
</ul>
</li>
<li>和赋值号结合
<ul>
<li>这四个运算符，除了按位取反只有一个操作数之外，其它三个都可以跟赋值号（=）结合到一块，使得代码更加简洁！</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> mask = <span class="number">0xFF</span>;</span><br><span class="line">    <span class="type">int</span> v1 = <span class="number">0xABCDEF</span>;</span><br><span class="line">    <span class="type">int</span> v2 = <span class="number">0xABCDEF</span>;</span><br><span class="line">    <span class="type">int</span> v3 = <span class="number">0xABCDEF</span>;</span><br><span class="line"></span><br><span class="line">    v1 &amp;= mask;</span><br><span class="line">    v2 |= mask;</span><br><span class="line">    v3 ^= mask;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;v1 = 0x%x\n&quot;</span>, v1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;v2 = 0x%x\n&quot;</span>, v2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;v3 = 0x%x\n&quot;</span>, v3);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">v1 = <span class="number">0xef</span></span><br><span class="line">v2 = <span class="number">0xabcdff</span></span><br><span class="line">v3 = <span class="number">0xabcd10</span></span><br></pre></td></tr></table></figure>
<h1>移位运算符</h1>
<p><strong>A = 0011 1100</strong></p>
<h2 id="左移位运算符">左移位运算符</h2>
<table>
<thead>
<tr>
<th>二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</th>
<th>A &lt;&lt; 2 将得到 240，即为 1111 0000</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="右移位运算符">右移位运算符</h2>
<table>
<thead>
<tr>
<th>二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</th>
<th>A &gt;&gt; 2 将得到 15，即为 0000 1111</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="一些未定义行为">一些未定义行为</h2>
<ul>
<li>左移、右移运算符右边的操作数如果是为负数，或者右边的操作数火于左边操作数支持的最大宽度，那么表达式的结果均是属于“未定义行为”。</li>
<li>左边的操作数是有符号还是无符号数其实也对移位运算符有着不同的影响。无等号数肯定没问题，因为这时候变量里边所有的位都用于表示该数值的大小。但如果是有符号数，那就要区别对待了，因为有符号数的左边第一位是符号位，所以如果恰好这个操作数是个负数，那么移动之后是否覆盖符号位的决定权还是落到了编译器上。</li>
</ul>
<h1>文件操作</h1>
<h2 id="文件概念">文件概念</h2>
<ul>
<li>计算机文件（或称文件、电脑档案、档亲），是存储在基种长期储存设备或临时存储设备中的一段数据流，并且归属于计算机文件系统管理之下。所谓“长期储存设备”一般指磁盘、光盘、磁带等。而“短期存储设备”一般指计算机内存。需要注意的是，存储于长期存储设备的文件不一定是长期存储的，有些也可能是程序或条统运行中产生的临时数据，并于程序或系统退出后删除。</li>
</ul>
<h2 id="打开文件">打开文件</h2>
<p>您可以使用 <strong>fopen( )</strong> 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 <strong>FILE</strong> 的一个对象，类型 <strong>FILE</strong> 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FILE *fopen( const char * filename, const char * mode );</span><br></pre></td></tr></table></figure>
<p>在这里，<strong>filename</strong> 是字符串，用来命名文件，访问模式 <strong>mode</strong> 的值可以是下列值中的一个：</p>
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">r</td>
<td style="text-align:left">打开一个已有的文本文件，允许读取文件。</td>
</tr>
<tr>
<td style="text-align:left">w</td>
<td style="text-align:left">打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</td>
</tr>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td>
</tr>
<tr>
<td style="text-align:left">r+</td>
<td style="text-align:left">打开一个文本文件，允许读写文件。</td>
</tr>
<tr>
<td style="text-align:left">w+</td>
<td style="text-align:left">打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td>
</tr>
<tr>
<td style="text-align:left">a+</td>
<td style="text-align:left">打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td>
</tr>
</tbody>
</table>
<p>如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;rb&quot;</span>, <span class="string">&quot;wb&quot;</span>, <span class="string">&quot;ab&quot;</span>, <span class="string">&quot;rb+&quot;</span>, <span class="string">&quot;r+b&quot;</span>, <span class="string">&quot;wb+&quot;</span>, <span class="string">&quot;w+b&quot;</span>, <span class="string">&quot;ab+&quot;</span>, <span class="string">&quot;a+b&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="关闭文件">关闭文件</h2>
<p>为了关闭文件，请使用 fclose( ) 函数。函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">( FILE *fp )</span>;</span><br></pre></td></tr></table></figure>
<p>如果成功关闭文件，<strong>fclose( )</strong> 函数返回零，如果关闭文件时发生错误，函数返回 <strong>EOF</strong>。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 <strong>stdio.h</strong> 中的常量。</p>
<p>C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。</p>
<h2 id="写入文件">写入文件</h2>
<p>下面是把字符写入到流中的最简单的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> c, FILE *fp )</span>;</span><br></pre></td></tr></table></figure>
<p>函数 <strong>fputc()</strong> 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 <strong>EOF</strong>。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *s, FILE *fp )</span>;</span><br></pre></td></tr></table></figure>
<p>函数 <strong>fputs()</strong> 把字符串 <strong>s</strong> 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 <strong>EOF</strong>。您也可以使用 <strong>int fprintf(FILE *fp,const char *format, …)</strong> 函数来写把一个字符串写入到文件中。</p>
<h1>读写单个字符</h1>
<h2 id="fgetc函数">fgetc函数</h2>
<h2 id="描述">描述</h2>
<p>C 库函数 <strong>char *fgets(char *str, int n, FILE *stream)</strong> 从指定的流 stream 读取一行，并把它存储在 <strong>str</strong> 所指向的字符串内。当读取 <strong>(n-1)</strong> 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</p>
<h2 id="声明">声明</h2>
<p>下面是 fgets() 函数的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *fgets(char *str, int n, FILE *stream)</span><br></pre></td></tr></table></figure>
<h2 id="参数">参数</h2>
<ul>
<li><strong>str</strong> – 这是指向一个字符数组的指针，该数组存储了要读取的字符串。</li>
<li><strong>n</strong> – 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。</li>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。</li>
</ul>
<h2 id="返回值">返回值</h2>
<p>如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。</p>
<p>如果发生错误，返回一个空指针。</p>
<h2 id="getc函数">getc函数</h2>
<h2 id="描述-2">描述</h2>
<p>C 库函数 <strong>int getc(FILE *stream)</strong> 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。</p>
<h2 id="声明-2">声明</h2>
<p>下面是 getc() 函数的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int getc(FILE *stream)</span><br></pre></td></tr></table></figure>
<h2 id="参数-2">参数</h2>
<ul>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了要在上面执行操作的流。</li>
</ul>
<h2 id="返回值-2">返回值</h2>
<p>该函数以无符号 char 强制转换为 int 的形式返回读取的字符，如果到达文件末尾或发生读错误，则返回 EOF</p>
<h1>单个字符写入</h1>
<h2 id="fputc函数">fputc函数</h2>
<h2 id="描述-3">描述</h2>
<p>C 库函数 <strong>int fputc(int char, FILE *stream)</strong> 把参数 <strong>char</strong> 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。</p>
<h2 id="声明-3">声明</h2>
<p>下面是 fputc() 函数的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fputc(int char, FILE *stream)</span><br></pre></td></tr></table></figure>
<h2 id="参数-3">参数</h2>
<ul>
<li><strong>char</strong> – 这是要被写入的字符。该字符以其对应的 int 值进行传递。</li>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符的流。</li>
</ul>
<h2 id="返回值-3">返回值</h2>
<p>如果没有发生错误，则返回被写入的字符。如果发生错误，则返回 EOF，并设置错误标识符。</p>
<h2 id="puts函数">puts函数</h2>
<h2 id="描述-4">描述</h2>
<p>C 库函数 <strong>int putc(int char, FILE *stream)</strong> 把参数 <strong>char</strong> 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。</p>
<h2 id="声明-4">声明</h2>
<p>下面是 putc() 函数的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int putc(int char, FILE *stream)</span><br></pre></td></tr></table></figure>
<h2 id="参数-4">参数</h2>
<ul>
<li><strong>char</strong> – 这是要被写入的字符。该字符以其对应的 int 值进行传递。</li>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符的流。</li>
</ul>
<h2 id="返回值-4">返回值</h2>
<p>该函数以无符号 char 强制转换为 int 的形式返回写入的字符，如果发生错误则返回 EOF。</p>
<h1>区别</h1>
<ul>
<li>fgetc（fputc）函数和getc （putc）函数两个的功和描述基本上是一模一样的，它们的区别主要在于实现上：fgetc（fputc）是一个函数；而getc （putc）则是一个宏的实现</li>
<li>一般来说宏产生较大的代码，但是避免了函数调用的堆栈操作，所以速度会比较快。</li>
<li>由于getc是由宏实现的，对其参数可能有不止一次的调用，所以不能使用带有副作用（side effects）的参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    FILE *fp1;</span><br><span class="line">    FILE *fp2;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp1 = fopen(<span class="string">&quot;D:\\c_study\\test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp2 = fopen(<span class="string">&quot;D:\\c_study\\demo2.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件夹失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((ch = fgetc((fp1))) != EOF)&#123;</span><br><span class="line">        fputc(ch, fp2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp1);</span><br><span class="line">    fclose(fp2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>读写整个字符串</h1>
<h1>fgets函数</h1>
<h2 id="描述-5">描述</h2>
<p>C 库函数 <strong>char *fgets(char *str, int n, FILE *stream)</strong> 从指定的流 stream 读取一行，并把它存储在 <strong>str</strong> 所指向的字符串内。当读取 <strong>(n-1)</strong> 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</p>
<h2 id="声明-5">声明</h2>
<p>下面是 fgets() 函数的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *fgets(char *str, int n, FILE *stream)</span><br></pre></td></tr></table></figure>
<h2 id="参数-5">参数</h2>
<ul>
<li><strong>str</strong> – 这是指向一个字符数组的指针，该数组存储了要读取的字符串。</li>
<li><strong>n</strong> – 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。</li>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。</li>
</ul>
<h2 id="返回值-5">返回值</h2>
<ol>
<li>如果成功，该函数返回相同的 str 参数。</li>
<li>如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。</li>
<li>如果发生错误，返回一个空指针。</li>
</ol>
<h1>fputs函数</h1>
<h2 id="描述-6">描述</h2>
<p>C 库函数 <strong>int fputs(const char *str, FILE *stream)</strong> 把字符串写入到指定的流 stream 中，但不包括空字符。</p>
<h2 id="声明-6">声明</h2>
<p>下面是 fputs() 函数的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fputs(const char *str, FILE *stream)</span><br></pre></td></tr></table></figure>
<h2 id="参数-6">参数</h2>
<ul>
<li><strong>str</strong> – 这是一个数组，包含了要写入的以空字符终止的字符序列。</li>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符串的流。</li>
</ul>
<h2 id="返回值-6">返回值</h2>
<p>该函数返回一个非负值，如果发生错误则返回 EOF。</p>
<h1>feof()函数</h1>
<h2 id="描述-7">描述</h2>
<p>C 库函数 <strong>int feof(FILE *stream)</strong> 测试给定流 stream 的文件结束标识符。</p>
<h2 id="声明-7">声明</h2>
<p>下面是 feof() 函数的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int feof(FILE *stream)</span><br></pre></td></tr></table></figure>
<h2 id="参数-7">参数</h2>
<ul>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li>
</ul>
<h2 id="返回值-7">返回值</h2>
<p>当设置了与流关联的文件结束标识符时，该函数返回一个非零值，否则返回零。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    FILE *fp1;</span><br><span class="line">    <span class="type">char</span> buff[MAX];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp1 = fopen(<span class="string">&quot;D:\\c_study\\demo3.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;Luenci 的文件操作1 。\n&quot;</span>, fp1);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;Luenci 的文件操作2 。\n&quot;</span>, fp1);</span><br><span class="line"></span><br><span class="line">    fclose(fp1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp1 = fopen(<span class="string">&quot;D:\\c_study\\demo3.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!feof(fp1))&#123;</span><br><span class="line">        fgets(buff, MAX, fp1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>格式化读写文件</h1>
<h1>fprintf（）函数</h1>
<h2 id="描述-8">描述</h2>
<p>C 库函数 <strong>int fprintf(FILE *stream, const char *format, …)</strong> 发送格式化输出到流 stream 中。</p>
<h2 id="声明-8">声明</h2>
<p>下面是 fprintf() 函数的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fprintf(FILE *stream, const char *format, ...)</span><br></pre></td></tr></table></figure>
<h2 id="参数-8">参数</h2>
<ul>
<li>
<p><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</p>
</li>
<li>
<p><strong>format</strong> – 这是 C 字符串，包含了要被写入到流 stream 中的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%[flags][width][.precision][length]specifier</span><br></pre></td></tr></table></figure>
<p>，具体讲解如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">specifier（说明符）</th>
<th style="text-align:left">输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">c</td>
<td style="text-align:left">字符</td>
</tr>
<tr>
<td style="text-align:left">d 或 i</td>
<td style="text-align:left">有符号十进制整数</td>
</tr>
<tr>
<td style="text-align:left">e</td>
<td style="text-align:left">使用 e 字符的科学科学记数法（尾数和指数）</td>
</tr>
<tr>
<td style="text-align:left">E</td>
<td style="text-align:left">使用 E 字符的科学科学记数法（尾数和指数）</td>
</tr>
<tr>
<td style="text-align:left">f</td>
<td style="text-align:left">十进制浮点数</td>
</tr>
<tr>
<td style="text-align:left">g</td>
<td style="text-align:left">自动选择 %e 或 %f 中合适的表示法</td>
</tr>
<tr>
<td style="text-align:left">G</td>
<td style="text-align:left">自动选择 %E 或 %f 中合适的表示法</td>
</tr>
<tr>
<td style="text-align:left">o</td>
<td style="text-align:left">有符号八进制</td>
</tr>
<tr>
<td style="text-align:left">s</td>
<td style="text-align:left">字符的字符串</td>
</tr>
<tr>
<td style="text-align:left">u</td>
<td style="text-align:left">无符号十进制整数</td>
</tr>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:left">无符号十六进制整数</td>
</tr>
<tr>
<td style="text-align:left">X</td>
<td style="text-align:left">无符号十六进制整数（大写字母）</td>
</tr>
<tr>
<td style="text-align:left">p</td>
<td style="text-align:left">指针地址</td>
</tr>
<tr>
<td style="text-align:left">n</td>
<td style="text-align:left">无输出</td>
</tr>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">字符</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">flags（标识）</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。</td>
</tr>
<tr>
<td style="text-align:left">(space)</td>
<td style="text-align:left">如果没有写入任何符号，则在该值前面插入一个空格。</td>
</tr>
<tr>
<td style="text-align:left">#</td>
<td style="text-align:left">与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。 与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">width（宽度）</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">(number)</td>
<td style="text-align:left">要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">.precision（精度）</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">.number</td>
<td style="text-align:left">对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。 对于 g 和 G 说明符：要输出的最大有效位数。 对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 对于 c 类型：没有任何影响。 当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。</td>
</tr>
<tr>
<td style="text-align:left">.*</td>
<td style="text-align:left">精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">length（长度）</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">h</td>
<td style="text-align:left">参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。</td>
</tr>
<tr>
<td style="text-align:left">l</td>
<td style="text-align:left">参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。</td>
</tr>
<tr>
<td style="text-align:left">L</td>
<td style="text-align:left">参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>附加参数</strong> – 根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。</li>
</ul>
<h2 id="返回值-8">返回值</h2>
<p>如果成功，则返回写入的字符总数，否则返回一个负数。</p>
<h1>fread()函数</h1>
<h2 id="描述-9">描述</h2>
<p>C 库函数 <strong>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</strong> 从给定流 <strong>stream</strong> 读取数据到 <strong>ptr</strong> 所指向的数组中。</p>
<h2 id="声明-9">声明</h2>
<p>下面是 fread() 函数的声明。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span><br></pre></td></tr></table></figure>
<h2 id="参数-9">参数</h2>
<ul>
<li><strong>ptr</strong> – 这是指向带有最小尺寸 <em>size*nmemb</em> 字节的内存块的指针。</li>
<li><strong>size</strong> – 这是要读取的每个元素的大小，以字节为单位。</li>
<li><strong>nmemb</strong> – 这是元素的个数，每个元素的大小为 size 字节。</li>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。</li>
</ul>
<h2 id="返回值-9">返回值</h2>
<p>成功读取的元素总数会以 size_t 对象返回，size_t 对象是一个整型数据类型。如果总数与 nmemb 参数不同，则可能发生了一个错误或者到达了文件末尾。</p>
<h1>fwrite（）函数</h1>
<h2 id="描述-10">描述</h2>
<p>C 库函数 <strong>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)</strong> 把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流 <strong>stream</strong> 中。</p>
<h2 id="声明-10">声明</h2>
<p>下面是 fwrite() 函数的声明。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span><br></pre></td></tr></table></figure>
<h2 id="参数-10">参数</h2>
<ul>
<li><strong>ptr</strong> – 这是指向要被写入的元素数组的指针。</li>
<li><strong>size</strong> – 这是要被写入的每个元素的大小，以字节为单位。</li>
<li><strong>nmemb</strong> – 这是元素的个数，每个元素的大小为 size 字节。</li>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。</li>
</ul>
<h2 id="返回值-10">返回值</h2>
<p>如果成功，该函数返回一个 size_t 对象，表示元素的总数，该对象是一个整型数据类型。如果该数字与 nmemb 参数不同，则会显示一个错误。</p>
<h1>文件随机读写</h1>
<h1>ftell（）函数</h1>
<h2 id="描述-11">描述</h2>
<p>C 库函数 <strong>long int ftell(FILE *stream)</strong> 返回给定流 stream 的当前文件位置。</p>
<h2 id="声明-11">声明</h2>
<p>下面是 ftell() 函数的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long int ftell(FILE *stream)</span><br></pre></td></tr></table></figure>
<h2 id="参数-11">参数</h2>
<ul>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li>
</ul>
<h2 id="返回值-11">返回值</h2>
<p>该函数返回位置标识符的当前值。如果发生错误，则返回 -1L，全局变量 errno 被设置为一个正值。</p>
<h1>rewind() 函数</h1>
<h2 id="描述-12">描述</h2>
<p>C 库函数 <strong>void rewind(FILE *stream)</strong> 设置文件位置为给定流 <strong>stream</strong> 的文件的开头。</p>
<h2 id="声明-12">声明</h2>
<p>下面是 rewind() 函数的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void rewind(FILE *stream)</span><br></pre></td></tr></table></figure>
<h2 id="参数-12">参数</h2>
<ul>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li>
</ul>
<h1>fseek() 函数</h1>
<h2 id="描述-13">描述</h2>
<p>C 库函数 <strong>int fseek(FILE *stream, long int offset, int whence)</strong> 设置流 <strong>stream</strong> 的文件位置为给定的偏移 <strong>offset</strong>，参数 offset 意味着从给定的 <strong>whence</strong> 位置查找的字节数。</p>
<h2 id="声明-13">声明</h2>
<p>下面是 fseek() 函数的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fseek(FILE *stream, long int offset, int whence)</span><br></pre></td></tr></table></figure>
<h2 id="参数-13">参数</h2>
<ul>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li>
<li><strong>offset</strong> – 这是相对 whence 的偏移量，以字节为单位。</li>
<li><strong>whence</strong> – 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">常量</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SEEK_SET</td>
<td style="text-align:left">文件的开头</td>
</tr>
<tr>
<td style="text-align:left">SEEK_CUR</td>
<td style="text-align:left">文件指针的当前位置</td>
</tr>
<tr>
<td style="text-align:left">SEEK_END</td>
<td style="text-align:left">文件的末尾</td>
</tr>
</tbody>
</table>
<h2 id="返回值-12">返回值</h2>
<p>如果成功，则该函数返回零，否则返回非零值。</p>
<h1>可移植性问题</h1>
<p>想要编写可移植的代码，就需要考虑以下问题：</p>
<ul>
<li>对于以二进制模式打开的文件，fseek函数在某些操作系统可能不支持SEEK_END位置。</li>
<li>一对于以文本模式打开的文件，fseek函数的whence参数只能取SEEK_SET才是有意义的，并且传递给offset参数的值要么是0，要么是上一次对同个文件调用fte11函数获得的返回值。</li>
</ul>
<h1>标准流和错误处理</h1>
<h2 id="文件流">文件流</h2>
<ul>
<li>标准输入（stdin）</li>
<li>标准输入（stdout）</li>
<li>标准错误输出（stderr）</li>
</ul>
<h2 id="重定向">重定向</h2>
<p>由于标准输出和标准错误输出通常都是直接打印到屏幕上，为了区分宅们，我们可以使用Linux shell的重定向功能：</p>
<ul>
<li>重定向标准输入使用 <strong>&lt;</strong></li>
<li>重定向标准输出使用 <strong>〉</strong></li>
<li>重定向标准错误输出使用 <strong>2〉</strong></li>
</ul>
<h2 id="错误处理">错误处理</h2>
<ul>
<li>
<p>错误指示器 - ferror（）</p>
<ul>
<li>
<h2 id="描述-14">描述</h2>
<p>C 库函数 <strong>int ferror(FILE *stream)</strong> 测试给定流 stream 的错误标识符。</p>
<h2 id="声明-14">声明</h2>
<p>下面是 ferror() 函数的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ferror(FILE *stream)</span><br></pre></td></tr></table></figure>
<h2 id="参数-14">参数</h2>
<ul>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li>
</ul>
<h2 id="返回值-13">返回值</h2>
<p>如果设置了与流关联的错误标识符，该函数返回一个非零值，否则返回一个零值。</p>
</li>
</ul>
</li>
<li>
<p>使用clearerr函数可以人为地清除文件末尾指示器和错误指示器的状态。</p>
</li>
<li>
<p>ferror函数只能检测是否出错，但无法获取错误原因。不过，大多数系统函数在出现错误的时候会将错误原因记录在errno中。</p>
</li>
<li>
<p>perror函数可以直观地打印出错误原因。</p>
<ul>
<li>
<h2 id="描述-15">描述</h2>
<p>C 库函数 <strong>void perror(const char *str)</strong> 把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 <strong>str</strong>，后跟一个冒号，然后是一个空格。</p>
<h2 id="声明-15">声明</h2>
<p>下面是 perror() 函数的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void perror(const char *str)</span><br></pre></td></tr></table></figure>
<h2 id="参数-15">参数</h2>
<ul>
<li><strong>str</strong> – 这是 C 字符串，包含了一个自定义消息，将显示在原本的错误消息之前。</li>
</ul>
<h2 id="返回值-14">返回值</h2>
<p>该函数不返回任何值</p>
</li>
</ul>
</li>
<li>
<p>strerror（）函数直接返回错误码对应的错误信息。</p>
<ul>
<li>
<h2 id="描述-16">描述</h2>
<p>C 库函数 <strong>char *strerror(int errnum)</strong> 从内部数组中搜索错误号 <strong>errnum</strong>，并返回一个指向错误消息字符串的指针。<strong>strerror</strong> 生成的错误字符串取决于开发平台和编译器。</p>
<h2 id="声明-16">声明</h2>
<p>下面是 strerror() 函数的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *strerror(int errnum)</span><br></pre></td></tr></table></figure>
<h2 id="参数-16">参数</h2>
<ul>
<li><strong>errnum</strong> – 错误号，通常是 <strong>errno</strong>。</li>
</ul>
<h2 id="返回值-15">返回值</h2>
<p>该函数返回一个指向错误字符串的指针，该错误字符串描述了错误 errnum。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fp = fopen(<span class="string">&quot;bucunzai.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出错啦，原因就是：%d\n&quot;</span>, errno);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;出错啦，原因就是：%s&quot;</span>, strerror(errno) );</span><br><span class="line">        perror(<span class="string">&quot;出错啦，原因就是：&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        fputs(&quot;打开文件失败！\n&quot;, stderr);</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>I/O 缓冲区</h1>
<p><img src="https://i.postimg.cc/kgqSns97/1571731846619.png" alt="I/O缓冲区"></p>
<h2 id="标准I-O提供的三种类型的缓冲模式">标准I/O提供的三种类型的缓冲模式</h2>
<ul>
<li>
<p>按块执行</p>
<ul>
<li>按块缓存也称为全缓存，即在填满缓冲区后才进行实际的设备读写操作；</li>
</ul>
</li>
<li>
<p>按行执行</p>
<ul>
<li>按行缓存是指在接收到换行符（‘\n’）之前，数据都是先缓存在缓冲区的；</li>
</ul>
</li>
<li>
<p>不缓存</p>
<ul>
<li>也就是允许你直接读写设备上的数据。</li>
</ul>
</li>
</ul>
<h1>setvbuf()函数</h1>
<h2 id="描述-17">描述</h2>
<p>C 库函数 <strong>int setvbuf(FILE *stream, char *buffer, int mode, size_t size)</strong> 定义流 stream 应如何缓冲。</p>
<h2 id="声明-17">声明</h2>
<p>下面是 setvbuf() 函数的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int setvbuf(FILE *stream, char *buffer, int mode, size_t size)</span><br></pre></td></tr></table></figure>
<h2 id="参数-17">参数</h2>
<ul>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流。</li>
<li><strong>buffer</strong> – 这是分配给用户的缓冲。如果设置为 NULL，该函数会自动分配一个指定大小的缓冲。</li>
<li><strong>mode</strong> – 这指定了文件缓冲的模式：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">_IOFBF</td>
<td style="text-align:left"><strong>全缓冲</strong>：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充。</td>
</tr>
<tr>
<td style="text-align:left">_IOLBF</td>
<td style="text-align:left"><strong>行缓冲</strong>：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符。</td>
</tr>
<tr>
<td style="text-align:left">_IONBF</td>
<td style="text-align:left"><strong>无缓冲</strong>：不使用缓冲。每个 I/O 操作都被即时写入。buffer 和 size 参数被忽略。</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>size</strong> --这是缓冲的大小，以字节为单位。</li>
</ul>
<h2 id="返回值-16">返回值</h2>
<p>如果成功，则该函数返回 0，否则返回非零值。</p>
<h1>fflush（）函数</h1>
<h2 id="描述-18">描述</h2>
<p>C 库函数 <strong>int fflush(FILE *stream)</strong> 刷新流 stream 的输出缓冲区。</p>
<h2 id="声明-18">声明</h2>
<p>下面是 fflush() 函数的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fflush(FILE *stream)</span><br></pre></td></tr></table></figure>
<h2 id="参数-18">参数</h2>
<ul>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个缓冲流。</li>
</ul>
<h2 id="返回值-17">返回值</h2>
<p>如果成功，该函数返回零值。如果发生错误，则返回 EOF，且设置错误标识符（即 feof）</p>
]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>django+nginx+uwsgi部署漫谈</title>
    <url>/2023/02/06/django+nginx+uwsgi%E9%83%A8%E7%BD%B2%E6%BC%AB%E8%B0%88/</url>
    <content><![CDATA[<blockquote>
<p>写在前面：关于Django的部署问题网上有很多教程，但是每个人的配置环境和遇到的情况都一样，所以在此记录下我部署过程中遇到的问题</p>
</blockquote>
<p>**看官方文档：**<a href="https://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html%EF%BC%88%E7%89%B9%E5%88%AB%E9%87%8D%E8%A6%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%89">https://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html（特别重要！！！）</a></p>
<h2 id="环境介绍">环境介绍</h2>
<ul>
<li>阿里云主机（<code>Ubuntu</code>系统）</li>
<li><code>virtualenv</code>虚拟环境
<ul>
<li>python3版本</li>
<li>Django 2.0.3 版本</li>
<li>uwsgi 2.0.19版本</li>
</ul>
</li>
<li>Nginx/1.10.3 (<code>Ubuntu</code>)</li>
</ul>
<h2 id="nginx目录介绍">nginx目录介绍</h2>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── [drwxr-xr-x]  conf.d</span><br><span class="line">├── [-rw-r--r--]  fastcgi.conf</span><br><span class="line">├── [-rw-r--r--]  fastcgi_params</span><br><span class="line">├── [-rw-r--r--]  koi-utf</span><br><span class="line">├── [-rw-r--r--]  koi-win</span><br><span class="line">├── [-rw-r--r--]  mime.types</span><br><span class="line">├── [-rw-r--r--]  nginx.conf</span><br><span class="line">├── [-rw-r--r--]  proxy_params</span><br><span class="line">├── [-rw-r--r--]  scgi_params</span><br><span class="line">├── [drwxr-xr-x]  sites-available</span><br><span class="line">│   └── [-rw-r--r--]  default</span><br><span class="line">├── [drwxr-xr-x]  sites-enabled</span><br><span class="line">│   └── [lrwxrwxrwx]  default -&gt; /etc/nginx/sites-available/default</span><br><span class="line">├── [drwxr-xr-x]  snippets</span><br><span class="line">│   ├── [-rw-r--r--]  fastcgi-php.conf</span><br><span class="line">│   └── [-rw-r--r--]  snakeoil.conf</span><br><span class="line">├── [-rw-r--r--]  uwsgi_params</span><br><span class="line">└── [-rw-r--r--]  win-utf</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">相关目录和文件作用</span><br><span class="line"></span><br><span class="line">client_body_temp  # Nginx所有配置文件的目录</span><br><span class="line">conf     #配置文件目录（.default 文件为对应的默认文件）</span><br><span class="line">fastcgi.conf    # fastcgi相关参数的配置文件</span><br><span class="line"></span><br><span class="line">fastcgi_params  # fastcgi的参数文件</span><br><span class="line"></span><br><span class="line">koi-utf        # 媒体类型</span><br><span class="line"></span><br><span class="line">koi-win       # 媒体类型</span><br><span class="line"></span><br><span class="line">mime.types #当 Web 服务器收到静态的资源文件请求时，依据请求文件的后缀名在服务器的 MIME 配置文件中找到对应的 MIME <span class="built_in">Type</span>，再根据 MIME <span class="built_in">Type</span> 设置 HTTP Response 的Content-<span class="built_in">Type</span>，然后浏览器根据 Content-<span class="built_in">Type</span> 的值处理文件</span><br><span class="line"></span><br><span class="line">nginx.conf   #Nginx主配置文件</span><br><span class="line"></span><br><span class="line">scgi_params  # scgi的配置文件</span><br><span class="line"></span><br><span class="line">uwsgi_params  # uwsgi 和 nginx的通信文件</span><br><span class="line"></span><br><span class="line">win-utf   #</span><br><span class="line"></span><br><span class="line">html     #默认解析的静态文件目录</span><br><span class="line"><span class="number">50</span>x.html     #错误页面优雅替代文件 </span><br><span class="line"></span><br><span class="line">index.html  #网站首页配置文件 </span><br><span class="line"></span><br><span class="line">logs     #日志目录</span><br><span class="line">access.log  #访问日志，包含所有访问记录</span><br><span class="line"></span><br><span class="line">error.log   #错误日志，包含访问出错的记录</span><br><span class="line"></span><br><span class="line">nginx.pid     Nginx运行的进程号，同ps -ef | grep nginx 第一行的进程号</span><br><span class="line"></span><br><span class="line">sbin #Nginx可执行文件目录</span><br><span class="line">nginx #Nginx 启动文件</span><br><span class="line"></span><br><span class="line">koi-utf、koi-win、win-utf 是与编码转换有关的配置文件</span><br><span class="line">其他带 temp 的为临时目录</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ASGI 是为了支持异步网络服务器和应用而新出现的Python 标准。</p>
</blockquote>
<!-- more --->
<h2 id="注意问题">注意问题</h2>
<ul>
<li>在阿里云上面部署的时候，需要注意nginx的配置</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># nginx的配置</span><br><span class="line"></span><br><span class="line">server_name 你的主机ip;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                # First attempt to serve request as file, then</span><br><span class="line">                # as directory, then fall back to displaying a <span class="number">404</span>.</span><br><span class="line">                #try_files $uri $uri/ =<span class="number">404</span>;</span><br><span class="line">                include  uwsgi_params;</span><br><span class="line">                        uwsgi_pass  你的主机ip:端口;</span><br><span class="line">        &#125;</span><br><span class="line">        location /static &#123;</span><br><span class="line">                 alias /home/myblog/static;</span><br><span class="line">&#125;</span><br><span class="line">        location /media &#123;</span><br><span class="line">                alias /home/myblog/media;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚拟环境的问题：</p>
<ul>
<li>
<p>在阿里云主机上如果直接用<code>virtualenv</code>创建虚拟环境会出现一些问题，因为系统默认的是<code>python2</code>的版本，需要指定版本</p>
<ul>
<li>
<pre><code class="language-python">virtualenv -p /usr/bin/python3 venv/
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="后记">后记</h2>
<ul>
<li>安装配置的过程是漫长痛苦的，尤其是找不到思路的时候。所以要静下心来，多读官方文档！！！多读官方文档！！！多读官方文档！！！仔细的检查配置，项目跑起来的那一刻是很激动开心的。</li>
</ul>
]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>Django部署</tag>
      </tags>
  </entry>
  <entry>
    <title>Django之编写URL</title>
    <url>/2023/02/06/django%E4%B9%8Burl%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h1>编写URL</h1>
<h2 id="编写规则">编写规则</h2>
<p>​	为了使其规范性，在每个新创建的App中设置独立的静态资源和模板文件夹并添加一个空白的<code>.py</code>文件，命为<code>urls.py</code>。如下是创建app中的文件结构：</p>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frist/</span><br><span class="line">  migrations/		<span class="comment"># 数据库前后是否有变化，生成出迁移文件</span></span><br><span class="line">    </span><br><span class="line">  static/			<span class="comment"># 创建App后存放App中的静态资源文件，自己手动添加</span></span><br><span class="line">    </span><br><span class="line">  templates/		<span class="comment"># 创建App后存放App中的模板文件，自己手动添加</span></span><br><span class="line">    </span><br><span class="line">  __init__.py</span><br><span class="line">  admin.py</span><br><span class="line">  apps.py</span><br><span class="line">  models.py</span><br><span class="line">  tests.py</span><br><span class="line">  urls.py			<span class="comment"># 创建App后由系统总路由映射到App的路由文件，自己手动添加</span></span><br><span class="line">  view.py</span><br></pre></td></tr></table></figure>
<h3 id="系统总路由和app的路由分发配置">系统总路由和app的路由分发配置</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根目录的urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,admin</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>,include(<span class="string">&#x27;frist.urls&#x27;</span>))      <span class="comment"># 引入app中的urls.py</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>代码详解:</p>
<ul>
<li><code>from django.contrib import admin</code>:导入Admin功能模块.</li>
<li><code>from django.urls import path,admin</code>:导入URL编写模块.</li>
<li><code>urlpatterns</code>:整个项目的URL集合,每个元素代表一条URL信息.</li>
<li><code>path('admin/', admin.site.urls)</code>:设定Admin的URL.<code>'admin/'</code>代表<code>127.0.0.1/admin</code>地址信息,<code>admin</code>后面的斜杠是路径分隔符;admin.site.urls是URL的处理函数,也称为视图函数.</li>
<li><code> path('',include('frist.urls'))	</code>:URL为空,代表网站的域名,即127.0.0.1,通常是网站的首页;include将该URL分发给app的urls.py处理.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app下的urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>,views.index)  <span class="comment"># 调用和url匹配的视图函数</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>当根目录的URL分发给app中的URL处理后,下一步就是根据所匹配的URL进行视图的调用.</p>
<p>在Views中编写相应的视图函数。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># index的views.py</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="comment"># creat you views here.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;hello world&quot;</span>)   </span><br></pre></td></tr></table></figure>
<p>视图函数的参数必须设置为<code>request</code>，该参数代表当前用户的请求对象，该对象包含用户名，请求内容和请求方式等信息，执行完成后必须使用<code>return</code>将处理结果返回。</p>
<h2 id="带变量的URL">带变量的URL</h2>
<p>​	在日常开发中，有时候一个URL可以代表多个不同的页面，如编写带有日期的URL，若根据前面的编写方式，按一年计算，则需要开发者编写365个不同的URL才能实现。这种做法是不可取的，因此，Django在编写URL时，可以对URL设置变量值，使URL具有多样性。</p>
<p>​	URL的变量类型有字符类型，整型，<code>slug</code>和<code>uuid</code>，常用的是字符类型和整型。说明如下：</p>
<ul>
<li>字符类型：匹配任何非空字符串，但不含斜杠。如果没有指定类型，默认使用该类型。</li>
<li>整形：匹配0和正整数</li>
<li>slug：可理解为注释，后缀或附属等概念，常作为URL的解释性字符。可匹配任何ASCII字符以及连接符和下画线，能使URL更加清晰易懂。比如网页的标题是“13岁的孩子”，其URL地址可以设置为“13-sui-de-hai-zi“。</li>
<li>uuid：匹配一个uuid格式的对象。为了防止冲突，规定必须使用破折号并且所有字母必须小写，例如0201203-3213-31e-321c34d435</li>
</ul>
<p>（未待完续）</p>
]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/02/06/django%E7%9A%84querySet%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>从数据库中查询出来的结果一般是一个集合，这个集合叫做 QuerySet。</p>
<h1>一、QuerySet何时被提交</h1>
<ul>
<li>在内部，创建、过滤、切片和传递一个QuerySet不会真实操作数据库，在你对查询集提交之前，不会发生任何实际的数据库操作。可以使用下列方法对QuerySet提交查询操作：</li>
</ul>
<h2 id="迭代">迭代</h2>
<ul>
<li>QuerySet是可迭代的，在首次迭代查询集时执行实际的数据库查询。 例如， 下面的语句会将数据库中所有Entry的headline打印出来：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> Entry.objects.<span class="built_in">all</span>():</span><br><span class="line">  <span class="built_in">print</span>(e.headline)</span><br></pre></td></tr></table></figure>
<ul>
<li>切片：如果使用切片的”step“参数，Django 将执行数据库查询并返回一个列表。</li>
</ul>
<h2 id="Pickling-缓存">Pickling/缓存</h2>
<ul>
<li>
<p>repr()</p>
</li>
<li>
<p>len()：当你对QuerySet调用len()时， 将提交数据库操作。</p>
</li>
<li>
<p>list()：对QuerySet调用list()将强制提交操作entry_list = list(Entry.objects.all())</p>
</li>
<li>
<p>bool()</p>
<ul>
<li>
<p>测试布尔值，像这样：</p>
</li>
<li>
<pre><code class="language-python">if Entry.objects.filter(headline=&quot;Test&quot;):
  print(&quot;There is at least one Entry with the headline Test&quot;)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">注：如果你需要知道是否存在至少一条记录（而不需要真实的对象），使用exists() 将更加高效。</span><br><span class="line"></span><br><span class="line"># 二、QuerySet</span><br><span class="line"></span><br><span class="line">下面是对于QuerySet的正式定义：</span><br><span class="line"></span><br><span class="line">- class QuerySet(model=None, query=None, using=None)[source]</span><br><span class="line"></span><br><span class="line">QuerySet类具有两个公有属性用于内省：</span><br><span class="line"></span><br><span class="line">- ordered：如果QuerySet是排好序的则为True，否则为False。</span><br><span class="line"></span><br><span class="line">- db：如果现在执行，则返回使用的数据库。</span><br><span class="line"></span><br><span class="line"># 三、返回新QuerySets的API</span><br><span class="line"></span><br><span class="line">- 以下的方法都将返回一个新的QuerySets。重点是加粗的几个API，其它的使用场景很少。</span><br><span class="line"></span><br><span class="line">## **方法名 解释**</span><br><span class="line"></span><br><span class="line">- filter() 过滤查询对象。</span><br><span class="line"></span><br><span class="line">- exclude() 排除满足条件的对象</span><br><span class="line">- annotate() 使用聚合函数</span><br><span class="line">- order_by() 对查询集进行排序</span><br><span class="line">- reverse() 反向排序</span><br><span class="line">- distinct() 对查询集去重</span><br><span class="line">- values() 返回包含对象具体值的字典的QuerySet</span><br><span class="line">- values_list() 与values()类似，只是返回的是元组而不是字典。</span><br><span class="line">- dates() 根据日期获取查询集</span><br><span class="line">- datetimes() 根据时间获取查询集</span><br><span class="line">- none() 创建空的查询集</span><br><span class="line">- all() 获取所有的对象</span><br><span class="line">- union() 并集</span><br><span class="line">- intersection() 交集</span><br><span class="line">- difference() 差集</span><br><span class="line">- select_related() 附带查询关联对象</span><br><span class="line">- prefetch_related()预先查询</span><br><span class="line">- extra() 附加SQL查询</span><br><span class="line">- defer() 不加载指定字段</span><br><span class="line">- only() 只加载指定的字段</span><br><span class="line">- using() 选择数据库</span><br><span class="line">- select_for_update()锁住选择的对象，直到事务结束。</span><br><span class="line">- raw() 接收一个原始的SQL查询</span><br><span class="line"></span><br><span class="line">### 1. filter()</span><br><span class="line"></span><br><span class="line">`filter(**kwargs)`</span><br><span class="line"></span><br><span class="line">- 返回满足查询参数的对象集合。</span><br><span class="line"></span><br><span class="line">- 查找的参数（**kwargs）应该满足下文字段查找中的格式。多个参数之间是和AND的关系。</span><br><span class="line"></span><br><span class="line">### 2. exclude()</span><br><span class="line"></span><br><span class="line">`exclude(**kwargs)`</span><br><span class="line"></span><br><span class="line">- 返回一个新的`QuerySet`，它包含`不满足给定的查找参数的对象`。</span><br><span class="line"></span><br><span class="line">- 查找的参数（**kwargs）应该满足下文字段查找中的格式。多个参数通过`AND连接`，然后所有的内容放入`NOT() `中。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"># 下面的示例排除所有pub_date晚于2005-1-3且headline为“Hello” 的记录：</span><br><span class="line"></span><br><span class="line">Entry.objects.exclude(pub_date__gt=[datetime.date](2005, 1, 3), headline=&#x27;Hello&#x27;)</span><br><span class="line"></span><br><span class="line"># 下面的示例排除所有pub_date晚于2005-1-3或者headline 为“Hello” 的记录：</span><br><span class="line"></span><br><span class="line">Entry.objects.exclude(pub_date__gt=[datetime.date](2005, 1, 3)).exclude(headline=&#x27;Hello&#x27;)</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="3-annotate">3. annotate()</h3>
<p><code>annotate(args, *kwargs)</code></p>
<ul>
<li>
<p>使用提供的聚合表达式查询对象。</p>
</li>
<li>
<p>表达式可以是简单的值、对模型（或任何关联模型）上的字段的引用或者聚合表达式（<code>平均值、总和等</code>）。</p>
</li>
<li>
<p>annotate()的每个参数都是一个annotation，它将添加到返回的QuerySet每个对象中。</p>
</li>
<li>
<p>关键字参数指定的Annotation将使用关键字作为Annotation 的别名。 匿名参数的别名将基于聚合函数的名称和模型的字段生成。 只有引用单个字段的聚合表达式才可以使用匿名参数。 其它所有形式都必须用关键字参数。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例如，如果正在操作一个Blog列表，你可能想知道每个Blog有多少Entry：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = Blog.objects.annotate(Count(<span class="string">&#x27;entry&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># The name of the first blog</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q[<span class="number">0</span>].name</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;Blogasaurus&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The number of entries on the first blog</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q[<span class="number">0</span>].entry__count</span><br><span class="line"><span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Blog模型本身没有定义entry__count属性，但是通过使用一个关键字参数来指定聚合函数，可以控制Annotation的名称：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = Blog.objects.annotate(number_of_entries=Count(<span class="string">&#x27;entry&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># The number of entries on the first blog, using the name provided</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q[<span class="number">0</span>].number_of_entries</span><br><span class="line"></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>
<h3 id="4-order-by">4. order_by()</h3>
<p><code>order_by(*fields)</code></p>
<ul>
<li>默认情况下，根据模型的Meta类中的ordering属性对QuerySet中的对象进行排序</li>
</ul>
<p><code>Entry.objects.filter(pub_date__year=2005).order_by('-pub_date', 'headline')</code></p>
<ul>
<li>
<p>上面的结果将按照pub_date降序排序，然后再按照headline升序排序。“-pub_date&quot;前面的负号表示降序顺序。 升序是默认的。 要随机排序，使用”?&quot;，如下所示：</p>
</li>
<li>
<p>Entry.objects.order_by(‘?’)</p>
</li>
</ul>
<blockquote>
<p>注：order_by(‘?’)可能耗费资源且很慢，这取决于使用的数据库。</p>
</blockquote>
<ul>
<li>
<p>若要按照另外一个模型中的字段排序，可以使用查询关联模型的语法。即通过字段的名称后面跟两个下划线（__），再加上新模型中的字段的名称，直到希望连接的模型。 像这样：</p>
</li>
<li>
<p>Entry.objects.order_by(‘blog__name’, ‘headline’)</p>
</li>
<li>
<p>如果排序的字段与另外一个模型关联，Django将使用关联的模型的默认排序，或者如果没有指定Meta.ordering将通过关联的模型的主键排序。 例如，因为Blog模型没有指定默认的排序：</p>
</li>
<li>
<p>Entry.objects.order_by(‘blog’)</p>
</li>
</ul>
<p>与以下相同：</p>
<p><code>Entry.objects.order_by('blog__id')</code></p>
<ul>
<li>
<p>如果Blog设置了ordering = [‘name’]，那么第一个QuerySet将等同于：</p>
</li>
<li>
<p>Entry.objects.order_by(‘blog__name’)</p>
</li>
<li>
<p>还可以通过调用表达式的<code>desc()</code>或者<code>asc()</code>方法：</p>
</li>
<li>
<p>Entry.objects.order_by(Coalesce(‘summary’, ‘headline’).desc())</p>
</li>
</ul>
<p>考虑下面的情况，指定一个多值字段来排序（例如，一个ManyToManyField 字段或者ForeignKey 字段的反向关联）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Event</span>(<span class="title class_ inherited__">Model</span>):</span><br><span class="line"></span><br><span class="line">parent = models.ForeignKey(</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;self&#x27;</span>,</span><br><span class="line"></span><br><span class="line">on_delete=models.CASCADE,</span><br><span class="line"></span><br><span class="line">related_name=<span class="string">&#x27;children&#x27;</span>,</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">date = models.DateField()</span><br><span class="line"></span><br><span class="line">Event.objects.order_by(<span class="string">&#x27;children__date&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>在这里，每个Event可能有多个排序数据；具有多个children的每个Event将被多次返回到order_by()创建的新的QuerySet中。 换句话说，用order_by()方法对QuerySet对象进行操作会返回一个扩大版的新QuerySet对象。因此，使用多值字段对结果进行排序时要格外小心。</p>
</li>
<li>
<p>没有方法指定排序是否考虑大小写。 对于大小写的敏感性，Django将根据数据库中的排序方式排序结果。</p>
</li>
<li>
<p>可以通过Lower将一个字段转换为小写来排序，它将达到大小写一致的排序：</p>
</li>
<li>
<p><code>Entry.objects.order_by(Lower('headline').desc())</code></p>
</li>
<li>
<p>可以通过检查QuerySet.ordered属性来知道查询是否是排序的。</p>
</li>
<li>
<p>每个<code>order_by()</code>都将清除前面的任何排序。 例如下面的查询将按照pub_date排序，而不是headline：</p>
</li>
<li>
<p><code>Entry.objects.order_by('headline').order_by('pub_date')</code></p>
</li>
</ul>
<h3 id="5-reverse">5. reverse()</h3>
<p><code>reverse()</code></p>
<ul>
<li>
<p>反向排序QuerySet中返回的元素。 第二次调用reverse()将恢复到原有的排序。</p>
</li>
<li>
<p>如要获取QuerySet中最后五个元素，可以这样做：</p>
</li>
<li>
<p>my_queryset.reverse()[:5]</p>
</li>
<li>
<p>这与Python直接使用负索引有点不一样。 <code>Django不支持负索引，只能曲线救国</code>。</p>
</li>
</ul>
<h3 id="6-distinct">6. distinct()</h3>
<p><code>distinct(*fields)</code></p>
<ul>
<li>
<p>去除查询结果中重复的行。</p>
</li>
<li>
<p>默认情况下，QuerySet不会去除重复的行。当查询跨越多张表的数据时，QuerySet可能得到重复的结果，这时候可以使用<code>distinct()</code>进行去重。</p>
</li>
</ul>
<h3 id="7-values">7. values()</h3>
<p><code>values(fields, *expressions)</code></p>
<ul>
<li>
<p>返回一个包含数据的字典的queryset，而不是模型实例。</p>
</li>
<li>
<p>每个字典表示一个对象，键对应于模型对象的属性名称。</p>
</li>
</ul>
<p>下面的例子将values() 与普通的模型对象进行比较：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列表中包含的是Blog对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.<span class="built_in">filter</span>(name__startswith=<span class="string">&#x27;Beatles&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&lt;Blog: Beatles Blog&gt;]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表中包含的是数据字典</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.<span class="built_in">filter</span>(name__startswith=<span class="string">&#x27;Beatles&#x27;</span>).values()</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Beatles Blog&#x27;</span>, <span class="string">&#x27;tagline&#x27;</span>: <span class="string">&#x27;All the latest Beatles news.&#x27;</span>&#125;]&gt;</span><br><span class="line"></span><br><span class="line">该方法接收可选的位置参数*fields，它指定values()应该限制哪些字段。如果指定字段，每个字典将只包含指定的字段的键/值。如果没有指定字段，每个字典将包含数据库表中所有字段的键和值。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.values()</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Beatles Blog&#x27;</span>, <span class="string">&#x27;tagline&#x27;</span>: <span class="string">&#x27;All the latest Beatles news.&#x27;</span>&#125;]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.values(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Beatles Blog&#x27;</span>&#125;]&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">values()方法还有关键字参数**expressions，这些参数将传递给annotate()：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models.functions <span class="keyword">import</span> Lower</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.values(lower_name=Lower(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">&#x27;lower_name&#x27;</span>: <span class="string">&#x27;beatles blog&#x27;</span>&#125;]&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在values()子句中的聚合应用于相同values()子句中的其他参数之前。 如果需要按另一个值分组，请将其添加到较早的values()子句中。 像这样：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.values(<span class="string">&#x27;author&#x27;</span>, entries=Count(<span class="string">&#x27;entry&#x27;</span>))</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">&#x27;author&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;entries&#x27;</span>: <span class="number">20</span>&#125;, &#123;<span class="string">&#x27;author&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;entries&#x27;</span>: <span class="number">13</span>&#125;]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.values(<span class="string">&#x27;author&#x27;</span>).annotate(entries=Count(<span class="string">&#x27;entry&#x27;</span>))</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">&#x27;author&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;entries&#x27;</span>: <span class="number">33</span>&#125;]&gt;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">如果你有一个字段foo是一个ForeignKey，默认的foo_id参数返回的字典中将有一个叫做foo 的键，因为这是保存实际值的那个隐藏的模型属性的名称。 当调用foo_id并传递字段的名称，传递foo 或values()都可以，得到的结果是相同的。像这样：</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values()</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">&#x27;blog_id&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;headline&#x27;</span>: <span class="string">&#x27;First Entry&#x27;</span>, ...&#125;, ...]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values(<span class="string">&#x27;blog&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">&#x27;blog&#x27;</span>: <span class="number">1</span>&#125;, ...]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values(<span class="string">&#x27;blog_id&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">&#x27;blog_id&#x27;</span>: <span class="number">1</span>&#125;, ...]&gt;</span><br><span class="line"></span><br><span class="line">当values()与distinct()一起使用时，注意排序可能影响最终的结果。</span><br><span class="line">如果values()子句位于extra()调用之后，extra()中的select参数定义的字段必须显式包含在values()调用中。 values( 调用后面的extra( 调用将忽略选择的额外的字段。在values()之后调用only()和defer()不太合理，所以将引发一个NotImplementedError。可以通过ManyToManyField、ForeignKey 和 OneToOneFiel 属性反向引用关联的模型的字段：</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.values(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;entry__headline&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;My blog&#x27;</span>, <span class="string">&#x27;entry__headline&#x27;</span>: <span class="string">&#x27;An entry&#x27;</span>&#125;,&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;My blog&#x27;</span>, <span class="string">&#x27;entry__headline&#x27;</span>: <span class="string">&#x27;Another entry&#x27;</span>&#125;, ...]&gt;</span><br></pre></td></tr></table></figure>
<h3 id="8-values-list">8. values_list()</h3>
<p><code>values_list(*fields, flat=False)</code></p>
<ul>
<li>与values()类似，只是在迭代时返回的是元组而不是字典。每个元组包含传递给values_list()调用的相应字段或表达式的值，因此第一个项目是第一个字段等。 像这样：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values_list(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;headline&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [(<span class="number">1</span>, <span class="string">&#x27;First entry&#x27;</span>), ...]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models.functions <span class="keyword">import</span> Lower</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values_list(<span class="string">&#x27;id&#x27;</span>, Lower(<span class="string">&#x27;headline&#x27;</span>))</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [(<span class="number">1</span>, <span class="string">&#x27;first entry&#x27;</span>), ...]&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果只传递一个字段，还可以传递<code>flat</code>参数。 如果为True，它表示返回的结果为单个值而不是元组。 如下所示：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values_list(<span class="string">&#x27;id&#x27;</span>).order_by(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet[(<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,), ...]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values_list(<span class="string">&#x27;id&#x27;</span>, flat=<span class="literal">True</span>).order_by(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...]&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>如果有多个字段，传递flat将发生错误。</p>
</li>
<li>
<p>如果不传递任何值给values_list()，它将返回模型中的所有字段，以在模型中定义的顺序。</p>
</li>
<li>
<p>常见的情况是获取某个模型实例的特定字段值。可以使用values_list()，然后调用get()：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values_list(<span class="string">&#x27;headline&#x27;</span>, flat=<span class="literal">True</span>).get(pk=<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;First entry&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>values()和values_list()都用于特定情况下的优化：检索数据子集，而无需创建模型实例。</li>
<li>注意通过ManyToManyField进行查询时的行为：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Author.objects.values_list(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;entry__headline&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [(<span class="string">&#x27;Noam Chomsky&#x27;</span>, <span class="string">&#x27;Impressions of Gaza&#x27;</span>),(<span class="string">&#x27;George Orwell&#x27;</span>, <span class="string">&#x27;Why Socialists Do Not Believe in Fun&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;George Orwell&#x27;</span>, <span class="string">&#x27;In Defence of English Cooking&#x27;</span>),(<span class="string">&#x27;Don Quixote&#x27;</span>, <span class="literal">None</span>)]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似地，当查询反向外键时，对于没有任何作者的条目，返回None。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values_list(<span class="string">&#x27;authors&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [(<span class="string">&#x27;Noam Chomsky&#x27;</span>,), (<span class="string">&#x27;George Orwell&#x27;</span>,), (<span class="literal">None</span>,)]&gt;</span><br></pre></td></tr></table></figure>
<h3 id="9-dates">9. dates()</h3>
<p><code>dates(field, kind, order='ASC')</code></p>
<ul>
<li>
<p>返回一个QuerySet，表示QuerySet内容中特定类型的所有可用日期的datetime.date对象列表。</p>
</li>
<li>
<p>field参数是模型的DateField的名称。 kind参数应为&quot;year&quot;，“month&quot;或&quot;day”。 结果列表中的每个datetime.date对象被截取为给定的类型。</p>
</li>
<li>
<p>“year” 返回对应该field的所有不同年份值的列表。</p>
</li>
<li>
<p>&quot;month&quot;返回字段的所有不同年/月值的列表。</p>
</li>
<li>
<p>&quot;day&quot;返回字段的所有不同年/月/日值的列表。</p>
</li>
<li>
<p>order参数默认为’ASC’，或者’DESC’。 它指定如何排序结果。</p>
</li>
</ul>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.dates(<span class="string">&#x27;pub_date&#x27;</span>, <span class="string">&#x27;year&#x27;</span>)</span><br><span class="line"></span><br><span class="line">[[datetime.date](<span class="number">2005</span>, <span class="number">1</span>, <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.dates(<span class="string">&#x27;pub_date&#x27;</span>, <span class="string">&#x27;month&#x27;</span>)</span><br><span class="line"></span><br><span class="line">[[datetime.date](<span class="number">2005</span>, <span class="number">3</span>, <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.dates(<span class="string">&#x27;pub_date&#x27;</span>, <span class="string">&#x27;day&#x27;</span>)</span><br><span class="line"></span><br><span class="line">[[datetime.date](<span class="number">2005</span>, <span class="number">3</span>, <span class="number">20</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.dates(<span class="string">&#x27;pub_date&#x27;</span>, <span class="string">&#x27;day&#x27;</span>, order=<span class="string">&#x27;DESC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">[[datetime.date](<span class="number">2005</span>, <span class="number">2</span>, <span class="number">20</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.<span class="built_in">filter</span>(headline__contains=<span class="string">&#x27;Lennon&#x27;</span>).dates(<span class="string">&#x27;pub_date&#x27;</span>, <span class="string">&#x27;day&#x27;</span>)</span><br><span class="line"></span><br><span class="line">[[datetime.date](<span class="number">2005</span>, <span class="number">3</span>, <span class="number">20</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="10-datetimes">10. datetimes()</h3>
<p><code>datetimes(field_name, kind, order='ASC', tzinfo=None)</code></p>
<ul>
<li>
<p>返回QuerySet，为datetime.datetime对象的列表，表示QuerySet内容中特定种类的所有可用日期。</p>
</li>
<li>
<p>field_name应为模型的DateTimeField的名称。</p>
</li>
<li>
<p>kind参数应为&quot;hour&quot;，“minute”，“month”，“year”，“second&quot;或&quot;day”。</p>
</li>
<li>
<p>结果列表中的每个datetime.datetime对象被截取到给定的类型。</p>
</li>
<li>
<p>order参数默认为’ASC’，或者’DESC’。 它指定如何排序结果。</p>
</li>
<li>
<p>tzinfo参数定义在截取之前将数据时间转换到的时区。</p>
</li>
</ul>
<h3 id="11-none">11. none()</h3>
<p><code>none()</code></p>
<ul>
<li>调用none()将创建一个不返回任何对象的查询集，并且在访问结果时不会执行任何查询。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">例子：</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.none()</span><br><span class="line"></span><br><span class="line">&lt;QuerySet []&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models.query <span class="keyword">import</span> EmptyQuerySet</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(Entry.objects.none(), EmptyQuerySet)</span><br><span class="line"></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="12-all">12. all()</h3>
<p><code>all()</code></p>
<ul>
<li>返回当前QuerySet（或QuerySet子类）的副本。通常用于获取全部QuerySet对象。</li>
</ul>
<h3 id="13-union">13. union()</h3>
<p><code>union(*other_qs, all=False)</code></p>
<ul>
<li>
<p>Django中的新功能1.11。也就是集合中并集的概念！</p>
</li>
<li>
<p>使用SQL的UNION运算符组合两个或更多个QuerySet的结果。例如：</p>
</li>
</ul>
<p><code>qs1.union(qs2, qs3)</code></p>
<ul>
<li>默认情况下，UNION操作符仅选择不同的值。 要允许重复值，请使用all=True参数。</li>
</ul>
<h3 id="14-intersection">14. intersection()</h3>
<ul>
<li>
<p>intersection(*other_qs)</p>
</li>
<li>
<p>Django中的新功能1.11。也就是集合中<code>交集</code>的概念！</p>
</li>
<li>
<p>使用SQL的INTERSECT运算符返回两个或更多个QuerySet的共有元素。例如：</p>
</li>
</ul>
<p><code>qs1.intersection(qs2, qs3)</code></p>
<h3 id="15-difference">15. difference()</h3>
<p><code>difference(*other_qs)</code></p>
<ul>
<li>
<p>Django中的新功能1.11。也就是集合中<code>差集</code>的概念！</p>
</li>
<li>
<p>使用SQL的EXCEPT运算符只保留QuerySet中的元素，但不保留其他QuerySet中的元素。例如：</p>
</li>
</ul>
<p><code>qs1.difference(qs2, qs3)</code></p>
<h3 id="16-select-related">16. select_related()</h3>
<p><code>select_related(*fields)</code></p>
<ul>
<li>
<p>沿着外键关系查询关联的对象的数据。这会生成一个复杂的查询并引起性能的损耗，但是在以后使用外键关系时将不需要再次数据库查询。</p>
</li>
<li>
<p>下面的例子解释了普通查询和select_related()查询的区别。 下面是一个标准的查询：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 访问数据库。</span></span><br><span class="line"></span><br><span class="line">e = Entry.objects.get(<span class="built_in">id</span>=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次访问数据库以得到关联的Blog对象。</span></span><br><span class="line"></span><br><span class="line">b = [e.blog]</span><br><span class="line"></span><br><span class="line">下面是一个select_related查询：</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问数据库。</span></span><br><span class="line"></span><br><span class="line">e = Entry.objects.select_related(<span class="string">&#x27;blog&#x27;</span>).get(<span class="built_in">id</span>=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不会访问数据库，因为e.blog已经在前面的查询中获得了。</span></span><br><span class="line"></span><br><span class="line">b = [e.blog]</span><br><span class="line"></span><br><span class="line">select_related()可用于objects任何的查询集：</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find all the blogs with entries scheduled to be published in the future.</span></span><br><span class="line"></span><br><span class="line">blogs = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> Entry.objects.<span class="built_in">filter</span>(pub_date__gt=[timezone.now]()).select_related(<span class="string">&#x27;blog&#x27;</span>):</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有select_related()，下面的语句将为每次循环迭代生成一个数据库查询,以获得每个entry关联的blog。</span></span><br><span class="line"></span><br><span class="line">blogs.add([e.blog])</span><br><span class="line"></span><br><span class="line"><span class="built_in">filter</span>()和select_related()的顺序不重要。 下面的查询集是等同的：</span><br><span class="line"></span><br><span class="line">Entry.objects.<span class="built_in">filter</span>(pub_date__gt=[timezone.now].select_related(<span class="string">&#x27;blog&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Entry.objects.select_related(<span class="string">&#x27;blog&#x27;</span>).<span class="built_in">filter</span>(pub_date__gt=[timezone.now]())</span><br></pre></td></tr></table></figure>
<p>可以沿着外键查询。 如果有以下模型：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">class City(models.Model):</span><br><span class="line">    # ...</span><br><span class="line">    pass</span><br><span class="line">class Person(models.Model):</span><br><span class="line">    # ...</span><br><span class="line">    hometown = models.ForeignKey(</span><br><span class="line">        City,</span><br><span class="line">        on_delete=models.SET_NULL,</span><br><span class="line">        blank=True,</span><br><span class="line">        null=True,</span><br><span class="line">    )</span><br><span class="line">class Book(models.Model):</span><br><span class="line">    # ...</span><br><span class="line">    author = models.ForeignKey(Person, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure>
<p>调用Book.objects.select_related(‘author__hometown’).get(id=4)将缓存相关的Person 和相关的City：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = Book.objects.select_related(<span class="string">&#x27;author__hometown&#x27;</span>).get(<span class="built_in">id</span>=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p = [b.author] <span class="comment"># Doesn&#x27;t hit the database.</span></span><br><span class="line"></span><br><span class="line">c = p.hometown <span class="comment"># Doesn&#x27;t hit the database.</span></span><br><span class="line"></span><br><span class="line">b = Book.objects.get(<span class="built_in">id</span>=<span class="number">4</span>) <span class="comment"># No select_related() in this example.</span></span><br><span class="line"></span><br><span class="line">p = [b.author] <span class="comment"># Hits the database.</span></span><br><span class="line"></span><br><span class="line">c = p.hometown <span class="comment"># Hits the database.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>在传递给select_related()的字段中，可以使用<code>任何ForeignKey</code>和<code>OneToOneField</code>。</p>
</li>
<li>
<p>在传递给select_related()的字段中，还可以反向引用OneToOneField。也就是说，可以回溯到定义OneToOneField 的字段。 此时，可以使用关联对象字段的related_name，而不要指定字段的名称。</p>
</li>
</ul>
<h3 id="17-prefetch-related">17. prefetch_related()</h3>
<p><code>prefetch_related(*lookups)</code></p>
<ul>
<li>
<p>在单个批处理中自动检索每个指定查找的相关对象。</p>
</li>
<li>
<p>与select_related类似，但是策略是完全不同的。</p>
</li>
</ul>
<p>假设有这些模型：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">class Topping(models.Model):</span><br><span class="line">    name = models.CharField(max_length=30)</span><br><span class="line">class Pizza(models.Model):</span><br><span class="line">    name = models.CharField(max_length=50)</span><br><span class="line">    toppings = models.ManyToManyField(Topping)</span><br><span class="line">    def __str__(self):              # __unicode__ on Python 2</span><br><span class="line">        return &quot;%s (%s)&quot; % (</span><br><span class="line">            self.name,</span><br><span class="line">            &quot;, &quot;.join(topping.name for topping in self.toppings.all()),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>并运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pizza.objects.<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line">[<span class="string">&quot;Hawaiian (ham, pineapple)&quot;</span>, <span class="string">&quot;Seafood (prawns, smoked salmon)&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>问题是每次QuerySet要求Pizza.objects.all()查询数据库，因此<code>self.toppings.all()</code>将在<code>Pizza Pizza.__str__()</code>中的每个项目的<code>Toppings</code>表上运行查询。</p>
</li>
<li>
<p>可以使用prefetch_related减少为只有两个查询：</p>
</li>
</ul>
<p><code>Pizza.objects.all().prefetch_related('toppings')</code></p>
<ul>
<li>
<p>这意味着现在每次<code>self.toppings.all()</code>被调用，不会再去数据库查找，而是在一个预取的QuerySet缓存中查找。</p>
</li>
<li>
<p>还可以使用正常连接语法来执行相关字段的相关字段。 假设在上面的例子中增加一个额外的模型：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Restaurant</span>(models.Model):</span><br><span class="line"></span><br><span class="line">  pizzas = models.ManyToManyField(Pizza, related_name=<span class="string">&#x27;restaurants&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  best_pizza = models.ForeignKey(Pizza, related_name=<span class="string">&#x27;championed_by&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>以下是合法的：</p>
<p><code>Restaurant.objects.prefetch_related('pizzas__toppings')</code></p>
<ul>
<li>这将预取所有属于餐厅的比萨饼，和所有属于那些比萨饼的配料。 这将导致总共3个查询 - 一个用于餐馆，一个用于比萨饼，一个用于配料。</li>
</ul>
<p><code> Restaurant.objects.prefetch_related('best_pizza__toppings')</code></p>
<ul>
<li>
<p>这将获取最好的比萨饼和每个餐厅最好的披萨的所有配料。 这将在3个表中查询 - 一个为餐厅，一个为“最佳比萨饼”，一个为配料。</p>
</li>
<li>
<p>当然，也可以使用best_pizza来获取select_related关系，以将查询数减少为2：</p>
</li>
</ul>
<p><code>Restaurant.objects.select_related('best_pizza').prefetch_related('best_pizza__toppings')</code></p>
<h3 id="18-extra">18. extra()</h3>
<p><code>extra(select=None, where=None, params=None, tables=None, order_by=None, select_params=None)</code></p>
<ul>
<li>有些情况下，Django的查询语法难以简单的表达复杂的WHERE子句，对于这种情况,可以在<code>extra()</code>生成的SQL从句中注入新子句。使用这种方法作为最后的手段，这是一个旧的API，在将来的某个时候可能被弃用。仅当无法使用其他查询方法表达查询时才使用它。</li>
</ul>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">qs.extra(</span><br><span class="line">  select=&#123;<span class="string">&#x27;val&#x27;</span>: <span class="string">&quot;select col from sometable where othercol = %s&quot;</span>&#125;,</span><br><span class="line">  select_params=(someparam,),</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>
<p>相当于：</p>
<p><code>qs.annotate(val=RawSQL(&quot;select col from sometable where othercol = %s&quot;, (someparam,)))</code></p>
<h3 id="19-defer">19. defer()</h3>
<p><code>defer(*fields)</code></p>
<ul>
<li>
<p>在一些复杂的数据建模情况下，模型可能包含大量字段，其中一些可能包含大尺寸数据（例如文本字段），将它们转换为Python对象需要花费很大的代价。</p>
</li>
<li>
<p>当最初获取数据时不知道是否需要这些特定字段的情况下，如果正在使用查询集的结果，可以告诉Django不要从数据库中检索它们。</p>
</li>
<li>
<p>通过传递字段名称到defer()实现不加载：</p>
</li>
</ul>
<p><code>Entry.objects.defer(&quot;headline&quot;, &quot;body&quot;)</code></p>
<ul>
<li>
<p>具有延迟加载字段的查询集仍将返回模型实例。</p>
</li>
<li>
<p>每个延迟字段将在你访问该字段时从数据库中检索（每次只检索一个，而不是一次检索所有的延迟字段）。</p>
</li>
<li>
<p>可以多次调用defer()。 每个调用都向延迟集添加新字段：</p>
</li>
</ul>
<h4 id="延迟body和headline两个字段。">延迟body和headline两个字段。</h4>
<p><code>Entry.objects.defer(&quot;body&quot;).filter(rating=5).defer(&quot;headline&quot;)</code></p>
<ul>
<li>
<p>字段添加到延迟集的顺序无关紧要。对已经延迟的字段名称再次defer()没有问题（该字段仍将被延迟）。</p>
</li>
<li>
<p>可以使用标准的双下划线符号来分隔关联的字段，从而加载关联模型中的字段：</p>
</li>
</ul>
<p><code>Blog.objects.select_related().defer(&quot;entry__headline&quot;, &quot;entry__body&quot;)</code></p>
<ul>
<li>如果要清除延迟字段集，将None作为参数传递到defer()：</li>
</ul>
<h4 id="立即加载所有的字段。">立即加载所有的字段。</h4>
<ul>
<li>
<p>my_queryset.defer(None)</p>
</li>
<li>
<p>defer()方法（及其兄弟，only()）仅适用于高级用例，它们提供了数据加载的优化方法。</p>
</li>
</ul>
<h3 id="20-only">20. only()</h3>
<p><code>only(*fields)</code></p>
<ul>
<li>
<p>only()方法与defer()相反。</p>
</li>
<li>
<p>如果有一个模型几乎所有的字段需要延迟，使用only()指定补充的字段集可以使代码更简单。</p>
</li>
<li>
<p>假设有一个包含字段biography、age和name的模型。 以下两个查询集是相同的，就延迟字段而言：</p>
<ul>
<li>Person.objects.defer(“age”, “biography”)</li>
<li>Person.objects.only(“name”)</li>
</ul>
</li>
</ul>
<p>每当你调用only()时，它将替换立即加载的字段集。因此，对only()的连续调用的结果是只有最后一次调用的字段被考虑：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This will defer all fields except the headline.</span></span><br><span class="line"></span><br><span class="line">Entry.objects.only(<span class="string">&quot;body&quot;</span>, <span class="string">&quot;rating&quot;</span>).only(<span class="string">&quot;headline&quot;</span>)</span><br><span class="line"></span><br><span class="line">由于defer()以递增方式动作（向延迟列表中添加字段），因此你可以结合only()和defer()调用：</span><br><span class="line"></span><br><span class="line"><span class="comment"># Final result is that everything except &quot;headline&quot; is deferred.</span></span><br><span class="line"></span><br><span class="line">Entry.objects.only(<span class="string">&quot;headline&quot;</span>, <span class="string">&quot;body&quot;</span>).defer(<span class="string">&quot;body&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Final result loads headline and body immediately (only() replaces any</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># existing set of fields).</span></span><br><span class="line"></span><br><span class="line">Entry.objects.defer(<span class="string">&quot;body&quot;</span>).only(<span class="string">&quot;headline&quot;</span>, <span class="string">&quot;body&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>当对具有延迟字段的实例调用save()时，仅保存加载的字段。</p>
<h3 id="21-using">21. using()</h3>
<p><code>using(alias)</code></p>
<ul>
<li>如果正在使用多个数据库，这个方法用于指定在哪个数据库上查询QuerySet。方法的唯一参数是数据库的别名，定义在DATABASES。</li>
</ul>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># queries the database with the &#x27;default&#x27; alias.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># queries the database with the &#x27;backup&#x27; alias</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.using(<span class="string">&#x27;backup&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="22-select-for-update">22. select_for_update()</h3>
<p><code>select_for_update(nowait=False, skip_locked=False)</code></p>
<ul>
<li>返回一个锁住行直到事务结束的查询集，如果数据库支持，它将生成一个SELECT … FOR UPDATE语句。</li>
</ul>
<p>例如：</p>
<p><code>entries = Entry.objects.select_for_update().filter(author=request.user)</code></p>
<ul>
<li>
<p>所有匹配的行将被锁定，直到事务结束。这意味着可以通过锁防止数据被其它事务修改。</p>
</li>
<li>
<p>一般情况下如果其他事务锁定了相关行，那么本查询将被阻塞，直到锁被释放。使用select_for_update(nowait=True)将使查询不阻塞。如果其它事务持有冲突的锁,那么查询将引发DatabaseError异常。也可以使用select_for_update(skip_locked=True)忽略锁定的行。nowait和skip_locked是互斥的。</p>
</li>
<li>
<p>目前，postgresql，oracle和mysql数据库后端支持select_for_update()。但是，MySQL不支持nowait和skip_locked参数。</p>
</li>
</ul>
<h3 id="23-raw">23. raw()</h3>
<p>raw(raw_query, params=None, translations=None)</p>
<p>接收一个原始的SQL查询，执行它并返回一个django.db.models.query.RawQuerySet实例。</p>
<p>这个RawQuerySet实例可以迭代，就像普通的QuerySet一样。</p>
<h1>四、不返回QuerySets的API</h1>
<ul>
<li>以下的方法不会返回QuerySets，但是作用非常强大，尤其是粗体显示的方法，需要背下来。</li>
</ul>
<h2 id="方法名-解释"><strong>方法名 解释</strong></h2>
<p>get() 获取单个对象</p>
<p>create() 创建对象，无需save()</p>
<p>get_or_create() 查询对象，如果没有找到就新建对象</p>
<p>update_or_create() 更新对象，如果没有找到就创建对象</p>
<p>bulk_create()</p>
<p>批量创建对象</p>
<p>count() 统计对象的个数</p>
<p>in_bulk()</p>
<p>根据主键值的列表，批量返回对象</p>
<p>iterator()</p>
<p>获取包含对象的迭代器</p>
<p>latest() 获取最近的对象</p>
<p>earliest() 获取最早的对象</p>
<p>first() 获取第一个对象</p>
<p>last() 获取最后一个对象</p>
<p>aggregate() 聚合操作</p>
<p>exists() 判断queryset中是否有对象</p>
<p>update() 批量更新对象</p>
<p>delete() 批量删除对象</p>
<p>as_manager() 获取管理器</p>
<h3 id="1-get">1. get()</h3>
<p><code>get(**kwargs)</code></p>
<ul>
<li>
<p>返回按照查询参数匹配到的单个对象，参数的格式应该符合Field lookups的要求。</p>
</li>
<li>
<p>如果匹配到的对象个数不只一个的话，触发MultipleObjectsReturned异常</p>
</li>
<li>
<p>如果根据给出的参数匹配不到对象的话，触发DoesNotExist异常。例如：</p>
</li>
</ul>
<p><code>Entry.objects.get(id='foo') # raises Entry.DoesNotExist</code></p>
<ul>
<li>DoesNotExist异常从django.core.exceptions.ObjectDoesNotExist继承，可以定位多个DoesNotExist异常。 例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> ObjectDoesNotExist</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  e = Entry.objects.get(<span class="built_in">id</span>=<span class="number">3</span>)</span><br><span class="line">  b = Blog.objects.get(<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> ObjectDoesNotExist:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Either the entry or blog doesn&#x27;t exist.&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果希望查询器只返回一行，则可以使用get()而不使用任何参数来返回该行的对象：</li>
</ul>
<p><code>entry = Entry.objects.filter(...).exclude(...).get()</code></p>
<h3 id="2-create">2. create()</h3>
<p><code>create(**kwargs)</code></p>
<ul>
<li>在一步操作中<code>同时创建</code>并且<code>保存对象</code>的便捷方法.</li>
</ul>
<p><code>p = Person.objects.create(first_name=&quot;Bruce&quot;, last_name=&quot;Springsteen&quot;)</code></p>
<p>等于:</p>
<p><code>p = Person(first_name=&quot;Bruce&quot;, last_name=&quot;Springsteen&quot;)</code></p>
<p><code>p.save(force_insert=True)</code></p>
<ul>
<li>参数force_insert表示强制创建对象。如果model中有一个你手动设置的主键，并且这个值已经存在于数据库中, 调用create()将会失败并且触发IntegrityError因为主键必须是唯一的。如果你手动设置了主键，做好异常处理的准备。</li>
</ul>
<h3 id="3-get-or-create">3. get_or_create()</h3>
<p><code>get_or_create(defaults=None, **kwargs)</code></p>
<ul>
<li>
<p>通过kwargs来查询对象的便捷方法（如果模型中的所有字段都有默认值，可以为空），如果该对象不存在则创建一个新对象。</p>
</li>
<li>
<p>该方法返回一个由(object, created)组成的元组，元组中的object 是一个查询到的或者是被创建的对象， created是一个表示是否创建了新的对象的布尔值。</p>
</li>
</ul>
<p>对于下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">  obj = Person.objects.get(first_name=<span class="string">&#x27;John&#x27;</span>, last_name=<span class="string">&#x27;Lennon&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Person.DoesNotExist:</span><br><span class="line"></span><br><span class="line">  obj = Person(first_name=<span class="string">&#x27;John&#x27;</span>, last_name=<span class="string">&#x27;Lennon&#x27;</span>, birthday=date(<span class="number">1940</span>, <span class="number">10</span>, <span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">  obj.save()</span><br></pre></td></tr></table></figure>
<p>如果模型的字段数量较大的话，这种模式就变的非常不易用了。 上面的示例可以用get_or_create()重写 :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj, created = Person.objects.get_or_create(</span><br><span class="line">  first_name=<span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  last_name=<span class="string">&#x27;Lennon&#x27;</span>,</span><br><span class="line">  defaults=&#123;<span class="string">&#x27;birthday&#x27;</span>: date(<span class="number">1940</span>, <span class="number">10</span>, <span class="number">9</span>)&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>任何传递给get_or_create()的关键字参数，除了一个可选的defaults，都将传递给get()调用。 如果查找到一个对象，返回一个包含匹配到的对象以及False 组成的元组。 如果查找到的对象超过一个以上，将引发MultipleObjectsReturned。如果查找不到对象，get_or_create()将会实例化并保存一个新的对象，返回一个由新的对象以及True组成的元组。新的对象将会按照以下的逻辑创建:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items() <span class="keyword">if</span> <span class="string">&#x27;__&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> k&#125;</span><br><span class="line"></span><br><span class="line">params.update(&#123;k: v() <span class="keyword">if</span> <span class="built_in">callable</span>(v) <span class="keyword">else</span> v <span class="keyword">for</span> k, v <span class="keyword">in</span> defaults.items()&#125;)</span><br><span class="line"></span><br><span class="line">obj = self.model(**params)</span><br><span class="line"></span><br><span class="line">obj.save()</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>它表示从非’defaults’ 且不包含双下划线的关键字参数开始。然后将defaults的内容添加进来，覆盖必要的键，并使用结果作为关键字参数传递给模型类。</p>
</li>
<li>
<p>如果有一个名为defaults__exact的字段，并且想在get_or_create()时用它作为精确查询，只需要使用defaults，像这样：</p>
</li>
</ul>
<p><code>Foo.objects.get_or_create(defaults__exact='bar', defaults=&#123;'defaults': 'baz'&#125;)</code></p>
<ul>
<li>
<p>当你使用手动指定的主键时，get_or_create()方法与create()方法有相似的错误行为 。 如果需要创建一个对象而该对象的主键早已存在于数据库中，IntegrityError异常将会被触发。</p>
</li>
<li>
<p>这个方法假设进行的是原子操作，并且正确地配置了数据库和正确的底层数据库行为。如果数据库级别没有对get_or_create中用到的kwargs强制要求唯一性（unique和unique_together），方法容易导致竞态条件，可能会有相同参数的多行同时插入。（简单理解，kwargs必须指定的是主键或者unique属性的字段才安全。）</p>
</li>
<li>
<p>最后建议只在Django视图的POST请求中使用get_or_create()，因为这是一个具有修改性质的动作，不应该使用在GET请求中，那样不安全。</p>
</li>
<li>
<p>可以通过ManyToManyField属性和反向关联使用get_or_create()。在这种情况下，应该限制查询在关联的上下文内部。 否则，可能导致完整性问题。</p>
</li>
</ul>
<p>例如下面的模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chapter</span>(models.Model):</span><br><span class="line"></span><br><span class="line">  title = models.CharField(max_length=<span class="number">255</span>, unique=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Book</span>(models.Model):</span><br><span class="line"></span><br><span class="line">  title = models.CharField(max_length=<span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">  chapters = models.ManyToManyField(Chapter)</span><br></pre></td></tr></table></figure>
<p>可以通过Book的chapters字段使用get_or_create()，但是它只会获取该Book内部的上下文：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>book = Book.objects.create(title=<span class="string">&quot;Ulysses&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>book.chapters.get_or_create(title=<span class="string">&quot;Telemachus&quot;</span>)</span><br><span class="line"></span><br><span class="line">(&lt;Chapter: Telemachus&gt;, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>book.chapters.get_or_create(title=<span class="string">&quot;Telemachus&quot;</span>)</span><br><span class="line"></span><br><span class="line">(&lt;Chapter: Telemachus&gt;, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Chapter.objects.create(title=<span class="string">&quot;Chapter 1&quot;</span>)</span><br><span class="line"></span><br><span class="line">&lt;Chapter: Chapter <span class="number">1</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>book.chapters.get_or_create(title=<span class="string">&quot;Chapter 1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Raises IntegrityError</span></span><br></pre></td></tr></table></figure>
<ul>
<li>发生这个错误是因为尝试通过Book “Ulysses”获取或者创建“Chapter 1”，但是它不能，因为它与这个book不关联，但因为title 字段是唯一的它仍然不能创建。</li>
</ul>
<p>在Django1.11在defaults中增加了对可调用值的支持。</p>
<h3 id="4-update-or-create">4. update_or_create()</h3>
<p><code>update_or_create(defaults=None, **kwargs)</code></p>
<p>类似前面的get_or_create()。</p>
<ul>
<li>
<p>通过给出的kwargs来更新对象的便捷方法， 如果没找到对象，则创建一个新的对象。defaults是一个由 (field, value)对组成的字典，用于更新对象。defaults中的值可以是可调用对象（也就是说函数等）。</p>
</li>
<li>
<p>该方法返回一个由(object, created)组成的元组,元组中的object是一个创建的或者是被更新的对象， created是一个标示是否创建了新的对象的布尔值。</p>
</li>
<li>
<p>update_or_create方法尝试通过给出的kwargs 去从数据库中获取匹配的对象。 如果找到匹配的对象，它将会依据defaults 字典给出的值更新字段。</p>
</li>
</ul>
<p>像下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">defaults = &#123;<span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">  obj = Person.objects.get(first_name=<span class="string">&#x27;John&#x27;</span>, last_name=<span class="string">&#x27;Lennon&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> key, value <span class="keyword">in</span> defaults.items():</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setattr</span>(obj, key, value)</span><br><span class="line"></span><br><span class="line">  obj.save()</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Person.DoesNotExist:</span><br><span class="line"></span><br><span class="line">  new_values = &#123;<span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Lennon&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">  new_values.update(defaults)</span><br><span class="line"></span><br><span class="line">  obj = Person(**new_values)</span><br><span class="line"></span><br><span class="line">  obj.save()</span><br></pre></td></tr></table></figure>
<p>如果模型的字段数量较大的话，这种模式就变的非常不易用了。 上面的示例可以用update_or_create() 重写:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj, created = Person.objects.update_or_create(</span><br><span class="line"></span><br><span class="line">first_name=<span class="string">&#x27;John&#x27;</span>, last_name=<span class="string">&#x27;Lennon&#x27;</span>,</span><br><span class="line"></span><br><span class="line">defaults=&#123;<span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>&#125;,</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>kwargs中的名称如何解析的详细描述可以参见get_or_create()。</p>
</li>
<li>
<p>和get_or_create()一样，这个方法也容易导致竞态条件，如果数据库层级没有前置唯一性会让多行同时插入。</p>
</li>
</ul>
<p>在Django1.11在defaults中增加了对可调用值的支持。</p>
<h3 id="5-bulk-create">5. bulk_create()</h3>
<p><code>bulk_create(objs, batch_size=None)</code></p>
<ul>
<li>以高效的方式（通常只有1个查询，无论有多少对象）将提供的对象列表插入到数据库中：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.bulk_create([</span><br><span class="line"></span><br><span class="line"><span class="meta">... </span>Entry(headline=<span class="string">&#x27;This is a test&#x27;</span>),</span><br><span class="line"></span><br><span class="line"><span class="meta">... </span>Entry(headline=<span class="string">&#x27;This is only a test&#x27;</span>),</span><br><span class="line"></span><br><span class="line"><span class="meta">... </span>])</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>
<p>不会调用模型的save()方法，并且不会发送pre_save和post_save信号。</p>
</li>
<li>
<p>不适用于多表继承场景中的子模型。</p>
</li>
<li>
<p>如果模型的主键是AutoField，则不会像save()那样检索并设置主键属性，除非数据库后端支持。</p>
</li>
<li>
<p>不适用于多对多关系。</p>
</li>
<li>
<p>batch_size参数控制在单个查询中创建的对象数。</p>
</li>
</ul>
<h3 id="6-count">6. count()</h3>
<p><code>count()</code></p>
<ul>
<li>返回在数据库中对应的QuerySet对象的个数。count()永远不会引发异常。</li>
</ul>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回总个数.</span></span><br><span class="line"></span><br><span class="line">Entry.objects.count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回包含有&#x27;Lennon&#x27;的对象的总数</span></span><br><span class="line"></span><br><span class="line">Entry.objects.<span class="built_in">filter</span>(headline__contains=<span class="string">&#x27;Lennon&#x27;</span>).count()</span><br></pre></td></tr></table></figure>
<h3 id="7-in-bulk">7. in_bulk()</h3>
<p><code>in_bulk(id_list=None)</code></p>
<ul>
<li>获取主键值的列表，并返回将每个主键值映射到具有给定ID的对象的实例的字典。 如果未提供列表，则会返回查询集中的所有对象。</li>
</ul>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.in_bulk([<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">&#123;<span class="number">1</span>: &lt;Blog: Beatles Blog&gt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.in_bulk([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">&#123;<span class="number">1</span>: &lt;Blog: Beatles Blog&gt;, <span class="number">2</span>: &lt;Blog: Cheddar Talk&gt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.in_bulk([])</span><br><span class="line"></span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.in_bulk()</span><br><span class="line"></span><br><span class="line">&#123;<span class="number">1</span>: &lt;Blog: Beatles Blog&gt;, <span class="number">2</span>: &lt;Blog: Cheddar Talk&gt;, <span class="number">3</span>: &lt;Blog: Django Weblog&gt;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>如果向in_bulk()传递一个空列表，会得到一个空的字典。</p>
</li>
<li>
<p>在旧版本中，id_list是必需的参数，现在是一个可选参数。</p>
</li>
</ul>
<h3 id="8-iterator">8. iterator()</h3>
<p><code>iterator()</code></p>
<ul>
<li>
<p>提交数据库操作，获取QuerySet，并返回一个迭代器。</p>
</li>
<li>
<p>QuerySet通常会在内部缓存其结果，以便在重复计算时不会导致额外的查询。而iterator()将直接读取结果，不在QuerySet级别执行任何缓存。对于返回大量只需要访问一次的对象的QuerySet，这可以带来更好的性能，显著减少内存使用。</p>
</li>
</ul>
<blockquote>
<p>请注意，在已经提交了的iterator()上使用QuerySet会强制它再次提交数据库操作，进行重复查询。此外，使用iterator()会导致先前的prefetch_related()调用被忽略，因为这两个一起优化没有意义。</p>
</blockquote>
<h3 id="9-latest">9. latest()</h3>
<p><code>latest(field_name=None)</code></p>
<ul>
<li>
<p>使用日期字段field_name，按日期返回最新对象。</p>
</li>
<li>
<p>下例根据Entry的’pub_date’字段返回最新发布的entry：</p>
<p><code>Entry.objects.latest('pub_date')</code></p>
</li>
<li>
<p>如果模型的Meta指定了get_latest_by，则可以将latest()参数留给earliest()或者field_name。 默认情况下，Django将使用get_latest_by中指定的字段。</p>
</li>
<li>
<p>earliest()和latest()可能会返回空日期的实例,可能需要过滤掉空值：</p>
</li>
</ul>
<p><code>Entry.objects.filter(pub_date__isnull=False).latest('pub_date')</code></p>
<h3 id="10-earliest">10. earliest()</h3>
<p>earliest(field_name=None)</p>
<p>类同latest()。</p>
<h3 id="11-first">11. first()</h3>
<p><code>first()</code></p>
<ul>
<li>返回结果集的第一个对象, 当没有找到时返回None。如果QuerySet没有设置排序,则将会自动按主键进行排序。例如：</li>
</ul>
<p><code>p = Article.objects.order_by('title', 'pub_date').first()</code></p>
<ul>
<li>first()是一个简便方法，下面的例子和上面的代码效果是一样：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  p = Article.objects.order_by(<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;pub_date&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">  p = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="12-last">12. last()</h3>
<p><code>last()</code></p>
<p>工作方式类似first()，只是返回的是查询集中最后一个对象。</p>
<h3 id="13-aggregate">13. aggregate()</h3>
<p><code>aggregate(args, *kwargs)</code></p>
<ul>
<li>
<p>返回汇总值的字典（平均值，总和等）,通过QuerySet进行计算。每个参数指定返回的字典中将要包含的值。</p>
</li>
<li>
<p>使用关键字参数指定的聚合将使用关键字参数的名称作为Annotation 的名称。 匿名参数的名称将基于聚合函数的名称和模型字段生成。 复杂的聚合不可以使用匿名参数，必须指定一个关键字参数作为别名。</p>
</li>
</ul>
<p>例如，想知道Blog Entry 的数目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count</span><br><span class="line"></span><br><span class="line">q = Blog.objects.aggregate(Count(<span class="string">&#x27;entry&#x27;</span>))</span><br><span class="line">&#123;<span class="string">&#x27;entry__count&#x27;</span>: <span class="number">16</span>&#125;</span><br></pre></td></tr></table></figure>
<p>通过使用关键字参数来指定聚合函数，可以控制返回的聚合的值的名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">q = Blog.objects.aggregate(number_of_entries=Count(<span class="string">&#x27;entry&#x27;</span>))</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&#x27;number_of_entries&#x27;</span>: <span class="number">16</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-exists">14. exists()</h3>
<p>exists()</p>
<ul>
<li>
<p>如果QuerySet包含任何结果，则返回True，否则返回False。</p>
</li>
<li>
<p>查找具有唯一性字段（例如primary_key）的模型是否在一个QuerySet中的最高效的方法是：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">entry = Entry.objects.get(pk=<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> some_queryset.<span class="built_in">filter</span>(pk=entry.pk).exists():</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Entry contained in queryset&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>它将比下面的方法快很多，这个方法要求对QuerySet求值并迭代整个QuerySet：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> entry <span class="keyword">in</span> some_queryset:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Entry contained in QuerySet&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>若要查找一个QuerySet是否包含任何元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> some_queryset.exists():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;There is at least one object in some_queryset&quot;</span>)</span><br><span class="line">将快于：</span><br><span class="line"><span class="keyword">if</span> some_queryset:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;There is at least one object in some_queryset&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="15-update">15. update()</h3>
<p><code>update(**kwargs)</code></p>
<ul>
<li>
<p>对指定的字段执行批量更新操作，并返回匹配的行数（如果某些行已具有新值，则可能不等于已更新的行数）。</p>
</li>
<li>
<p>例如，要对2010年发布的所有博客条目启用评论，可以执行以下操作：</p>
</li>
</ul>
<p><code>Entry.objects.filter(pub_date__year=2010).update(comments_on=False)</code></p>
<ul>
<li>可以同时更新多个字段 （没有多少字段的限制）。 例如同时更新comments_on和headline字段：</li>
</ul>
<p><code>Entry.objects.filter(pub_date__year=2010).update(comments_on=False, headline='This is old')</code></p>
<p>update()方法<code>无需save</code>操作。唯一限制是它只能更新模型主表中的列，而不是关联的模型，例如不能这样做：</p>
<p><code>Entry.objects.update(blog__name='foo') 	# Won't work!</code></p>
<p>仍然可以根据相关字段进行过滤：</p>
<p><code>Entry.objects.filter(blog__id=1).update(comments_on=True)</code></p>
<p>update()方法返回受影响的行数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Entry.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">64</span>).update(comments_on=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.<span class="built_in">filter</span>(slug=<span class="string">&#x27;nonexistent-slug&#x27;</span>).update(comments_on=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.<span class="built_in">filter</span>(pub_date__year=<span class="number">2010</span>).update(comments_on=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">132</span></span><br></pre></td></tr></table></figure>
<p>如果你只是更新一下对象，不需要为对象做别的事情，最有效的方法是调用update()，而不是将模型对象加载到内存中。 例如，不要这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = Entry.objects.get(<span class="built_in">id</span>=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">e.comments_on = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">e.save()</span><br></pre></td></tr></table></figure>
<p>建议如下操作：</p>
<p><code>Entry.objects.filter(id=10).update(comments_on=False)</code></p>
<p>用update()还可以防止在加载对象和调用save()之间的短时间内数据库中某些内容可能发生更改的竞争条件。</p>
<p>如果想更新一个具有自定义save()方法的模型的记录，请循环遍历它们并调用save()，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> Entry.objects.<span class="built_in">filter</span>(pub_date__year=<span class="number">2010</span>):</span><br><span class="line">  e.comments_on = <span class="literal">False</span></span><br><span class="line">  e.save()</span><br></pre></td></tr></table></figure>
<h3 id="16-delete">16. delete()</h3>
<p><code>delete()</code></p>
<ul>
<li>
<p>批量删除QuerySet中的所有对象，并返回删除的对象个数和每个对象类型的删除次数的字典。</p>
</li>
<li>
<p>delete()动作是立即执行的。</p>
</li>
<li>
<p>不能在QuerySet上调用delete()。</p>
</li>
<li>
<p>例如，要删除特定博客中的所有条目：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = Blog.objects.get(pk=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Delete all the entries belonging to this Blog.</span></span><br><span class="line">Entry.objects.<span class="built_in">filter</span>(blog=b).delete()</span><br><span class="line">(<span class="number">4</span>, &#123;<span class="string">&#x27;weblog.Entry&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;weblog.Entry_authors&#x27;</span>: <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>默认情况下，Django的ForeignKey使用SQL约束ON DELETE CASCADE，任何具有指向要删除的对象的外键的对象将与它们一起被删除。 像这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blogs = Blog.objects.<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># This will delete all Blogs and all of their Entry objects.</span></span><br><span class="line">blogs.delete()</span><br><span class="line">(<span class="number">5</span>, &#123;<span class="string">&#x27;weblog.Blog&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;weblog.Entry&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;weblog.Entry_authors&#x27;</span>: <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>这种级联的行为可以通过的ForeignKey的on_delete参数自定义。（什么时候要改变这种行为呢？比如日志数据，就不能和它关联的主体一并被删除！）</p>
<p>delete()会为所有已删除的对象（包括级联删除）发出<code>pre_delete</code>和<code>post_delete</code>信号。</p>
<h3 id="17-as-manager">17. as_manager()</h3>
<p><code>classmethod as_manager()</code></p>
<ul>
<li>一个类方法，返回Manager的实例与QuerySet的方法的副本</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Django简介</title>
    <url>/2023/02/06/django%E9%85%8D%E7%BD%AE%E5%88%9D%E5%90%AF/</url>
    <content><![CDATA[<h1>Django简介</h1>
<h2 id="背景">背景</h2>
<ul>
<li>2003诞生 它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的</li>
</ul>
<h2 id="MVT（框架）">MVT（框架）</h2>
<ul>
<li>
<p>Models 模型 数据库</p>
</li>
<li>
<p>Views 视图 放和拿</p>
</li>
<li>
<p>Template 模板 前端</p>
<ul>
<li>From 表单 <code>django</code> 会根据你后台数据库字段及表单层的设计对应的给你创建HTML关于表单的代码</li>
</ul>
</li>
</ul>
<h2 id="Django优点">Django优点</h2>
<ul>
<li>对象关系映射（Object Relational Mapping ORM）：通过定义映射类来构建数据模型，将模型与关系型数据库连接起来，使用ORM框架内置的数据库接口可实现复杂的数据操作。（简单来说就是把数据库的语句换成了python可识别的语言）</li>
<li>URL设计：开发者可以设计任意的URL（网站地址）， 而且支持使用正则表达式设计。</li>
<li>模板系统：提供可扩展的模板语言，模板之间具有可继承性。</li>
<li>表单处理：可以生成各种表单模型，而且表单具有有效性检验功能。</li>
<li>Cache系统：完善的缓存系统，可支持多种缓存方式</li>
<li>用户管理系统：提供用户认证，权限设置和用户组功能，功能扩展性强。</li>
<li>国际化：内置国际化系统，方便开发出多语言的网站。</li>
<li>admin管理系统：内置admin管理系统，系统的扩展性强。</li>
</ul>
<span id="more"></span>
<h2 id="Django项目目录">Django项目目录</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">用django-admin startproject demo 创建一个demo项目</span><br><span class="line">文件结构如下：</span><br><span class="line">demo/        <span class="comment"># 最外层 这个是整个项目的容器文件夹，可以随意改名字</span></span><br><span class="line">  </span><br><span class="line">    demo/      <span class="comment"># 内层的demo 是这个项目中关于配置文件的一个管理文件夹，这个不允许改名字</span></span><br><span class="line">    </span><br><span class="line">        __init__.py  <span class="comment">#初始化文件，代表这个文件夹是一个包，一个模块，demo文件夹就是一个模块了</span></span><br><span class="line">    </span><br><span class="line">        settings.py <span class="comment"># 这个是整个项目的配置文件，配置中间，配置邮件等</span></span><br><span class="line">    </span><br><span class="line">        urls.py    <span class="comment"># django项目的总路由配置文件。网站的地址信息</span></span><br><span class="line">        </span><br><span class="line">    wsgi.py		<span class="comment"># 全称为Python Web Server Gateway Interface，即为python服务器网关接口，					   是python应用与Web服务器之间的接口，用于Django项目在服务器上的部署和上线，一 					   般不需要修改</span></span><br><span class="line">  manage.py		<span class="comment"># 命令行工具，允许以多种方式与项目交互。 可输入 python manage.py help 查看					    该工具的具体用法 </span></span><br></pre></td></tr></table></figure>
<h2 id="Django的创建的App目录">Django的创建的App目录</h2>
<ul>
<li>
<p>使用命令创建app： python <a href="http://manage.py">manage.py</a> startapp frist</p>
<ul>
<li>
<p><strong>创建了App必须把App名称添加到<kbd>INSTALL_APPS</kbd>里面。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frist/</span><br><span class="line">  migrations/		<span class="comment"># 数据库前后是否有变化，生成出迁移文件</span></span><br><span class="line">    </span><br><span class="line">  static/			<span class="comment"># 创建App后存放App中的静态资源文件，自己手动添加</span></span><br><span class="line">    </span><br><span class="line">  templates/		<span class="comment"># 创建App后存放App中的模板文件，自己手动添加</span></span><br><span class="line">    </span><br><span class="line">  __init__.py</span><br><span class="line">  admin.py</span><br><span class="line">  apps.py</span><br><span class="line">  models.py</span><br><span class="line">  tests.py</span><br><span class="line">  urls.py			<span class="comment"># 创建App后由系统总路由映射到App的路由文件，自己手动添加</span></span><br><span class="line">  view.py</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="Django（settings）配置全览">Django（settings）配置全览</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Django settings for mysite project.</span></span><br><span class="line"><span class="string">Generated by &#x27;django-admin startproject&#x27; using Django 2.1.2.</span></span><br><span class="line"><span class="string">For more information on this file, see</span></span><br><span class="line"><span class="string">https://docs.djangoproject.com/en/2.1/topics/settings/</span></span><br><span class="line"><span class="string">For the full list of settings and their values, see</span></span><br><span class="line"><span class="string">https://docs.djangoproject.com/en/2.1/ref/settings/</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目路径</span></span><br><span class="line"><span class="comment"># Build paths inside the project like this: os.path.join(BASE_DIR, ...)</span></span><br><span class="line">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Quick-start development settings - unsuitable for production</span></span><br><span class="line"><span class="comment"># See https://docs.djangoproject.com/en/2.1/howto/deployment/checklist/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 密匙配置</span></span><br><span class="line"><span class="comment"># SECURITY WARNING: keep the secret key used in production secret!</span></span><br><span class="line">SECRET_KEY = <span class="string">&#x27;#g$qgqkee8csvp67l$(8ugkx%+i_9k%mbykw-%9zpbnyn!bb!=&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调试模式</span></span><br><span class="line"><span class="comment"># SECURITY WARNING: don&#x27;t run with debug turned on in production!</span></span><br><span class="line">DEBUG = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 域名访问权限</span></span><br><span class="line">ALLOWED_HOSTS = [<span class="string">&#x27;*&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># App列表</span></span><br><span class="line"><span class="comment"># Application definition</span></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;myblog&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;article&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">ROOT_URLCONF = <span class="string">&#x27;mysite.urls&#x27;</span></span><br><span class="line"></span><br><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.template.backends.django.DjangoTemplates&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;DIRS&#x27;</span>: [BASE_DIR, <span class="string">&#x27;templates&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;APP_DIRS&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&#x27;OPTIONS&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;context_processors&#x27;</span>: [</span><br><span class="line">                <span class="string">&#x27;django.template.context_processors.debug&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.template.context_processors.request&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.contrib.auth.context_processors.auth&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.contrib.messages.context_processors.messages&#x27;</span>,</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 自定义模版全局变量(默认变量)</span></span><br><span class="line">                <span class="string">&#x27;article.views.global_settings&#x27;</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">WSGI_APPLICATION = <span class="string">&#x27;mysite.wsgi.application&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Database</span></span><br><span class="line"><span class="comment"># https://docs.djangoproject.com/en/2.1/ref/settings/#databases</span></span><br><span class="line"></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.sqlite3&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: os.path.join(BASE_DIR, <span class="string">&#x27;db.sqlite3&#x27;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Password validation</span></span><br><span class="line"><span class="comment"># https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validators</span></span><br><span class="line"></span><br><span class="line">AUTH_PASSWORD_VALIDATORS = [</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">&#x27;NAME&#x27;</span>:<span class="string">&#x27;django.contrib.auth.password_validation.UserAttributeSimilarityValidator&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;django.contrib.auth.password_validation.MinimumLengthValidator&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;django.contrib.auth.password_validation.CommonPasswordValidator&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;django.contrib.auth.password_validation.NumericPasswordValidator&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internationalization</span></span><br><span class="line"><span class="comment"># https://docs.djangoproject.com/en/2.1/topics/i18n/</span></span><br><span class="line"></span><br><span class="line">LANGUAGE_CODE = <span class="string">&#x27;zh-Hans&#x27;</span></span><br><span class="line"></span><br><span class="line">TIME_ZONE = <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"></span><br><span class="line">USE_I18N = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">USE_L10N = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">USE_TZ = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Static files (CSS, JavaScript, Images)</span></span><br><span class="line"><span class="comment"># https://docs.djangoproject.com/en/2.1/howto/static-files/</span></span><br><span class="line"></span><br><span class="line">STATIC_URL = <span class="string">&#x27;/static/&#x27;</span></span><br><span class="line">STATIC_ROOT = os.path.join(BASE_DIR, <span class="string">&quot;static/&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>项目路径 BASE_DIR：主要通过<code>os</code>模块读取当前项目在系统的具体路径，该代码在创建项目时自动生成，一般情况无需修改</p>
<p>密匙配置SECRET_KEY：是一个随机值，在项目创建的时候自动生成，一般情况下无需修改。主要用于重要的数据		 加密处理，提高系统的安全性，避免遭到攻击者的恶意破坏。密匙主要用于用户密码，<code>CSRF</code>机制和会话<code>Session</code>等数据加密。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">* 用户密码：Django内置一套用户管理系统，该系统具有用户认证和存储用户信息等功能，在创建用户的时候，将用户的密码通过密匙进行加密处理，保证用户的安全性。</span><br><span class="line"></span><br><span class="line">* CSRF机制：该机制主要用于表单提交，防止窃取网站的用户信息来制造恶意请求</span><br><span class="line"></span><br><span class="line">* 会话Session：Session的信息存放在Cookies，以一串随机的字符串表示，用于标识当前访问网站的用户身份，记录相关用户信息。</span><br></pre></td></tr></table></figure>
<p>调试模式DEBUG：该值为布尔类型。如果在开发调试阶段应设置为True，在开发调试过程中会自动检测代码是否 发生更改，根据检测结果执行是否刷新重启系统。如果项目部署上线，将其改为False，否则会泄露系统的相关信息。</p>
<p>域名访问权限ALLOWED_HOSTS:设置可访问的域名，默认值为空。当DEBUG为True并且ALLOWED_HOSTS为空时，项目只允许以<code>localhost</code>或<kbd>127.0.0.1</kbd>在浏览器上访问启动。当DEBUG为False时，ALLOWED_HOSTS为必填项，否则程序无法启动，如果想允许所有域名访问，可设置ALLOW_HOSTS=[‘*’]。</p>
<p>App列表INSTALLED_APPS：告诉Django有哪些App。在创建项目时已有admin，auth，和session等配置等信息，这些都是Django内置的应用功能，各个功能说明如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">* admin:内置的后台管理系统。</span><br><span class="line">* auth：内置的用户认证系统。</span><br><span class="line">* contenttypes：记录项目中所有的model元数据（Django的ORM框架）。</span><br><span class="line">* session：Session会话功能，用于标识当前访问网站的 用户身份，记录相关用户信息。</span><br><span class="line">* message：消息提示功能。</span><br><span class="line">* staticfiles：查找静态资源路径。</span><br></pre></td></tr></table></figure>
<h3 id="静态资源（static）">静态资源（static）</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Static files (CSS, JavaScript, Images)</span></span><br><span class="line"><span class="comment"># https://docs.djangoproject.com/en/2.1/howto/static-files/</span></span><br><span class="line"></span><br><span class="line">STATIC_URL = <span class="string">&#x27;/static/&#x27;</span>  </span><br><span class="line">STATIC_ROOT = os.path.join(BASE_DIR, <span class="string">&quot;static/&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置根目录的静态资源文件夹static</span></span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">            os.path.join(BASE_DIR, <span class="string">&#x27;static&#x27;</span>),</span><br><span class="line"><span class="comment"># 设置App的静态资源文件夹</span></span><br><span class="line">            os.path.join(BASE_DIR, <span class="string">&#x27;/static&#x27;</span>)，</span><br><span class="line">                   ]</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>​	CSS也称层叠样式表（Cascading Style Sheets），是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。</p>
<p>​	JavaScript是一种直译式脚本语言，也是一种动态类型，弱类型，基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。</p>
<ul>
<li>
<p><kbd>STATIC_URL</kbd>是必须配置的属性而且属性值不能为空。如果没有配置<kbd>STATICFILES_DIRS</kbd>，则<kbd>STATIC_URL</kbd>只能识别App里的static静态资源文件夹。</p>
</li>
<li>
<p><kbd>STATICFILES_DIRS</kbd>是可选配置属性，属性值为列表或元组格式，每个列表（元组）元素代表一个静态资源文件夹，这些文件夹可行命名。</p>
</li>
<li>
<p>在浏览器上访问项目的静态资源时，无论项目的静态资源文件夹是如何命名的，在浏览器上，静态资源的上级目录必须为static，而static而<kbd>STATIC_URL</kbd>的属性值,因为<kbd>STATIC_URL</kbd>也是静态资源的起始URL。</p>
</li>
</ul>
<p>​    除此之外，静态资源配置还有<kbd>STATIC_ROOT</kbd>，其作用是方便在服务器上部署项目，实现服务器和项目之间的映射。</p>
<p><strong>STATIC_URL和STATICFILES_DIRS区别</strong></p>
<ul>
<li>STATIC_URL是必须配置的属性而且属性的值不能为空。如果没有配置STATICFILES_DIRS,则STATIC_URL只能识别App里面的static静态资源文件夹。</li>
<li>STATICFILES_DIRS是可选配置属性，属性值为列表或元组格式，每个列表（元组）元素代表一个静态资源文件夹，这些文件夹可自行命名。</li>
<li>在浏览器上访问项目的静态资源时，无论项目的静态资源文件夹是如何命名的，在浏览器上，静态资源的上级目录必须为static，而static是STATIC_URL的属性值，因为STATIC_URL也是静态资源的起始URL。</li>
</ul>
<h3 id="模板路径（template）">模板路径（template）</h3>
<ul>
<li>在web开发中，模板是一种较为特殊的HTML文档。这个HTML文档嵌入了一些能够让Python识别的变量和指令，然后程序解析这些变量和指令，生成完整的HTML网页并返回给用户浏览。模板是Django里面的MTV框架模式的<code>T</code>部分，配置模板路径是Django在解析模板时，如何找到模板所在的位置。创建项目时，Django以有初始的模板配置信息。如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.template.backends.django.DjangoTemplates&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;DIRS&#x27;</span>: [BASE_DIR, <span class="string">&#x27;templates&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;APP_DIRS&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&#x27;OPTIONS&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;context_processors&#x27;</span>: [</span><br><span class="line">                <span class="string">&#x27;django.template.context_processors.debug&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.template.context_processors.request&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.contrib.auth.context_processors.auth&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.contrib.messages.context_processors.messages&#x27;</span>,</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 自定义模版全局变量(默认变量)</span></span><br><span class="line">                <span class="string">&#x27;article.views.global_settings&#x27;</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>模板信息是以列表格式呈现的，每个元素具有不同的含义，说明如下：</p>
<ul>
<li>
<p>BACKEND：定义模板引擎，用于识别模板里面的变量和指令。内置的模板引擎有<code>DjangoTemplate</code>和<code>jinjia2.Jinjia2</code>，每个模板引擎都有自己的变量和指令语法。</p>
</li>
<li>
<p>DIRS：设置模板所在的路径，告诉Django在那个地方查找模板的位置，默认为空列表</p>
</li>
<li>
<p>APP_DIRS:是否在App里面查找模板文件</p>
</li>
<li>
<p>OPTIONS：用于填充在RequestContext中上下文调用函数，一般情况下不做任何修改。</p>
</li>
</ul>
</li>
</ul>
<h3 id="数据库设置（Databases）">数据库设置（Databases）</h3>
<ul>
<li>
<p>在settings文件下 有一个DATABASES属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.sqlite3&#x27;</span>,     <span class="comment"># 数据库引擎</span></span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: os.path.join(BASE_DIR, <span class="string">&#x27;db.sqlite3&#x27;</span>), <span class="comment"># 本地sqllite3数据库位置</span></span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>:                     <span class="comment"># 用户名</span></span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>:                   <span class="comment"># 数据库密码</span></span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>:                      <span class="comment"># 数据库主机地址</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">#  默认的django使用sqllite3作为数据库</span></span><br><span class="line">  <span class="comment"># django提供四种 ENGINE 数据库引擎</span></span><br><span class="line">      <span class="comment">#	django.db.backends.mysql</span></span><br><span class="line">        <span class="comment">#  django.db.backends.oracle</span></span><br><span class="line">        <span class="comment">#  django.db.backends.splite3</span></span><br><span class="line"><span class="comment">#  如果你使用的是 PostgreSQL 或者Mysql的话，已经是先创建了数据库，但是默认的SQLlite不需要</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>sqlite3</code> 轻量级数据库（数据存放在文件里面）</p>
</li>
<li>
<p>在Django连接MYSQL数据库时候如果提示django.db.utils.OperationalError的错误信息，这是因为MYSQL8.0版本的密码加密方式发生了变化，8.0版本的用户密码采用的是cha2加密方法。</p>
<ul>
<li>
<p>解决方法，把SQL语句将8.0版本加密方法改回原来的加密方式。</p>
</li>
<li>
<pre><code class="language-sql"># newpassword 是我们设置的用户密码
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'newpassword';
FLUSH PRIVILEGES;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="中间件（Middlewere）">中间件（Middlewere）</h3>
<p>中间件（Middleware）是处理Django的request和response对象的钩子。当用户在网站中进行单击某个按钮等操作时，这个动作是用户向网站发送请求（request）；而网页会根据用户的操作返回相关的网页内容，这个过程称为响应处理（response）。从请求到响应的过程中，当Django接收到用户的请求时，Django首先经过中间件处理请求消息，执行相关的处理，然后将处理结果返回给用户，中间件的执行流程如图：</p>
<p><img src="C:%5CUsers%5CLuenci%5CDesktop%5CWeb%E7%AC%94%E8%AE%B0%5CDjango%5Ctimg.jpg" alt="Alt"></p>
<p>如上图，中间件的作用主要是处理用户的请求信息。开发者也可以根据自己的开发需求自定义中间件，只要将自定义的中间件添加到配置属性MIDDLEWARE中即可激活。一般情况下，Django默认的中间件配置均可满足大部分的开发需求。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,</span><br></pre></td></tr></table></figure>
<p>配置属性MIDDLEWARE的数据格式为列表类型，每个中间件的设置顺序是固定的，如果随意变更中间件很容易导致程序异常，每个中间件的说明如下：</p>
<ul>
<li>SecurityMiddleware：内置的安全机制，保护用户与网站的通信安全。</li>
<li>SessionMiddleware：会话Session。</li>
<li>LocaleModdleware：支持中文语言。</li>
<li>CommonMiddleware：处理请求信息，规范化请求内容。</li>
<li>CsrViewMiddleware：开启CSRF防护功能。</li>
<li>AuthenticationMiddleware：开启内置的用户认证系统。</li>
<li>MessageMiddleware：开启内置的信息提示功能。</li>
<li>XFrameOptionsMiddleware：防止恶意程序点击劫持。</li>
</ul>
<h2 id="修改时区及语言">修改时区及语言</h2>
<ul>
<li>
<p>LANGUAGE_CODE = ‘en-us’  #语言</p>
</li>
<li>
<p>TIME_ZONE = ‘UTC’ #时区</p>
</li>
</ul>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LANGUAGE_CODE = <span class="string">&#x27;zh-Hans&#x27;</span></span><br><span class="line">TIME_ZONE = <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="开启测试服务器">开启测试服务器</h2>
<ul>
<li>用来展示你创建出来的空项目</li>
<li>/home/Publc_Class/5-17-django框架/</li>
<li>python3 <a href="http://manage.py">manage.py</a> runserver 0.0.0.0:9090
<ul>
<li>开启了一个测试服务器</li>
<li>runserver 可以让你在浏览器看到效果，但是这个是测试服务器，压力不过百</li>
</ul>
</li>
</ul>
<h2 id="创建默认数据库">创建默认数据库</h2>
<ul>
<li>
<p>因为django自带的admin界面，首先需要数据库来支持</p>
<ul>
<li>我们来先创建出一个数据库</li>
</ul>
</li>
</ul>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">makemigrations 数据库前后是否有变化，生成出迁移文件</span><br><span class="line">migrate 根据迁移文件 来对应的执行SQL语句 </span><br><span class="line">python3 manage.py makemigrations</span><br><span class="line">python3 manage.py migrate </span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>如果数据库创建完成，那么目录结构下和<code>manage.py</code>同级的就会有一个<code>db.splite3</code>文件</p>
</li>
<li>
<p>有了这个数据库，就可以创建超级用户来管理<code>admin</code>界面啦！</p>
</li>
</ul>
<p><strong>为<code>admin</code>界面创建超级用户</strong></p>
<ul>
<li>
<p>数据库有了，要创建超级用户</p>
<ul>
<li>python3 <a href="http://manage.py">manage.py</a> createsuperuser</li>
</ul>
</li>
</ul>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Username (leave blank to use <span class="string">&#x27;root&#x27;</span>): root</span><br><span class="line">Email address: <span class="number">2573799357</span>@qq.com   </span><br><span class="line">Password: </span><br><span class="line">Password (again): </span><br><span class="line">Superuser created successfully.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>docker相关知识学习</title>
    <url>/2023/02/06/docker%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1><code>IaaS</code>、<code>PaaS</code>、<code>SaaS</code> 的区别</h1>
<ul>
<li>
<p><strong>基础设施(infrastructure)、平台(platform)和软件(software)</strong></p>
</li>
<li>
<p>其实就是云计算的三个分层，基础设施在最下端，平台在中间，软件在顶端，分别是分别是<strong>Infrastructure-as-a-Service</strong>(<code>IaaS</code>)，<strong>Platform-as-a-Service</strong>(<code>PaaS</code>)，<strong>Software-as-a-Service</strong>(<code>SaaS</code>)</p>
</li>
</ul>
<h2 id="IaaS-Infrastructure-as-a-Service-基础设施即服务"><strong>IaaS:</strong> Infrastructure-as-a-Service(基础设施即服务)</h2>
<ul>
<li>
<p>有了IaaS，你可以将硬件外包到别的地方去。IaaS公司会提供场外服务器，存储和网络硬件，你可以租用。节省了维护成本和办公场地，公司可以在任何时候利用这些硬件来运行其应用。</p>
</li>
<li>
<p>一些大的IaaS公司包括Amazon, Microsoft, VMWare, Rackspace和Red Hat.不过这些公司又都有自己的专长，比如Amazon和微软给你提供的不只是IaaS，他们还会将其计算能力出租给你来host你的网站。</p>
</li>
</ul>
<h2 id="PaaS-Platform-as-a-Service-平台即服务"><strong>PaaS:</strong> Platform-as-a-Service(平台即服务)</h2>
<ul>
<li>
<p>第二层就是所谓的PaaS，某些时候也叫做中间件。你公司所有的开发都可以在这一层进行，节省了时间和资源。PaaS公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统。这节省了你在硬件上的费用，也让分散的工作室之间的合作变得更加容易。网页应用管理，应用设计，应用虚拟主机，存储，安全以及应用开发协作工具等。</p>
</li>
<li>
<p>一些大的PaaS提供者有Google App Engine,Microsoft Azure，<a href="http://Force.com">Force.com</a>,Heroku，Engine Yard。最近兴起的公司有AppFog,Mendix和Standing Cloud.</p>
</li>
</ul>
<h2 id="SaaS-Software-as-a-Service-软件即服务"><strong>SaaS:</strong> Software-as-a-Service(软件即服务)</h2>
<ul>
<li>第三层也就是所谓SaaS。这一层是和你的生活每天接触的一层，大多是通过网页浏览器来接入。任何一个远程服务器上的应用都可以通过网络来运行，就是SaaS了。</li>
</ul>
<h1>docker知识</h1>
<ul>
<li>Docker 是世界领先的软件容器平台</li>
<li>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核 的<code>cgroup</code>，<code>namespace</code>，以及<code>AUFS</code>类的<code>UnionFS</code>等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。 由于隔离的进程独立于宿主和其它的隔离的进 程，因此也称其为容器。Docker最初实现是基于 <code>LXC.</code></li>
<li>Docker 能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：构建杰出的软件。</li>
<li>用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</li>
</ul>
<h2 id="物理机">物理机</h2>
<ul>
<li>物理机，对应采购的服务器设备，又叫裸设备，bare metal，比如普通的主机。笔记本电脑，台式电脑都可以叫物理机。</li>
</ul>
<h2 id="虚拟机">虚拟机</h2>
<ul>
<li>虚拟机，与现在流行的“云计算”的概念的有着紧密联系，虚拟机的概念在<code>IaaS</code>层，即基础设施即服务部分，可以自行学习一下。为了让全人类能够像使用自来水、电一样使用计算资源，我们需要在几百上千台物理机上部署虚拟化软件，如vmware等等，使得他们的表现就像一台巨大的计算机。同时它还具有灵活性和解耦性，你可以在一台物理机上部署10台虚拟机，使得一台物理机的表现就像10台性能略差的服务器，当你不需要他们时，你又可以随时的回收资源重新分配。</li>
</ul>
<h2 id="容器">容器</h2>
<p><strong>一句话概括容器：容器就是将软件打包成标准化单元，以用于开发、交付和部署。</strong></p>
<ul>
<li><strong>容器镜像是轻量的、可执行的独立软件包</strong> ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</li>
<li><strong>容器化软件适用于基于Linux和Windows的应用，在任何环境中都能够始终如一地运行。</strong></li>
<li><strong>容器赋予了软件独立性</strong> ，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。</li>
</ul>
<p><strong>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。</strong></p>
<span id="more"></span>
<h1>Docker思想</h1>
<ul>
<li><strong>集装箱</strong></li>
<li><strong>标准化：</strong> ①运输方式 ② 存储方式 ③ API接口</li>
<li><strong>隔离</strong></li>
</ul>
<h1>Docker容器的特点</h1>
<ul>
<li>
<h2 id="轻量">轻量</h2>
<p>在一台机器上运行的多个 Docker 容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。</p>
</li>
<li>
<h2 id="标准">标准</h2>
<p>Docker 容器基于开放式标准，能够在所有主流 Linux 版本、Microsoft Windows 以及包括 <code>VM</code>、裸机服务器和云在内的任何基础设施上运行。</p>
</li>
<li>
<h2 id="安全">安全</h2>
<p>Docker 赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker 默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。</p>
</li>
</ul>
<h1>Docker优势</h1>
<ul>
<li>一致的运行环境
<ul>
<li>Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题</li>
</ul>
</li>
<li>更快速的启动时间
<ul>
<li>可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</li>
</ul>
</li>
<li>隔离性
<ul>
<li>避免公用的服务器，资源会容易受到其他用户的影响。</li>
</ul>
</li>
<li>弹性伸缩，快速扩展
<ul>
<li>善于处理集中爆发的服务器使用压力；</li>
</ul>
</li>
<li>迁移方便
<ul>
<li>可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</li>
</ul>
</li>
<li>持续交付和部署
<ul>
<li>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。</li>
</ul>
</li>
</ul>
<h1>Docker基本概念</h1>
<p>Docker 包括三个基本概念</p>
<ul>
<li>镜像（Image）</li>
<li>容器（Container）</li>
<li>仓库（Repository）</li>
</ul>
<h2 id="镜像（Image）——-一个特殊的文件系统"><strong>镜像（Image）—— 一个特殊的文件系统</strong></h2>
<ul>
<li><strong>操作系统分为内核和用户空间</strong>。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而Docker 镜像（Image），就相当于是一个 root 文件系统。</li>
<li>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 <strong>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</strong></li>
<li>Docker 设计时，就充分利用 <strong>Union FS</strong>的技术，将其设计为 <strong>分层存储的架构</strong> 。 镜像实际是由多层文件系统联合组成。</li>
<li>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。 比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</li>
<li>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像</li>
</ul>
<h2 id="容器（Container-——镜像运行时的实体">容器（Container)——镜像运行时的实体</h2>
<ul>
<li>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。<strong>容器可以被创建、启动、停止、删除、暂停等 。</strong></li>
<li>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</li>
<li>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</li>
<li>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失。</li>
</ul>
<h2 id="仓库（Repository）——集中存放镜像文件的地方">仓库（Repository）——集中存放镜像文件的地方</h2>
<ul>
<li>镜像构建完成后，可以很容易的在当前宿主上运行，但是， <strong>如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。</strong></li>
<li>一个 Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：<strong>镜像仓库是Docker用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。</strong></li>
<li>通常，<strong>一个仓库会包含同一个软件不同版本的镜像</strong>，而<strong>标签就常用于对应该软件的各个版本</strong> 。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签.。</li>
<li>这里补充一下Docker Registry 公开服务和私有 Docker Registry的概念：</li>
<li>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</li>
<li>最常使用的 Registry 公开服务是官方的 <strong>Docker Hub</strong> ，这也是默认的 Registry，并拥有大量的高质量的官方镜像，网址为：<a href="https://hub.docker.com/">hub.docker.com/</a> 。在国内访问<strong>Docker Hub</strong> 可能会比较慢国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://hub.tenxcloud.com/">时速云镜像库</a>、<a href="https://www.163yun.com/product/repo">网易云镜像服务</a>、<a href="https://www.daocloud.io/">DaoCloud 镜像市场</a>、<a href="https://www.aliyun.com/product/containerservice?utm_content=se_1292836">阿里云镜像库</a>等。</li>
<li>除了使用公开服务外，用户还可以在 <strong>本地搭建私有 Docker Registry</strong> 。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</li>
</ul>
<h2 id="Build-Ship-and-Run">Build, Ship, and Run</h2>
<ul>
<li><strong>Build（构建镜像）</strong> ： 镜像就像是集装箱包括文件以及运行环境等等资源。</li>
<li><strong>Ship（运输镜像）</strong> ：主机和仓库间运输，这里的仓库就像是超级码头一样。</li>
<li><strong>Run （运行镜像）</strong> ：运行的镜像就是一个容器，容器就是运行程序的地方。</li>
</ul>
<p>​    Docker 运行过程也就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。所以，我们也常常将Docker称为码头工人或码头装卸工，这和Docker的中文翻译搬运工人如出一辙。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker知识</tag>
      </tags>
  </entry>
  <entry>
    <title>flask框架学习</title>
    <url>/2023/02/06/flask%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1>基本概念</h1>
<h2 id="1-静态资源">1.静态资源</h2>
<p>​	一旦准备好资源，不在需要经常变化的资源.由于该资源不需要经常变化，所以可以提前准备.比如<code>png/jpg/css/js</code>等文件</p>
<h2 id="2-动态资源">2.动态资源</h2>
<p>​	和静态资源相反，这种资源会经常变化.比如，我们要编写一个电商网站，我们无法预测用户在浏览商品时选择什么样的条件。<br>
根据用户选择条件不同，我们给用户提供可供选择的商品就不同.这种资源无法提前准备。</p>
<h2 id="3-模板文件">3.模板文件</h2>
<p>​	在用户搜索各种商品的时候，大家是否发现虽然大家的条件不同，但是显示商品的网页中除了那些商品信息整个网页的结构/布局几乎是一模一样的.<br>
​	而模板文件就是网页中通用的结构构成的一个页面.这个页面中不含有任何用户需要查看的数据，当用户查询数据的时候会将最终的结果放到模板中形成用户真正需要的页面。<br>
​	这就好比，生活中一个毛坯房可以装饰上不同的风格.我们把模板文件转化为用户真正看到的网页的过程就称为模板替换.</p>
<h1>通信规范</h1>
<p>服务器和浏览器之间通信使用HTTP协议<br>
同理，框架和web服务器之间进行通信也需要一个协议为了简单明了，一个简单的协议（例子）：</p>
<ul>
<li>1、web服务器在接收到浏览器的动态套源请求的时候会将请求报文请求切割拆分为键值对放到一个字典中</li>
<li>2、web服务器调用框架提供的方法执行框架的功能并且传给框架一个字典</li>
<li>3、框架通过字典取出用户请求根据请求产生处理状态/响应头信息/响应体</li>
<li>4、框架通过返回值将处理状态/响应头信息/响应体给服务器，完成一次动态资源请求的过程</li>
</ul>
<h1>Flask程序运行过程</h1>
<ul>
<li>
<p>1.当客户端想要获取资源时，一般会通过浏览器发起HTTP请求。</p>
</li>
<li>
<p>2.此时，<code>Web</code>服务器会把来自客户端的所有请求都交给Flask程序实例</p>
</li>
<li>
<p>3.程序实例使用<code>Werkzeug</code>来做路由分发（<code>URL</code>请求和视图函数之间的对应关系）。</p>
</li>
<li>
<p>4.根据每个<code>URL</code>请求，找到具体的视图函数并进行调用。</p>
<ul>
<li>在<code>Flask</code>程序中，路由的实现一般是通过程序实例的装饰器实现。</li>
</ul>
</li>
<li>
<p>5.<code>Flask</code>调用视图函数后，可以返回两种内容：</p>
<ul>
<li>字符串内容：将视图函数的返回值作为响应的内容，返回给客户端（浏览器）</li>
<li><code>HTML</code>模版内容：获取到数据后，把数据传入<code>HTML</code>模板文件中，板引擎负责渲染<code>HTTP</code>响应数据，然后返回响应数据给客户端（浏览器）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建flask应用实例</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义路由及是视图函数（装饰器路由）</span></span><br><span class="line"><span class="comment"># 路由默认只支持GET请求方式，如需要支持别的请求需要添加</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="comment"># return &quot;Hello Flask&quot;z</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span></span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>路由传参</h1>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用一个视图函数 来显示不同用户的订单信息</span></span><br><span class="line"><span class="comment"># &lt;&gt;路由定义的参数，&lt;&gt;内需要起个名字</span></span><br><span class="line"><span class="comment"># int：限定参数类型为int类型，其他的不解析</span></span><br><span class="line"><span class="comment">#   -大致原理是将参数强转为int，如果成功，则可以进行路由匹配</span></span><br><span class="line"><span class="comment">#   -如果参数无法转换成功，就无法匹配该路由</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/orders/&lt;int:order_id&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_order_id</span>(<span class="params">order_id</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(order_id))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;order_id %s&#x27;</span> % order_id</span><br></pre></td></tr></table></figure>
  <span id="more"></span>
<h1><code>Jinja2</code>模板引擎</h1>
<h2 id="模板">模板</h2>
<pre><code>在前面的示例中，视图函数的主要作用是生成请求的响应，这是最简单的请求。实际上，视图函数有两个作用：处理业务逻辑和返回响应内容。在大型应用中，把业务逻辑和表现内容放在一起，会增加代码的复杂度和维护成本。本节学到的模板，它的作用即是承担视图函数的另一个作用，即返回响应内容。
</code></pre>
<ul>
<li>
<p>模板其实是一个包含响应文本的文件，其中用占位符（变量）表示动态部分，告诉模板引擎其具体的值需要从使用的数据中获取</p>
</li>
<li>
<p>使用真实值替换变量，再返回最终得到的字符串，这个过程称为“渲染”</p>
</li>
<li>
<p><code>Flask</code>是使用<code>Jinja2</code>这个模板引擎来渲染模板</p>
</li>
</ul>
<p>使用模板的好处：</p>
<ul>
<li>
<p>视图函数只负责业务逻辑和数据处理（业务逻辑方面）</p>
</li>
<li>
<p>而模板则取到视图函数的数据结果进行展示（视图展示方面）</p>
</li>
<li>
<p>代码结构清晰，耦合度低</p>
</li>
</ul>
<h2 id="JinJia2"><code>JinJia2</code></h2>
<p>两个概念：</p>
<ul>
<li>
<p><code>Jinja2</code>：是Python下一个被广泛应用的模板引擎，是由Python实现的模板语言，他的设计思想来源于<code>Django</code>的模板引擎，并扩展了其语法和一系列强大的功能，其是<code>Flask</code>内置的模板语言。</p>
</li>
<li>
<p>模板语言：是一种被设计来自动生成文档的简单文本格式，在模板语言中，一般都会把一些变量传给模板，替换模板的特定位置上预先定义好的占位变量名。</p>
</li>
</ul>
<p>渲染模版函数</p>
<ul>
<li>
<p><code>Flask</code>提供的<code>render_template </code>函数封装了该模板引擎</p>
</li>
<li>
<p><code>render_template</code>函数的第一个参数是模板的文件名，后面的参数都是键值对，表示模板中变量对应的真实值。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    name = <span class="string">&#x27;Luenci&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>, name=name)</span><br></pre></td></tr></table></figure>
<h2 id="使用方法">使用方法</h2>
<h3 id="变量代码块">变量代码块</h3>
<ul>
<li>用<img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200427161314597.png" alt="">来表示变量名， 这种<img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200427161314597.png" alt="">语法叫做变量代码块</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200427160426403.png" alt="image-20200427160426403">)</p>
<ul>
<li>字典和列表的使用</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200427154043162.png" alt="image-20200427154043162"></p>
<h3 id="控制代码块">控制代码块</h3>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200427160633257.png" alt="img"></p>
<h2 id="过滤器">过滤器</h2>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200427160813513.png" alt="imgs"></p>
<h1>Web表单</h1>
<ul>
<li>web表单是web应用程序的基本功能。</li>
<li>它是HTML页面中负责数据采集的部件。表单有三个部分组成：表单标签、表单域、表单按钮。表单允许用户输入数据，负责HTML页面数据采集，通过表单将用户输入的数据提交给服务器。</li>
<li>在Flask中，为了处理web表单，我们一般使用<code>Flask-WTF</code>扩展，它封装了<code>WTForms</code>，并且它有验证表单数据的功能</li>
</ul>
<div class="htmledit_views" id="content_views">
                                            <div class="table-box"><table><thead><tr><th>字段对象</th>
			<th>说明</th>
		</tr></thead><tbody><tr><td>StringField</td>
			<td>文本字段</td>
		</tr><tr><td>TextAreaField</td>
			<td>多行文本字段</td>
		</tr><tr><td>PasswordField</td>
			<td>密码文本字段</td>
		</tr><tr><td>HiddenField</td>
			<td>隐藏文件字段</td>
		</tr><tr><td>DateField</td>
			<td>文本字段，值为 datetime.date 文本格式</td>
		</tr><tr><td>DateTimeField</td>
			<td>文本字段，值为 datetime.datetime 文本格式</td>
		</tr><tr><td>IntegerField</td>
			<td>文本字段，值为整数</td>
		</tr><tr><td>DecimalField</td>
			<td>文本字段，值为decimal.Decimal</td>
		</tr><tr><td>FloatField</td>
			<td>文本字段，值为浮点数</td>
		</tr><tr><td>BooleanField</td>
			<td>复选框，值为True 和 False</td>
		</tr><tr><td>RadioField</td>
			<td>一组单选框</td>
		</tr><tr><td>SelectField</td>
			<td>下拉列表</td>
		</tr><tr><td>SelectMutipleField</td>
			<td>下拉列表，可选择多个值</td>
		</tr><tr><td>FileField</td>
			<td>文件上传字段</td>
		</tr><tr><td>SubmitField</td>
			<td>表单提交按钮</td>
		</tr><tr><td>FormField</td>
			<td>把表单作为字段嵌入另一个表单</td>
		</tr><tr><td>FieldList</td>
			<td>一组指定类型的字段</td>
		</tr></tbody></table></div><h2 id="wtforms常用验证函数"><a name="t0"></a>WTForms常用验证函数</h2>
<div class="table-box"><table><thead><tr><th>验证函数</th>
			<th>说明</th>
		</tr></thead><tbody><tr><td>DataRequired</td>
			<td>确保字段中有数据</td>
		</tr><tr><td>EqualTo</td>
			<td>比较两个字段的值，常用于比较两次密码输入</td>
		</tr><tr><td>Length</td>
			<td>验证输入的字符串长度</td>
		</tr><tr><td>NumberRange</td>
			<td>验证输入的值在数字范围内</td>
		</tr><tr><td>URL</td>
			<td>验证URL</td>
		</tr><tr><td>AnyOf</td>
			<td>验证输入值在可选列表中</td>
		</tr><tr><td>NoneOf</td>
			<td>验证输入值不在可选列表中</td>
		</tr></tbody></table>
<ul>
<li>
<p>使用 <code>Flask-WTF </code>需要配置参数 <code>SECRET_KEY</code></p>
</li>
<li>
<p>CSRF_ENABLED是为了CSRF（跨站请求伪造）保护。 <code>SECRET_KEY</code>用来生成加密令牌，当<code>CSRF</code>激活的时候，该设置会根据设置的密匙生成加密令牌。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置密匙</span></span><br><span class="line">app.secret_key = <span class="string">&#x27;luenci&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/login.html&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        <span class="comment"># 获取表单的数据</span></span><br><span class="line">        username = request.form.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.form.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(username, password)</span><br><span class="line">        <span class="keyword">if</span> username == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            flash(<span class="string">&#x27;请填写邮箱&#x27;</span>)  </span><br><span class="line">        <span class="keyword">elif</span> password == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            flash(<span class="string">&#x27;请设置密码&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;sucess&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;login_demo.html&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200427161032568.png" alt=""></p>
<h2 id="Flask-WTF实现表单"><code>Flask-WTF</code>实现表单</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_wtf <span class="keyword">import</span> FlaskForm</span><br><span class="line"><span class="comment"># 导入文本字段，密码字段，和提交按钮</span></span><br><span class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> StringField, PasswordField, SubmitField</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建表单类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoginFrom</span>(<span class="title class_ inherited__">FlaskForm</span>):</span><br><span class="line">    username = StringField(<span class="string">&quot;用户名&quot;</span>)</span><br><span class="line">    password1 = PasswordField(<span class="string">&quot;密码&quot;</span>)</span><br><span class="line">    password2 = PasswordField(<span class="string">&quot;确认密码&quot;</span>)</span><br><span class="line">    submit = SubmitField(<span class="string">&quot;提交&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/form&#x27;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">form_demo</span>():</span><br><span class="line">    <span class="comment"># 创建表单实例</span></span><br><span class="line">    form_login = LoginFrom()</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;login_demo.html&quot;</span>, form=form_login)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200427161047472.png" alt=""></p>
]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Git命令集合</title>
    <url>/2023/02/06/git%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="git-config">git config</h2>
<p>配置 Git 的相关参数。</p>
<p>Git 一共有3个配置文件：</p>
<ol>
<li>仓库级的配置文件：在仓库的 <code>.git/.gitconfig</code>，该配置文件只对所在的仓库有效。</li>
<li>全局配置文件：Mac 系统在 <code>~/.gitconfig</code>，Windows 系统在 <code>C:\Users\&lt;用户名&gt;\.gitconfig</code>。</li>
<li>系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 <code>/usr/local/git</code>）的 <code>etc</code> 文件夹中的 <code>gitconfig</code>。</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看配置信息</span></span><br><span class="line"><span class="comment"># --local：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line"><span class="variable">$ </span>git config &lt;--local |<span class="params"> --global </span>| --system&gt; -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前生效的配置信息</span></span><br><span class="line"><span class="variable">$ </span>git config -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line"><span class="comment"># --local：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line"><span class="variable">$ </span>git config &lt;--local |<span class="params"> --global </span>| --system&gt; -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加配置项</span></span><br><span class="line"><span class="comment"># --local：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line"><span class="variable">$ </span>git config &lt;--local |<span class="params"> --global </span>| --system&gt; --add &lt;name&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取配置项</span></span><br><span class="line"><span class="variable">$ </span>git config &lt;--local |<span class="params"> --global </span>| --system&gt; --get &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除配置项</span></span><br><span class="line"><span class="variable">$ </span>git config &lt;--local |<span class="params"> --global </span>| --system&gt; --unset &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置提交记录中的用户信息</span></span><br><span class="line"><span class="variable">$ </span>git config --global user.name &lt;用户名&gt;</span><br><span class="line"><span class="variable">$ </span>git config --global user.email &lt;邮箱地址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改Git缓存区的大小</span></span><br><span class="line"><span class="comment"># 如果提交的内容较大，默认缓存较小，提交会失败</span></span><br><span class="line"><span class="comment"># 缓存大小单位：B，例如：524288000（500MB）</span></span><br><span class="line"><span class="variable">$ </span>git config --global http.postBuffer &lt;缓存大小&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态</span></span><br><span class="line"><span class="variable">$ </span>git config --global color.ui <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置可以缓存密码，默认缓存时间15分钟</span></span><br><span class="line"><span class="variable">$ </span>git config --global credential.helper cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置密码的缓存时间</span></span><br><span class="line"><span class="comment"># 缓存时间单位：秒</span></span><br><span class="line"><span class="variable">$ </span>git config --global credential.helper <span class="string">&#x27;cache --timeout=&lt;缓存时间&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置长期存储密码</span></span><br><span class="line"><span class="variable">$ </span>git config --global credential.helper store</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="git-clone">git clone</h2>
<p>从远程仓库克隆一个版本库到本地。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定本地仓库的目录</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; &lt;本地目录&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -b 指定要克隆的分支，默认是master分支</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-init">git init</h2>
<p>初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化本地仓库，在当前目录下生成 .git 文件夹</span></span><br><span class="line"><span class="variable">$ </span>git init</span><br></pre></td></tr></table></figure>
<h2 id="git-status">git status</h2>
<p>查看本地仓库的状态。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看本地仓库的状态</span></span><br><span class="line"><span class="variable">$ </span>git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以简短模式查看本地仓库的状态</span></span><br><span class="line"><span class="comment"># 会显示两列，第一列是文件的状态，第二列是对应的文件</span></span><br><span class="line"><span class="comment"># 文件状态：A 新增，M 修改，D 删除，?? 未添加到Git中</span></span><br><span class="line"><span class="variable">$ </span>git status -s</span><br></pre></td></tr></table></figure>
<h2 id="git-remote">git remote</h2>
<p>操作远程库。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出已经存在的远程仓库</span></span><br><span class="line"><span class="variable">$ </span>git remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出远程仓库的详细信息，在别名后面列出URL地址</span></span><br><span class="line"><span class="variable">$ </span>git remote -v</span><br><span class="line"><span class="variable">$ </span>git remote --verbose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加远程仓库</span></span><br><span class="line"><span class="variable">$ </span>git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的<span class="variable constant_">URL</span>地址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改远程仓库的别名</span></span><br><span class="line"><span class="variable">$ </span>git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定名称的远程仓库</span></span><br><span class="line"><span class="variable">$ </span>git remote remove &lt;远程仓库的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改远程仓库的 URL 地址</span></span><br><span class="line"><span class="variable">$ </span>git remote set-url &lt;远程仓库的别名&gt; &lt;新的远程仓库<span class="variable constant_">URL</span>地址&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-branch">git branch</h2>
<p>操作 Git 的分支命令。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出本地的所有分支，当前所在分支以 &quot;*&quot; 标出</span></span><br><span class="line"><span class="variable">$ </span>git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本地的所有分支并显示最后一次提交，当前所在分支以 &quot;*&quot; 标出</span></span><br><span class="line"><span class="variable">$ </span>git branch -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新分支，新的分支基于上一次提交建立</span></span><br><span class="line"><span class="variable">$ </span>git branch &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改分支名称</span></span><br><span class="line"><span class="comment"># 如果不指定原分支名称则为当前所在分支</span></span><br><span class="line"><span class="variable">$ </span>git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"><span class="comment"># 强制修改分支名称</span></span><br><span class="line"><span class="variable">$ </span>git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的本地分支</span></span><br><span class="line"><span class="variable">$ </span>git branch -d &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除指定的本地分支</span></span><br><span class="line"><span class="variable">$ </span>git branch -D &lt;分支名称&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-checkout">git checkout</h2>
<p>检出命令，用于创建、切换分支等。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到已存在的指定分支</span></span><br><span class="line"><span class="variable">$ </span>git checkout &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并切换到指定的分支，保留所有的提交记录</span></span><br><span class="line"><span class="comment"># 等同于 &quot;git branch&quot; 和 &quot;git checkout&quot; 两个命令合并</span></span><br><span class="line"><span class="variable">$ </span>git checkout -b &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并切换到指定的分支，删除所有的提交记录</span></span><br><span class="line"><span class="variable">$ </span>git checkout --orphan &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响</span></span><br><span class="line"><span class="variable">$ </span>git checkout &lt;文件路径&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-cherry-pick">git cherry-pick</h2>
<p>把已经提交的记录合并到当前分支。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把已经提交的记录合并到当前分支</span></span><br><span class="line"><span class="variable">$ </span>git cherry-pick &lt;commit <span class="variable constant_">ID</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-add">git add</h2>
<p>把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 把指定的文件添加到暂存区中</span></span><br><span class="line">$ git <span class="keyword">add</span> &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta"># 添加所有修改、已删除的文件到暂存区中</span></span><br><span class="line">$ git <span class="keyword">add</span> -u [&lt;文件路径&gt;]</span><br><span class="line">$ git <span class="keyword">add</span> --update [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="meta"># 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录</span></span><br><span class="line">$ git <span class="keyword">add</span> -A [&lt;文件路径&gt;]</span><br><span class="line">$ git <span class="keyword">add</span> --all [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="meta"># 查看所有修改、已删除但没有提交的文件，进入一个子命令系统</span></span><br><span class="line">$ git <span class="keyword">add</span> -i [&lt;文件路径&gt;]</span><br><span class="line">$ git <span class="keyword">add</span> --interactive [&lt;文件路径&gt;]</span><br></pre></td></tr></table></figure>
<h2 id="git-commit">git commit</h2>
<p>将暂存区中的文件提交到本地仓库中。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息</span></span><br><span class="line"><span class="variable">$ </span>git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把暂存区中的文件提交到本地仓库中并添加描述信息</span></span><br><span class="line"><span class="variable">$ </span>git commit -m <span class="string">&quot;&lt;提交的描述信息&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把所有修改、已删除的文件提交到本地仓库中</span></span><br><span class="line"><span class="comment"># 不包括未被版本库跟踪的文件，等同于先调用了 &quot;git add -u&quot;</span></span><br><span class="line"><span class="variable">$ </span>git commit -a -m <span class="string">&quot;&lt;提交的描述信息&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改上次提交的描述信息</span></span><br><span class="line"><span class="variable">$ </span>git commit --amend</span><br></pre></td></tr></table></figure>
<h2 id="git-fetch">git fetch</h2>
<p>从远程仓库获取最新的版本到本地的 tmp 分支上。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将远程仓库所有分支的最新版本全部取回到本地</span></span><br><span class="line"><span class="variable">$ </span>git fetch &lt;远程仓库的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将远程仓库指定分支的最新版本取回到本地</span></span><br><span class="line"><span class="variable">$ </span>git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-merge">git merge</h2>
<p>合并分支。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把指定的分支合并到当前所在的分支下</span></span><br><span class="line"><span class="variable">$ </span>git merge &lt;分支名称&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-diff">git diff</h2>
<p>比较版本之间的差异。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改</span></span><br><span class="line"><span class="variable">$ </span>git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较暂存区中的文件和上次提交时的差异</span></span><br><span class="line"><span class="variable">$ </span>git diff --cached</span><br><span class="line"><span class="variable">$ </span>git diff --staged</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较当前文件和上次提交时的差异</span></span><br><span class="line"><span class="variable">$ </span>git diff <span class="variable constant_">HEAD</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看从指定的版本之后改动的内容</span></span><br><span class="line"><span class="variable">$ </span>git diff &lt;commit <span class="variable constant_">ID</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个分支之间的差异</span></span><br><span class="line"><span class="variable">$ </span>git diff &lt;分支名称&gt; &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看两个分支分开后各自的改动内容</span></span><br><span class="line"><span class="variable">$ </span>git diff &lt;分支名称&gt;...&lt;分支名称&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-pull">git pull</h2>
<p>从远程仓库获取最新版本并合并到本地。<br>
首先会执行 <code>git fetch</code>，然后执行 <code>git merge</code>，把获取的分支的 HEAD 合并到当前分支。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从远程仓库获取最新版本。</span></span><br><span class="line"><span class="variable">$ </span>git pull</span><br></pre></td></tr></table></figure>
<h2 id="git-push">git push</h2>
<p>把本地仓库的提交推送到远程仓库。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把本地仓库的分支推送到远程仓库的指定分支</span></span><br><span class="line"><span class="variable">$ </span>git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;<span class="symbol">:&lt;</span>远程分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的远程仓库的分支</span></span><br><span class="line"><span class="variable">$ </span>git push &lt;远程仓库的别名&gt; <span class="symbol">:&lt;</span>远程分支名&gt;</span><br><span class="line"><span class="variable">$ </span>git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-log">git log</h2>
<p>显示提交的记录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印所有的提交记录</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印从第一次提交到指定的提交的记录</span></span><br><span class="line">$ git <span class="built_in">log</span> &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印指定数量的最新提交的记录</span></span><br><span class="line">$ git <span class="built_in">log</span> -&lt;指定的数量&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-reset">git reset</h2>
<p>还原提交记录。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重置暂存区，但文件不受影响</span></span><br><span class="line"><span class="comment"># 相当于将用 &quot;git add&quot; 命令更新到暂存区的内容撤出暂存区，可以指定文件</span></span><br><span class="line"><span class="comment"># 没有指定 commit ID 则默认为当前 HEAD</span></span><br><span class="line"><span class="variable">$ </span>git reset [&lt;文件路径&gt;]</span><br><span class="line"><span class="variable">$ </span>git reset --mixed [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改</span></span><br><span class="line"><span class="variable">$ </span>git reset &lt;commit <span class="variable constant_">ID</span>&gt;</span><br><span class="line"><span class="variable">$ </span>git reset --mixed &lt;commit <span class="variable constant_">ID</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改</span></span><br><span class="line"><span class="comment"># 相当于调用 &quot;git reset --mixed&quot; 命令后又做了一次 &quot;git add&quot;</span></span><br><span class="line"><span class="variable">$ </span>git reset --soft &lt;commit <span class="variable constant_">ID</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件也修改了</span></span><br><span class="line"><span class="variable">$ </span>git reset --hard &lt;commit <span class="variable constant_">ID</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-revert">git revert</h2>
<p>生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一个新的提交来撤销某次提交</span></span><br><span class="line"><span class="variable">$ </span>git revert &lt;commit <span class="variable constant_">ID</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-tag">git tag</h2>
<p>操作标签的命令。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印所有的标签</span></span><br><span class="line"><span class="variable">$ </span>git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录</span></span><br><span class="line"><span class="variable">$ </span>git tag &lt;标签名称&gt; [&lt;commit <span class="variable constant_">ID</span>&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加带有描述信息的附注标签，可以指定之前的提交记录</span></span><br><span class="line"><span class="variable">$ </span>git tag -a &lt;标签名称&gt; -m &lt;标签描述信息&gt; [&lt;commit <span class="variable constant_">ID</span>&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定的标签</span></span><br><span class="line"><span class="variable">$ </span>git checkout &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看标签的信息</span></span><br><span class="line"><span class="variable">$ </span>git show &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的标签</span></span><br><span class="line"><span class="variable">$ </span>git tag -d &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定的标签提交到远程仓库</span></span><br><span class="line"><span class="variable">$ </span>git push &lt;远程仓库的别名&gt; &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地所有的标签全部提交到远程仓库</span></span><br><span class="line"><span class="variable">$ </span>git push &lt;远程仓库的别名&gt; –tags</span><br></pre></td></tr></table></figure>
<h2 id="git-mv">git mv</h2>
<p>重命名文件或者文件夹。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重命名指定的文件或者文件夹</span></span><br><span class="line"><span class="variable">$ </span>git mv &lt;源文件/文件夹&gt; &lt;目标文件/文件夹&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-rm">git rm</h2>
<p>删除文件或者文件夹。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 移除跟踪指定的文件，并从本地仓库的文件夹中删除</span></span><br><span class="line"><span class="variable">$ </span>git rm &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除</span></span><br><span class="line"><span class="variable">$ </span>git rm -r &lt;文件夹路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件</span></span><br><span class="line"><span class="variable">$ </span>git rm --cached</span><br></pre></td></tr></table></figure>
<h2 id="Git操作场景示例">Git操作场景示例</h2>
<h3 id="1-删除掉本地不存在的远程分支">1. 删除掉本地不存在的远程分支</h3>
<p>多人合作开发时，如果远程的分支被其他开发删除掉，在本地执行 <code>git branch --all</code> 依然会显示该远程分支，可使用下列的命令进行删除：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 pull 命令，添加 -p 参数</span></span><br><span class="line"><span class="variable">$ </span>git pull -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于下面的命令</span></span><br><span class="line"><span class="variable">$ </span>git fetch -p</span><br><span class="line"><span class="variable">$ </span>git fetch --prune origin</span><br></pre></td></tr></table></figure>
<p>来源：<a href="https://www.jianshu.com/p/93318220cdce">https://www.jianshu.com/p/93318220cdce</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git命令</tag>
      </tags>
  </entry>
  <entry>
    <title>12306自动化抢票实现</title>
    <url>/2023/02/06/12306%E8%87%AA%E5%8A%A8%E6%8A%A2%E7%A5%A8/</url>
    <content><![CDATA[<h1>selenium常用API</h1>
<ul>
<li><code>find_element_by_xxx</code>  返回第一个符合条件<code>WebElement</code>元素</li>
<li><code>find_elements_by_xxx</code>  返回符合条件所有元素包含了 <code>WebEelemnt </code>列表</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>find_element_by_class_name</td>
<td>通过class查询元素</td>
</tr>
<tr>
<td>find_element_by_id</td>
<td>通过ID查询元素</td>
</tr>
<tr>
<td>find_element_by_name</td>
<td>通过name查询元素</td>
</tr>
<tr>
<td>find_element_by_tag_name</td>
<td>通过标签名称</td>
</tr>
<tr>
<td>find_element_by_css_selector</td>
<td>css样式选择</td>
</tr>
<tr>
<td>find_element_by_link_text</td>
<td>通过链接内容查找</td>
</tr>
<tr>
<td>find_element_by_partial_link_text</td>
<td>通过链接内容包含的内容查找，模糊查询</td>
</tr>
<tr>
<td>find_element_by_xpath</td>
<td>通过xpath查找数据</td>
</tr>
</tbody>
</table>
<h1>获取元素属性和文本内容</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取属性</span></span><br><span class="line">element.get_attribute（<span class="string">&#x27;属性名”）</span></span><br><span class="line"><span class="string">#获取文本内容</span></span><br><span class="line"><span class="string">element.text</span></span><br><span class="line"><span class="string"># 输入框输入内容</span></span><br><span class="line"><span class="string">input_element.send_keys（&#x27;</span>Luenci<span class="string">&#x27;）</span></span><br><span class="line"><span class="string"># 元素点击</span></span><br><span class="line"><span class="string">element.click()</span></span><br></pre></td></tr></table></figure>
<h2 id="三种等待方式">三种等待方式</h2>
<ul>
<li>当控制浏览器时，浏览器正在加载页面同时又去获取数据导致浏览器寻找不到需要操作的元素引发异常。</li>
<li>方式一：强制等待，浪费时间
<ul>
<li><code>time.sleep（秒数）</code></li>
</ul>
</li>
<li>方式二：隐性等待，无法控制Ajax请求
<ul>
<li><code>browser.implicit1y_wait（等待时间）</code></li>
</ul>
</li>
<li>方式三：显性等待，每个元素都可以自己定义检查条件。手动编写方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#显性等待-手动编写</span></span><br><span class="line">t = time.time（）</span><br><span class="line"><span class="comment">#定义超时时间</span></span><br><span class="line">timeout = <span class="number">60</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>：</span><br><span class="line">  <span class="keyword">try</span>：</span><br><span class="line">        <span class="comment">#超时时间间隔</span></span><br><span class="line">        time.sleep（<span class="number">0.1</span>）</span><br><span class="line">        ur1_element = browser.find_element_by_class_name（<span class="string">&quot;fav ur1&quot;</span>）</span><br><span class="line">    <span class="keyword">break</span> </span><br><span class="line">  <span class="keyword">except</span>：</span><br><span class="line">        <span class="comment">#超时处理</span></span><br><span class="line">        <span class="keyword">if</span> time.time（）- t &gt; timeout：</span><br><span class="line">          <span class="keyword">break</span> </span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h2 id="系统提供显性等待API">系统提供显性等待API</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入显性等待的API需要的模块</span></span><br><span class="line"><span class="comment"># 1等待对象模块</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverwait</span><br><span class="line"><span class="comment"># 2导入等待条件模块</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="comment"># 3导入查询元素模块</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.创建等待对象</span></span><br><span class="line"><span class="comment"># 参数一浏览器对象</span></span><br><span class="line"><span class="comment"># 参数二超时时间</span></span><br><span class="line"><span class="comment"># 参数三检查元素时间间隔</span></span><br><span class="line">wait = WebDriverwait（browser，<span class="number">5.0</span>，<span class="number">0.5</span>）</span><br><span class="line"><span class="comment"># 2.通过等待对象获取元素</span></span><br><span class="line"><span class="comment"># presence_of_element_located 检查元素是否存在，如果存在就返回如果不存在就继续检查</span></span><br><span class="line"><span class="comment"># visibility_of_element_located 检查元素是否可见</span></span><br><span class="line">linkelement = s wait.until（EC.presence_of_element_located（（By.CLASS_NAME，<span class="string">&quot;favurl&quot;</span>）</span><br><span class="line">link_element.click（）</span><br></pre></td></tr></table></figure>
<h1>12306爬虫实现</h1>
<p>完成代码见：<a href="https://github.com/Lucareful/12306_Tickets">https://github.com/Lucareful/12306_Tickets</a></p>
<ul>
<li>实现步骤
<ul>
<li>1.访问列表页</li>
<li>2.通过时间判定选择点击预订</li>
<li>3.点击账号登录</li>
<li>4.输入用户名和密码（15523750230）</li>
<li>5.截图获取验证码图片</li>
<li>6.发送打码平台获取识别数字</li>
<li>7.定义8个点击坐标</li>
<li>8.模拟点击坐标</li>
<li>9.点击登录</li>
<li>10.点击选择人物</li>
<li>11.点击提交订单</li>
<li>12.点击确认订单</li>
</ul>
</li>
</ul>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="comment"># 判断YDMHTTP模块是否在python环境中（我的是不在，所以加上去）</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.insert(<span class="number">1</span>, <span class="string">r&quot;YDMHTTP.py&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> YDMHTTP <span class="keyword">import</span> decode</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.maximize_window()</span><br><span class="line"></span><br><span class="line">linktypeid = <span class="string">&quot;dc&quot;</span></span><br><span class="line">fs = <span class="string">&quot;北京&quot;</span></span><br><span class="line">ts = <span class="string">&quot;武汉&quot;</span></span><br><span class="line">date = <span class="string">&quot;2020-01-13&quot;</span></span><br><span class="line">flag = <span class="string">&quot;N,N,Y&quot;</span></span><br><span class="line"></span><br><span class="line">base_url = <span class="string">&#x27;https://kyfw.12306.cn/otn/leftTicket/init?linktypeid=&#123;&#125;&amp;fs=&#123;&#125;,BJP&amp;ts=&#123;&#125;,WHN&amp;date=&#123;&#125;&amp;flag=&#123;&#125;&#x27;</span></span><br><span class="line">url = base_url.<span class="built_in">format</span>(linktypeid, fs, ts, date, flag)</span><br><span class="line"></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line">wait = WebDriverWait(browser, <span class="number">10</span>, <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过时间判定选择预定车次</span></span><br><span class="line"><span class="comment"># 寻找tr标签中的 属性id 已 ’ticket_‘ 开头的数据</span></span><br><span class="line">tr_list = wait.until(EC.visibility_of_all_elements_located((By.XPATH, <span class="string">&#x27;//tr[starts-with(@id, &quot;ticket_&quot;)]&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tr <span class="keyword">in</span> tr_list:</span><br><span class="line">    date_string = tr.find_element_by_class_name(<span class="string">&quot;start-t&quot;</span>).text</span><br><span class="line">    <span class="comment"># 判断时间是否在符合你想要的时间范围中</span></span><br><span class="line">    tr.find_element_by_class_name(<span class="string">&#x27;no-br&#x27;</span>).click()</span><br><span class="line">    <span class="comment"># print(date_string)</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 点击账号 异步加载需要显性等待</span></span><br><span class="line">wait.until(EC.visibility_of_element_located((By.LINK_TEXT, <span class="string">&quot;账号登录&quot;</span>))).click()</span><br><span class="line"><span class="comment"># browser.find_element_by_link_text(&quot;账号登录&quot;).click()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入用户名和密码（我将我的用户名和密码保存在了json文件中，若别人使用需要更改）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;account.json&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    account = json.load(f)</span><br><span class="line"></span><br><span class="line">browser.find_element_by_id(<span class="string">&quot;J-userName&quot;</span>).send_keys(account[<span class="string">&quot;username&quot;</span>])</span><br><span class="line">browser.find_element_by_id(<span class="string">&quot;J-password&quot;</span>).send_keys(account[<span class="string">&quot;password&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取全屏截图</span></span><br><span class="line">full_img_data = browser.get_screenshot_as_png()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取验证图片</span></span><br><span class="line">login_img_element = wait.until((EC.visibility_of_element_located((By.ID, <span class="string">&quot;J-loginImg&quot;</span>))))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算截图位置</span></span><br><span class="line"><span class="comment"># 截取验证码的位置</span></span><br><span class="line">scale = <span class="number">2.0</span></span><br><span class="line">x1 = login_img_element.location[<span class="string">&quot;x&quot;</span>]</span><br><span class="line">y1 = login_img_element.location[<span class="string">&quot;y&quot;</span>]</span><br><span class="line">x2 = x1 + login_img_element.size[<span class="string">&quot;width&quot;</span>] * scale</span><br><span class="line">y2 = y1 + login_img_element.size[<span class="string">&quot;height&quot;</span>] * scale</span><br><span class="line"></span><br><span class="line">cut_info = (x1, y1, x2, y2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把全屏图片构建成全屏图片操作对象</span></span><br><span class="line">full_img = Image.<span class="built_in">open</span>(BytesIO(full_img_data))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过截图信息对象截取图片</span></span><br><span class="line">cut_img = full_img.crop(cut_info)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把图片保存到本地</span></span><br><span class="line">cut_img.save(<span class="string">&#x27;demo.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将验证图片发送到打码平台</span></span><br><span class="line">result = decode(<span class="string">&#x27;demo.png&#x27;</span>, codetype=<span class="number">6701</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义八个点击坐标点</span></span><br><span class="line">positions = [</span><br><span class="line">    (<span class="number">7.30</span>*<span class="number">25</span>, <span class="number">140</span>),</span><br><span class="line">    (<span class="number">10.58</span>*<span class="number">25</span>, <span class="number">140</span>),</span><br><span class="line">    (<span class="number">13.83</span>*<span class="number">25</span>, <span class="number">140</span>),</span><br><span class="line">    (<span class="number">17.11</span>*<span class="number">25</span>, <span class="number">140</span>),</span><br><span class="line">    (<span class="number">7.30</span>*<span class="number">25</span>, <span class="number">250</span>),</span><br><span class="line">    (<span class="number">10.58</span>*<span class="number">25</span>, <span class="number">250</span>),</span><br><span class="line">    (<span class="number">13.83</span>*<span class="number">25</span>, <span class="number">250</span>),</span><br><span class="line">    (<span class="number">17.05</span>*<span class="number">25</span>, <span class="number">250</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟点击坐标</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> result:</span><br><span class="line">    position = positions[<span class="built_in">int</span>(num) - <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 动作对象</span></span><br><span class="line">    ActionChains(browser).move_to_element_with_offset(login_img_element, position[<span class="number">0</span>]/<span class="number">2</span>, position[<span class="number">1</span>]/<span class="number">2</span>).click().perform()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 点击登录</span></span><br><span class="line">browser.find_element_by_id(<span class="string">&quot;J-login&quot;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 点击选择乘车人</span></span><br><span class="line">wait.until(EC.visibility_of_element_located((By.ID, <span class="string">&quot;normalPassenger_0&quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 点击提交订单</span></span><br><span class="line">browser.find_element_by_id(<span class="string">&quot;submitOrder_id&quot;</span>).click()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>selenium知识</category>
      </categories>
      <tags>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言中 void* 详解及应用</title>
    <url>/2023/02/06/C%20%E8%AF%AD%E8%A8%80%E4%B8%AD%20void%20%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1>C 语言中 void* 详解及应用</h1>
<p>void 在英文中作为名词的解释为 <strong>“空虚、空间、空隙”</strong>，而在 C 语言中，void 被翻译为**“无类型”<strong>，相应的</strong>void *** 为**“无类型指针”**。</p>
<p>void 似乎只有&quot;注释&quot;和限制程序的作用，当然，这里的&quot;注释&quot;不是为我们人提供注释，而是为编译器提供一种所谓的注释。</p>
<span id="more"></span>
<h2 id="void-的作用">void 的作用</h2>
<p>1.对函数返回的限定，这种情况我们比较常见。</p>
<p>2.对函数参数的限定，这种情况也是比较常见的。</p>
<p>一般我们常见的就是这两种情况：</p>
<ul>
<li>当函数不需要返回值值时，必须使用void限定，这就是我们所说的第一种情况。例如：void func（int a,char *b）。</li>
<li>当函数不允许接受参数时，必须使用void限定，这就是我们所说的第二种情况。例如：int func(void)。</li>
</ul>
<hr>
<h2 id="void-指针的使用规则">void 指针的使用规则</h2>
<p>\1. void 指针可以指向任意类型的数据，就是说可以用任意类型的指针对 void 指针对 void 指针赋值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *a；</span><br><span class="line">void *p；</span><br><span class="line">p=a；</span><br></pre></td></tr></table></figure>
<p>如果要将 void 指针 p 赋给其他类型的指针，则需要强制类型转换，就本例而言：<strong>a=（int *）p</strong>。在内存的分配中我们可以见到 void 指针使用：内存分配函数 malloc 函数返回的指针就是 <strong>void *</strong> 型，用户在使用这个指针的时候，要进行强制类型转换，也就是显式说明该指针指向的内存中是存放的什么类型的数据 <strong>(int *)malloc(1024)</strong> 表示强制规定 malloc 返回的 void* 指针指向的内存中存放的是一个个的 int 型数据。</p>
<p>\2. 在 ANSI C 标准中，不允许对 void 指针进行一些算术运算如 p++ 或 p+=1 等，因为既然 void 是无类型，那么每次算术运算我们就不知道该操作几个字节，例如 char 型操作 sizeof(char) 字节，而 int 则要操作 sizeof(int) 字节。而在 GNU 中则允许，因为在默认情况下，GNU 认为 <strong>void *</strong> 和 <strong>char *</strong> 一样，既然是确定的，当然可以进行一些算术操作，在这里<strong>sizeof(*p)==sizeof(char)</strong>。</p>
<p>void 几乎只有&quot;注释&quot;和限制程序的作用，因为从来没有人会定义一个 void 变量，让我们试着来定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void a;</span><br></pre></td></tr></table></figure>
<p>这行语句编译时会出错，提示**“illegal use of type ‘void’”**。即使 <strong>void a</strong> 的编译不会出错，它也没有任何实际意义。</p>
<p>众所周知，如果指针 p1 和 p2 的类型相同，那么我们可以直接在 p1 和 p2 间互相赋值；如果 p1 和 p2 指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的指针类型转换为左边指针的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float *p1;</span><br><span class="line">int *p2;</span><br><span class="line">p1 = p2;</span><br><span class="line">//其中p1 = p2语句会编译出错，</span><br><span class="line">//提示“&#x27;=&#x27; : cannot convert from &#x27;int *&#x27; to &#x27;float *&#x27;”，必须改为：</span><br><span class="line">p1 = (float *)p2;</span><br></pre></td></tr></table></figure>
<p>而 <strong>void *</strong> 则不同，任何类型的指针都可以直接赋值给它，无需进行强制类型转换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *p1;</span><br><span class="line">int *p2;</span><br><span class="line">p1 = p2;</span><br></pre></td></tr></table></figure>
<p>但这并不意味着，<strong>void *</strong> 也可以无需强制类型转换地赋给其它类型的指针。因为&quot;无类型&quot;可以包容&quot;有类型&quot;，而&quot;有类型&quot;则不能包容&quot;无类型&quot;。</p>
<p>小心使用 void 指针类型:</p>
<p>按照 ANSI(American National Standards Institute) 标准，不能对 void 指针进行算法操作，即下列操作都是不合法的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void * pvoid;</span><br><span class="line">pvoid++; //ANSI：错误</span><br><span class="line">pvoid += 1; //ANSI：错误</span><br><span class="line">//ANSI标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指向数据类型大小的。</span><br><span class="line">//例如：</span><br><span class="line">int *pint;</span><br><span class="line">pint++; //ANSI：正确</span><br></pre></td></tr></table></figure>
<p>pint++ 的结果是使其增大 sizeof(int)。</p>
<p>但是 GNU 则不这么认定，它指定 <strong>void *</strong> 的算法操作与 <strong>char *</strong> 一致。因此下列语句在 GNU 编译器中皆正确：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pvoid++; //GNU：正确</span><br><span class="line">pvoid += 1; //GNU：正确</span><br></pre></td></tr></table></figure>
<p>pvoid++ 的执行结果是其增大了 1。</p>
<p>在实际的程序设计中，为迎合 ANSI 标准，并提高程序的可移植性，我们可以这样编写实现同样功能的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void * pvoid;</span><br><span class="line">((char *)pvoid)++; //ANSI：错误；GNU：正确</span><br><span class="line">(char *)pvoid += 1; //ANSI：错误；GNU：正确</span><br></pre></td></tr></table></figure>
<p>GNU 和 ANSI 还有一些区别，总体而言，GNU 较 ANSI 更&quot;开放&quot;，提供了对更多语法的支持。但是我们在真实设计时，还是应该尽可能地迎合 ANSI 标准。 如果函数的参数可以是任意类型指针，那么应声明其参数为<strong>void *</strong>。</p>
<p>**注：**void 指针可以任意类型的数据，可以在程序中给我们带来一些好处，函数中形为指针类型时，我们可以将其定义为 void 指针，这样函数就可以接受任意类型的指针。如：</p>
<p>典型的如内存操作函数 memcpy 和 memset 的函数原型分别为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void * memcpy(void *dest, const void *src, size_t len);</span><br><span class="line">void * memset ( void * buffer, int c, size_t num );</span><br></pre></td></tr></table></figure>
<p>这样，任何类型的指针都可以传入 memcpy 和 memset 中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型（<a href="https://www.runoob.com/w3cnote/c-general-function.html">参见 C 语言实现泛型编程</a>）。如果 memcpy 和 memset 的参数类型不是 <strong>void *</strong>，而是 <strong>char *</strong>，那才叫真的奇怪了！这样的 memcpy 和 memset 明显不是一个&quot;纯粹的，脱离低级趣味的&quot;函数！void 的出现只是为了一种抽象的需要，如果你正确地理解了面向对象中&quot;抽象基类&quot;的概念，也很容易理解 void 数据类型。正如不能给抽象基类定义一个实例，我们也不能定义一个 void（让我们类比的称 void 为&quot;抽象数据类型&quot;）变量。</p>
<p><em>原文地址：<a href="https://www.cnblogs.com/wuyudong/p/c-void-point.html">https://www.cnblogs.com/wuyudong/p/c-void-point.html</a></em></p>
]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>Void* 知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>C结构体打包技艺</title>
    <url>/2023/02/06/C%E8%AF%AD%E8%A8%80%E6%89%93%E5%8C%85%E6%8A%80%E8%89%BA/</url>
    <content><![CDATA[<h1>失传的 C 结构体打包技艺（转）</h1>
<p>转自： <a href="https://fishc.com.cn/forum.php?mod=viewthread&amp;tid=83418&amp;extra=page%3D2%26filter%3Dtypeid%26typeid%3D571">https://fishc.com.cn/forum.php?mod=viewthread&amp;tid=83418&amp;extra=page%3D2%26filter%3Dtypeid%26typeid%3D571</a></p>
<p><a href="https://en.wikipedia.org/wiki/Eric_S._Raymond">作者：Eric S. Raymond</a><br>
原文链接：<a href="http://www.catb.org/esr/structure-packing">http://www.catb.org/esr/structure-packing</a></p>
<h2 id="谁应阅读本文"><strong>谁应阅读本文</strong></h2>
<p>如果你在内存容量受限的嵌入式系统中写程序，或者编写操作系统内核代码，就有必要了解这项技术。如果数据集巨大，应用时常逼近内存极限，这项技术会有所帮助。倘若你非常非常关心如何最大限度地减少处理器缓存段（cache-line）未命中情况的发生，这项技术也有所裨益。</p>
<hr>
<p>2013 年底，我大量应用了一项 C 语言优化技术，这项技术是我早在二十余年前就已掌握的，但彼时之后，鲜有使用。</p>
<p>通过精心调整结构成体员的顺序，可以在这种情况下大幅减少内存占用。其效果显著——在上述案例中，可以减少 40% 的内存空间。程序应用于更大的软件仓库，也不会因内存耗尽而崩溃。</p>
<p>事出有因。计算机科学课程（正确地）引导人们远离微观优化，转而寻求更理想的算法。计算成本一路走低，令压榨内存的必要性变得越来越低。旧日里，黑客们通过在陌生的硬件架构中跌跌撞撞学习 —— 如今已不多见。</p>
<span id="more"></span>
<hr>
<p>首先需要了解的是，对于现代处理器，C 编译器在内存中放置基本 C 数据类型的方式受到约束，以令内存的访问速度更快。</p>
<p>用行话来说，x86 和 ARM 上的基本 C 类型是“自对齐（self-aligned）”的。关于指针，无论 32 位（4 字节）还是 64 位（8 字节）也都是自对齐的。</p>
<p>我提到“现代处理器”，是因为有些老平台强迫 C 程序违反对齐规则（例如，为 int 指针分配一个奇怪的地址并试图使用它），不仅令速度减慢，还会导致非法指令错误。例如 Sun SPARC 芯片就有这种问题。事实上，如果你下定决心，并恰当地在处理器中设置标志位（e18），在 x86 平台上，也能引发这种错误。</p>
<p>你还可以通过 pragma 指令（通常为 ）强迫编译器不采用处理器惯用的对齐规则。但请别随意运用这种方式，因为它强制生成开销更大、速度更慢的代码。通常，采用我在下文介绍的方式，可以节省相同或相近的内存。<br>
#pragma pack</p>
<hr>
<p>我们来看一个关于变量在内存中分布的简单案例。思考形式如下的一系列变量声明，它们处在一个 C 模块的顶层。</p>
<p>然而实际情况（在 x86、ARM 或其他采用自对齐类型的平台上）如下。存储 p 需要自对齐的 4 或 8 字节空间，这取决于机器字的大小。这是指针对齐 —— 极其严格。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="type">char</span> *p;    <span class="comment">/* 4 or 8 bytes */</span></span><br><span class="line"><span class="number">2.</span> <span class="type">char</span> c;    <span class="comment">/* 1 byte */</span></span><br><span class="line"><span class="number">3.</span> <span class="type">char</span> pad[<span class="number">3</span>]; <span class="comment">/* 3 bytes */</span></span><br><span class="line"><span class="number">4.</span> <span class="type">int</span> x;     <span class="comment">/* 4 bytes */</span></span><br></pre></td></tr></table></figure>
<p>字符数组 pad[3] 意味着在这个结构体中，有 3 个字节的空间被浪费掉了。老派术语将其称之为“废液（slop）”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="type">char</span> *p;</span><br><span class="line"><span class="number">2.</span> <span class="type">char</span> c;</span><br><span class="line"><span class="number">3.</span> <span class="type">short</span> x;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，实际分布将会是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="type">char</span> *p;</span><br><span class="line"><span class="number">2.</span> <span class="type">char</span> c;</span><br><span class="line"><span class="number">3.</span> <span class="type">long</span> x;</span><br></pre></td></tr></table></figure>
<p>我们将得到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="type">char</span> c;</span><br><span class="line"><span class="number">2.</span> <span class="type">char</span> *p;</span><br><span class="line"><span class="number">3.</span> <span class="type">int</span> x;</span><br></pre></td></tr></table></figure>
<p>假如实际内存分布可以写成下面这样：</p>
<p>首先，在此例中，N 将为 0，x 的地址紧随 p 之后，能确保是与指针对齐的，因为指针的对齐要求总比 int 严格。</p>
<p>不过更有可能的情况是，c 将被映射为机器字的首字节。于是乎 M 将会用于填充，以使 p 指针对齐——32 位系统中为 3 字节，64 位系统中为 7 字节。</p>
<p>倘若你希望这些变量占用的空间更少，那么可以交换 x 与 c 的次序。</p>
<p>在讲述这部分内容前，我们先对标量数组做个说明。在具有自对齐类型的平台上，char、short、int、long 和指针数组都没有内部填充，每个成员都与下一个成员自动对齐。</p>
<hr>
<p>通常情况下，结构体实例以其最宽的标量成员为基准进行对齐。编译器之所以如此，是因为此乃确保所有成员自对齐，实现快速访问最简便的方法。</p>
<p>假如你对此有疑惑，ANSI C 提供了一个 宏，可用于读取结构体成员位移。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo1</span> &#123;</span></span><br><span class="line"><span class="number">2.</span> <span class="type">char</span> *p;</span><br><span class="line"><span class="number">3.</span> <span class="type">char</span> c;</span><br><span class="line"><span class="number">4.</span> <span class="type">long</span> x;</span><br><span class="line"><span class="number">5.</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>假定处在 64 位系统中，任何 struct fool 的实例都采用8字节对齐。不出所料，其内存分布将会像下面这样：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo2</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="type">char</span> c;    <span class="comment">/* 1 byte */</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="type">char</span> pad[<span class="number">7</span>]; <span class="comment">/* 7 bytes */</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> <span class="type">char</span> *p;   <span class="comment">/* 8 bytes */</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> <span class="type">long</span> x;    <span class="comment">/* 8 bytes */</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>如果成员是互不关联的变量，c便可能从任意位置起始，pad的大小则不再固定。因为struct foo2的指针需要与其最宽的成员为基准对齐，这变得不再可能。现在 c 需要指针对齐，接下来填充的7个字节被锁定了。</p>
<p>结构体尾填充的通用法则是：编译器将会对结构体进行尾填充，直至它的跨步地址。这条法则决定了 sizeof() 的返回值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo3</span> &#123;</span></span><br><span class="line"><span class="number">2.</span> <span class="type">char</span> *p;   <span class="comment">/* 8 bytes */</span></span><br><span class="line"><span class="number">3.</span> <span class="type">char</span> c;    <span class="comment">/* 1 byte */</span></span><br><span class="line"><span class="number">4.</span> &#125;;</span><br><span class="line"><span class="number">5.</span> </span><br><span class="line"><span class="number">6.</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo3</span> <span class="title">singleton</span>;</span></span><br><span class="line"><span class="number">7.</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo3</span> <span class="title">quad</span>[4];</span></span><br></pre></td></tr></table></figure>
<p><em>复制代码</em></p>
<p>你以为 的值是 9，但实际是 16。它的跨步地址是 。于是，在 quad 数组中，每个成员都有 7 字节的尾填充，因为下个结构体的首个成员需要在 ８ 字节边界上对齐。内存分布就好像这个结构是这样声明的：</p>
<ol>
<li>
<pre><code class="language-c">1. struct foo4 &#123;
2. short s;   /* 2 bytes */
3. char c;    /* 1 byte */
4. &#125;;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">因为 s 只需要 2 字节对齐，跨步地址仅在 c 的 1 字节之后，整个 struct foo4 也只需要 1 字节的尾填充。形式如下：</span><br><span class="line"></span><br><span class="line"> 的返回值将为 4。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. ```c</span><br><span class="line">   1. struct foo5 &#123;</span><br><span class="line">   2. short s;</span><br><span class="line">   3. char c;</span><br><span class="line">   4. int flip:1;</span><br><span class="line">   5. int nybble:4;</span><br><span class="line">   6. int septet:7;</span><br><span class="line">   7. &#125;;</span><br></pre></td></tr></table></figure>




</code></pre>
</li>
</ol>
<p>关于位域需要了解的是，它们是由字（或字节）层面的掩码和移位指令实现的。从编译器的角度来看，struct foo5 中的位域就像 ２ 字节、16 位的字符数组，只用到了其中 12 位。为了使结构体的长度是其最宽成员长度 的整数倍，接下来进行了填充。</p>
<ol>
<li>
<pre><code class="language-c">

1. struct foo6 &#123;
2. char c;
3. struct foo5 &#123;
4. ​     char *p;
5. ​     short x;
6. &#125; inner;
7. &#125;;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">内层结构体成员 char *p 强迫外层结构体与内层结构体指针对齐一致。在 64 位系统中，实际的内存分布将类似这样：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">理解了编译器在结构体中间和尾部插入填充的原因与方式后，我们来看看如何榨出这些废液。此即结构体打包的技艺。</span><br><span class="line"></span><br><span class="line">消除废液最简单的方式，是按对齐值递减重新对结构体成员排序。即让所有指针对齐成员排在最前面，因为在 64 位系统中它们占用 8 字节；然后是 4 字节的 int；再然后是 2 字节的 short，最后是字符。</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">1. struct foo7 &#123;</span><br><span class="line">2.   char c;</span><br><span class="line">3.   struct foo7 *p;</span><br><span class="line">4.   short x;</span><br><span class="line">5. &#125;;</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ol>
<p>将隐含的废液写明，形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">1. struct foo8 &#123;</span><br><span class="line">2.   struct foo8 *p;</span><br><span class="line">3.   short x;</span><br><span class="line">4.   char c;</span><br><span class="line">5. &#125;;</span><br></pre></td></tr></table></figure>
<p>考虑到自对齐，我们看到所有数据域之间都不需填充。因为有较严对齐要求（更长）成员的跨步地址对不太严对齐要求的（更短）成员来说，总是合法的对齐地址。重打包过的结构体只需要尾填充：</p>
<p>注意，重新打包不能确保在所有情况下都能节省空间。将这项技术应用于更靠前 struct foo6 的那个例子，我们得到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo9</span> &#123;</span></span><br><span class="line"><span class="number">2.</span>   <span class="class"><span class="keyword">struct</span> <span class="title">foo9_inner</span> &#123;</span></span><br><span class="line"><span class="number">3.</span>      <span class="type">char</span> *p;    <span class="comment">/* 8 bytes */</span></span><br><span class="line"><span class="number">4.</span>      <span class="type">int</span> x;     <span class="comment">/* 4 bytes */</span></span><br><span class="line"><span class="number">5.</span>      <span class="type">char</span> pad[<span class="number">4</span>]; <span class="comment">/* 4 bytes */</span></span><br><span class="line"><span class="number">6.</span>   &#125; inner;</span><br><span class="line"><span class="number">7.</span>   <span class="type">char</span> c;       <span class="comment">/* 1 byte */</span></span><br><span class="line"><span class="number">8.</span>   <span class="type">char</span> pad[<span class="number">7</span>];    <span class="comment">/* 7 bytes */</span></span><br><span class="line"><span class="number">9.</span> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果还是 24 字节，因为 c 无法作为内层结构体的尾填充。要想节省空间，你需要得新设计数据结构。<br>
<strong>棘手的标量案例</strong></p>
<p>#define<br>
请当心，重打包结构体时，枚举型变量通常是 int，这与编译器相关；但也可能是 short、long、甚至默认为 char。编译器可能会有 预处理指令或命令行选项指定枚举的尺寸。</p>
<p>以上两种情况，最好用 来检查存储尺寸。</p>
<hr>
<p>尽管按尺寸重排是最简单的消除废液的方式，却不一定是正确的方式。还有两个问题需要考量：可读性与缓存局部性。</p>
<p>笨拙地、机械地重排结构体可能有损可读性。倘若有可能，最好这样重排成员：将语义相关的数据放在一起，形成连贯的组。最理想的情况是，结构体的设计应与程序的设计相通。</p>
<p>为保持可读性所做的工作（将相关和同时访问的数据放在临近位置）也会提高缓存段的局部性。这些都是需要明智地重排，并对数据的存取模式了然于心的原因。</p>
<p>是的，某些时候，这种做法与前文将相关数据放入与缓存段长度相同块的做法矛盾。多线程的确是个难题。缓存段弹跳和其他多线程优化问题是很高级的话题，值得单独为它们写份指导。这里我所能做的，只是让你了解有这些问题存在。<br>
<strong>其他打包技术</strong></p>
<p>你可能会有一点儿存取时间的损失，但只要将工作集合压缩得足够小，那点损失可以靠避免缓存未命中补偿。</p>
<p>这不仅减小了结构体的可见尺寸，还可以消除废液和/或创造额外的机会来进行重新排序。这种良性串连的效果不难被触发。</p>
<hr>
<p>clang 编译器有个 Wpadded 选项，可以生成有关对齐和填充的信息。</p>
<hr>
<p>读者可以下载一段程序源代码 ，验证上文有关标量和结构体尺寸的结论。</p>
<p>理解这些规则的第二个层次是，知其何时及如何会被打破。在我学习它们的日子里（1980 年代早期），我们把不理解这些规则的人称为“所有机器都是 VAX 综合症”的牺牲品。记住，世上所有电脑并非都是 PC。</p>
]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>扩展知识</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言笔记（1）</title>
    <url>/2023/02/06/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p><em>ps:先举三反一，再举一反三，学习就应该是这样，先模仿，再改进，最后实现自己的创意！					--小甲鱼论坛</em></p>
<h2 id="C语言中各种数据类型所占用的存储空间的大小">C语言中各种数据类型所占用的存储空间的大小</h2>
<ul>
<li>
<p>int—32位	四个字节</p>
</li>
<li>
<p>float —32位	四个字节</p>
</li>
<li>
<p>char—8位	一个字节</p>
</li>
<li>
<p>double----64位	8个字节</p>
</li>
<li>
<p>bool----16位	2个字节</p>
</li>
<li>
<p>long----32位	四个字节</p>
</li>
</ul>
<h3 id="整数类型">整数类型</h3>
<p>下表列出了关于标准整数类型的存储大小和值范围的细节：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">存储大小</th>
<th style="text-align:left">值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">1 字节</td>
<td style="text-align:left">-128 到 127 或 0 到 255</td>
</tr>
<tr>
<td style="text-align:left">unsigned char</td>
<td style="text-align:left">1 字节</td>
<td style="text-align:left">0 到 255</td>
</tr>
<tr>
<td style="text-align:left">signed char</td>
<td style="text-align:left">1 字节</td>
<td style="text-align:left">-128 到 127</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">2 或 4 字节</td>
<td style="text-align:left">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td style="text-align:left">unsigned int</td>
<td style="text-align:left">2 或 4 字节</td>
<td style="text-align:left">0 到 65,535 或 0 到 4,294,967,295</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:left">2 字节</td>
<td style="text-align:left">-32,768 到 32,767</td>
</tr>
<tr>
<td style="text-align:left">unsigned short</td>
<td style="text-align:left">2 字节</td>
<td style="text-align:left">0 到 65,535</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">4 字节</td>
<td style="text-align:left">-2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td style="text-align:left">unsigned long</td>
<td style="text-align:left">4 字节</td>
<td style="text-align:left">0 到 4,294,967,295</td>
</tr>
</tbody>
</table>
<h3 id="浮点类型">浮点类型</h3>
<p>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">存储大小</th>
<th style="text-align:left">值范围</th>
<th style="text-align:left">精度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">4 字节</td>
<td style="text-align:left">1.2E-38 到 3.4E+38</td>
<td style="text-align:left">6 位小数</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">8 字节</td>
<td style="text-align:left">2.3E-308 到 1.7E+308</td>
<td style="text-align:left">15 位小数</td>
</tr>
<tr>
<td style="text-align:left">long double</td>
<td style="text-align:left">16 字节</td>
<td style="text-align:left">3.4E-4932 到 1.1E+4932</td>
<td style="text-align:left">19 位小数</td>
</tr>
</tbody>
</table>
<h3 id="void-类型">void 类型</h3>
<p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">类型与描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>函数返回为空</strong> C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 <strong>void exit (int status);</strong></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>函数参数为空</strong> C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 <strong>int rand(void);</strong></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>指针指向 void</strong> 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 <strong>void *malloc( size_t size );</strong> 返回指向 void 的指针，可以转换为任何数据类型。</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h2 id="C语言运算符优先级">C语言运算符优先级</h2>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>名称或含义</th>
<th>使用形式</th>
<th>结合方向</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>[]</td>
<td>数组下标</td>
<td>数组名[常量表达式]</td>
<td>左到右</td>
<td></td>
</tr>
<tr>
<td>()</td>
<td>圆括号</td>
<td>（表达式）/函数名(形参表)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>.</td>
<td>成员选择（对象）</td>
<td>对象.成员名</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>-&gt;</td>
<td>成员选择（指针）</td>
<td>对象指针-&gt;成员名</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>-</td>
<td>负号运算符</td>
<td>-表达式</td>
<td>右到左</td>
<td>单目运算符</td>
</tr>
<tr>
<td>(类型)</td>
<td>强制类型转换</td>
<td>(数据类型)表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>++</td>
<td>自增运算符</td>
<td>++变量名/变量名++</td>
<td>单目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>–</td>
<td>自减运算符</td>
<td>–变量名/变量名–</td>
<td>单目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>*</td>
<td>取值运算符</td>
<td>*指针变量</td>
<td>单目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&amp;</td>
<td>取地址运算符</td>
<td>&amp;变量名</td>
<td>单目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>!</td>
<td>逻辑非运算符</td>
<td>!表达式</td>
<td>单目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>~</td>
<td>按位取反运算符</td>
<td>~表达式</td>
<td>单目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>sizeof</td>
<td>长度运算符</td>
<td>sizeof(表达式)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>/</td>
<td>除</td>
<td>表达式/表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>表达式*表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>%</td>
<td>余数（取模）</td>
<td>整型表达式/整型表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>+</td>
<td>加</td>
<td>表达式+表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>表达式-表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>&lt;&lt;</td>
<td>左移</td>
<td>变量&lt;&lt;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>变量&gt;&gt;表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>&gt;</td>
<td>大于</td>
<td>表达式&gt;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
<td>表达式&gt;=表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>表达式&lt;表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>表达式&lt;=表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>==</td>
<td>等于</td>
<td>表达式==表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
<td>表达式!= 表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>&amp;</td>
<td>按位与</td>
<td>表达式&amp;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>9</td>
<td>^</td>
<td>按位异或</td>
<td>表达式^表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>10</td>
<td>|</td>
<td>按位或</td>
<td>表达式|表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>表达式&amp;&amp;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>12</td>
<td>||</td>
<td>逻辑或</td>
<td>表达式||表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>13</td>
<td>?:</td>
<td>条件运算符</td>
<td>表达式1? 表达式2: 表达式3</td>
<td>右到左</td>
<td>三目运算符</td>
</tr>
<tr>
<td>14</td>
<td>=</td>
<td>赋值运算符</td>
<td>变量=表达式</td>
<td>右到左</td>
<td></td>
</tr>
<tr>
<td>/=</td>
<td>除后赋值</td>
<td>变量/=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>*=</td>
<td>乘后赋值</td>
<td>变量*=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>%=</td>
<td>取模后赋值</td>
<td>变量%=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>+=</td>
<td>加后赋值</td>
<td>变量+=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>-=</td>
<td>减后赋值</td>
<td>变量-=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>左移后赋值</td>
<td>变量&lt;&lt;=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>右移后赋值</td>
<td>变量&gt;&gt;=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&amp;=</td>
<td>按位与后赋值</td>
<td>变量&amp;=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>^=</td>
<td>按位异或后赋值</td>
<td>变量^=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>|=</td>
<td>按位或后赋值</td>
<td>变量|=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>,</td>
<td>逗号运算符</td>
<td>表达式,表达式,…</td>
<td>左到右</td>
<td>从左向右顺序运算</td>
</tr>
</tbody>
</table>
<p>注：同一优先级的运算符，运算次序由结合方向所决定。</p>
<h2 id="break和continue语句区别">break和continue语句区别</h2>
<ul>
<li>
<p>break语句</p>
</li>
<li>
<p>结束当前循环</p>
</li>
<li>
<p>continue语句</p>
<ul>
<li>跳过本次循环</li>
</ul>
</li>
</ul>
<h2 id="二维下标直接索引和指针间接索引的相互转化">二维下标直接索引和指针间接索引的相互转化</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*（<span class="built_in">array</span> + i） = <span class="built_in">array</span>[i]</span><br><span class="line">*(*(<span class="built_in">array</span> + i) + j) = <span class="built_in">array</span>[i][j]</span><br><span class="line">*(*(*(<span class="built_in">array</span> + i) + j) + K) = <span class="built_in">array</span>[i][j][k]</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>
<h2 id="二维数组和数组指针的关系">二维数组和数组指针的关系</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">3</span>] = <span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**(p+1): %d\n&quot;</span>, **(p+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**(array+1): %d\n&quot;</span>, **(<span class="built_in">array</span>+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array[1][0]: %d\n&quot;</span>, <span class="built_in">array</span>[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*(*(p+1)+2): %d\n&quot;</span>, *(*(p+<span class="number">1</span>)+<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*(*(array+1)+2): %d\n&quot;</span>, *(*(<span class="built_in">array</span>+<span class="number">1</span>)+<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array[1][2]: %d\n&quot;</span>, <span class="built_in">array</span>[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="void指针和NULL指针">void指针和NULL指针</h2>
<h3 id="Void指针">Void指针</h3>
<ul>
<li>void指针我们把它称之为通用指针，就是可以指向任意类型的数据。也就是说，任何类型的指针都可以赋值给void指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">int</span> *pi = &amp;num;</span><br><span class="line">    <span class="type">char</span> *ps = <span class="string">&quot;Luenci&quot;</span>;</span><br><span class="line">    <span class="type">void</span> *pv;</span><br><span class="line"></span><br><span class="line">    pv = pi;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pi:%p, pv:%p\n&quot;</span>, pi,pv);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pv:%d\n&quot;</span>, *(<span class="type">int</span> *)pv);</span><br><span class="line"></span><br><span class="line">    pv = (<span class="type">char</span> *)ps;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ps:%p, pv:%p\n&quot;</span>, ps, pv);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pv:%s\n&quot;</span>, (<span class="type">char</span> *)pv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NULL指针">NULL指针</h3>
<ul>
<li>
<p>当你还不清楚要将指针初始值为什么地址时，请先将它初始化为**<code>NULL</code>**；在对指针进行解引用时，先检查该指针是否为NULL。这种策略可以为今后编写大型程序 节省大量的	调试时间。</p>
</li>
<li>
<pre><code class="language-c">#define  NULL ((void *)0)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">//</span><br><span class="line">// Created by Luenci on 2019/10/5.</span><br><span class="line">//</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int null_pointer()&#123;</span><br><span class="line">    int *p1;</span><br><span class="line">    int *p2 = NULL;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d\n&quot;, *p1);</span><br><span class="line">    printf(&quot;%d\n&quot;, *p2);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
<h2 id="指向指针的指针">指向指针的指针</h2>
<ul>
<li>
<pre><code class="language-c">int main()&#123;

    int num = 520;
    int *p = &amp;num;
    int **pp = &amp;p;

    printf(&quot;num: %d\n&quot;, num);
    printf(&quot;*p: %d\n&quot;, *p);
    printf(&quot;**PP: %d\n&quot;, **pp);
    printf(&quot;&amp;p: %p, pp:%p\n&quot;, &amp;p, pp);
    printf(&quot;&amp;num:%p, p:%p, *pp:%p\n&quot;, &amp;num,p,*pp);
 
    return 0;
&#125;
    
    out:
    num: 520
	*p: 520
	**PP: 520
	&amp;p: 0061FF14, pp:0061FF14
	&amp;num:0061FF18, p:0061FF18, *pp:0061FF18
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 指针数组和指向指针的指针</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  int pointer_array()&#123;</span><br><span class="line">  </span><br><span class="line">      char *cBooks[] = &#123;</span><br><span class="line">              &quot;&lt;c程序设计语言&gt;&quot;,</span><br><span class="line">              &quot;&lt;c专家编程&gt;&quot;,</span><br><span class="line">              &quot;&lt;c和指针&gt;&quot;,</span><br><span class="line">              &quot;&lt;c prime plus&gt;&quot;,</span><br><span class="line">              &quot;&lt;C study&gt;&quot;</span><br><span class="line">      &#125;;</span><br><span class="line">  </span><br><span class="line">      char **byLuenci;</span><br><span class="line">      char **byGood[4];</span><br><span class="line">  </span><br><span class="line">      byLuenci = &amp;cBooks[4];</span><br><span class="line">      byGood[0] = &amp;cBooks[0];</span><br><span class="line">      byGood[1] = &amp;cBooks[1];</span><br><span class="line">      byGood[2] = &amp;cBooks[2];</span><br><span class="line">      byGood[3] = &amp;cBooks[3];</span><br><span class="line">  </span><br><span class="line">      printf(&quot;Luenci拥有的书: %s\n&quot;, *byLuenci);</span><br><span class="line">      printf(&quot;Luenci喜欢的图书有：\n&quot;);</span><br><span class="line">  </span><br><span class="line">      int i;</span><br><span class="line">  </span><br><span class="line">      for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">          printf(&quot;%s\n&quot;,*byGood[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  out: </span><br><span class="line">  Luenci拥有的书: &lt;C study&gt;</span><br><span class="line">  Luenci喜欢的图书有：</span><br><span class="line">  &lt;c程序设计语言&gt;</span><br><span class="line">  &lt;c专家编程&gt;</span><br><span class="line">  &lt;c和指针&gt;</span><br><span class="line">  &lt;c prime plus&gt;</span><br></pre></td></tr></table></figure>




</code></pre>
</li>
</ul>
<h1>常量</h1>
<ul>
<li>定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">520</span>，‘a’, <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> price 520</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A <span class="string">&#x27;a&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用const关键字修饰</span></span><br><span class="line">    </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> price = <span class="number">520</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> A = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> pi = <span class="number">3.14</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="指向常量的指针">指向常量的指针</h2>
<ul>
<li>指针可以修改为指向不同的常量</li>
<li>指针可以修改为指向不同的变量</li>
<li>可以通过解引用来读取指针指向的数据</li>
<li>不可以通过解引用修改指针指向的数据</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num =<span class="number">520</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> cnum = <span class="number">880</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *pc = &amp;cnum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cnum:%d, &amp;cum:%p \n&quot;</span>, cnum, &amp;cnum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pc:%d, pc:%p\n&quot;</span>, *pc, pc);</span><br><span class="line"></span><br><span class="line">    pc = &amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num:%d, &amp;num:%p \n&quot;</span>, num, &amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pc:%d, pc:%p\n&quot;</span>, *pc, pc);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>函数</h1>
<h2 id="结构">结构</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类型名 函数名（参数列表）</span><br><span class="line">&#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数的声明">函数的声明</h2>
<ul>
<li>
<p>所谓的声明（Declaration），就是告诉编译器我要是用这个函数，你现在没有找到它的定义不要紧，请不要报错，稍后我将会把它补上。</p>
</li>
<li>
<p>函数的参数和返回值</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_c</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="comment">// a？b:c 当a的值为真时，返回b的值；否则返回c的值</span></span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x:y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            result += n;</span><br><span class="line">        &#125;<span class="keyword">while</span> (n-- &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_c</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; ###### \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;##    ##\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;##      \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;##      \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;##    ##\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; ###### \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    print_c();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n,x,y;</span><br><span class="line"><span class="comment">//    printf(&quot;请输入n的值：&quot;);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入x,y的值：&quot;</span>);</span><br><span class="line"><span class="comment">//    scanf(&quot;%d&quot;, &amp;n);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    printf(&quot;1+2+3+...+(n-1)+n的结果是：%d\n&quot;,sum(n));</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x,y中最大值的值为：%d\n&quot;</span>, max(x,y));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="形参和实参">形参和实参</h2>
<ul>
<li>用于数据传输，形参就相当与一个占位符，只在函数内部有效。</li>
</ul>
<h2 id="传值和传址">传值和传址</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *temp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In swap 互换前：x %d, y %d\n&quot;</span>, *x,*y);</span><br><span class="line">    temp = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In swap 互换后：x %d, y %d\n&quot;</span>, *x,*y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">3</span>, y = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In main 互换前：x %d, y %d\n&quot;</span>, x,y);</span><br><span class="line">    swap(&amp;x,&amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In main 互换后：x %d, y %d\n&quot;</span>, x,y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="传数组">传数组</h2>
<ul>
<li>实际上传过去的是数组的地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_array</span><span class="params">(<span class="type">int</span> b[<span class="number">10</span>])</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof b: %d\n&quot;</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof a:%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    get_array(a);</span><br><span class="line">    </span><br><span class="line">out:</span><br><span class="line"><span class="keyword">sizeof</span> a:<span class="number">40</span></span><br><span class="line"><span class="keyword">sizeof</span> b: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="可变参数">可变参数</h2>
<ul>
<li>引入 头文件**#include&lt;stdarg.h&gt;**</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n, ...)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    va_list vap;</span><br><span class="line"></span><br><span class="line">    va_start(vap, n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        sum += va_arg(vap, <span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(vap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result,result2,result3;</span><br><span class="line"></span><br><span class="line">    result = sum(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result:%d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    result2 = sum(<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result2:%d\n&quot;</span>, result2);</span><br><span class="line"></span><br><span class="line">    result3 = sum(<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result3:%d\n&quot;</span>, result3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>指针函数</h1>
<ul>
<li>使用指针变量作为函数的返回值，就是指针函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">// Created by Luenci on 2019/10/8.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">char *getchartchar();</span><br><span class="line"></span><br><span class="line">char *getchart(char c)&#123;</span><br><span class="line">    switch (c)</span><br><span class="line">    &#123;</span><br><span class="line">        case &#x27;A&#x27;:</span><br><span class="line">            return &quot;Apple&quot;;</span><br><span class="line">        case &#x27;B&#x27;:</span><br><span class="line">            return &quot;Banana&quot;;</span><br><span class="line">        case &#x27;C&#x27;:</span><br><span class="line">            return &quot;Cat&quot;;</span><br><span class="line">        case &#x27;D&#x27;:</span><br><span class="line">            return &quot;Dog&quot;;</span><br><span class="line">        default:</span><br><span class="line">            return &quot;None&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char input;</span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入一个字母：&quot;);</span><br><span class="line">    scanf(&quot;%c&quot;, &amp;input);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%s\n&quot;, getchart(input));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">in:A</span><br><span class="line">out:Apple</span><br></pre></td></tr></table></figure>
<ul>
<li><em><strong>PS:不要返回局部变量的指针</strong></em></li>
</ul>
<h1>函数指针</h1>
<ul>
<li>指针函数  - - &gt; *<em>int <em>p();</em></em></li>
<li>函数指针 - -  &gt; *<em>int  (<em>p)();</em></em></li>
</ul>
<h2 id="函数指针作为参数">函数指针作为参数</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">clac</span><span class="params">(<span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">clac</span><span class="params">(<span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (*fp)(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3 + 5 = %d\n&quot;</span>, clac(add, <span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3 - 5 = %d\n&quot;</span>, clac(sub, <span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="函数指针作为返回值">函数指针作为返回值</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> (*)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> (*slect(<span class="type">char</span>))(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>),<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (*fp)(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*slect(<span class="type">char</span> op))(<span class="type">int</span>, <span class="type">int</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> add;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> sub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num1, num2;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个式子 (如 1+3) :&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%c%d&quot;</span>, &amp;num1, &amp;op, &amp;num2);</span><br><span class="line"></span><br><span class="line">    fp = slect(op);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %c %d = %d\n&quot;</span>, num1, op, num2, calc(fp, num1, num2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>局部变量和全局变量</h1>
<h2 id="局部变量">局部变量</h2>
<ul>
<li>不同函数的变量无法相互访问</li>
</ul>
<h2 id="全局变量">全局变量</h2>
<ul>
<li>如果不对全局变量进行初始化，那么它会自动初始化为0.</li>
<li>如果函数在内部存在一个与全局变量同名的局部变量，编译器不会报错，而是在函数中屏蔽全局变量。</li>
</ul>
<h2 id="exsten关键字">exsten关键字</h2>
<ul>
<li>告诉编译器我等下会定义变量，不要报错</li>
</ul>
<h2 id="不要大量的使用全局变量">不要大量的使用全局变量</h2>
<ul>
<li>使用全局变量会使你的程序占用更多的内存，因为全局变量从定义时候开始，知道程序退出才释放。</li>
<li>污染命名空间</li>
<li>提高了程序耦合性</li>
</ul>
<h1>作用域和链接属性</h1>
<ul>
<li>当变量被定义在不同的位置时，它的作用域的范围是不一样的，这个作用范围就是我们所说的作用域</li>
<li>C语言编译器可以确认四种不同类型的作用域：
<ul>
<li>代码块的作用域</li>
<li>文件作用域</li>
<li>原型作用域</li>
<li>函数作用域</li>
</ul>
</li>
</ul>
<h2 id="代码块作用域（Block-scope）">代码块作用域（Block scope）</h2>
<ul>
<li>在代码块中定义的变量，具有代码块作用域。作用范围是从变量定义的位置开始，到标志代码块结束的大括号（}）处。</li>
</ul>
<h2 id="文件作用域（file-scope）">文件作用域（file scope）</h2>
<ul>
<li>任何在代码块之外声明的标识符都具有文件作用域，作用域的范围是从他们的声明位置开始，到文件的结尾处都是可以访问的。</li>
</ul>
<h2 id="原型作用域（prototype-scope）">原型作用域（prototype scope）</h2>
<ul>
<li>原型作用域只适用于那些在函数原型中声明的参数名。</li>
</ul>
<h2 id="函数作用域（function-scope）">函数作用域（function scope）</h2>
<ul>
<li>函数作用域只适合于<strong>goto语句</strong>的标签，作用将<strong>goto语句</strong>得标签限制在同一个函数内部，以防止出现重名的标签。</li>
</ul>
<h1>定义和声明</h1>
<ul>
<li>当一个变量被定义的时候，编译器为变量申请内存空间并填充值</li>
<li>当一个变量被声明的时候，编译器就知道该变量被定义在其他地方</li>
<li>声明是通知编译器该变量名及相关的类型已经存在，不需要再为此申请内存空间。</li>
<li>局部变量即是定义又是声明</li>
<li>定义只能来一次，否则就叫做重复定义某个同名的变量；而声明可以由你很多次。</li>
</ul>
<h1>链接属性</h1>
<ul>
<li>
<p>external（外部的）</p>
</li>
<li>
<p>多个文件中声明的同名标识符表示一个实体</p>
</li>
<li>
<p>internal（内部的）</p>
<ul>
<li>单个文件中声明的同名标识符表示同一个实体</li>
</ul>
</li>
<li>
<p>none（无）</p>
<ul>
<li>声明的同名标识符被当做独立的不同实体</li>
</ul>
</li>
<li>
<p>只有具备文件作用域的标识符才能拥有<strong>external</strong>或<strong>internal</strong>的链接属性，其他作用域的标识符都是<strong>none</strong>属性。</p>
</li>
<li>
<p>默认情况下，具备文件的作用域的标识符拥有<strong>external</strong>属性。也就是说该标识符允许跨文件访问。对于<strong>external</strong>属性的标识符，无论在不同文件中声明多少次，表示的都是一个实体。</p>
</li>
<li>
<p>使用<strong>static</strong>关键字可以使得原先拥有的<strong>external</strong>属性的标识符变为<strong>internal</strong>属性。这里有两点需要注意：</p>
<ul>
<li>使用<strong>static</strong>关键字修改链接属性，只对具有文件作用域的标识符生效（对于拥有其他作用域的标志符是另一种功能）</li>
<li>链接属性只能修改一次，也就是说一旦将标识符的链接属性改为<strong>internal</strong>，就无法变回<strong>external</strong>。</li>
</ul>
</li>
</ul>
<h1>生存期和存储类型</h1>
<h2 id="C语言变量拥有两种生存周期">C语言变量拥有两种生存周期</h2>
<ul>
<li>
<p>静态存储器</p>
</li>
<li>
<p>自动存储器</p>
</li>
<li>
<p>具有文件作用域的变量属于静态存储器，函数也属于静态存储器。属于静态存储器的变量在程序执行期间将一直占据存储空间，直到程序关闭才释放</p>
</li>
<li>
<p>具有代码块作用域的变量一般情况下属于自动存储器。属于自动存储期的变量在代码块结束时将自动释放。</p>
</li>
</ul>
<h2 id="存储类型">存储类型</h2>
<ul>
<li>存储类型其实是指存储变量值的内存类型，C语言提供了五种类型。</li>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>typedef</li>
</ul>
]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言笔记（2）</title>
    <url>/2023/02/06/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<p><em>先举三反一，再举一反三，学习就应该是这样，先模仿，再改进，最后实现自己的创意！					--小甲鱼论坛</em></p>
<h1>递归</h1>
<ul>
<li>调用函数本身</li>
<li>设置递归结束条件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/11.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">fact</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (count--)&#123;</span><br><span class="line">        fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">fact</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        result = num * fact(num<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="comment">//    fun();</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">long</span> re;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入您要求阶乘的数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">    re = fact(num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, re);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>汉罗塔</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> x, <span class="type">char</span> y, <span class="type">char</span> z)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> x, <span class="type">char</span> y, <span class="type">char</span> z)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c --&gt; %c \n&quot;</span>, x,z);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 将前n-1个圆盘借助z移动到y</span></span><br><span class="line">        hanoi(n<span class="number">-1</span>, x, z, y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c --&gt; %c \n&quot;</span>, x,z);</span><br><span class="line">        <span class="comment">// 将前n-1个圆盘借助x移动到z</span></span><br><span class="line">        hanoi(n<span class="number">-1</span>, y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入您的层数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    hanoi(n, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>快速排序</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/11.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[], <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = left, j = right;</span><br><span class="line">    <span class="type">int</span> temp;   <span class="comment">// 交换的中间变量</span></span><br><span class="line">    <span class="type">int</span> pivot; <span class="comment">// 基准点</span></span><br><span class="line"></span><br><span class="line">    pivot = <span class="built_in">array</span>[(left + right) / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="comment">// 从右往左找到大于等于基准点的元素</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">array</span>[i] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右到左找到小于等于基准点的元素</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">array</span>[j] &gt; pivot) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 i &lt;= j,则互换</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">            temp = <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="built_in">array</span>[i] = <span class="built_in">array</span>[j];</span><br><span class="line">            <span class="built_in">array</span>[j] = temp;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; j) &#123;</span><br><span class="line">        quick_sort(<span class="built_in">array</span>, left, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; right) &#123;</span><br><span class="line">        quick_sort(<span class="built_in">array</span>, i, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">73</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">101</span>, <span class="number">78</span>, <span class="number">109</span>, <span class="number">66</span>, <span class="number">48</span>, <span class="number">88</span>, <span class="number">135</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算数组的长度</span></span><br><span class="line">    length = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    quick_sort(<span class="built_in">array</span>, <span class="number">0</span>, length<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的结果是：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d ,&quot;</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1>动态内存管理</h1>
<ul>
<li>malloc
<ul>
<li>申请动态内存空间</li>
</ul>
</li>
<li>free
<ul>
<li>释放动态内存空间</li>
</ul>
</li>
<li>calloc
<ul>
<li>申请并初始化一系列内存空间</li>
</ul>
</li>
<li>realloc
<ul>
<li>重新分配内训空间</li>
</ul>
</li>
</ul>
<h2 id="malloc函数">malloc函数</h2>
<ul>
<li>
<p>函数原型</p>
<ul>
<li>void *malloc（size_t size）</li>
</ul>
</li>
<li>
<p>malloc函数向系统申请分配size个字节的内存空间，并返回一个指向这块空间的地址。</p>
</li>
<li>
<p>如果函数调用成功，返回一个指向申请的内存空间的指针，由于返回类型是void 指针（void * ）， 所以它是可以被转换成任何类型的数据；如果函数调用失败，返回值是NULL。另外，如果size的参数设置为0，返回值也可能是NULL，但这并不意味着函数调用失败。</p>
</li>
</ul>
<h2 id="free函数">free函数</h2>
<ul>
<li>函数原型
<ul>
<li>void free（void *ptr）</li>
</ul>
</li>
<li>free函数释放<strong>ptr</strong>参数指向的内存空间。该内存空间必须是有<strong>malloc</strong>，<strong>calloc</strong>或<strong>realloc</strong>函数申请的。否则，该函数将导致未定义行为。如果ptr参数是NULL，则不执行任何操作。注意：该函数并不会修改ptr参数的值，所以调用后仍然指向原来的地方（变为非法空间）。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/12.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ptr == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配内存失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您输入的整数是:%d\n&quot;</span>, *ptr);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您输入的整数是:%d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="内存泄漏">内存泄漏</h2>
<ul>
<li>隐式内存泄漏
<ul>
<li>用完内存块没有及时使用free函数释放</li>
</ul>
</li>
<li>丢失内存块的地址</li>
</ul>
<h1>初始化内存空间</h1>
<ul>
<li><strong>mem</strong>开头的函数被编入字符串标准库，函数的声明包含在<strong>string.h</strong>这个头文件中：
<ul>
<li>memset – 使用一个常量字节填充空间</li>
<li>memcpy – 拷贝内存空间</li>
<li>memmove – 拷贝内存空间</li>
<li>memcmp – 比较内存空间</li>
<li>memchr – 在内存空间中搜索一个字符</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/12.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span>  i;</span><br><span class="line"></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(ptr == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(ptr, <span class="number">0</span>, N * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i= <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    putchar(&quot;\n&quot;);</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、含义不同。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">用单引号引起的一个字符实际上代表一个整数，整数值对应于该字符在编译器采用的字符集中的序列值。而一般我们的编译器采用的都是ASCII字符集。因此&#x27;s&#x27;的含义其实和十进制数115的含义是一致的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">而用双引号引起的字符串，代表的是一个指向无名数组起始字符的指针。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、大小不同。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">用单引号引起的一个字符大小就是一个字节。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">而用双引号引起的字符串大小是字符的总大小+1，因为用双引号引起的字符串会在字符串末尾添加一个二进制为0的字符&#x27;\0&#x27;。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="calloc函数">calloc函数</h2>
<ul>
<li>函数原型
<ul>
<li>void *calloc(size_t nmemb, sizet_t size);</li>
</ul>
</li>
<li>calloc函数在内存中动态地申请nmemb个长度为size的连续内存空间（即申请的总空间尺寸为nmemb * size），这些内存空间全部被初始化为 0.</li>
<li>calloc函数与malloc函数的一个重要区别是：
<ul>
<li>calloc函数在申请完内存后，自动初始化该内存空间为零</li>
<li>malloc函数不进行初始化操作，里面数据是随机的</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两者等价</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// calloc() 分配内存空间并初始化</span></span><br><span class="line"><span class="type">int</span> *ptr = （<span class="type">int</span> *）<span class="built_in">calloc</span>（<span class="number">8</span>， <span class="keyword">sizeof</span>（<span class="type">int</span>））；</span><br><span class="line"></span><br><span class="line"><span class="comment">//malloc()分配内存空间并用memset（）初始化</span></span><br><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>))；</span><br><span class="line"><span class="built_in">memset</span>(prt, <span class="number">0</span>, <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>
<h1>realloc函数</h1>
<ul>
<li>如果ptr参数为NULL，那么调用该函数就相当于调用malloc（size）</li>
<li>如果size参数为0，并且ptr参数不为NULL，那么调用该函数就相当于调用free（ptr）</li>
<li>除非ptr参数为NULL，否则ptr的值必须由先前调用malloc，calloc或realloc函数返回。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, num;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *ptr = <span class="literal">NULL</span>;<span class="comment">// 注意这里必须初始化为NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数：（输入-1表示结束）&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        ptr = (<span class="type">int</span> *)<span class="built_in">realloc</span>(ptr, count * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">if</span>(ptr == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ptr[count<span class="number">-1</span>] = num;</span><br><span class="line">    &#125;<span class="keyword">while</span>(num != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入的整数分别是：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;count ; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ptr[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>c语言的内存布局</h1>
<p><img src="https://i.ibb.co/LNtmKzb/1570944470659.png" alt="c"></p>
<p><img src="https://i.ibb.co/8PF6XrX/1570944566357.png" alt="cc"></p>
<h2 id="代码段">代码段</h2>
<ul>
<li>代码段（Text segment）通常是指用来存放在程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读。在代码段中，也有可能包含一些只读的常熟变量，例如字符串常量等。</li>
</ul>
<h2 id="BSS段">BSS段</h2>
<ul>
<li>BSS段（BSS segment/Uninitialized data segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BBS是英文Block Started Symbol的简称，这个区段中的数据在程序运行前将被自动初始化为数字0。</li>
</ul>
<h2 id="堆">堆</h2>
<ul>
<li>堆是用于存放进程中被动态分配的内存段，它的大小并不固定，可动态扩展或缩小。当进程调用malloc等函数分配内存时，新分配的内存就被动态调价到对上；当利用free等函数释放内存时，被释放的内存从堆中被剔除。</li>
</ul>
<h2 id="栈">栈</h2>
<ul>
<li>栈是函数执行的内存区域，通常和堆共享同一片区域。</li>
</ul>
<h2 id="堆和栈的区别">堆和栈的区别</h2>
<ul>
<li>申请方式
<ul>
<li>堆是由程序员手动申请</li>
<li>栈时系统自动分配</li>
</ul>
</li>
<li>释放方式
<ul>
<li>堆是由程序员手动释放</li>
<li>栈由系统自动释放</li>
</ul>
</li>
<li>生存周期
<ul>
<li>堆的生存周期由动态申请到程序员主动释放位置，不同函数之间均可自由访问。</li>
<li>栈的生存周期由函数调用开始到函数返回时结束，函数之间的局部变量不能互相访问。</li>
</ul>
</li>
</ul>
<h1>高级宏定义</h1>
<ul>
<li>本质就是替换</li>
</ul>
<h1>内联函数</h1>
<ul>
<li>
<p>在程序函数调用时，直接展开，而不是去查找调用。</p>
</li>
<li>
<p>内联函数嵌入调用者代码中的操作是一种优化操作，因此只有进行优化编译时才会执行代码嵌入处理。若编译过程中没有使用优化选项**‘-o’**，那么内联函数的代码就不会真正地嵌入到函数调用者代码中，而是只作为普通函数调用来处理。</p>
</li>
<li>
<p>内联函数虽然节省了函数调用的时间消耗，但由于每一个函数出现的地方都要进行替换，因此增加了代码的编译时间。另外，并不是所有的函数都能变成内联函数</p>
</li>
<li>
<p>现在的编译器也很智能，就算你不写<strong>inline</strong>，它也会自动将一些函数优化成内联函数</p>
</li>
</ul>
<h2 id="不带参数的宏定义">不带参数的宏定义</h2>
<ul>
<li>
<p>为了和普通的变量进行区分，宏的名字通常我们约定是由大写字母组成</p>
</li>
<li>
<p>宏定义只是简单地进行替换，并且由于预处理是在编译之前进行，而编译工作的任务之一就是语法检查，所以编译器不会对宏定义进行语法检查</p>
</li>
<li>
<p>宏定义不是说明或语句，在末尾不必加分号</p>
</li>
<li>
<p>宏定义的作用是从定义的位置开始到整个程序的结束</p>
</li>
<li>
<p>可以用 <strong>#undef</strong> 来终止宏定义的作用域</p>
</li>
<li>
<p>宏定义允许嵌套</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">float</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入圆的半径：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;r);</span><br><span class="line"><span class="comment">// #undef PI 终止宏定义</span></span><br><span class="line">    s = PI * r * r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;圆的面积是：%.2f\n&quot;</span>, s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 宏定义的嵌套</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R 6371</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V PI * R * R * R * 4 / 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;地球的体积是：%.2f\n&quot;</span>, V);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="带参数的宏定义">带参数的宏定义</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//带参数的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入两个数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d是最大的那个数！\n&quot;</span>, MAX(x, y));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="‘-’-和-‘-’">‘#’ 和 ‘##’</h3>
<ul>
<li>‘#’ 和 '##'是两个预处理运算符</li>
<li>在带参数的宏定义中， #运算符后面应该跟着一个参数，预处理器会把这个参数转换为一个字符串。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR(s) # s</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(STR(Hlloc       %s num = %d), STR(Luenci), <span class="number">520</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">out :</span><br><span class="line">Hlloc Luenci num = <span class="number">520</span></span><br></pre></td></tr></table></figure>
<ul>
<li>'##‘运算符被称为记号连接运算符，我们可以使用’##'运算符连接两个参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOGETHER(x,y) x ## y</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, TOGETHER(<span class="number">2</span>,<span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Luenci on 2019/10/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOGETHER(x,y) x ## y</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, TOGETHER(<span class="number">2</span>,<span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="number">250</span></span><br></pre></td></tr></table></figure>
<h3 id="可变参数">可变参数</h3>
<ul>
<li>
<p>之前学习了如何让函数支持可变参数，带参数的宏定义是使用可变参数的：</p>
<ul>
<li>
<pre><code class="language-c">#define SHOWLIST（...）  printf（#__VA_ARGS__）
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 其中**...**表示可变参数，</span><br><span class="line"></span><br></pre></td></tr></table></figure>
#__VA_ARGS__
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">    在预处理中被实际的参数集所替代。</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define SHOWLIST(...) printf(#__VA_ARGS__)</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    SHOWLIST(Luenci,5 20, 3.14 \n);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">Luenci,5 20, 3.14</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOWLIST(format, ...) printf(#format, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    SHOWLIST(num = %d\n,<span class="number">520</span>);</span><br><span class="line">    SHOWLIST(hello Luenci\n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line">num = <span class="number">520</span></span><br><span class="line">hello Luenci</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Django重定向指南（转载）</title>
    <url>/2023/02/06/Django%20%E9%87%8D%E5%AE%9A%E5%90%91%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<blockquote>
<p>原文转载自：<a href="https://www.jianshu.com/p/5e322fb5b61c%EF%BC%88%E7%AE%80%E4%B9%A6%EF%BC%9A">https://www.jianshu.com/p/5e322fb5b61c（简书：</a><a href="https://www.jianshu.com/u/a4b0307eac4d">爱吃鱼de大猫</a>）</p>
</blockquote>
<p>当你使用 Django 框架构建 Python Web 应用程序时，在某些时候需要将用户从一个URL重定向到另一个URL。本指南将提供 HTTP 重定向所需要了解的所有知识，以及在 Django 中该如何处理。</p>
<p>完成本教程，你将学到：</p>
<ul>
<li>能够将用户从一个URL重定向到另一个URL</li>
<li>了解临时重定向和永久重定向之间的区别</li>
<li>使用重定向时避免常见陷阱</li>
</ul>
<p>本教程假设你熟悉Django应用程序的基本构建块，如视图和URL模式。</p>
<h2 id="一个超简单的-Django-重定向例子">一个超简单的 Django 重定向例子</h2>
<p>在 Django 中，通过从视图返回<code>HttpResponseRedirect</code>或<code>HttpResponsePermanentRedirect</code>的实例，可以将用户重定向到另一个URL。要做到这一点，最简单的方法是使用模块 <code>django.shortcuts</code> 中的函数 <code>redirect()</code>。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> redirect</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">redirect_view</span>(<span class="params">request</span>):</span><br><span class="line">    response = redirect(<span class="string">&#x27;/redirect-success/&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>
<p>只需在你的视图中将新的 URL 作为参数调用 redirect() 即可搞定。 该视图函数将返回一个 HttpResponseRedirect 类。</p>
<p>注意，如同其他视图一样，返回的重定向URL必须在你的 <a href="http://urls.py">urls.py</a> 中注册：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .views <span class="keyword">import</span> redirect_view</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;/redirect/&#x27;</span>, redirect_view)</span><br><span class="line">    <span class="comment"># ... more URL patterns here</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>假定这个是 Django 项目的主 <a href="http://urls.py">urls.py</a> 文件，现在 URL<code>/redirect/</code> 将被重定向到 <code>/redirect-success/</code>。此外，为避免硬编码 URL，你可以用视图、URL 模式或者模型的名字来调用 redirect() 。通过传递关键字参数<code>Permanent=True</code>来创建永久重定向。</p>
<p>好了，你需要了解的 Django 重定向就这么多。为让这篇教程配得上“终极指南”这个标题，下面我们将进一步探讨 redirect() 函数、HTTP 状态码以及 <code>HttpRedirectResponse</code> 类型。我们从头开始，从一个基本的问题开始。</p>
<h2 id="为什么要使用重定向？">为什么要使用重定向？</h2>
<p>我们为什么要将用户的访问重定向到不同的 URL 地址？我们看看 Django 项目是怎么回答的：</p>
<ul>
<li>当你未登录并请求需要身份验证的URL(如Django管理员)时，Django会将你重定向到登录页面</li>
<li>成功登录后，Django会将你重定向到最初请求的URL</li>
<li>当你使用Django管理员更改密码时，系统会将你重定向到指示更改成功的页面</li>
<li>当你在Django管理员中创建对象时，Django会将你重定向到对象列表。</li>
</ul>
<p>如果不使用重定向来实现会是什么样子？</p>
<p>如果用户必须登录才能查看页面，则可以简单地显示类似“单击此处登录”之类的页面。这样子做也行，但它是对用户不友好的。</p>
<p>另外，像 <a href="http://bit.ly/">http://bit.ly</a> 这样的短网址是重定向派上用场的另一个例子：你在浏览器的地址栏中键入一个短URL，然后被重定向到一个长而笨重的URL的页面。</p>
<p>此外，重定向不仅仅是为了方便。重定向是引导用户正确使用 Web 应用程序的基本工具。在用户进行带有副作用的操作(如创建或删除对象)后，最佳做法是重定向到另一个URL，以防止意外执行该操作两次。</p>
<p>下面的代码示例演示通常是如何处理表单的，一个用户在成功提交表单后会被重定向到另一个URL：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> redirect, render</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_message</span>(<span class="params">name, message</span>):</span><br><span class="line">    <span class="comment"># Code for actually sending the message goes here</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContactForm</span>(forms.Form):</span><br><span class="line">    name = forms.CharField()</span><br><span class="line">    message = forms.CharField(widget=forms.Textarea)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">contact_view</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># The request method &#x27;POST&#x27; indicates</span></span><br><span class="line">    <span class="comment"># that the form was submitted</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:  <span class="comment"># 1</span></span><br><span class="line">        <span class="comment"># Create a form instance with the submitted data</span></span><br><span class="line">        form = ContactForm(request.POST)  <span class="comment"># 2</span></span><br><span class="line">        <span class="comment"># Validate the form</span></span><br><span class="line">        <span class="keyword">if</span> form.is_valid():  <span class="comment"># 3</span></span><br><span class="line">            <span class="comment"># If the form is valid, perform some kind of</span></span><br><span class="line">            <span class="comment"># operation, for example sending a message</span></span><br><span class="line">            send_message(</span><br><span class="line">                form.cleaned_data[<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">                form.cleaned_data[<span class="string">&#x27;message&#x27;</span>]</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># After the operation was successful,</span></span><br><span class="line">            <span class="comment"># redirect to some other page</span></span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;/success/&#x27;</span>)  <span class="comment"># 4</span></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 5</span></span><br><span class="line">        <span class="comment"># Create an empty form instance</span></span><br><span class="line">        form = ContactForm()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;contact_form.html&#x27;</span>, &#123;<span class="string">&#x27;form&#x27;</span>: form&#125;)</span><br></pre></td></tr></table></figure>
<p>此视图的目的是用来处理和显示用户发送消息时的联系人表单。它有几个步骤：</p>
<ol>
<li>首先，视图查看请求方法。当用户访问连接到此视图的URL时，浏览器执行GET请求</li>
<li>如果使用POST请求调用视图，则POST发送的数据将用于实例化<code>ContactForm</code>对象</li>
<li>如果表单有效，则将表单数据传递给<code>send_message()</code>。此函数与此上下文无关，因此此处未显示</li>
<li>发送消息后，视图返回到URL<code>/SUCCESS/</code>的重定向。这是我们重点关注的一步。为简单起见，这里对URL进行了硬编码（后面讲如何避免这种情况）</li>
<li>如果视图接收到一个GET请求(或者确切地说，任何一种不是POST请求的请求)，它将创建一个<code>ContactForm</code>实例并使用<code>django.lowcuts.ender()</code>来呈现<code>Contact_form.html</code>模板</li>
<li>如果用户现在刷新页面，则只重新加载/SUCCESS/URL。如果没有重定向，重新加载页面将重新提交表单并发送另一条消息</li>
</ol>
<span id="more"></span>
<h2 id="幕后：HTTP重定向的工作原理">幕后：HTTP重定向的工作原理</h2>
<p>现在你知道为什么重定向有意义了，但是它们是如何工作的呢？让我们快速回顾一下，当你在Web浏览器的地址栏中输入URL时会发生什么。</p>
<h3 id="HTTP-快速入门">HTTP 快速入门</h3>
<p>假设你已经创建了一个带“HelloWorld”视图的Django应用程序，该视图处理路径/hello/。如果使用django开发服务器运行应用程序，完整的 url 将是 <a href="http://127.0.0.1:8000/hello/">http://127.0.0.1:8000/hello/</a> 。</p>
<p>当你在浏览器中输入该 URL 时，它将连接到IP地址为127.0.0.1的服务器的端口8000，并发送对路径 /hello/ 的 HTTP GET 请求。服务器返回 HTTP响应来回应。</p>
<p>HTTP 是基于文本的，因此查看客户端和服务器之间的前后通信比较容易。你可以使用命令行工具 curl 加上选项 -include 查看包括标头的完整HTTP响应，如下所示：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl --include http://127.0.0.1:8000/hello/</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sun, 01 Jul 2018 20:32:55 GMT</span><br><span class="line">Server: WSGIServer/0.2 CPython/3.6.3</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">X-Frame-Options: SAMEORIGIN</span><br><span class="line">Content-Length: 11</span><br><span class="line"></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>
<p>HTTP 响应第一行为包含状态代码和状态信息状态行。后面跟着任意数量的 HTTP 标头。空行表示标头的结尾和响应正文的开头，正文为服务器发回的实际数据。</p>
<h3 id="HTTP-重定向状态码">HTTP 重定向状态码</h3>
<p>重定向的响应是怎么样的呢？为简单起见，我们假设路径 /redirect/ 是经由 redirect_view() 处理，如果你访问 <a href="http://127.0.0.1:8000/redirect/">http://127.0.0.1:8000/redirect/</a> ，使用 curl 工具的话，命令行提示信息应该类似这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl --include http://127.0.0.1:8000/redirect/</span></span><br><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Date: Sun, 01 Jul 2018 20:35:34 GMT</span><br><span class="line">Server: WSGIServer/0.2 CPython/3.6.3</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Location: /redirect-success/</span><br><span class="line">X-Frame-Options: SAMEORIGIN</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure>
<p>响应跟前面的例子很类似，只有少许的差别，重定向的响应：</p>
<ul>
<li>返回不同的状态代码(302 VS 200)</li>
<li>包含具有相对URL的位置标头（Location: /redirect-success/）</li>
<li>以空行结尾，因为重定向响应的正文为空</li>
</ul>
<p>主要区别在于状态码。HTTP 规范具体规定如下：</p>
<blockquote>
<p>302(Found)状态代码指示目标资源暂时位于不同的URI下。由于有时可能会更改重定向，因此客户端应该继续为将来的请求使用有效的请求URI。服务器应在响应中生成一个位置标头字段，其中包含一个 URI 对不同 URI 的引用。客户端可以使用位置字段值进行自动重定向。<a href="https://tools.ietf.org/html/rfc7231#section-6.4">来源</a></p>
</blockquote>
<p>也就是说，当服务器返回一个 302 状态码，它的意思是告诉客户端：“嘿，此刻，您正在寻找的东西可以在另一个位置找到”。</p>
<p>规范中的一个关键短语是“可以使用位置字段值进行自动重定向”。这意味着您不能强制客户端加载另一个URL。客户端可以选择等待用户确认，也可以决定根本不加载URL。</p>
<p>现在你已经了解了，重定向只是一个带有3xx状态代码和位置标头的HTTP响应。关键点是，HTTP重定向类似于通常的HTTP响应，但具有空主体、3xx状态代码和位置标头。要理解的就这么多，下面我们回到 Django 中，首先了解3xx状态码中的两种重定向，并了解它们在 Web 开发中的重要性。</p>
<h3 id="临时与永久重定向">临时与永久重定向</h3>
<p>HTTP标准指定了多个重定向状态代码，所有代码都在3xx范围内。两个最常见的状态代码是 301（永久重定向）和 302（Found/发现）。</p>
<p>状态码302表示临时重定向。临时重定向是指：“此刻，你正在寻找的东西可以在另一个地址找到”。把它想象成一个商店的标志，上面写着：“我们的商店目前因装修而关闭。请到我们拐角处的另一家店”。由于这只是暂时的，所以下次购物时还是要检查原来的地址。</p>
<blockquote>
<p>注意：在 HTTP1.0 规范中，状态代码302的说明是临时重定向。HTTP 1.1中已更改为 Found 。</p>
</blockquote>
<p>顾名思义，永久重定向应该是永久的。永久重定向会告诉浏览器：“你要查找的内容不再位于此地址。它现在这个新地址上，再也不会在老地址上了”。永久重定向就像商店的标牌，上面写着“我们搬家了，我们的新店就在拐角处”。这个变化是永久性的，所以下次你想去商店的时候，你可以直接去新的地址。</p>
<blockquote>
<p>注意：永久重定向可能会产生一些意想不到的后果。在使用永久重定向之前请完成本指南，或者跳到“永久重定向是永久的”一节了解。</p>
</blockquote>
<p>浏览器在处理重定向时的行为大致差不多：当URL返回永久重定向响应时，此响应将被缓存。下一次浏览器遇到旧URL时，它会记住重定向并直接请求新地址。<br>
缓存重定向可以节省不必要的请求，并提供更好、更快的用户体验。此外，临时重定向和永久重定向之间的区别会与搜索引擎优化相关。</p>
<h2 id="Django-中的重定向">Django 中的重定向</h2>
<p>现在你知道了，重定向只是一个带有 3xx 状态代码和位置标头的 HTTP 响应。你完全可以手工从常规<code>HttpResponse</code>对象构建这样的响应：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hand_crafted_redirect_view</span>(<span class="params">request</span>):</span><br><span class="line">  response = HttpResponse(status=<span class="number">302</span>)</span><br><span class="line">  response[<span class="string">&#x27;Location&#x27;</span>] = <span class="string">&#x27;/redirect/success/&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>
<p>这个在技术上是可行的，但它涉及到相当多的输入。</p>
<h3 id="HTTPResponseRedirect-类">HTTPResponseRedirect 类</h3>
<p>使用 HttpResponseRedirect 类可以帮助我们减少输入, 它是 HttpResponse 的一个子类。 你只需要把需要重定向的 URL 作为第一个参数生成实例，初始化时会正确地匹配状态码和报文地址头：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">redirect_view</span>(<span class="params">request</span>):</span><br><span class="line">  <span class="keyword">return</span> HttpResponseRedirect(<span class="string">&#x27;/redirect/success/&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在命令行中使用 HttpResponseRedirect 类的演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>redirect = HttpResponseRedirect(<span class="string">&#x27;/redirect/success/&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>redirect.status_code</span><br><span class="line"><span class="number">302</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>redirect[<span class="string">&#x27;Location&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;/redirect/success/&#x27;</span></span><br></pre></td></tr></table></figure>
<p>还有一个用于永久重定向的类：HttpResponsePermanentRedirect 名字很直观。它的工作原理与 HttpResponseRedirect 相同，唯一的区别是它的状态代码为301(永久移动)。</p>
<blockquote>
<p>注意：在上面的示例中，重定向URL是硬编码的。对URL进行硬编码是一种不好的做法：如果URL发生了变化，你必须搜索所有的代码并改为正确的URL。下面我们来修复这个缺陷。</p>
</blockquote>
<p>我们可以使用 django.urls.reverse() 来构建URL，但是还有一种更方便的方法。</p>
<h3 id="redirect-函数">redirect() 函数</h3>
<p>为了使你的工作更轻松，Django提供了你在前面简介中已经看到的通用快捷函数: django.shortcuts.redirect()。</p>
<p>可以使用以下命令调用此函数：</p>
<ul>
<li>带有get_absolute_url()方法的模型实例或任何其他对象。</li>
<li>URL或视图名称以及位置和/或关键字参数。</li>
<li>URL</li>
</ul>
<p>它将采取适当的步骤将参数转换为URL并返回<code>HTTPResponseRedirect</code>。如果传递<code>Permanent=True</code>，它将返回<code>HttpResponsePermanentRedirect</code>的实例，从而导致永久重定向。</p>
<p>下面有三个示例来说明不同的用法：</p>
<ol>
<li>传入模型：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> redirect</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">model_redirect_view</span>(<span class="params">request</span>):</span><br><span class="line">    product = Product.objects.<span class="built_in">filter</span>(featured=<span class="literal">True</span>).first()</span><br><span class="line">    <span class="keyword">return</span> redirect(product)</span><br></pre></td></tr></table></figure>
<p>redirect() 将调用 product.get_absolute_url() 并将结果用作重定向目标。如果给定的类(在本例中为Product)没有 get_absolute_url() 方法，则抛出 TypeError 异常。</p>
<ol>
<li>传入URL名称和参数：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> redirect</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fixed_featured_product_view</span>(<span class="params">request</span>):</span><br><span class="line">    ...</span><br><span class="line">    product_id = settings.FEATURED_PRODUCT_ID</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;product_detail&#x27;</span>, product_id=product_id)</span><br></pre></td></tr></table></figure>
<p>redirect() 将尝试使用给定的参数来调换 URL。本例中假设你的 URL 模式中采用以下模式:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path(<span class="string">&#x27;/product/&lt;product_id&gt;/&#x27;</span>, <span class="string">&#x27;product_detail_view&#x27;</span>, name=<span class="string">&#x27;product_detail&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>传入 URL:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> redirect</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">featured_product_view</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/products/42/&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>redirect() 将处理任何包含<code>/</code>或<code>.</code>的字符串。作为URL并将其用作重定向目标。</p>
<h3 id="基于类的视图-RedirectView-重定向">基于类的视图 RedirectView 重定向</h3>
<p>如果你的视图只返回一个重定向，那么可以使用基于类的视图<code>django.views.generic.base.RedirectView</code>。</p>
<p>你可以通过定制 RedirectView 各种属性来满足你的需要。</p>
<p>如果类具有<code>.url</code>属性，则它将用作重定向URL。字符串格式占位符将被替换为URL中的命名参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> .views <span class="keyword">import</span> SearchRedirectView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;/search/&lt;term&gt;/&#x27;</span>, SearchRedirectView.as_view())</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="keyword">from</span> django.views.generic.base <span class="keyword">import</span> RedirectView</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SearchRedirectView</span>(<span class="title class_ inherited__">RedirectView</span>):</span><br><span class="line">  url = <span class="string">&#x27;https://google.com/?q=%(term)s&#x27;</span></span><br></pre></td></tr></table></figure>
<p>URL模式定义了一个参数，用于在<code>SearchRedirectView</code>中构建重定向URL。应用程序中的路径 <code>/search/kittens/</code> 将被重定向到 <code>https://google.com/?q=kittens</code>。</p>
<p>你还可以将关键字参数url传递给<code>urlPatterns</code>中的<code>as_view()</code>，而不需通过重写 <code>RedirectView</code> 子类的 url 属性来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.views.generic.base <span class="keyword">import</span> RedirectView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;/search/&lt;term&gt;/&#x27;</span>,</span><br><span class="line">         RedirectView.as_view(url=<span class="string">&#x27;https://google.com/?q=%(term)s&#x27;</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>你同样可以通过重写 get_redirect_url() 来获得完全地自定义重定向行为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="keyword">from</span> django.views.generic.base <span class="keyword">import</span> RedirectView</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomAnimalView</span>(<span class="title class_ inherited__">RedirectView</span>):</span><br><span class="line"></span><br><span class="line">     animal_urls = [<span class="string">&#x27;/dog/&#x27;</span>, <span class="string">&#x27;/cat/&#x27;</span>, <span class="string">&#x27;/parrot/&#x27;</span>]</span><br><span class="line">     is_permanent = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">get_redirect_url</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> choice(self.animal_urls)</span><br></pre></td></tr></table></figure>
<p>这个基于类的视图将重定向到从 .animal_urls 中随机选择的 URL。</p>
<p><code>django.views.generic.base.RedirectView</code> 为定制提供了更多的挂钩。以下是完整的列表：</p>
<ul>
<li>.url</li>
</ul>
<p>如果设置了此属性，则它应该是一个带有要重定向到的URL字符串。如果它包含像<code>%(name)s</code>这样的字符串格式占位符，它们将被传递给视图的关键字参数替代展开。</p>
<ul>
<li>.pattern_name</li>
</ul>
<p>如果设置了此属性，则它应该是要重定向到的URL模式的名称。传递给视图的任何位置参数和关键字参数都用于URL模式互换。</p>
<ul>
<li>.permanent</li>
</ul>
<p>如果此属性为 True，视图将返回永久重定向。默认情况下为 False。</p>
<ul>
<li>.query_string</li>
</ul>
<p>如果此属性为 True，则视图将任何提供的查询字符串附加到重定向URL。如果为false(默认值)，则废弃查询字符串。</p>
<ul>
<li>get_redirect_url(*args, **kwargs)</li>
</ul>
<p>此方法负责构建重定向URL。如果此方法不返回任何值，视图将返回 410 Gone 状态。</p>
<p>默认实现首先检查.url。它将.url视为“旧式”格式字符串，使用传递给视图的任何命名URL参数来展开任何命名格式说明符。如果未设置.url，则检查是否设置了.mode_name。如果是，它将使用它来互换它接收到的任何位置参数和关键字参数的URL。你可以通过覆盖此方法以任何方式更改该行为。只需确保它返回一个包含URL字符串。</p>
<blockquote>
<p>注意：基于类的视图是一个强大的概念，但是比较难理解它。与常规的基于函数的视图不同，在常规的基于函数的视图中，代码流程相对简单，而基于类的视图是由混合和基类组成的复杂层次结构组成的。</p>
</blockquote>
<p>要理解基于类的视图，一个很好的工具是基于类的网站视图。</p>
<p>通过这个简单的基于函数的视图，你可以实现从面的示例中<code>RandomAnimalView</code>的功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> redirect</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_animal_view</span>(<span class="params">request</span>):</span><br><span class="line">    animal_urls = [<span class="string">&#x27;/dog/&#x27;</span>, <span class="string">&#x27;/cat/&#x27;</span>, <span class="string">&#x27;/parrot/&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> redirect(choice(animal_urls))</span><br></pre></td></tr></table></figure>
<p>正如代码，基于类的方法在增加一些隐藏的复杂性的同时并没有提供任何明显的好处。这就提出了一个问题：什么时候应该使用<code>RedirectView</code>？</p>
<p>如果你想在<code>urls.py</code>中直接添加重定向，那么使用<code>RedirectView</code>是有意义的。但是，如果你发现自己正在重写get_redirect_url，那么基于函数的视图可能更容易理解，并且对于未来的功能扩展也更灵活。</p>
<h2 id="高级用法">高级用法</h2>
<p>一旦知道使用 django.shortcuts.redirect()，那么重定向到一个不同的URL就非常简单了。但是有几个高级用例并不那么明显。<br>
通过重定向传递参数。<br>
有时，你希望将一些参数传递给要重定向到的视图。最佳选择是在重定向URL的查询字符串中传递数据，这意味着重定向的URL类似于：<code>http://example.com/redirect-path/?parameter=value</code><br>
假设你希望从 some_view() 重定向到 product_view()，还要传递一个可选的参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">some_view</span>(<span class="params">request</span>):</span><br><span class="line">    ...</span><br><span class="line">    base_url = reverse(<span class="string">&#x27;product_view&#x27;</span>)  <span class="comment"># 1 /products/</span></span><br><span class="line">    query_string =  urlencode(&#123;<span class="string">&#x27;category&#x27;</span>: category.<span class="built_in">id</span>&#125;)  <span class="comment"># 2 category=42</span></span><br><span class="line">    url = <span class="string">&#x27;&#123;&#125;?&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(base_url, query_string)  <span class="comment"># 3 /products/?category=42</span></span><br><span class="line">    <span class="keyword">return</span> redirect(url)  <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">product_view</span>(<span class="params">request</span>):</span><br><span class="line">    category_id = request.GET.get(<span class="string">&#x27;category&#x27;</span>)  <span class="comment"># 5</span></span><br><span class="line">    <span class="comment"># Do something with category_id</span></span><br></pre></td></tr></table></figure>
<p>这段代码有点多，我们分步来探讨：</p>
<ol>
<li>首先，使用 django.urls.verse() 获取到 product_view() 的URL映射。</li>
<li>接下来，你必须构建查询字符串。这是问号之后的部分。建议此时使用 urllib.urlparse.urlcode()，因为它正确处理任何特殊字符的编码。</li>
<li>现在使用问号将 base_ur l和 query_string 连接起来。格式字符串可以很好地实现这一点。</li>
<li>最后，将 url 传递给 django.shortcuts.redirect() 或某个重定向响应类。</li>
</ol>
<p>在重定向目标 product_view() 中，该参数将在<code>request.GET</code>字典中可用。而参数可能会丢失，因此应使用<code>requests.GET.get('category')</code>而不是<code>requests.GET['category']</code>。当参数不存在时，前者不返回任何值，而后者将引发异常。</p>
<blockquote>
<p>注意：请确保验证从查询字符串读取的任何数据。看起来这些数据是在你自己的控制之下，因为是你创建了重定向URL。</p>
</blockquote>
<p>实际上，重定向可以被用户操作，如同任何其他的用户输入那样不能被信任。如果没有正确的验证，攻击者可能会获得未经授权的访问。</p>
<h3 id="特殊重定向码">特殊重定向码</h3>
<p>Django 为状态代码 301 和 302 提供 HTTP 响应类。这些应该涵盖了大多数用例，但是如果你必须返回状态代码303、307或308，那么你可以很容易地创建自己的响应类。只需简单地继承 <code>HttpResponseRedirectBase</code> 并在子类中重写<code>STATUS_CODE</code>属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HttpResponseTemporaryRedirect</span>(<span class="title class_ inherited__">HttpResponseRedirectBase</span>):</span><br><span class="line">    status_code = <span class="number">307</span></span><br></pre></td></tr></table></figure>
<p>或者，你可以使用 <code>django.shortcuts.redirect()</code> 方法来创建响应对象并更改返回值。当你有要重定向到的视图、URL或模型的名字时，此方法可行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">temporary_redirect_view</span>(<span class="params">request</span>):</span><br><span class="line">    response = redirect(<span class="string">&#x27;success_view&#x27;</span>)</span><br><span class="line">    response.status_code = <span class="number">307</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：实际上还有第三个类，它的状态代码在3xx范围内：<code>HttpResponseNotModified</code>，它的状态代码304。它指示URL的内容尚未更改，客户端可以使用缓存版本。</p>
</blockquote>
<blockquote>
<p>有人可能会说，304并未修改响应重定向到一个URL的缓存版本，但这有点牵强。因此，它不再列在 HTTP 标准的 “重定向3xx” 部分中。</p>
</blockquote>
<h2 id="陷阱">陷阱</h2>
<h3 id="重定向到并不会重定向的位置">重定向到并不会重定向的位置</h3>
<p>django.shortcuts.redirect() 的简单性可能具有欺骗性。函数本身不执行重定向：它只返回一个重定向响应对象。你必须从视图(或在中间件中)返回此响应对象。否则，不会产生重定向。</p>
<p>但是，即使你知道仅仅调用 redirect() 是不够的，也很容易进行简单的重构时将此错误引入工作的应用程序中。这里有一个例子来说明这一点。</p>
<p>假设我们正在构建一个商店，并且有一个负责显示产品的视图。如果产品不存在，则重定向到主页：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">product_view</span>(<span class="params">request, product_id</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        product = Product.objects.get(pk=product_id)</span><br><span class="line">    <span class="keyword">except</span> Product.DoesNotExist:</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;product_detail.html&#x27;</span>, &#123;<span class="string">&#x27;product&#x27;</span>: product&#125;)</span><br></pre></td></tr></table></figure>
<p>现在，你需要添加第二个视图来显示产品的客户评论。如果产品不存在它还应该重定向到主页，因此作为第一步，你可以将此功能从 product_view() 提取到辅助函数 get_product_or_redirect() 中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_product_or_redirect</span>(<span class="params">product_id</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> Product.objects.get(pk=product_id)</span><br><span class="line">    <span class="keyword">except</span> Product.DoesNotExist:</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">product_view</span>(<span class="params">request, product_id</span>):</span><br><span class="line">    product = get_product_or_redirect(product_id)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;product_detail.html&#x27;</span>, &#123;<span class="string">&#x27;product&#x27;</span>: product&#125;)</span><br></pre></td></tr></table></figure>
<p>不幸的是，在重构之后，重定向不再起作用。<br>
redirect() 的结果是从 get_product_or_redirect() 返回的，但 product_view() 不没有返回它。它将被传递给模板。根据在 product_detail.html模板中使用 product 变量的方式，这可能不会导致错误消息，而只是显示空值。</p>
<h3 id="重定向循环">重定向循环</h3>
<p>在处理重定向时，你可能会意外地创建一个重定向循环，方法是让URL A返回指向URL B的重定向，而URL B返回到URL A的重定向，以此类推。大多数HTTP客户端检测到这种重定向循环，并在多次请求后显示错误消息。</p>
<p>不幸的是，这种错误可能很难发现，因为服务器端的一切看起来都很好。除非你的用户抱怨此问题，否则唯一可能出现问题的迹象是，你收到了来自一个客户端的多个请求，这些请求都会导致快速连续的重定向响应，但没有一个状态为200 OK的响应。</p>
<p>以下是重定向循环的一个简单示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_view</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;another_view&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">another_view</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;a_view&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这个例子说明了原理，但过于简单化了。在现实生活中遇到的重定向循环可能更难发现。让我们来看一个更详细的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">featured_products_view</span>(<span class="params">request</span>):</span><br><span class="line">    featured_products = Product.objects.<span class="built_in">filter</span>(featured=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(featured_products == <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;product_view&#x27;</span>, kwargs=&#123;<span class="string">&#x27;product_id&#x27;</span>: featured_products[<span class="number">0</span>].<span class="built_in">id</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;featured_products.html&#x27;</span>, &#123;<span class="string">&#x27;product&#x27;</span>: featured_products&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">product_view</span>(<span class="params">request, product_id</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        product = Product.objects.get(pk=product_id, in_stock=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">except</span> Product.DoesNotExist:</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;featured_products_view&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;product_detail.html&#x27;</span>, &#123;<span class="string">&#x27;product&#x27;</span>: product&#125;)</span><br></pre></td></tr></table></figure>
<p>featured_products_view() 获取所有特定的产品，也就是说，Product 实例的 .featured 属性被设置为True。如果只有一个特定产品存在，它将直接重定向到 product_view()。否则，它将用 featured_products 查询集渲染一个模板。</p>
<p>product_view 与上一节看起来很相似，但它有两个微小的区别：</p>
<ul>
<li>该视图试图获取一个库存产品，将<code>.in_stock</code>设置为<code>True</code>来指示该产品。</li>
<li>如果没有产品库存，视图将重定向到 featured_products_view()。</li>
</ul>
<p>这种逻辑工作的不错，直到你的商店成为自己成功的牺牲品，而你目前拥有的某种特色产品脱销为止。如果你将<code>.in_stock</code>设置为 False，但忘记将<code>.featured</code>也设置为False，那么任何访问 feature_product_view() 的访问者都将被困在重定向循环中。</p>
<p>没有防止此类错误的万全方法，一个好的起点是检查要重定向到的视图是否使用了重定向本身。</p>
<h3 id="永久重定向是永久的">永久重定向是永久的</h3>
<p>永久重定向可能类似于糟糕的纹身：在当时，它们可能看起来是个好主意，但一旦你意识到它们是一个错误，就很难摆脱它们。</p>
<p>当浏览器收到URL的永久重定向响应时，它会无限期地缓存此响应。你将来任何时候再请求旧的 URL，浏览器都不会再费事地加载它而是直接加载新URL。</p>
<p>指示浏览器重新加载曾经返回过永久重定向的URL可能会非常困难。Google Chrome在缓存重定向方面尤为激进。</p>
<p><strong>为什么这会成为个问题？</strong></p>
<p>假设你希望使用 Django 构建 Web 应用程序。你可以在 <a href="http://myawesomedjangowebapp.com/">myawesomedjangowebapp.com</a> 注册你的域名。作为第一步，你可以在https://myawesomedjangowebapp.com/blog/ 安装了一个博客应用程序，并构建了邮件列表。</p>
<p>你的站点 <a href="https://myawesomedjangowebapp.com/">https://myawesomedjangowebapp.com/</a> 的主页仍在建设中，因此你将主页重定向到 <a href="https://myawesomedjangowebapp.com/blog/">https://myawesomedjangowebapp.com/blog/</a> 。之所以决定使用永久重定向，是因为听说永久重定向是缓存的，缓存会让访问变得更快，因为速度是 Google 搜索结果排名的一个因素，所以速度越快越好。</p>
<p>结果，你不仅是一位优秀的开发人员，而且还是一位才华横溢的作家。你的博客变得流行起来，你创建的邮件列表也不断增长。几个月后，你的应用程序准备就绪。它现在有了一个闪亮的主页，你决定移除重定向。</p>
<p>你发送一封带有特殊折扣码的通知电子邮件到你已经相当大的运营邮件列表。你靠坐在电脑前，等待注册通知的滚动。</p>
<p>可怕的是，你邮箱里充满了困惑的访问者发来的信息，他们想要访问你的应用程序，但总是被重定向到你的博客。</p>
<p>什么情况？当你的博客读者访问 <a href="https://myawesomedjangowebapp.com/">https://myawesomedjangowebapp.com/</a> 时，重定向仍然处于活动状态，将会跳转到 <a href="https://myawesomedjangowebapp.com/blog/">https://myawesomedjangowebapp.com/blog/</a> 。因为这是一个永久的重定向，所以这个URL会缓存在他们的浏览器中。</p>
<p>当他们点击你发布公告邮件中的链接时，他们的浏览器不会查找你的新主页而会直接访问你的博客。此时你不是在庆祝你的项目成功启动，而是忙于指导你的用户如何通过 <a href="chrome://net-internals/">chrome://net-internals</a> 来重置其浏览器的缓存。</p>
<p>永久重定向的永久性质也会在本地计算机上开发时给你制造麻烦。让我们回到为 <a href="http://myawesomedjangowebapp.com">myawesomedjangowebapp.com</a> 实现永久重定向的时刻。</p>
<p>你启动开发服务器并打开 <a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a> 。如预期那样，应用程序将你的浏览器访问重定向到 <a href="http://127.0.0.1:8000/blog/">http://127.0.0.1:8000/blog/</a> 。当你对项目感到满意后，你关闭开发服务器去吃个午饭。</p>
<p>当你吃饱回来，准备处理一些客户端的工作，需要对主页进行一些简单的更改，因此你启动开发服务器，打开客户端，但是异常情况发生了。这是怎么回事？主页被破坏了，它现在返回404！忙碌一下午，你过了一段时间才注意到你正被重定向到项目中已经不存在的 <a href="http://127.0.0.1:8000/blog/">http://127.0.0.1:8000/blog/</a> 。对于浏览器来说，URL <a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a> 现在是否服务于一个完全不同的应用程序并不重要。最重要的是这个 URL 曾经返回到http://127.0.0.1:8000/blog/ 的永久重定向。</p>
<p>从这个故事的启示是，你计划今后不再打算再次使用的网址才安排永久重定向。永久重定向的地方，你必须意识到它们的后果。即使你确信你确实需要永久重定向，最好还是先实现临时重定向，并且只有在你100%确定一切正常工作后才切换到永久重定向。</p>
<h3 id="未经验证的重定向可能导致安全问题">未经验证的重定向可能导致安全问题</h3>
<p>从安全的角度来看，重定向是一种相对安全的技术。攻击者无法通过重定向攻击网站。毕竟，重定向只是重定向到一个URL，这个URL攻击者只需在浏览器地址栏中键入即可。</p>
<p>但是，如果你使用某种类型的用户输入(如URL参数)，重定向URL时没有将其正确验证，则攻击者可能会利用此输入进行网络钓鱼攻击。这种重定向称为开放重定向或未经验证的重定向。</p>
<p>有一些合法的重定向到的URL用例来自用户的输入。Django的登录视图就是一个很好的例子。它接受一个URL参数Next，该参数包含用户登录后重定向到的页面的URL。要在登录后将用户重定向到其配置文件，URL可能如下所示：</p>
<p><a href="https://myawesomedjangowebapp.com/login/?next=/profile/">https://myawesomedjangowebapp.com/login/?next=/profile/</a></p>
<p>Django确实验证了下一个参数，但是这里我们假设它没有验证下一个参数。在没有验证的情况下，攻击者可以创建URL，将用户重定向到其控制下的网站，例如：</p>
<p><a href="https://myawesomedjangowebapp.com/login/?next=https://myawesomedjangowebapp.co/profile/">https://myawesomedjangowebapp.com/login/?next=https://myawesomedjangowebapp.co/profile/</a></p>
<p>然后，<a href="http://myawesomedjangowebapp.co">myawesomedjangowebapp.co</a> 网站可能会显示一条错误消息，并诱使用户再次输入他们的凭据。</p>
<p>避免开放重定向的最佳方法是在构建重定向URL时不使用任何用户输入。</p>
<p>如果不能确定重定向URL是否安全，可以使用函数 django.utils.http.is_safe_url() 对其进行验证。文档字符串很好地解释了它的用法：</p>
<blockquote>
<p>is_safe_url(url, host=None, allowed_hosts=None, require_https=False)<br>
如果url是安全重定向(即不会指向其他主机并使用安全方案)，则返回True。空 url 总是返回 False。如果 require_https 为 True（默认为 False），则只有 <code>https</code> 被视为有效方案。</p>
</blockquote>
<p>我们来看一些例子。</p>
<p>相对URL被认为是安全的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Import the function first.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.utils.http <span class="keyword">import</span> is_safe_url</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_safe_url(<span class="string">&#x27;/profile/&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>通常认为指向其他主机的URL不安全：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_safe_url(<span class="string">&#x27;https://myawesomedjangowebapp.com/profile/&#x27;</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>如果在 ALLOWED_HOSTS中 提供了指向另一个主机的URL，则该URL被认为是安全的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_safe_url(<span class="string">&#x27;https://myawesomedjangowebapp.com/profile/&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>            allowed_hosts=&#123;<span class="string">&#x27;myawesomedjangowebapp.com&#x27;</span>&#125;)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>如果参数 require_https 为True，则使用 http 方案的URL被视为不安全：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_safe_url(<span class="string">&#x27;http://myawesomedjangowebapp.com/profile/&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>            allowed_hosts=&#123;<span class="string">&#x27;myawesomedjangowebapp.com&#x27;</span>&#125;,</span><br><span class="line"><span class="meta">... </span>            require_https=<span class="literal">True</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>到此终于结束了关于HTTP重定向的 Django 指南。现在你已经了解了重定向的各个方面，从HTTP协议的低级细节到Django中处理它们的高级方式。</p>
<p>你了解了HTTP重定向在幕后看起来如何，不同的状态代码是什么，以及永久重定向和临时重定向有何不同。这些知识并不是Django所特有的，对于任何语言的Web开发都是有价值的。</p>
<p>现在，你可以使用 Django 执行重定向，可以使用重定向响应类 HttpResponseRedirect 和 HttpResponsePermanentRedirect，也可以使用方便函数django.lowcuts.redirect()。你看到了一些高级用例的解决方案，并知道如何避免常见的陷阱。</p>
<p>如果你有任何关于HTTP重定向的问题和建议，请在下面留言，同时，祝你重定向愉快！</p>
]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>Django重定向原文</tag>
      </tags>
  </entry>
  <entry>
    <title>Django参数和模板</title>
    <url>/2023/02/06/Django%E5%8F%82%E6%95%B0%E5%92%8C%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="render方法参数"><code>render</code>方法参数</h2>
<ul>
<li><code>request</code>: 是一个固定参数。</li>
<li><code>template_name</code>: <code>templates</code> 中定义的文件, 要注意路径名. 比如<code>’templates\polls\index.html’</code>, 参数就要写<code>‘polls\index.html’</code></li>
<li><code>context</code>: 要传入文件中用于渲染呈现的数据, 默认是字典格式</li>
<li><code>content_type</code>: 生成的文档要使用的MIME 类型。默认为DEFAULT_CONTENT_TYPE 设置的值。</li>
<li><code>status</code>: http的响应代码,默认是200.</li>
<li><code>using</code>: 用于加载模板使用的模板引擎的名称。</li>
</ul>
<h2 id="request对象方法和属性"><code>request</code>对象方法和属性</h2>
<ul>
<li><code>request.scheme</code>   # 代表请求的方案,http或者https</li>
<li><code>request.body</code># 原始HTTP请求主体为字节串。这对于以不同于常规HTML格式的方式处理数据很有用：二进制图像，XML有效负载等。对于处理常规格式的数据，请使用 <code>HttpRequest.POST</code>。</li>
<li><code>request.path</code>   # 请求的路径,比如请求<code>127.0.0.1/org/list</code>,那这个值就是<code>/org/list</code></li>
<li><code>request.get_full_path()</code> # 获取完整的请求路径</li>
<li><code>request.method</code>  # 表示请求使用的http方法,GET或者POST请求</li>
<li><code>request.encoding</code> # 表示提交数据的编码方式</li>
<li><code>request.GET</code>     # 获取GET请求</li>
<li><code>request.POST</code>    # 获取post的请求,比如前端提交的用户密码,可以通过<code>request.POST.get()</code>来获取</li>
</ul>
<blockquote>
<p><strong>NOTICED：如果使用 POST 上传文件的话，文件信息将包含在 FILES 属性中</strong></p>
</blockquote>
<p><code>request.COOKIES</code> #包含所有的cookie</p>
<p><code>request.META</code>   #一个标准的Python 字典，包含所有的HTTP 首部。具体的头部信息取决于客户端和服务器，下面是一些示例：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">CONTENT_LENGTH   —— 请求的正文的长度（是一个字符串）。</span><br><span class="line">CONTENT_TYPE   —— 请求的正文的MIME 类型。</span><br><span class="line">HTTP_ACCEPT   —— 响应可接收的Content-<span class="built_in">Type</span>。</span><br><span class="line">HTTP_ACCEPT_ENCODING —— 响应可接收的编码。</span><br><span class="line">HTTP_ACCEPT_LANGUAGE —— 响应可接收的语言。</span><br><span class="line">HTTP_HOST     —— 客服端发送的HTTP Host 头部。</span><br><span class="line">HTTP_REFERER   —— Referring 页面。</span><br><span class="line">HTTP_USER_AGENT —— 客户端的user-agent 字符串。</span><br><span class="line">QUERY_STRING   —— 单个字符串形式的查询字符串（未解析过的形式）。</span><br><span class="line">REMOTE_ADDR   —— 客户端的IP 地址。</span><br><span class="line">REMOTE_HOST   —— 客户端的主机名。</span><br><span class="line">REMOTE_USER   —— 服务器认证后的用户。</span><br><span class="line">REQUEST_METHOD  —— 一个字符串，例如&quot;GET&quot; 或&quot;POST&quot;。</span><br><span class="line">SERVER_NAME   —— 服务器的主机名。</span><br><span class="line">SERVER_PORT   —— 服务器的端口（是一个字符串）</span><br></pre></td></tr></table></figure>
<ul>
<li><code>request.user</code>   #一个 <code>AUTH_USER_MODEL</code> 类型的对象，表示当前登录的用户。
<ul>
<li>如果用户当前没有登录，user 将设置为 <code>django.contrib.auth.models.AnonymousUser</code> 的一个实例。你可以通过 <code>s_authenticated() </code>区分它们</li>
<li>把<code>request</code>传给前端的时候,前端可以通过 <code> if request.user.is_authenticated</code>判断用户时候登录</li>
</ul>
</li>
<li><code>request.session</code> #一个既可读又可写的类似于字典的对象，表示当前的会话</li>
</ul>
<span id="more"></span>
<h2 id="response对象"><code>response</code>对象</h2>
<ul>
<li><code>Httpresponse</code>对象对于 <code>Httpreques</code>对象来说，是由<code> django</code>自动创建的，但是， <code>Httpresponse</code>对象就必须我们自己创建。每个<code>view</code>请求处理方法必须返回一个 <code>Httpresponse</code>对象。</li>
</ul>
<blockquote>
<p><code>Httpresponse</code>类在<code>djangohttpHttprespons</code></p>
</blockquote>
<blockquote>
<p>在 <code>Httpresponse</code>对象上扩展的常用方法：</p>
</blockquote>
<ul>
<li>
<p>页面渲染</p>
<ul>
<li><code>render() </code></li>
<li><code>render to response()</code></li>
</ul>
</li>
<li>
<p>页面跳转：</p>
<ul>
<li><code>redirect(&quot;路径&quot;)</code></li>
</ul>
</li>
<li>
<p><code>locals()</code>：可以直接将函数中所有的变里传给模板</p>
</li>
</ul>
<h2 id="内置变量过滤器filter">内置变量过滤器<code>filter</code></h2>
<p>​    可以理解为python中的内置函数，过滤器是模板的特有语法，通过前端来过滤部分数据。注意filter只能传递一个参数(也可以说是两个参数，因为第一个个参数已经固定，就是被处理的那个)。<br>
格式：</p>
<figure class="highlight jinja"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">`</span><span class="template-variable">&#123;&#123;` var|method:parameter`&#125;&#125;</span><span class="language-xml">`</span></span><br></pre></td></tr></table></figure>
<ul>
<li>method表示过滤器部分过滤器如下</li>
</ul>
<table>
<thead>
<tr>
<th>过滤器</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>first</td>
<td>取列表第一个元素</td>
<td></td>
</tr>
<tr>
<td>last</td>
<td>取列表最后元素</td>
<td></td>
</tr>
<tr>
<td>capfirst</td>
<td>首字母大写</td>
<td></td>
</tr>
</tbody>
</table>
<p><img src="https://raw.githubusercontent.com/Lucareful/ImgRepo/master/img/hexo_img/image-20200614210257960.png" alt="filter"></p>
<h2 id="logging配置"><code>logging</code>配置</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下面就是logging的配置</span></span><br><span class="line">LOGGING = &#123;</span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,  <span class="comment"># 指明dictConnfig的版本，目前就只有一个版本</span></span><br><span class="line">    <span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>,  <span class="comment"># 表示是否禁用所有的已经存在的日志配置</span></span><br><span class="line">    <span class="string">&#x27;formatters&#x27;</span>: &#123;  <span class="comment"># 格式器</span></span><br><span class="line">        <span class="string">&#x27;verbose&#x27;</span>: &#123;  <span class="comment"># 详细</span></span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;standard&#x27;</span>: &#123;  <span class="comment"># 标准</span></span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;[%(asctime)s] [%(levelname)s] %(message)s&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># handlers：用来定义具体处理日志的方式，可以定义多种，&quot;default&quot;就是默认方式，&quot;console&quot;就是打印到控制台方式。file是写入到文件的方式，注意使用的class不同</span></span><br><span class="line">    <span class="string">&#x27;handlers&#x27;</span>: &#123; <span class="comment"># 处理器，在这里定义了两个个处理器</span></span><br><span class="line">        <span class="string">&#x27;console&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.StreamHandler&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;stream&#x27;</span>: <span class="string">&#x27;ext://sys.stdout&#x27;</span>,   <span class="comment"># 文件重定向的配置，将打印到控制台的信息都重定向出去 python manage.py runserver &gt;&gt; /home/aea/log/test.log</span></span><br><span class="line">            <span class="comment"># &#x27;stream&#x27;: open(&#x27;/home/aea/log/test.log&#x27;,&#x27;a&#x27;),  #虽然成功了，但是并没有将所有内容全部写入文件，目前还不清楚为什么</span></span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;standard&#x27;</span>   <span class="comment"># 制定输出的格式，注意 在上面的formatters配置里面选择一个，否则会报错</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;file&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.FileHandler&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filename&#x27;</span>: os.path.join(BASE_DIR,<span class="string">&#x27;debug.log&#x27;</span>),  <span class="comment">#这是将普通日志写入到日志文件中的方法，</span></span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;standard&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>:<span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>:<span class="string">&#x27;logging.handlers.RotatingFileHandler&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filename&#x27;</span>: os.path.join(BASE_DIR,<span class="string">&#x27;All.log&#x27;</span>),     <span class="comment">#日志输出文件</span></span><br><span class="line">            <span class="string">&#x27;maxBytes&#x27;</span>: <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">5</span>,                  <span class="comment">#文件大小</span></span><br><span class="line">            <span class="string">&#x27;backupCount&#x27;</span>: <span class="number">5</span>,                         <span class="comment">#备份份数</span></span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>:<span class="string">&#x27;standard&#x27;</span>,                   <span class="comment">#使用哪种formatters日志格式</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment"># 上面两种写入日志的方法是有区别的，前者是将控制台下输出的内容全部写入到文件中，这样做的好处就是我们在views代码中的所有print也会写在对应的位置</span></span><br><span class="line">        <span class="comment"># 第二种方法就是将系统内定的内容写入到文件，具体就是请求的地址、错误信息等，小伙伴也可以都使用一下然后查看两个文件的异同。</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;loggers&#x27;</span>: &#123;  <span class="comment"># log记录器，配置之后就会对应的输出日志</span></span><br><span class="line">        <span class="comment"># django 表示就是django本身默认的控制台输出，就是原本在控制台里面输出的内容，在这里的handlers里的file表示写入到上面配置的file-/home/aea/log/jwt_test.log文件里面</span></span><br><span class="line">        <span class="comment"># 在这里的handlers里的console表示写入到上面配置的console-/home/aea/log/test.log文件里面</span></span><br><span class="line">        <span class="string">&#x27;django&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;console&#x27;</span>,<span class="string">&#x27;file&#x27;</span>],</span><br><span class="line">            <span class="comment"># 这里直接输出到控制台只是请求的路由等系统console，当使用重定向之后会把所有内容输出到log日志</span></span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;django.request &#x27;</span>:&#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;console&#x27;</span>,<span class="string">&#x27;file&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;WARNING&#x27;</span>,  <span class="comment"># 配合上面的将警告log写入到另外一个文件</span></span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;django.db.backends&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;file&#x27;</span>], <span class="comment"># 指定file handler处理器，表示只写入到文件</span></span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>:<span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ORM的增删改查"><code>ORM</code>的增删改查</h2>
<ul>
<li>增加数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方式一创建记录</span></span><br><span class="line">b = Book(name=<span class="string">&quot;python基础&quot;</span>, price=<span class="number">99</span>, author=<span class="string">&quot;luenci&quot;</span>, pub_date=<span class="string">&quot;2020-06-14&quot;</span>)</span><br><span class="line">b.save()</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法二创建数据</span></span><br><span class="line">Book.objects.create(name=<span class="string">&quot;python基础&quot;</span>, price=<span class="number">99</span>, author=<span class="string">&quot;luenci&quot;</span>, pub_date=<span class="string">&quot;2020-06-14&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 便捷方法</span></span><br><span class="line">dic = &#123;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;go基础&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;price&#x27;</span>: <span class="number">99</span>,</span><br><span class="line"><span class="string">&#x27;author&#x27;</span>: <span class="string">&#x27;luenci&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;pub_date&#x27;</span>: <span class="string">&#x27;2020-06-13&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Book.objects.create(**dic)</span><br></pre></td></tr></table></figure>
<ul>
<li>更新数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法一：(推荐用)</span></span><br><span class="line">Book.objects.<span class="built_in">filter</span>(author=<span class="string">&#x27;luenci&#x27;</span>).update(price=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">b = Book.objects.get(name=<span class="string">&#x27;go基础&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># &lt;QuerySet [&lt;Book: Book object (3)&gt;]</span></span><br><span class="line">b.price = <span class="number">8.9</span></span><br><span class="line">b.save()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b)) <span class="comment"># &lt;class &#x27;app01.models.Book&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> HttpResponse(<span class="string">&quot;修改成功&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>删除数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Book.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;go基础&quot;</span>).delete()</span><br></pre></td></tr></table></figure>
<ul>
<li>查找数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取所有对象</span></span><br><span class="line">book_list = Book.objects.<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对name去重</span></span><br><span class="line">book_list = Book.objects.<span class="built_in">all</span>().values(<span class="string">&quot;name&quot;</span>).distinct()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计</span></span><br><span class="line">book_list = Book.objects.<span class="built_in">all</span>().values(<span class="string">&quot;name&quot;</span>).distinct().count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询的是对象的集合，即使只有一个对象也是集合的形式</span></span><br><span class="line">book_list = Book.objects.<span class="built_in">filter</span>(author=<span class="string">&#x27;luenci&#x27;</span>) </span><br><span class="line"></span><br><span class="line">book_list = Book.objects.first()</span><br><span class="line">book_list = Book.objects.last()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定查询到一个对象</span></span><br><span class="line">book_list = Book.objects.get(<span class="built_in">id</span>=<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询作者为luenci出版的书名.（字典的集合）</span></span><br><span class="line">book_list1 = Book.objects.<span class="built_in">filter</span>(author=<span class="string">&#x27;luenci&#x27;</span>).values(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;price&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询作者为luenci出版的书名.（列表的集合）</span></span><br><span class="line">book_list2 = Book.objects.<span class="built_in">filter</span>(author=<span class="string">&#x27;luenci&#x27;</span>).values_list(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;price&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;QuerySet [&#123;&#x27;name&#x27;: &#x27;go基础&#x27;, &#x27;price&#x27;: 99.0&#125;, &#123;&#x27;name&#x27;: &#x27;python基础&#x27;, &#x27;price&#x27;: 99.0&#125;, &#123;&#x27;name&#x27;: &#x27;python基础&#x27;, &#x27;price&#x27;: 66.0&#125;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(book_list1) </span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;QuerySet [(&#x27;go基础&#x27;, 99.0), (&#x27;python基础&#x27;, 99.0), (&#x27;python基础&#x27;, 66.0), (&#x27;docker基础&#x27;, 8.9)]&gt;</span></span><br><span class="line"><span class="built_in">print</span>(book_list2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Python后端架构演进（转载）</title>
    <url>/2023/02/06/Django%E5%90%8E%E7%AB%AF%E6%BC%94%E5%8C%96/</url>
    <content><![CDATA[<h1>Python后端架构演进</h1>
<p><em><strong>本文转自python社区：<a href="https://www.pythontab.com/html/2018/pythonweb_0725/1329.html">https://www.pythontab.com/html/2018/pythonweb_0725/1329.html</a></strong></em></p>
<h2 id="架构">架构</h2>
<p>做了3年的后端开发, 经历一款SaaS产品从0到10(还没有到100, 哈哈哈)的过程, 3年间后端的架构逐步演变, 在微服务的实践过程中遇到的问题也越来越多, 在这里总结下.</p>
<p>产品是一款服务于人力资源的SaaS在线服务, 面向HR有Web Android/iOS 小程序多个客户端, 后端采用RESTful风格API来提供服务. 主要使用Python语言, 方便快速迭代.</p>
<p>架构的演进经历了4个大的阶段: 1. MVC 2. 服务拆分 3. 微服务架构 4. 领域驱动设计.</p>
<h3 id="1-MVC">1. MVC</h3>
<p>项目刚开始的时候, 后端同事不超过5个, 这个阶段主要的工作是实现产品的原型, 没有太多的考虑架构, 使用Django来快速实现功能, DB的表结构设计好之后, 抽象出功能View, 由于产品设计也很不完善, 后端需要很多的预留设计, 避免产品逻辑的变更带来整个表结构的变动, 在这个阶段代码上最重要的是确定适合团队的代码规范, 代码检查规则.</p>
<p><img src="https://www.pythontab.com/uploadfile/other/90431532483907.jpg" alt="img"></p>
<p>整体上架构如上图, Nginx负责负载均衡, 分发流量到多个Django服务, Django处理逻辑, 需要异步任务就交给Celery, 然后数据量比较大的地方使用Redis做缓存. 同时还有实时消息通知的需要使用了Nginx Push Module.</p>
<p>问题与优化方式:</p>
<p>Django并发性能差 使用uWSGI Master+Worker 配合 gevent 携程支持高并发</p>
<p>Redis连接数过多 使用redis-py自带的连接池来实现连接复用</p>
<p>MySQL连接数过多 使用djorm-ext-pool连接池复用连接</p>
<p>Celery配置gevent支持并发任务</p>
<p>随着开发的功能越来越多, Django下的app也越来越多, 这就带了发布上的不方便, 每次发布版本都需要重启所有的Django服务, 如果发布遇到问题, 只能加班解决了. 而且单个Django工程下的代码量也越来越多, 不好维护.</p>
<span id="more"></span>
<h3 id="2-服务拆分">2. 服务拆分</h3>
<p>随着后端团队的壮大, 分给每个同事的需求也越来越细, 如果继续在一个工程里面开发所有的代码, 维护起来的代价太高, 而我们的上一个架构中在Django里面已经按模块划分了一个个app, app内高类聚, app之间低耦合, 这就为服务的拆分带来了便利. 拆分的过程没有遇到太大的问题, 初期的拆分只是代码的分离, 把公用的代码抽离出来实现一个公用的Python库, 数据库, Redis还是共用, 随着负载的增加, 数据库也做了多实例.</p>
<p><img src="https://www.pythontab.com/uploadfile/other/3221532483908.jpg" alt="img"></p>
<p>如上图, 服务之间尽量避免相互调用, 需要交互的地方采用http请求的方式, 内网的调用使用hosts指向内网地址.</p>
<p>问题与优化方式:</p>
<p>Nginx Push Module由于长时间没有维护, 长连接最大数量不够, 使用Tornado + ZeroMQ实现了tormq服务来支撑消息通知</p>
<p>服务之间的调用采用http的方式, 并且要求有依赖的服务主机配置hosts指向被调用的地址, 这样带来的维护上的不方便. 以及在调用链的过程中没有重试, 错误处理, 限流等等的策略, 导致服务可用性差. 随着业务拆分, 继续使用Nginx维护配置非常麻烦, 经常因为修改Nginx的配置引发调用错误. 每一个服务都有一个完整的认证过程, 认证又依赖于用户中心的数据库, 修改认证时需要重新发布多个服务.</p>
<h3 id="3-微服务架构">3. 微服务架构</h3>
<p><img src="https://www.pythontab.com/uploadfile/other/88111532483909.jpg" alt="img"></p>
<p>首先是在接入层引入了基于OpenResty的Kong API Gateway, 定制实现了认证, 限流等插件. 在接入层承接并剥离了应用层公共的认证, 限流等功能. 在发布新的服务时, 发布脚本中调用Kong admin api注册服务地址到Kong, 并加载api需要使用插件.</p>
<p>为了解决相互调用的问题, 维护了一个基于gevent+msgpack的RPC服务框架doge, 借助于etcd做服务治理, 并在rpc客户端实现了限流, 高可用, 负载均衡这些功能.</p>
<p>在这个阶段最难的技术选型, 开源的API网关大多用Golang与OpenResty(lua)实现, 为了应对我们业务的需要还要做定制. 前期花了1个月时间学习OpenResty与Golang, 并使用OpenResty实现了一个短网址服务shorturl用在业务中. 最终选择Kong是基于Lua发布的便利性, Kong的开箱即用以及插件开发比较容易. 性能的考量倒不是最重要的, 为了支撑更多的并发, 还使用了云平台提供的LB服务分发流量到2台Kong服务器组成的集群. 集群之间自动同步配置.</p>
<p>饿了么维护一个纯Python实现的thrift协议框架thriftpy, 并提供很多配套的工具, 如果团队足够大, 这一套RPC方案其实是合适的, 但是我们的团队人手不足, 水平参差不齐, 很难推广这一整套学习成本高昂的方案. 最终我们开发了类Duboo的RPC框架doge, 代码主要参考了weibo开源的motan.</p>
<h3 id="4-领域驱动设计">4. 领域驱动设计</h3>
<p><img src="https://www.pythontab.com/uploadfile/other/83971532483909.jpg" alt="img"></p>
<p>在这一架构中我们尝试从应用服务中抽离出数据服务层, 每一个数据服务包含一个或多个界限上下文, 界限上下文类只有一个聚合根来暴露出RPC调用的方法. 数据服务不依赖于应用服务, 应用服务可以依赖多个数据服务. 有了数据服务层, 应用就解耦了相互之间的依赖, 高层服务只依赖于底层服务.</p>
<p>在我离职时领域驱动设计还在学习设计阶段, 还没有落地, 但是我相信前公司的后端架构一定会往这个方向继续演进.</p>
<h3 id="总结">总结</h3>
<p>架构的设计, 技术的选型, 不能完全按照流行的技术走, 最终还是服务于产品, 服务于客户的需求. 设计过程中由于团队, 人员的结构问题, 有很多的妥协之处, 如何在妥协中找到最优解才是最大的挑战.</p>
]]></content>
      <categories>
        <category>python后端架构</category>
      </categories>
      <tags>
        <tag>架构演进</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie和Session知识</title>
    <url>/2023/02/06/Django%E7%9A%84Cookie%E5%92%8CSession/</url>
    <content><![CDATA[<blockquote>
<p>参考：</p>
<p><a href="https://juejin.im/post/5aa783b76fb9a028d663d70a">https://juejin.im/post/5aa783b76fb9a028d663d70a</a></p>
<p><a href="https://www.cnblogs.com/wj-1314/p/10496253.html">https://www.cnblogs.com/wj-1314/p/10496253.html</a></p>
</blockquote>
<ul>
<li><strong>Session是存储在服务器端的，Cookie是存储在客户端的</strong></li>
</ul>
<h2 id="Cookie的概念">Cookie的概念</h2>
<ul>
<li>Cookie是客户端用户信息的一种机制，用来记录用户的一些信息，实际上Cookie是服务器在<strong>本地机器</strong>上存储的一小段文本，并随着每次请求发送到服务器。</li>
</ul>
<h2 id="Cookie与Session的区别">Cookie与Session的区别</h2>
<ol>
<li>cookie数据存放在客户的浏览器（客户端）上，session数据放在服务器上，但是服务端的session的实现对客户端的cookie有依赖关系的。</li>
<li><strong>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</strong>，考虑到安全应当使用session；</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE；</li>
<li>一个服务器最多在客户端浏览器上保存20个Cookie；</li>
<li>一个浏览器最多保存300个Cookie</li>
<li>单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K；</li>
</ol>
<blockquote>
<p>上面的数据只是HTTP的Cookie规范，但是在浏览器大战的今天，一些浏览器为了打败对手，为了展示自己的能力起见，可能对Cookie规范“扩展”了一些，例如每个Cookie的大小为8KB，最多可保存500个Cookie等！但也不会出现将你的硬盘占满的可能</p>
</blockquote>
<h2 id="Cookie与session的实现原理">Cookie与session的实现原理</h2>
<p><img src="C:%5CUsers%5CLuenci%5CPictures%5C1226410-20190326171141383-1715230740.png" alt="img"></p>
<p>上图很明显的展示了Django的session和cookie的实现原理。</p>
<ul>
<li>
<p>服务器会生成两份相同的cookie字符串，一份保存在本地，一份发向请求的浏览器。</p>
</li>
<li>
<p>浏览器将会受到的cookie字符串保存下来，当下次再发请求时，会将信息与这段cookie一同发送到服务器，服务器得到这段cookie会与本地保存的那份判断是否相同，如果相同就表示用户已经登录成功，保存用户登录成功的状态。</p>
</li>
<li>
<p>Django的session保存在数据库中的数据相当于一个大字典，key为cookie的字符串，value仍是一个字典，字典的key和value为用户设置的相关信息，这样就可以方便的存取session里面的信息。</p>
</li>
</ul>
<h2 id="cookie和session内容">cookie和session内容</h2>
<ul>
<li>cookie内容主要包括：key，value，过期时间，路径和域。路径和域一起构成了cookie的作用范围。</li>
<li>cookie的使用由浏览器按照一定的规则在后台自动发送给服务器的，浏览器检查所在存储的cookie，如果某个cookie的作用范围大于等于将要请求的资源所在位置，将cookie附在请求资源的HTTP请求头上发给服务器。</li>
<li>cookie的生命周期跟过期时间相关，如果不设置过期时间，成为会话cookie，保存在内存中，关闭浏览器窗口，cookie消失。如果设置过期时间，浏览器会把cookie写入硬盘，这些cookie仍然有效，知道超过设定的过期时间。</li>
<li>存在硬盘上的cookie可以在同一个浏览器不同进程间共享，比如两个Chrome窗口。存在内存的，不同浏览器不同的处理方式</li>
<li>session内容，服务器使用类似Python字典的key value 的形式存储，存储session方式很多，数据库，缓存，文件，加密cookie，数据库加缓存。</li>
</ul>
<span id="more"></span>
<h2 id="Cookie的用途">Cookie的用途</h2>
<ul>
<li>服务器使用Cookie来跟踪客户端状态</li>
<li>保存购物车</li>
<li>显示上次登录名</li>
</ul>
<h3 id="Cookie与HTTP头">Cookie与HTTP头</h3>
<p>Cookie是通过HTTP请求和响应头在客户端和服务器端传递的：</p>
<ul>
<li>Cookie：</li>
</ul>
<p>请求头，客户端发送给服务器端；</p>
<p>格式：Cookie：a=A；b=B；c=C。即多个Cookie用分号离开；</p>
<ul>
<li>Set-Cookie：</li>
</ul>
<p>响应头，服务器端发送给客户端。</p>
<p>一个Cookie对象一个Set-Cookie：</p>
<p>Set-Cookie：a=A</p>
<p>Set-Cookie：b = B</p>
<p>Set-Cookie：c=C</p>
<h3 id="Cookie的覆盖">Cookie的覆盖</h3>
<ul>
<li>如果服务器端发送重复的Cookie，那么会覆盖原有的Cookie。</li>
<li>cookies是浏览器为Web服务器存储的一小段信息。每次浏览器从某个服务器请求页面时，它向服务器会送之前收到的cookies，它保存在浏览器下的某个文件夹下。</li>
</ul>
<h2 id="Cookie的使用">Cookie的使用</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录校验</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, redirect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="built_in">print</span>(request.COOKIES)</span><br><span class="line">    <span class="built_in">print</span>(request.session)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        name = request.POST.get(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">        pwd = request.POST.get(<span class="string">&quot;passwd&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&#x27;luenci&#x27;</span> <span class="keyword">and</span> pwd == <span class="string">&#x27;123&#x27;</span>:</span><br><span class="line">            ret = redirect(<span class="string">&quot;/index/&quot;</span>)</span><br><span class="line">            ret.set_cookie(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;luenci&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>, <span class="built_in">locals</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># &#123;&#x27;Hm_lvt_ca9c9aeca6d24b987c40c4c8ad091e42&#x27;: &#x27;1591770252,1591772319&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;csrftoken&#x27;: &#x27;DP9BWOWgK1fGi5goPqAlFhR4tX2TC4eXL2NuIC6TjrObLc6IwmGmup0r5M5sCZBH&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;sessionid&#x27;: &#x27;edvrn0uevgi556t8wrlvh2iqg0xzmm92&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;name&#x27;: &#x27;luenci&#x27;&#125;</span></span><br><span class="line">    <span class="built_in">print</span>(request.COOKIES)</span><br><span class="line">    <span class="keyword">if</span> request.COOKIES.get(<span class="string">&#x27;name&#x27;</span>, <span class="literal">None</span>) == <span class="string">&#x27;luenci&#x27;</span>:</span><br><span class="line">        name = request.COOKIES.get(<span class="string">&#x27;name&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&#x27;index.html&#x27;</span>, <span class="built_in">locals</span>())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/login/&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Session概述">Session概述</h2>
<ul>
<li>session就是在服务器端的“Cookie”，将用户数据保存在服务器端，远比保存在用户端要安全，方便和快捷的多。Session依赖于Cookie，但是与Cookie不同的地方就是在于session将所有的数据都放在服务器端，用户浏览器的cookie中只会保存一个非明文的识别信息，比如哈希值。</li>
<li>Session是服务器端技术，利用这个技术，服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象，由于session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户再去访问该服务器中的其他web资源时，其他web资源再从用户各自的session中取出数据为用户服务。</li>
<li>Django的Session机器会向请求的浏览器发送cookie字符串。同时也会保存在本地一份，用来验证浏览器登录是否为同一用户。他存在于服务器，Django默认会把session存入数据库中。</li>
<li>Session依赖于Cookie，如果浏览器不能保存cookie，那么session就失效了。因为他需要浏览器的cookie和session做对比。session就是用来在服务器端保存用户的会话状态</li>
</ul>
<h2 id="Session的作用">Session的作用</h2>
<p>session下次通过cookie中的sessionID（键）获取用户信息值（值）</p>
<ul>
<li>1，会话保持，记住用户的登录状态（WEB网站，分布式架构）</li>
<li>2，避免了敏感信息保存在客户端，防止客户端修改cookie信息（和cookie的区别）</li>
</ul>
<h4 id="session的过期时间">session的过期时间</h4>
<p>session的过期时间：django默认设置是2周 ，如果session过期，浏览器再携带之前的cookie就不能免登陆了。因为cookie已经失效了。</p>
<ul>
<li>
<p>前端：如果超出了session的过期时间，那么浏览器会自动将对应的cookie删除掉</p>
</li>
<li>
<p>后端：django没有对过期的session做任何处理</p>
</li>
</ul>
<h4 id="删除后台保留的一些过期的session信息">删除后台保留的一些过期的session信息</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py clearsessions</span><br></pre></td></tr></table></figure>
<ul>
<li>当然，如果用户在过期时间内主动退出登录，那么django会将该用户对应的session数据给删除掉 （<code>request.session.flush()</code>）</li>
<li>但是如果用户在登录完以后没有主动退出，并且超出了过期时间，用户需要重新登录，<strong>但django中的过期session是不清除的</strong>，需要定期清理过期的session数据。</li>
</ul>
<h2 id="Session的保存方式">Session的保存方式</h2>
<p>Session是大多数网站都需要具备的功能，Django为我们提供了一个通用的session框架，并且可以使用多种session数据的保存方式：</p>
<ul>
<li>保存在数据库内</li>
<li>保存到缓存</li>
<li>保存到文件内</li>
<li>保存到cookie内</li>
</ul>
<p>通常情况下，没有特别需求的话，请使用保存在数据库内的方式，尽量不要保存在cookie内。</p>
<ul>
<li>django的session框架支持匿名会话，封装了cookies的发送和接收过程。cookie包含一个会话ID而不是数据本身（除非你使用的是基于后端的cookie）</li>
<li>django的会话框架完全的，唯一的基于cookie。它不像PHP一样，把会话的ID放在URL中，那样不仅使得URL变得丑陋，而且使得你的网站易于受到通过<code>Referer</code>头部进行窃取会话ID的攻击。</li>
</ul>
<h2 id="Session的使用">Session的使用</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录校验</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, redirect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cookies:&quot;</span>, request.COOKIES)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Session:&quot;</span>, request.session)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        name = request.POST.get(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">        pwd = request.POST.get(<span class="string">&quot;passwd&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&#x27;luenci&#x27;</span> <span class="keyword">and</span> pwd == <span class="string">&#x27;123&#x27;</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Cookie Session</span></span><br><span class="line">            request.session[<span class="string">&quot;is_login&quot;</span>] = <span class="literal">True</span></span><br><span class="line">            request.session[<span class="string">&quot;user&quot;</span>] = name</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;/index/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>, <span class="built_in">locals</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># &#123;&#x27;Hm_lvt_ca9c9aeca6d24b987c40c4c8ad091e42&#x27;: &#x27;1591770252,1591772319&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;csrftoken&#x27;: &#x27;DP9BWOWgK1fGi5goPqAlFhR4tX2TC4eXL2NuIC6TjrObLc6IwmGmup0r5M5sCZBH&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;sessionid&#x27;: &#x27;edvrn0uevgi556t8wrlvh2iqg0xzmm92&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;name&#x27;: &#x27;luenci&#x27;&#125;</span></span><br><span class="line">    <span class="comment"># print(request.COOKIES)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> request.session.get(<span class="string">&quot;is_login&quot;</span>, <span class="literal">None</span>):</span><br><span class="line">        name = request.session.get(<span class="string">&quot;user&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;index.html&quot;</span>, <span class="built_in">locals</span>())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/login/&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Http知识</category>
      </categories>
      <tags>
        <tag>Cookie和Session</tag>
      </tags>
  </entry>
  <entry>
    <title>Django的ORM字段介绍</title>
    <url>/2023/02/06/Django%E7%9A%84Field%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1>Django的Field详解（转载）</h1>
<blockquote>
<p>本文转载于：<a href="https://www.cnblogs.com/ellisonzhang/p/10679054.html">https://www.cnblogs.com/ellisonzhang/p/10679054.html</a></p>
</blockquote>
<h2 id="字段">字段</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、models.AutoField　　自增列 = <span class="built_in">int</span>(<span class="number">11</span>)</span><br><span class="line">　　如果没有的话，默认会生成一个名称为 <span class="built_in">id</span> 的列，如果要显示的自定义一个自增列，必须将给列设置为主键 primary_key=<span class="literal">True</span>。</span><br><span class="line"><span class="number">2</span>、models.CharField　　字符串字段</span><br><span class="line">　　必须 max_length 参数</span><br><span class="line"><span class="number">3</span>、models.BooleanField　　布尔类型=tinyint(<span class="number">1</span>)</span><br><span class="line">　　不能为空，Blank=<span class="literal">True</span></span><br><span class="line"><span class="number">4</span>、models.ComaSeparatedIntegerField　　用逗号分割的数字=varchar</span><br><span class="line">　　继承CharField，所以必须 max_lenght 参数</span><br><span class="line"><span class="number">5</span>、models.DateField　　日期类型 date</span><br><span class="line">　　对于参数，auto_now = <span class="literal">True</span> 则每次更新都会更新这个时间；auto_now_add 则只是第一次创建添加，之后的更新不再改变。</span><br><span class="line"><span class="number">6</span>、models.DateTimeField　　日期类型 datetime</span><br><span class="line">　　同DateField的参数</span><br><span class="line"><span class="number">7</span>、models.Decimal　　十进制小数类型 = decimal</span><br><span class="line">　　必须指定整数位max_digits和小数位decimal_places</span><br><span class="line"><span class="number">8</span>、models.EmailField　　字符串类型（正则表达式邮箱） =varchar</span><br><span class="line">　　对字符串进行正则表达式</span><br><span class="line"><span class="number">9</span>、models.FloatField　　浮点类型 = double</span><br><span class="line"><span class="number">10</span>、models.IntegerField　　整形</span><br><span class="line"><span class="number">11</span>、models.BigIntegerField　　长整形</span><br><span class="line">　　integer_field_ranges = &#123;</span><br><span class="line">　　　　<span class="string">&#x27;SmallIntegerField&#x27;</span>: (-<span class="number">32768</span>, <span class="number">32767</span>),</span><br><span class="line">　　　　<span class="string">&#x27;IntegerField&#x27;</span>: (-<span class="number">2147483648</span>, <span class="number">2147483647</span>),</span><br><span class="line">　　　　<span class="string">&#x27;BigIntegerField&#x27;</span>: (-<span class="number">9223372036854775808</span>, <span class="number">9223372036854775807</span>),</span><br><span class="line">　　　　<span class="string">&#x27;PositiveSmallIntegerField&#x27;</span>: (<span class="number">0</span>, <span class="number">32767</span>),</span><br><span class="line">　　　　<span class="string">&#x27;PositiveIntegerField&#x27;</span>: (<span class="number">0</span>, <span class="number">2147483647</span>),</span><br><span class="line">　　&#125;</span><br><span class="line"><span class="number">12</span>、models.IPAddressField　　字符串类型（ip4正则表达式）</span><br><span class="line"><span class="number">13</span>、models.GenericIPAddressField　　字符串类型（ip4和ip6是可选的）</span><br><span class="line">　　参数protocol可以是：both、ipv4、ipv6</span><br><span class="line">　　验证时，会根据设置报错</span><br><span class="line"><span class="number">14</span>、models.NullBooleanField　　允许为空的布尔类型</span><br><span class="line"><span class="number">15</span>、models.PositiveIntegerFiel　　正Integer</span><br><span class="line"><span class="number">16</span>、models.PositiveSmallIntegerField　　正smallInteger</span><br><span class="line"><span class="number">17</span>、models.SlugField　　减号、下划线、字母、数字</span><br><span class="line"><span class="number">18</span>、models.SmallIntegerField　　数字</span><br><span class="line">　　数据库中的字段有：tinyint、smallint、<span class="built_in">int</span>、bigint</span><br><span class="line"><span class="number">19</span>、models.TextField　　字符串=longtext</span><br><span class="line"><span class="number">20</span>、models.TimeField　　时间 HH:MM[:ss[.uuuuuu]]</span><br><span class="line"><span class="number">21</span>、models.URLField　　字符串，地址正则表达式</span><br><span class="line"><span class="number">22</span>、models.BinaryField　　二进制</span><br><span class="line"><span class="number">23</span>、models.ImageField   图片</span><br><span class="line"><span class="number">24</span>、models.FilePathField 文件</span><br></pre></td></tr></table></figure>
<h2 id="参数">参数</h2>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、null=True</span><br><span class="line">　　数据库中字段是否可以为空</span><br><span class="line"><span class="number">2</span>、blank=True</span><br><span class="line">　　django的 Admin 中添加数据时是否可允许空值</span><br><span class="line"><span class="number">3</span>、primary_key = False</span><br><span class="line">　　主键，对AutoField设置主键后，就会代替原来的自增 id 列</span><br><span class="line"><span class="number">4</span>、auto_now 和 auto_now_add</span><br><span class="line">　　auto_now   自动创建---无论添加或修改，都是当前操作的时间</span><br><span class="line">　　auto_now_add  自动创建---永远是创建时的时间</span><br><span class="line"><span class="number">5</span>、choices</span><br><span class="line">    sex_choice=((“F”,“FEMAL”),(“M”,’Male’),)　　　　#admin专用下拉选项    </span><br><span class="line">    gender=models.CharFiled(max_length=<span class="number">2</span>,choice=sex_choice)</span><br><span class="line"><span class="number">6</span>、max_length</span><br><span class="line"><span class="number">7</span>、default　　默认值</span><br><span class="line"><span class="number">8</span>、verbose_name　　Admin中字段的显示名称</span><br><span class="line"><span class="number">9</span>、name|db_column　　数据库中的字段名称</span><br><span class="line"><span class="number">10</span>、unique=True　　不允许重复</span><br><span class="line"><span class="number">11</span>、db_index = True　　数据库索引</span><br><span class="line"><span class="number">12</span>、editable=True　　在Admin里是否可编辑</span><br><span class="line"><span class="number">13</span>、error_messages=None　　错误提示</span><br><span class="line"><span class="number">14</span>、auto_created=False　　自动创建</span><br><span class="line"><span class="number">15</span>、help_text　　在Admin中提示帮助信息</span><br><span class="line"><span class="number">16</span>、validators=[]</span><br><span class="line"><span class="number">17</span>、upload-to</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>Django的ORM多表操作</title>
    <url>/2023/02/06/Django%E7%9A%84ORM%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1>ORM多表操作</h1>
<h2 id="API">API</h2>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>all()</td>
<td>查询所有结果</td>
</tr>
<tr>
<td>filter(**kwargs)</td>
<td>包含了与所给筛选条件相匹配的对象</td>
</tr>
<tr>
<td>get(**kwargs)</td>
<td>返回与所给筛选条件相匹配的对象，返回结果有且只有一个， 如果符合筛选条件的对象超过一个或者没有都会抛出错误。</td>
</tr>
<tr>
<td>exclude(**kwargs)</td>
<td>它包含了与所给筛选条件不匹配的对象</td>
</tr>
<tr>
<td>order_by(*field)</td>
<td>对查询结果排序 用法:order_by (“price”)  <code>DESC</code> 降序</td>
</tr>
<tr>
<td>reverse():</td>
<td>对查询结果反向排序</td>
</tr>
<tr>
<td>count()</td>
<td>返回数据库中匹配查询(<code>QuerySet</code>)的对象数量</td>
</tr>
<tr>
<td>first()</td>
<td>返回第一条记录</td>
</tr>
<tr>
<td>last()</td>
<td>返回最后一条记录</td>
</tr>
<tr>
<td>exists()</td>
<td>如果<code>QuerySet</code>包含数据，就返回<code>True</code>，否则返回<code>False</code> 相当于<code>limit 1</code>(用途查询这个表中是否有值)</td>
</tr>
<tr>
<td>values(*field)</td>
<td>用法:<code>Book.objects.all.values(‘title’,‘price’)</code> 返回值是<code>&lt;queryset[&#123;‘title’:‘aa’,‘pirce’:12&#125;,&#123;&#125;]</code></td>
</tr>
<tr>
<td>values_list(*field):</td>
<td>用法:<code>Book.objects.all.values_list(‘title’,‘price’)</code> 返回值是<code>&lt;queryset[(‘aa’,12),(‘bb’,33)]</code></td>
</tr>
<tr>
<td>distinct()</td>
<td>从返回结果中剔除重复纪录 用法:<code>Book.objects.all.values(‘title’,‘price’).distinct()</code> 错误用法 <code>Book.objects.all.distinct()</code> 因为id不相同,其他相同,无法去重</td>
</tr>
</tbody>
</table>
<h2 id="模糊查询">模糊查询</h2>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">__exact   精确等于 like ‘aaa’</span><br><span class="line">__iexact   精确等于 忽略大小写 ilike ‘aaa’</span><br><span class="line">__contains  是否包含 like ‘<span class="variable">%aaa%</span>’</span><br><span class="line">__icontains 包含 忽略大小写 ilike ‘<span class="variable">%aaa%</span>’，但是对于sqlite来说，contains的作用效果等同于icontains。</span><br><span class="line">__gt     大于</span><br><span class="line">__gte     大于等于</span><br><span class="line">__lt     小于</span><br><span class="line">__lte     小于等于</span><br><span class="line">__in     存在于一个list范围内</span><br><span class="line">__startswith 以…开头</span><br><span class="line">__istartswith 以…开头 忽略大小写</span><br><span class="line">__endswith  以…结尾</span><br><span class="line">__iendswith 以…结尾，忽略大小写</span><br><span class="line">__range   在…范围内</span><br><span class="line">__year     日期字段的年份</span><br><span class="line">__month   日期字段的月份</span><br><span class="line">__day     日期字段的日</span><br><span class="line">__isnull=True/False</span><br><span class="line">__isnull=True 与 __exact=None的区别</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="外键的定义">外键的定义</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># modeld.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    price = models.FloatField()</span><br><span class="line">    pub_date = models.DateField()</span><br><span class="line">    publish = models.ForeignKey(<span class="string">&quot;Publish&quot;</span>,on_delete=models.CASCADE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Publish</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    city = models.CharField(max_length=<span class="number">32</span>)</span><br></pre></td></tr></table></figure>
<h3 id="on-delete的参数"><code>on_delete</code>的参数</h3>
<ul>
<li><code>CASCADE</code>:这就是默认的选项，级联删除，你无需显性指定它。</li>
<li><code>PROTECT</code>: 保护模式，如果采用该选项，删除的时候，会抛出<code>ProtectedError</code>错误。</li>
<li><code>SET_NULL</code>: 置空模式，删除的时候，外键字段被设置为空，前提就是<code>blank=True</code>, <code>null=True</code>,定义该字段的时候，允许为空。</li>
<li><code>SET_DEFAULT</code>: 置默认值，删除的时候，外键字段设置为默认值，所以定义外键的时候注意加上一个默认值。</li>
<li><code>SET()</code>: 自定义一个值，该值只能是对应的实体了</li>
<li><code>DO_NOTHING</code>:不采取行动。如果您的数据库后端强制执行参照完整性，会造成<code>IntegrityError</code>，除非您手动将SQL 约束<code>ON DELETE</code>添加到数据库字段。</li>
</ul>
<h2 id="一对多之对象查询">一对多之对象查询</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过外键实现关联查询</span></span><br><span class="line"><span class="comment"># 一对多： book_obj ————————————》一定是一个对象</span></span><br><span class="line">book_obj = Book.objects.get(name=<span class="string">&quot;python进阶&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(book_obj.publish)</span><br><span class="line"><span class="built_in">print</span>(book_obj.publish.name)</span><br><span class="line"><span class="built_in">print</span>(book_obj.publish.city)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询出版社出版的所有书籍和价格</span></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">pub_obj = Publish.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;人民出版社&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">ret = Book.objects.<span class="built_in">filter</span>(publish=pub_obj).values(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;price&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ret) <span class="comment"># &lt;QuerySet [&#123;&#x27;name&#x27;: &#x27;linux运维&#x27;, &#x27;price&#x27;: 77.0&#125;]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">pub_obj = Publish.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;机械出版社&quot;</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(pub_obj.book_set.<span class="built_in">all</span>())  <span class="comment"># &lt;QuerySet [&lt;Book: python进阶&gt;]&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(pub_obj.book_set.<span class="built_in">all</span>()))  <span class="comment"># &lt;class &#x27;django.db.models.query.QuerySet&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pub_obj.book_set.<span class="built_in">all</span>().values(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;price&quot;</span>))</span><br></pre></td></tr></table></figure>
<h2 id="多对多对象添加">多对多对象添加</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多对多添加信息</span></span><br><span class="line">book_obj = Book.objects.get(<span class="built_in">id</span>=<span class="number">2</span>)</span><br><span class="line">author_obj = Author.objects.get(<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 添加关系</span></span><br><span class="line">book_obj.author.add(author_obj)</span><br><span class="line"><span class="comment"># 删除关系</span></span><br><span class="line">book_obj.author.remove(author_obj)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="聚合查询与分组查询">聚合查询与分组查询</h2>
<h3 id="聚合查询">聚合查询:</h3>
<h4 id="aggregate-args-kwargs"><code>aggregate</code>(*args, **kwargs)</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.聚合  aggregate:返回值是一个字典</span></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Avg,Max,Min,Count</span><br><span class="line"><span class="comment">#问题:查询所有书籍的平均价格,最高价格,最低价格</span></span><br><span class="line"></span><br><span class="line">ret = Book.objects.<span class="built_in">all</span>().aggregate(avg_price=Avg(<span class="string">&#x27;price&#x27;</span>),max_price = Max(<span class="string">&#x27;price&#x27;</span>),min_price=Min(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(ret)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>aggregate()</code>是<code>QuerySet</code> 的一个终止子句，意思是说，它返回一个包含一些键值对的字典。键的名称是聚合值的标识符，值是计算出来的聚合值。键的名称是按照字段和聚合函数的名称自动生成出来的。如果你想要为聚合值指定一个名称，可以向聚合子句提供它。</li>
</ul>
<h2 id="分组查询">分组查询</h2>
<h3 id="annotate-args-kwargs">annotate(*args, **kwargs)</h3>
<ul>
<li>表单模型.objects.values(“group by 分组字段”).annotate(聚合函数(‘聚合字段’))</li>
</ul>
<h2 id="F查询">F查询</h2>
<ul>
<li>Django 支持 F() 对象之间以及 F() 对象和常数之间的加减乘除和取模的操作。</li>
</ul>
<h2 id="Q查询">Q查询</h2>
<ul>
<li>filter() 等方法中的关键字参数查询都是一起进行“AND” 的。 如果你需要执行更复杂的查询（例如OR语句），你可以使用Q对象</li>
</ul>
]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>python解释器的GIL锁</title>
    <url>/2023/02/06/GIL%E9%94%81/</url>
    <content><![CDATA[<h2 id="GlL锁定义">GlL锁定义</h2>
<p>Gll锁：Global Interpreter Lock，又称：全局解释器锁</p>
<blockquote>
<p>任何Python线程执行前，必须先获得GlL锁，然后，每执行100条字节码，解释器就自动释放GL锁，让别的线程有机会执行。这个GlL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
</blockquote>
<h2 id="GlL不是Python特性">GlL不是Python特性</h2>
<p>GlL是Pythn解释器（Cpython）时引入的概念，在JPython、PyPy中没有GlL。GIL并不是Python的语言缺陷。是解释器层级的锁，跟Python语言特性无关</p>
<blockquote>
<p>言外之意，就是全局解释器就是为了锁定整个解释器内部的全局资源，每个线程想要运行首先获取GlL，而GlL本身又是一把互斥锁，造成所有线程只能一个一个one-by-one-并发-交替的执行。</p>
</blockquote>
<h2 id="GlL存在的原因">GlL存在的原因</h2>
<ul>
<li>
<p>早期计算机都是单核设计</p>
</li>
<li>
<p>CPython在执行多线程的时候并不是线程安全的，所以为了程序的稳定性，加一把全局解释锁，能够确保任何时候都只有一个Python线程执行</p>
</li>
</ul>
<blockquote>
<p>GlL产生的背景在CPython解释内部运行多个线程的时候，每个线程都需要解释器内部申请相应的全局资源，由于C语言本身比较底层造成CPython在管理所有全局资源的时候并不能应对所有线程同时的资源请求，因此为了防止资源竞争而发生错误，对所有线程申请全局资源增加了限制-全局解释器锁。</p>
</blockquote>
<span id="more"></span>
<h2 id="GlL锁什么时候释放？">GlL锁什么时候释放？</h2>
<ul>
<li>在当前线程执行超时后会自动释放</li>
<li>在当前线程执行阻塞操作时会自动释放</li>
<li>当前执行完成时</li>
</ul>
<p>Guido对GIL锁的看法：<a href="https://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235">https://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235</a></p>
<h2 id="关于GIL面试题">关于GIL面试题</h2>
<ul>
<li>
<p>描述Python GL的概意，以及它对python多线程的影响？编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否可比单线程性能有提升，并解释原因。</p>
</li>
<li>
<p>Python语言和GlL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机（解释器），难以移除GlL。</p>
</li>
<li>
<p>GlIL：全局解释器锁。每个线程在执行的过程都需要先获取GlL，保证同一时刻只有一个线程可以执行代码。</p>
</li>
<li>
<p>线程释放GL锁的情况：</p>
<ul>
<li>在IO操作等可能会引起阻塞的system call之前，可以暂时释放GIL，但在执行完毕后，必须重新获取GlL</li>
<li>Python 3.x使用计时器（执行时间达到阔值后，当前线程释放GlL）或Python 2.x，tickets计数达到100</li>
</ul>
</li>
<li>
<p>Python使用多进程是可以利用多核的CPU资源的。</p>
</li>
<li>
<p>多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁</p>
</li>
</ul>
<blockquote>
<p>严重问题：既然CPython解释存在GL是否意味每个线程在全局变量就不用加Lock互斥锁了呢？这是一个严重错误的想法，为什么用户操作全局数据还需要加Lock，因为GlL的释放时机我们无法控制-操作非常可能并没有完成，而不像Lock那样我们用完才释放（操作完整）</p>
</blockquote>
<p>举例</p>
<blockquote>
<p>线程1取出全局变量g_number==0一直加到20000，但是还没有来得及将20000写入g_number中，就超时了自动释放GIL 而线程2取出g_number==19999加到39999由于超时自动释放GlL此时线程2获取到GIL继续着未完成的事业将20000写入g_number….这就是之前的多线程案例没有加互斥锁的情况晨终结果是140w东右的盾因</p>
</blockquote>
<h2 id="GIL锁解决方案">GIL锁解决方案</h2>
<h3 id="解决方案一（不推荐）：">解决方案一（不推荐）：</h3>
<ul>
<li>我们换一个解释器执行程序就行了（jython：用JAVA写的python解释器）</li>
</ul>
<h3 id="解决方案二（推荐）">解决方案二（推荐）</h3>
<ul>
<li>使用多进程替换多线程multiprocessing是一个多进程模块，开多个进程，每个进程都带一个GlL，就相当于多线程来用了。</li>
</ul>
<h3 id="解决方案三（推荐）">解决方案三（推荐）</h3>
<ul>
<li>使用python语言的特性：胶水.<br>
我们让子线程部分用c来写，就ok。（实质上也相当于那部分代码绕过了cython解释器）第一步，编写C语言文件：<br>
测试代码，C语言写的死循环，文件名为test2.c：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Loop</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们把将其编译成.so文件（share object）需要执行如下命令(Linux下)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc test.c -shared -o libtets.so</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-shared：将其编译成so文件</p>
<p>-o：表示output，用来输出的文件名</p>
<p>库文件是以lib开头</p>
<p>编译过后，在当前的文件夹下就会生成一个.so文件</p>
</blockquote>
<p>第二步，编写python文件04-04_GIL锁解决方案.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes <span class="keyword">import</span> threading</span><br><span class="line"><span class="comment">#加载动态库</span></span><br><span class="line">my_lib=ctypes，cdll.LoadLibrary（<span class="string">&quot;./libtest2.so&quot;</span>）</span><br><span class="line"><span class="comment">#创建子线程</span></span><br><span class="line">t=threading.Thread（target=my_lib.Loop）</span><br><span class="line">t.start（）</span><br><span class="line"><span class="comment">#主线程</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>：<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>第三步，执行pvthon文件就可避开Cpython解释器的GIL锁</p>
<h3 id="总结">总结</h3>
<ul>
<li>GIL锁称为：“全局解释器锁“，是CPytrton解释器中的锁机制，也是历史遗留问题</li>
<li>要提升多线程执行效率，解决方案：
<ul>
<li>更换解释器</li>
<li>改为进程替换多线程</li>
<li>子线程使用C语言实现（绕过GL锁）</li>
</ul>
</li>
<li>必须要知道的是：
<ul>
<li>CPU密集型不太适合多线程</li>
<li>I/O密集型适合多线程（Gil锁会释放）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>GIL锁</tag>
      </tags>
  </entry>
</search>
