<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[12306自动化抢票实现]]></title>
    <url>%2F2020%2F01%2F02%2F12306%E8%87%AA%E5%8A%A8%E6%8A%A2%E7%A5%A8%2F</url>
    <content type="text"><![CDATA[selenium常用APIfind_element_by_xxx 返回第一个符合条件WebElement元素find_elements_by_xxx 返回符合条件所有元素包含了 WebEelemnt列表函数作用find_element_by_class_name通过class查询元素find_element_by_id通过ID查询元素find_element_by_name通过name查询元素find_element_by_tag_name通过标签名称find_element_by_css_selectorcss样式选择find_element_by_link_text通过链接内容查找find_element_by_partial_link_text通过链接内容包含的内容查找，模糊查询find_element_by_xpath通过xpath查找数据获取元素属性和文本内容12345678#获取属性element.get_attribute（'属性名”）#获取文本内容element.text# 输入框输入内容input_element.send_keys（'Luenci'）# 元素点击element.click()三种等待方式当控制浏览器时，浏览器正在加载页面同时又去获取数据导致浏览器寻找不到需要操作的元素引发异常。方式一：强制等待，浪费时间time.sleep（秒数）方式二：隐性等待，无法控制Ajax请求browser.implicit1y_wait（等待时间）方式三：显性等待，每个元素都可以自己定义检查条件。手动编写方式123456789101112131415#显性等待-手动编写t = time.time（）#定义超时时间timeout = 60while True： try： #超时时间间隔 time.sleep（0.1） ur1_element = browser.find_element_by_class_name（"fav ur1"） break except： #超时处理 if time.time（）- t &gt; timeout： break pass系统提供显性等待API123456789101112131415161718# 导入显性等待的API需要的模块# 1等待对象模块from selenium.webdriver.support.wait import WebDriverwait# 2导入等待条件模块from selenium.webdriver.support import expected_conditions as EC# 3导入查询元素模块from selenium.webdriver.common.by import By# 1.创建等待对象# 参数一浏览器对象# 参数二超时时间# 参数三检查元素时间间隔wait = WebDriverwait（browser，5.0，0.5）# 2.通过等待对象获取元素# presence_of_element_located 检查元素是否存在，如果存在就返回如果不存在就继续检查# visibility_of_element_located 检查元素是否可见linkelement = s wait.until（EC.presence_of_element_located（（By.CLASS_NAME，"favurl"）link_element.click（）12306爬虫实现完成代码见：https://github.com/Lucareful/12306_Tickets实现步骤1.访问列表页2.通过时间判定选择点击预订3.点击账号登录4.输入用户名和密码（15523750230）5.截图获取验证码图片6.发送打码平台获取识别数字7.定义8个点击坐标8.模拟点击坐标9.点击登录10.点击选择人物11.点击提交订单12.点击确认订单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# -*- coding: utf-8 -*-import jsonimport timefrom selenium import webdriverfrom selenium.webdriver import ActionChainsfrom selenium.webdriver.support.wait import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.common.by import Byfrom PIL import Imagefrom io import BytesIO# 判断YDMHTTP模块是否在python环境中（我的是不在，所以加上去）import syssys.path.insert(1, r"YDMHTTP.py")from YDMHTTP import decodebrowser = webdriver.Chrome()browser.maximize_window()linktypeid = "dc"fs = "北京"ts = "武汉"date = "2020-01-13"flag = "N,N,Y"base_url = 'https://kyfw.12306.cn/otn/leftTicket/init?linktypeid=&#123;&#125;&amp;fs=&#123;&#125;,BJP&amp;ts=&#123;&#125;,WHN&amp;date=&#123;&#125;&amp;flag=&#123;&#125;'url = base_url.format(linktypeid, fs, ts, date, flag)browser.get(url)wait = WebDriverWait(browser, 10, 0.5)# 通过时间判定选择预定车次# 寻找tr标签中的 属性id 已 ’ticket_‘ 开头的数据tr_list = wait.until(EC.visibility_of_all_elements_located((By.XPATH, '//tr[starts-with(@id, "ticket_")]')))for tr in tr_list: date_string = tr.find_element_by_class_name("start-t").text # 判断时间是否在符合你想要的时间范围中 tr.find_element_by_class_name('no-br').click() # print(date_string) break# 点击账号 异步加载需要显性等待wait.until(EC.visibility_of_element_located((By.LINK_TEXT, "账号登录"))).click()# browser.find_element_by_link_text("账号登录").click()# 输入用户名和密码（我将我的用户名和密码保存在了json文件中，若别人使用需要更改）with open("account.json", "r", encoding="utf-8") as f: account = json.load(f)browser.find_element_by_id("J-userName").send_keys(account["username"])browser.find_element_by_id("J-password").send_keys(account["password"])# 获取全屏截图full_img_data = browser.get_screenshot_as_png()# 截取验证图片login_img_element = wait.until((EC.visibility_of_element_located((By.ID, "J-loginImg"))))# 计算截图位置# 截取验证码的位置scale = 2.0x1 = login_img_element.location["x"]y1 = login_img_element.location["y"]x2 = x1 + login_img_element.size["width"] * scaley2 = y1 + login_img_element.size["height"] * scalecut_info = (x1, y1, x2, y2)# 把全屏图片构建成全屏图片操作对象full_img = Image.open(BytesIO(full_img_data))# 通过截图信息对象截取图片cut_img = full_img.crop(cut_info)# 把图片保存到本地cut_img.save('demo.png')# 将验证图片发送到打码平台result = decode('demo.png', codetype=6701)# 定义八个点击坐标点positions = [ (7.30*25, 140), (10.58*25, 140), (13.83*25, 140), (17.11*25, 140), (7.30*25, 250), (10.58*25, 250), (13.83*25, 250), (17.05*25, 250)]# 模拟点击坐标for num in result: position = positions[int(num) - 1] # 动作对象 ActionChains(browser).move_to_element_with_offset(login_img_element, position[0]/2, position[1]/2).click().perform()# 点击登录browser.find_element_by_id("J-login").click()# 点击选择乘车人wait.until(EC.visibility_of_element_located((By.ID, "normalPassenger_0")))# 点击提交订单browser.find_element_by_id("submitOrder_id").click()time.sleep(5)]]></content>
      <categories>
        <category>selenium知识</category>
      </categories>
      <tags>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js的基本知识]]></title>
    <url>%2F2019%2F12%2F26%2Fvue%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Vue.js概念Vue.js是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App，Vue语法也是可以用于进行手机App开发的，需要借助于Weex）Vue.js 是前端的主流框架之一，和Angularjs、Reactjs一起，并成为前端三大主流框架！·Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）框架和库的区别框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。后端中的MVC与前端中的MVVM之间的区别MVC是后端的分层开发概念；MVVM是前端视图层的概念，主要关注于视图层分离，也就是说：MVVM把前端的视图层，分为了三部分Model，View，VM ,ViewModelvue.js基本架构12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 导入Vue的包 --&gt; &lt;script src="../lib/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 将来new的实例，会控制这个元素中的所有内容 --&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建一个vue的实例 // 当我们导入包之后，在浏览器的内存中，就多了一个vue构造函数 var vm = new Vue(&#123; el: '#app', //表示，当前我们new的这个vue实例，要控制页面上的哪个区域 data: &#123; // data属性中存放的是 el 中要用到的内容 msg: '欢迎学习Vue' //通过vue提供的指令，很方便的就能把数据渲染到页面上，程序员不再手动操作DOM元素了 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;基本事件语法&lt;！--1.如何定义一个基本的vue代码结构--&gt;&lt;！--2.插值表达式和 v-text--&gt;&lt;!--3.v-cloak--&gt;&lt;!--4.v-html--&gt;&lt;！--5.v-bind vue提供的属性绑定机制缩写是 : --&gt;&lt;l--6.v-on vue提供的事件绑定机制缩写是 @ --&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="../lib/vue.min.js"&gt;&lt;/script&gt; &lt;style&gt; [v-cloak]&#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- v-cloak能够解决 插值表达式闪烁的问题 --&gt; &lt;p v-cloak&gt;++++++ &#123;&#123; msg &#125;&#125; ----------&lt;/p&gt; &lt;!-- 默认v-text没有闪烁问题 --&gt; &lt;h1 v-text="msg"&gt;&lt;/h1&gt; &lt;!--v-text会覆盖元素中原本的内容，但是插值表达式只会替换自己的这个占位符，不会把整个元素的内容清空--&gt;I &lt;div&gt; &#123;&#123;msg2&#125;&#125; &lt;/div&gt; &lt;div&gt; &lt;p v-text="msg2"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div v-html="msg2"&gt;&lt;/div&gt; &lt;!-- v-bind: 是vue中，提供用于绑定属性的指令 --&gt; &lt;!-- v-bind 也可以简写为 :要绑定的属性 --&gt; &lt;!-- v-bind 中可以写合法的js表达式 --&gt; &lt;!-- Vue中提供了 v-on: 事件绑定机制 --&gt; &lt;!-- &lt;input type="button" value="按钮" :title="myTitle" v-on:click = "alter('Hello')"&gt; --&gt; &lt;input type="button" value="按钮" @click="show"&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123', msg2: '&lt;h2&gt;Luenci&lt;/h2&gt;', myTitle: '自定义标题' &#125;, methods: &#123; show: function()&#123; alert('Hello') &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;Vue指令之事件修饰符事件修饰符.stop 阻止冒泡.prevent 阻止默认事件.capture 添加事件侦听器时使用事件捕获模式.self只当事件在该元素本身（比如不是子元素）触发时触发回调.once事件只触发一次Vue指令之v-model和双向数据绑定1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="../lib/vue.min.js"&gt;&lt;/script&gt; &lt;style&gt; .btn&#123; width:100%&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;h4&gt;&#123;&#123; msg &#125;&#125;&lt;/h4&gt; &lt;!--v-bind只能实现数据的单向绑定，从M自动绑定到V，无法实现数据的双向绑定--&gt; &lt;!--&lt;input type="text" v-bind:value="msg" style="width：100%；"&gt;--&gt; &lt;!--使用v-mode1指令，可以实现表单元素和 Model 中数据的双向数据绑定--&gt; &lt;!--注意：v-mode1只能运用在表单元素中--&gt; &lt;!--input（radio，text，address，email....）select checkbox textarea--&gt; &lt;input class="btn" type="text" v-model="msg"&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; msg:'hello Vue.js' &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;Vue中使用样式使用class样式1.数组&lt;h1 :class=&quot;[&#39;red&#39;,&#39;thin&#39;]&quot;&gt;这是一个H1&lt;/h1&gt;2.数组中使用三元表达&lt;h1 :class=&quot;[&#39;red&#39;,&#39;thin&#39;,is active?&#39;active&#39;:&#39;&#39;]&quot;&gt;这是一个H1&lt;/h1&gt;3.数组中嵌套对象&lt;h1 :class=&quot;[&#39;red&#39;,&#39;thin&#39;, {&#39;active&#39;:isactive}]&quot;&gt;这是一个H1&lt;/h1&gt;4.直接使用对象&lt;h1 :class=&quot;{red:true, italic:true, active:true，thin:true}&quot;&gt;这是一个H1&lt;/h1&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Luenci&lt;/title&gt; &lt;script src="../lib/vue.min.js"&gt;&lt;/script&gt; &lt;style&gt; .red&#123; color: red; &#125; .thin&#123; font-weight: 200; &#125; .italic&#123; font-style: italic; &#125; .active&#123; letter-spacing: 0.5em; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- &lt;h1 class="red"&gt;这是一个很大很大的H1&lt;/h1&gt; --&gt; &lt;!--第一种使用方式，直接传递一个数组，注意：这里的class需要使用 v-bind 做数据绑定--&gt; &lt;h1 :class="['thin', 'active']"&gt;这是一个很大很大的H1&lt;/h1&gt; &lt;!-- 数组中使用三元表达式 --&gt; &lt;h1 :class="['thin', 'active', falg ? 'red':'italic']"&gt;这是一个很大很大的H1&lt;/h1&gt; &lt;!-- 数组中嵌套对象 --&gt; &lt;h1 :class="['thin', 'active', &#123;'red':falg&#125;]"&gt;这是一个很大很大的H1&lt;/h1&gt; &lt;!-- 直接使用对象 --&gt; &lt;h1 :class="&#123;'thin': true, 'active': true, 'italic': false&#125;"&gt;这是一个很大很大的H1&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data:&#123; falg: true &#125;, methods:&#123;&#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;使用内联样式1.直接在元素上通过style的形式，书写样式对象&lt;h1 :style=&quot;{color:‘red&#39;，&#39;font-size&#39;：&#39;40px&#39;}&quot;&gt;这是一个善良的H1&lt;/hl&gt;2.将样式对象，定义到data中，并直接引用到:style中在data上定义样式：123data:&#123; histyObj:&#123;color:&apos;red&apos;，&apos;font-size&apos;：&apos;40px&apos;，&apos;font-weight&apos;：200&apos; &#125;在元素中，通过属性绑定的形式，将样式对象应用到元素中：&lt;h1 :style=&quot;histyObj&quot;&gt;这是一个h1&lt;/h1&gt;3.在:style中通过数组，引用多个data上的样式对象在data上定义样式：123data:&#123; histy0bj:&#123;color:&apos;red&apos;，&apos;font-size&apos;：‘40px&apos;，‘font-weight&quot;：&apos;200&apos;&#125;, histy0bj2:&#123;fontstyle:&apos;italic&apos;&#125;在元素中，通过属性绑定的形式，将样式对象应用到元素中：&lt;h1 :style=&quot;[histy0bj，histy0bj2]&quot;&gt;这是一个h1&lt;/h1&gt;123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="../lib/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 直接在元素上通过`style`的形式，书写样式对象 --&gt; &lt;h1 :style="&#123;color:'red', 'font-weight':200&#125;"&gt;我是一个标题&lt;/h1&gt; &lt;!-- 2.将样式对象，定义到`data`中，并直接引用到`:style`中 --&gt; &lt;h1 :style="styleObj"&gt;我是一个标题&lt;/h1&gt; &lt;!-- 3.在`:style`中通过数组，引用多个`data`上的样式对象 --&gt; &lt;h1 :style="[styleObj, styleObj2]"&gt;我是一个标题&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; styleObj: &#123; color: 'red', 'font-weight': 200 &#125;, styleObj2: &#123; 'font-style': 'italic' &#125; &#125;, methods: &#123;&#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;Vue指令之v-for和key属性1.迭代数组1&lt;1i v-for="（item，i）in list"&gt;索引：&#123;&#123;i&#125;&#125;---姓名：&#123;&#123;item.name&#125;&#125;---年龄：&#123;&#123;item.age&#125;&#125;&lt;/li&gt;2.迭代对象中的属性12&lt;4--循环遍历对象身上的属性--&gt;&lt;div v-for="（val，key，i）in userInfo"&gt;&#123;&#123;val&#125;&#125;---&#123;&#123;key&#125;&#125;---&#123;&#123;i]&#125;&lt;/div&gt;3.迭代数字&lt;p v-for=&quot;ks in 8&quot;&gt;这是第（{i}}个P标签&lt;/p&gt;22.0+的版本里，当在细件中使用v-for时，key现在是必须的。当Vue.js 用v-for正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定素引下显示已被渲染过的每个元素。为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一key属性。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0,minimal-ui:ios"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="../lib/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 循环普通数组 --&gt; &lt;p v-for="(item,i) in list"&gt;索引值:&#123;&#123;i&#125;&#125;-----数值:&#123;&#123;item&#125;&#125;&lt;/p&gt; &lt;!-- 循环对象数组 --&gt; &lt;p v-for="(user,i) in list2"&gt;&#123;&#123;user.id&#125;&#125;====&#123;&#123;user.name&#125;&#125;------&#123;&#123;i&#125;&#125;&lt;/p&gt; &lt;!-- 循环对象 --&gt; &lt;p v-for="(value, key, i) in list3"&gt;&#123;&#123;i&#125;&#125;-------&#123;&#123;key&#125;&#125;----&#123;&#123;value&#125;&#125;&lt;/p&gt; &lt;!-- 循环数字 --&gt; &lt;p v-for="count in 6"&gt;第&#123;&#123;count&#125;&#125;循环&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; list: [1, 2, 3, 4], list2: [ &#123; id: 1, name: 'Luenci' &#125;, &#123; id: 2, name: 'Lynn' &#125;, &#123; id: 3, name: 'lucy' &#125;, &#123; id: 4, name: 'll' &#125;, ], list3: &#123; user: 'Luenci', age: 20, sex: '男', &#125; &#125;, methods: &#123;&#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;Vue指令之v-if和v-show一般来说，v-if有更高的切换消精而v-show 有更高的初始渲染消耗。如果需要频繁切换v-show较好如果元素可能永远也不会被显示出来被用户看到，则推荐使用v-if12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0,minimal-ui:ios"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="../lib/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" value="点击" @click="flag=!flag"&gt; &lt;!-- v-if的特点：每次都会重新删除或创建元素 --&gt; &lt;!-- v-show的特点：每次不会重新进行DoM的删除和创建操作，只是切换了元素的 display:none 样式 --&gt; &lt;!-- v-if有较高的切换性能消耗 --&gt; &lt;!-- v-show 有较高的初始渲染消耗 --&gt; &lt;!-- 如果元素涉及到频繁的切换，最好不要使用v-if --&gt; &lt;!-- 如果元素可能永远也不会被显示出来被用户看到，则推荐使用v-if --&gt; &lt;h1 v-if="flag"&gt;这是v-if控制的元素&lt;/h1&gt; &lt;h1 v-show="flag"&gt;这是v-show控制的元素&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; flag: true &#125;, methods: &#123;&#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;过滤器概念：Vue.js允许你自定义过滤器，可被用作一些嚣见的文本格式化。过滤器可以用在两个地方：mustache插值和v-bind 表达式。过滤器应该被添加在JavaScript表达式的尾部，由“管道”符指示全局过滤器1234567891011121314151617Vue.filter('time', function (Ctime, pattern = '') &#123;var dt = new Date(Ctime)var y = dt.getFullYear()var m = dt.getMonth() + 1var d = dt.getDate()// return y + '--' + m + '--' + dif (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; var hh = dt.getHours() var mm = dt.getMinutes() var ss = dt.getSeconds() return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125;&#125;);局部过滤器12345678910111213141516171819202122232425262728293031var vm2 = new Vue(&#123; el: '#app2', data: [ dt = new Date(), ], methods: &#123;&#125;, filters: &#123; // 定义私有过滤器过滤器有两个条件【过滤器名称和处理函数】 // 过滤器调用的时候，采用的是`就近原则`， //如果私有过滤器和全局过滤器名称一致了，这时候优先调用私有过滤器 deteFormat: function (dateStr, pattern = '') &#123; var dt = new Date(Ctime) var y = dt.getFullYear() var m = dt.getMonth() + 1 var d = dt.getDate() // return y + '--' + m + '--' + d if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; var hh = dt.getHours() var mm = dt.getMinutes() var ss = dt.getSeconds() return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125; &#125; &#125; &#125;)ES6中的字符串新方法String，prototype，padStart(maxlength，fillString=&#39;&#39;）或 String，prototype，padEnd(maxlength，filString=&#39;&#39;）来填充字符串；]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Vue框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL性能调优]]></title>
    <url>%2F2019%2F12%2F20%2FSQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[原文链接：https://blog.csdn.net/u010520146/article/details/81161762一.创建索引1.要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引2.1在经常需要进行检索的字段上创建索引，比如要按照表字段username进行检索，那么就应该在姓名字段上创建索引，如果经常要按照员工部门和员工岗位级别进行检索，那么就应该在员工部门和员工岗位级别这两个字段上创建索引。2.2创建索引给检索带来的性能提升往往是巨大的，因此在发现检索速度过慢的时候应该首先想到的就是创建索引。2.3一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。二.避免在索引上使用计算在where字句中，如果索引列是计算或者函数的一部分，DBMS的优化器将不会使用索引而使用全表查询,函数属于计算的一种,同时在in和exists中通常情况下使用EXISTS，因为in不走索引。效率低：select * from user where salary*22 &gt; 11000 (salary是索引列)效率高：select * from user where salary &gt; 11000/22 (salary是索引列)三.使用预编译查询程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。四.调整Where字句中的连接顺序DBMS一般采用自下而上的顺序解析where字句，根据这个原理表连接最好写在其他where条件之前，那些可以过滤掉最大数量记录。五.尽量将多条SQL语句压缩到一句SQL中每次执行SQL的时候都要建立网络连接、进行权限校验、进行SQL语句的查询优化、发送执行结果，这个过程是非常耗时的，因此应该尽量避免过多的执行SQL语句，能够压缩到一句SQL执行的语句就不要用多条来执行。六.用where字句替换HAVING字句避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。七.使用表的别名当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减少哪些友列名歧义引起的语法错误。八.用union all替换union当SQL语句需要union两个查询结果集合时，即使检索结果中不会有重复的记录，如果使用union这两个结果集同样会尝试进行合并，然后在输出最终结果前进行排序，因此如果可以判断检索结果中不会有重复的记录时候，应该用union all，这样效率就会因此得到提高。九.考虑使用“临时表”暂存中间结果简化SQL语句的重要方法就是采用临时表暂存中间结果，但是，临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。但是也得避免频繁创建和删除临时表，以减少系统表资源的消耗。十.只在必要的情况下才使用事务begin translationSQL Server中一句SQL语句默认就是一个事务，在该语句执行完成后也是默认commit的。其实，这就是begin tran的一个最小化的形式，好比在每句语句开头隐含了一个begin tran，结束时隐含了一个commit。有些情况下，我们需要显式声明begin tran，比如做“插、删、改”操作需要同时修改几个表，要求要么几个表都修改成功，要么都不成功。begin tran 可以起到这样的作用，它可以把若干SQL语句套在一起执行，最后再一起commit。 好处是保证了数据的一致性，但任何事情都不是完美无缺的。Begin tran付出的代价是在提交之前，所有SQL语句锁住的资源都不能释放，直到commit掉。可见，如果Begin tran套住的SQL语句太多，那数据库的性能就糟糕了。在该大事务提交之前，必然会阻塞别的语句，造成block很多。Begin tran使用的原则是，在保证数据一致性的前提下，begin tran套住的SQL语句越少越好！有些情况下可以采用触发器同步数据，不一定要用begin tran。十一.尽量避免使用游标尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。十二.用varchar/nvarchar代替 char/nchar尽可能的使用 varchar/nvarchar代替char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。不要以为 NULL不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null不占用空间。十三.查询select语句优化1.任何地方都不要使用 select * from T，用具体的字段列表代替“*”，不要返回用不到的任何字段2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：1select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：12select id from t where num=0select id from t where num=10 or num=20可以这样查询：123select id from t where num=10 union allselect id from t where num=204.不能前置百分1select id from t where name like ‘%abc%’若要提高效率，可以考虑全文检索。select id from t where num in(1,2,3)对于连续的数值，能用 between 就不要用 in 了：select id from t where num between 1 and 36.如果查询的两个表大小相当，那么用in和exists差别不大。in：例如：表A（小表），表B（大表）12select * from A where cc in (select cc from B) 效率低，用到了A表上cc列的索引； select * from A where exists(select cc from B where cc=A.cc) 效率高，用到了B表上cc列的索引。相反的12select * from B where cc in (select cc from A) 效率高，用到了B表上cc列的索引；select * from B where exists(select cc from A where cc=B.cc) 效率低，用到了A表上cc列的索引。十四.更新Update语句优化1.如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志十五. 删除Delete语句优化语句1.最高效的删除重复记录方法 ( 因为使用了ROWID)例子：1DELETE FROM EMP E WHERE E.ROWID &gt; (SELECT MIN(X.ROWID) FROM EMP X WHERE X.EMP_NO = E.EMP_NO);十六.插入Insert语句优化在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量log，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。]]></content>
      <categories>
        <category>SQL知识</category>
      </categories>
      <tags>
        <tag>SQL调优</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[积善科技（快代理）Python面试总结]]></title>
    <url>%2F2019%2F12%2F19%2F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[输入密码，查看文章 6a0aa1e145b8da5aa67098086c5c237b1a602a217b1b91fa43d79f31035365bd46747d218b88e8be76b24ee23b752479c33c6ba5f917ddc8d200fb8fcb23e6fc56d719c8c1abfdcef11cad74cadf0e1b18f7edc399dbb83aac72ee9ee970ea84da84936a0a8e2cf3bb06602f161126629b40262d66ac80fcb343137a47615a23799436eb42d9271680722e871d0381bf5a29a9bd198cc184eb79d94f8934159ee541fa463ea2c6c96cbedf631ce1c3ce7d98b3fc146048832305ec5d0f1fdfa5708ebaef71e30b7f4db22477878656ae6b439f99f22a395cb7db803307dba57478f38eacb347af1494ecf56caec4470712b27feed6cdc28eb69cef4f9f2884df2aaf8fd764e7c36877f057ed1772e890505c629dc68393be951afa8aaad86effef7c7823012746e11b9c6fe5787f843e4471238030e1e054aad95ae1cef6d3a11d64b18669e8412297e62f86cc281901c2dcdf9618cc6fd00c60f89acf079c705cbcf341a032c72dce5689fbfbbbf0a325780182525c513779e3744bdd7dba40e8d2cd788315b90746a4e6cb7f0e09d4673b51447caeb50c9c0afd510bf20b80bb6b39cc8ae868878786e264a8fe585be030afd56c8de023793860acc96c49613d2e371f30a002d2291ced6031df5f8fa1347aaf0345d2a6fc5c6bef8228952cbfca60c11402fd4759c1bc54a26db68141e520cd053c950e891ead9e1fc2987f1709e61d3fb6524861aeb5346ec313117dc1085f973a6acf80f30b6061515ff1f05aa7cdfb5252b176161a8a77a852e67cc60266d80d8bd7e66eb588bf3fd2fca752ff6ab8cbd6a95bd75ec9ac8a110ee0ce29f54a2461d87d9cc71713f3167ebb56a21146af65461e77228b5193766e993cb59ae3e6fe24b1bc4b2b31767b02a63a4aeb61dd2cc023dee96b9da733b2d12b3f703be6505814454785246b57cf21f856dc490528a8510e69147e440391d625dde97d16f5119bb7313b53c3d2626be62561007f8ed4d5688ca181eeaedbd997fa72fcd864a2c5da4161c793cebff56c71a9b05eae284f7196836131b8b3057511c2bf62fff4e6eb2084daf98e277d26888ab7dacae6cba7c57c3b3f339085863dde7bafabf89b7085a95316eb68d30c9214f5a569987694c14cf53949e2862d7d56659bec6806634b5dd502316b440f3fc8a79a7836c1d1a3f9a77d08b808b0694a94efb4afc9df0cd6f9cec465c4eb85b6f2f1f31c855e2d6d02e529275f9e9bf08bd2f88298d20d0491e29b2ddcd26a768e6948f0d07d482cbd4eeae547a9bf807427b9f4820dcdfd4257aa30fc4003374fe1042b0dfad569478dc410407fb107e0b5aadbcdfc8d876198e9109a00c92e4490d8cee2d8c848c629f28dc5e03a02f30f684f7788a364cd3dbb8374fb2b532e51f37ce8dfc4eca64953873abfa7b266469c2b2d620bb239c53a1a09523a6957d46e45ffc11d2a20d5e9e05b601b29d2d0018d80eab5ee010a995824a0fbe54c3238d654977cf60fb05d26766aa9550f07bdb3df206753418f4992408b5e7eb3a2e4aa17e1c4064b55bccde042875ec9f37d76088311297bc8cdeb1cd839b9967525de9fe26c4640f94aacb1e91e5b059b0817714ac08de436b9668d549ad598cb483fbb28fa4f8c3cd08b73e42f8d747c3dcc30e1a077660b9a366c44ba87c032ee48a5da53e820ccab9c40d2b0c63cb18ae4682825f13bdb943f41fd6ad901a4ff27e3d030f53c92dd9c022fa93afaaffa65436ea9c6c56eedec4d682638102c1edd566d0dd7e14c604da00d8ec9cde3983c0fd72a6d5486d7568f01017ae1324f14ab0103acab68ab31217ed92328ba76f2869de6e81161eb675028486b3d6eda9507ec32e68b0684f50a249dd316b4d47dfaa05d21175912fef2474af0095955d41943d70901a5d900663006a6d902b108d62bd4ed13718dc3688abf2fa0f47b1afb4371f942af940b876f1673d1d54c389c4c9cda0558eeed4ba6c0ae866894fb89bc6084b0df5991da39f6111494f567e1dc0aa151b7a72c36eb7fc325e9e90b505210fdc1fc89915f5f59b5eb5ffa290d078740952786e9b51463c9c22b09e374d4da5dd0dd93069ccb267f17b067d904de06eb29022ca2bbd5680b50b7a94c3dabcaf8e4f546ed9ef4b365f9eeace62a518eb1d52d5903731e36d7ec4bf56c701c026ac25828b0cb2b931edab6e4c7829fa0bc4ab867354528ab9fe7f1d3c4cf6b23d674e98124360303d75ad86fb5f6348b00bf5787f56fcf3b948e41c259fdeac9bab9034979ab7853839611e0236c761e116c8461034d7b97fd6bedf2f243c5bb38c1729afc0985f80940551bd45a7696adc456326ac21011cbcb95bba11a70dddd2a26cf81915ccef00a998bb535a6911b5325a181333c11f3d8cc4b06115fe419bb4a98e5f334c0c7b14188758091955ea8991a4acb0ec8bec8b90b10684976437986f067bb455a6f607825e91e553a31e283368421f40293e7dc1b5593ec55fcf7dd08715cc21befea032a33e7636b4a320ef967c6a8a193ff26120e8abc0d02ae7732109a828074dfec1f93a3c0be09a4ae05a2b94ed1597778be98b16cd462200804d86544f7fa852373c07ca7670f54fbbdff09ef05aec43fd2c33b48c4bd324998f21261453d274bfb25e15217f578ef0475c287934599c0a6a49c9a6d57c90b0e0a0b862e7ada91993e2d4a0e6c28b12def096e909c3ac0ad4d5dfbbf54a90956907589c30c2eb0543ec1c106788af882ebf0f935b4532188a3fb0d84f87f281ec5ba79fc5b09a1789966baf34f12e03ab68721300fbe86bcea0de1efec0e95a73842da1490c84d8256e9273eb676e5cedcc426207ca403f8c99127154d1de6f98814e7f03c5247081548fddafd174b29dbdfaf16a4d6528497d59d239241d86677522de0c4eefe66f6213065c463c37bcdc14c0983636ec71fc76187dd06d9356f9d53d3596dbedaf34ca3a0bb5cfd96b499e662b8593c68db83bd7a079b3857414eefd0d85b9b1a2054186dc6bf1a431344e3e7e263addacd72ef2ebfe0f8954b3d10161ab4633ba78040d0ddb3c766672a169d87f75e29352893a03491e2e765b32d4eb1c3fb47e475aa37a725647ba6542e531b1ca05bef3193d4cbc92464979e85a4f9a51d07c0078986509801e916563fbff788008c0228fc22e7feb49e17fd153007928b638472eb9358dff09209043feaff47dbe4e7cf296660dbb96312184721c771fe4fddd0aecdfa80cd86d83a613ed13515481d3c2e6ec4f740a389dd5eab80b705437b936e1b9e27fbc5c71a951425898804af95d2235370e8c4846e06ea119be648a801f6f2e8464b344395adbd41485d7091e55a7388f208b8de2b2082fedc59dbac6c3d78f9d76229bb9e8d74e39f14aa73f89933e165433037ad0f74a4959001999a0fc56c9d9a00bcc67334ff48c534af96a95d246a846aa9e76258e2ea1c6278d5d3a61e4012e71facd13987cabf097bd71f8738c6641c1e423bb202ad3efd246bab4d95045603af794b63a551db71957a583d4daf95551ef83aceaabbd17a51fce5d0b8591ab4921aa544c88099b4ab39e52c1785da9811b74aa18e6c7b291a2c17a9e6e1a608a24b0dc37d89a6a389080ba45e26f900abf6257bcae4a0550a7d354ab36902caab1ccfa42e0884894272b7186a3e96ba3b7aebb716378d3f6dc451da25651e4a901cc7dd00742f9de86bc42ec548b81512afe2917948454db92590d4c036a3e2e0e187b16bd163623dc83bfb45030142c325ef35c1d9a3cf102c3594324e03f294af11cf4947a039826ab9bd322efec91fa7962b420c831374d47b35861672d4e7588f67372b3a91b1b679f2eb87e45e7a6230738a47d4a4c751f637c8cca449d12bdbe4b323e0c0cf26e2ed6629417faab3c061d8c1bd85081548db82d208da7bf831b66c0380c8c2b9598de68e545c4c6009a185b074c4cfc25491bd12ea2479b0ad8b5da02c02d78dc5381e10102f8e1d54424476da0486748be36a9ece524a54a1e2ef73022fab8727b5b1277ce64770f5255f82ca9d16a620229378f0ecf645355615d1f9d5fc09a8bbffd8faf9397d6dd626f749ce50f35da6b3c2f5857d27a4e41deb6a5345f2908d350b3872539abb8ed9cdc5a5ceaff35d338c9d0f3da6827912de3789b81e770e232d7d25aca91d9f4a6b8a8b805728a4233278e3b4dd7c7e3c527471c0946d1903d2d6cdbd4919a82ca12becce950238822bb4fc2307392ff47b38d74cc58ce7f47cb1ea3a1cca6b082bef3c453353e08da4f4b98230d6198a4269e2bef71e90ac7a919b5af5ae486733e32ed6976bc826d42498263a115c336dc8f6966b81c1fd646019ac1dc909040c627321fbeb1df1c10a4569f3d9f67df8bd82e7f896e7f1df459c499d9d82d4fb140bf9cac29820af02788a99724d4eeae5796a71646526acc1c0bd67f7c96fdac77441de65020f396274c4358345452d647ad74db6ac0787d8889266378feaa70350d35c8092c166cbc2eaf535af50c452c4216f85d9e4abbf114471cfdeb60370122ebb38dfde841acb2c1f87a8a27d5bf07bea9b6538ae02b67275e090964b41f52feb7e4d6d3d784a66ae0b390e24a4b1f8c0ae73f71b371e2302f56bdddddb6f683d517764c540527696b7a1571d74a24357be0daa9058e41f0397775a301f87c7a3ba43f298cac9eeb15c492a5bc65622a84e015ba4ad350205ea8be5c6edc4c40c67731c5bbfd1e23171d810002fefd442bf63d9ccd993f1239373d4426629d508f023ee472df858899f6fdff054a42cd174ae48838a5ca933fd39dc877de30419ac2afcc439c9118abe21cef4691a1dab00458122a787a1e95bdd507ecf871cc7e49335b5730bdcff61f85f53899e8296f6486e671e5cf0bd2ca73cc320bbd2b88df56cb4945065d08a8d1c1e50937f89ecba5c47565371e4082a9fea5ddd4db2f7f176fbb15a9ded8abdc4999af3282844b658611a88bc95ef7fee49eb676cd2aa68264ba48e34c084d06c4980effadfb8085d99943fa1965638d87ddd7f14769c6e73df16343e1cbbef114b833d563dad9dd0495830eb3c0700fd5b354255b4f98335d290c16551ca9920257626d755b6c646852bd0a00ac0fff5556c594899ad854f0b4abaa85ae5e751ce690a4696282adc0fcd6328ca2adb0369e7c75f3ea3375412072ae2bb1d4a7b0dc508e71c3dcbe1fa52192643a787e4f0af79244db07e0069e7acd7b827a3bb7c705be47bf33a38261e7f3463a8a1ed489c6abd5d598c38a79c985fb5209f11345a625a5d49d05650b6991837436d1d165dcb04a30823da946dfff344f628efb5f09081b9eb13f3bd3e9c4e192fb00059f5931c4f4b8c859943569900ee0edee560c689aa0b86e7c4064be6cc73cbf29118383dd2e5f3af33127a1c7554db2bf761dcb8796d46ea55d24e2e16e1379e5875e1977fb9826f81f26c1b2c2b476e3845b254e0c59874f2c4750dc2841ff56e92ba16665bd1831287223d7449ed1467510493ed4acdddaba6f0cc2596f11bc245050ce17bf8460cfd142ca5daa5f3973a866b7435fd6a3ba88b8d20163eb3d56f983193ab58dc28eee4e800bfce6ff37a18b52d6a87379ad86070be16f7b054d59239d79317cdcd68ce16352501d00158a90e93bd6665b625c547f52421c127d6f0970cab322afb5d57f11db20bee3b7ae227b2fb4c1c1bb725e4cf9a644a4ed911b7975121b3973a83e8366e3410078098c12c63b4fef65cee81b5efa0d958fc4952c5975ddc410ce13ce9006719a603992357eb4cbca42c0d410f00cbef59ce68a10b65c065ae4f423cd765015b6361986829ad756a7de6cbc43c9180328ea964a8596358308bcd5834d638f665ae867d3d224e16c447ee47578d6e7dd164f86e89bd4efc71e3013110cdd9374f83ea9c102deebf3010f71a4760ceddc26a1c7f9d6f63f87df18c7f626ad8b5f9ac8e9a8ed27cf0ffa7a11d5eaf56c1b710117e36a0eb36a91e94c055c258530ad56bdc03a80de43600343ec8c939db0d76d78d58977d58c10244ee975b2af6e4c68737774417b9ec178ffbd339c6f0a3bc94580cf402bb1df2665a398805d59ab6ae742e83b295c496665f75e8eb73dc459bc8cd25f0d0a40dc0e209fa2c037bb40585195ec5fcf26236c10aba19ced0929ad799697dcb8faf914688a7f36ae5969f5d17913190e3e6ca1218d7b78da817116caa5d6fbe78515a041c63a4d2496dc6f6b06a78114f80b07e16321e116f571d02f4c4217b1c2831c3c400b25d640cfb6ec9f106dbdae0fe236cd0c83139f7c4b8e7ef51a4113d41a13baf88452a6910f384d8ab6f0a71018cf9d3dfd9750e1b33929311ff513990890460edafa30f9fe8d3ee8d2e993db07761c6f7bc1810a8668e50f48c24741f7d1e1af08de54c04464d3fce1fd904a3fdaafc917c88fcd16335e7a923a5a4f3dd654cf8d66a2069644bf59d87e97f040ff3be49abd9a353f0b62dc7b35360d46e3866ef7b09946ae5de452966772cf723df232e62657b992364bd0b818b39a76a871306b621f31a3594706195cc2618e78337270fa621ae95a048191758fc5ee54ae0377988271df3ff0ea6c58349c156dc2bc8839fa6d147556f14a18ccbff01fed8cc6029c60dfba0af501735943a312f84c257b279901878cb10719e75cb3535fd9f6e0109c0b6574c5dd2e86a3521e8e6e0913bb6154ea7f2ea3ebd66a0ad9d4cec6f883a428e2a130b324c0c527c353bee74a239b3b39b14b906da41417a1a4b4bf72cb4ef442a5cb0e12414582463101963d5cee9f9453096120584c54b097b7e81d34a400216deaa638ba3f3c0bc1d99ff96965817738be94583cc9b93932fde805b3e884d9b8d95db8eb2d028cd195db3a5c6f42c380f35dbd7cf2dd9920d233e656c09c4dbf51a03d5a4942962bb57b11db65c71b82170df5513fb2e2e2749afe94cd77274e867d29d90a395d03d9e73e1b4128ef9750ae4112ebbd715de33b9d88ef882cc41be5a9240f8c0f5c8d1341f48c0c2eea88d9171a7c1d488d923e2692f2df11764e715fe186a69a018882966f0aa12e05d302c7e98b0f7eaee233bc7c43d0ca22b9fdc0fec6709d2fdf34bc3c3c78c4c62374c0bc07f1205bf9caad69e635bccf5b9358458761da4182bb23ca89b149d7582526e682cb9e6f4865a1569d831d4b8e4a68cc280a29ff53633f8dcb551ab109eba699e374a2ec36c4f17cdafe8abe3760ed5c223f64ae70495446f783491b14396b5d0b170af87f24c955d57f8c7e098763369ea12a6f8e679fc6f90019e425703d92b62f576a0c46bd70c45870b20afd66df7b916a47838199ee68df8338a2064f82a9a4751768e7e2084ce99ec6814dd364ec225481aa5f9f458879145fd539d7025c5c299928cc9585b9f0f0b89e5dde2ee90520f16ec0665efdbcbd4d93b009c4b9d7d2b5afca11dd72f66a69c752c4783a512bd99ee1ad8085b09213259c5a99f1d134800f2e8a4262e632c1c315c06c8e4ee8d607ec36dec3a0564a53f3266d10713cd61c149960d6e60a9053b4ee4928d60153e33c0cda00f4369556a88a74d209aea5c5c925a9e07ade1497e53f21ecd52f50e1734f8e66faa4fb895b4f5485020815e2c98763d5d1ca6d61304417c48387241d2f7cb78a579acde5b73a9cb8bb8f367eee255e1779b5a4c2eb05e5cfdaa5e7689319a27e008c409e63449f2cc62cacf925f592e00ad89f5617d2a699e741fdffaf1637dff5b43490b4ac0e87fb2cccb1c5d94ac7dadf8961dbacf4710e87af1820ff2b23b3da9c7167f14797e061f5a23ab1fbe37b1e44bb8beb66354a9ca3a72c50c75b0e5993054c1d0ea48914f345563c9c3157f9f9dc9b115dea6e28ec6cdb3c63ae72d755c68b6c264d5a51882d9897bbb95b9fd67d98b6d5c076526f90d3a449428fb6fe6e503ebc19dbdf1cea749cba5703a92ef3c98017bb1a1455347aad46d1c6d0d0dd0dfa23bf60fd0207cf318edbe87176847873ed0dca19a58e882b2d9392c9e4b4d8482d4c693824764a9c0e128f442189da937ff30b281acfbaccfeea33e08bf65d76304b9db830a92fd052be38e163f67d0fe4e91288f1ce4572236707108f730e8ecca0688d1f215ecb4c7678f613bee3c46df8001e2d41ed510fe16371eff10e1f2b5e4f08e153270ae81b8d630aa3f1ca6af7d2d8829169e6f21a139af9487e615c43505e2274537dc77a2da04697ae2519b97f4c4ab6ac0cf7772c32d9078075aae070451daca6e38f2833788329c14d504cd7b7c0cef9655716fba4858556c535d3740e364fb869949b400be1fa6275077fec5f468758dd9726dd4dbf742851c15a846160e4bcffeed743cbe0d16c31808751026b8415623970630c879cc12b154e99bbbf10d45e5064c270751c6412a34451d33387510eb90281baf00588f78e4c2e3ed54e23a5fef6d7f002e42675c82ff3b3ad8895352b59c91d26f9c3189a118a64912ff052af0828cceb0ea66fc8cbe827312aa3bcd18b93148f29f290021973f98f2338367c70f9180a8c948d6b498b3b089f608a02ee5854f8950c0b5f5d1de2d2867e380bdab5d762a4fea091bc4af3e02b81e4c1a0168a1acdce289d66add65a94b3ef4bcd3f16bd309616e2ee037fa5c2135dd3cf620e48c15208ed5e97cc64b34227afb2a6ca801b84b652f3d8b0753826dc4bd2a456b7c581a69a65968b24e299588fa536ca770a4d30845ab604b5e88c49c5751b532a3ce288349435ef1f9a7ee134bcc94dce1b082bb69d3105e6b4966a7ed5ea89c2a959ba7056fc9ca4f3bbed666dede79697f1bc87531cc0d4cd4988f33255ea4c6ba9dc98687825198730a6bf233e1784b9268bb9d02fb9429d70aa02e08f7025c5de33a23390506b1e2f2316c98db717e5fb571adc4ed62327965baed1afed02997f4a3301966c1d975b3ecdb6ed046f74f5da8585b138ec429fb2fabd92fb1d4a99894ae74cebb02c7546c538ed8543e0a8b6459566b6128cf90beee43d66a8916ff131759832a4b3a3233e94e3467098efd787f9173f9e23f22c266d3f85e022d96d71874778f35438cc168f65e8e73cbb7ea6987bfe65dc132d6b224bdcf555030546947056f45f130562be615ed0f1f425c89d860e557cd96a3da41059f61d2c7e221a3639fa95b12901abf8aff041eb092f58b76f8b3ad49b7cc2c4bc506af45a9c75bd7609bbd0db6bf8010d39cd311bfc8aa882b408edd762cf091c13642525346571f445c68aae5b91a0f4a7edda687c75d0d396047c6cd797c042412d527f0d39949ce493afefae395d6dcd8ac4cb9cb23021f8a1e201009ae4361e734636012a21b8ceb374b18146ed0e5611896a93cb9394f6afa0f249fce9435cd22be11aeb87ab3c6d2668882d9b99b8c59877e1472b3424caf172288ab1435be14a2d9e7cf05382431ffc6d200031b8dd5944132c99c4babf7888cb8dc024ccc8fa4415784b5ebf08879b28985492ac5fa3d83953f1db91b698d6a65855c8f5802e8f29c6a2d34e444a2885e0e242ee195b031f07813930f15a1d48e7b28850150d8f42fc937e833e7f466ac3190931ed57790257d14c8d266a1689be962a90e106def8f99937e7ed9cc4fc7cb01903086894f68925436e3892bd24cadb10d2e6946a784abe04b63eb3406ee1880c1fca7c9d0cfe94a4df627d7437d9f11ce7ba50b7f959adea3af6fb9380c0df06f70e1b515074cfbb367be0d89e65b58dad6c33016ace99c2e02936f10f05df8351517f97b3de8c8dce80062f6f72a2b8d86d2e2bd89a1d5b15198c44013ce8d6bb608561bc512dbecfebd381eb1972b651afec88b7f02a963515ced84b2f285ee2f472a3af46f1d8a41ed05fd09684ac30b2cc97de332c57b85bad7dbf98abfee0e2406b802d71b6039db1ff747cd969aaa31457527716e2ad3e1ec73bacf5413af333addd3d035f42f363f1914bfc69eb04f3a236fe704ef09f689171d1700fe07410b47bb1969ff285f4a58691b75a01227c433b31f198f47b1f1eb4f01be96a9d2d256188d0bd2efab440440541a837288258f1b70ac7fa367d27eec9cca27883eb19910de4ea5e37ccaa2412e41ea998ee11ad8206b3b153f264c5ed60ea31544bda1dd9ed443f4eba17074907686757ce321c6ea9a5f1fbed8f98cd3cce81d887e03afcde2e7391254a11c81a15667a8211b4c9b8873e84eac6d1521c651d63fe1501a8e963f8bec3656eff4e70f6bbe0755c6c2d2ea886e231df26d685b9ceb6187f52bd2f4cd8c73bf2e1e791dab5ce1d89c94ca6ae7b2cb262e5ed84131f3fa7739b437bbccc309f5406281c01fee8f55406587e9b1668e1d355bee4314be4a5c6b434e749c7b891f601d0630b8671d0cae394197c0612eb98600c5276249302da444bbea7286d9fc86544c09670ea2a0d4ff52f7c37367949b5dc2f857b2db493bd6f0b025f1357293bfc02f15f828c51281ef90a58a80652b6a99752432bedbe8623b680b21184de4ccde80283b2dfeb084465ee97932a208e63a811a8174b4a4bb6ffcfb7d6d05d25713a5e6d1c461ea4fc7a6022cfb1cc85988fa85e56357697c460f09675973d54d016939006b23a9f177e9cbc2a97198609a068f1ce2f5f0864e14af8a8d93ec599bef7bb18c03124f46790450a51efd824c72817bfd448307665046c3c9b5e983f52e2c45070811f2aee64198c0076c4dcdabc00390b6ca5bc6f42da9e312a104dc0feb5e68ec3e304d7cf370a08a62543818e06935550d85b3bf2a656ba74df98f11f96e8b0b81ecb0b24053e228fbe2416c8f1824e9b0de4d3c4b595880f27372ba949965efacd4da31a602eba87c656a2efb7a08b13f9fd94773a3a6381fcba6ba6ee97c167841f0d7df32481d266a5235864daa9920aeeb1f25a8b4ffff24bca13350c5853f24c3f4e13d5868c6185f8d5e7f45471085725b28dc6e3e49152c25f63838a6cf701b8666a4fe4e8d133f108870e72d01d21b57e9aaa15417377246c85776e782f384662f1daa3a911914666294b6325e6ce67015c7963a08dac8e5853d7f9f1be35e8510bfdb2042e5ad41214cef321a908a15dc342f21b2ab4c0d9dc20b42e93b91e960a71e5439cb8262a00710827a656fca2a6733837662e07db05aff52b289132da2170c660f880a0cd3fa47fdf3076e2a19bde9cead03612b18172d15d0ed43ab1e07c60b0e26182befc8149727cf9d5cece9603909636329dfe0ee64a90ff5a692c027b9f0e9dae08348250e11e6881e7aa6d749e62fb9b86adc3ceb2e006ac006e22aa564401d83b7a151f4d72fe38845e976c047762952e89a42e7af744b2a76227761b3f59bfe77832e7c92535697f4018f2206510fccd473680a9094346af278477046090d14ed4d5324126539ca0f35c56a36e026c9390e7f8445fb48a86bf0821b8411595c6556d0fac8a7e139f300b2a233b0863704216ada73912b2afcab65eb597d5a27c2037d1c19f62b51eacfedf639ae05b7374fd69f5b1c9bd4b13c95bf9487115d878be9099b8f540a115a43f12471ac531f7e79dd426bac52ba6fe2e60740f77b1c472755fbaeee8038a7cfcfb19203887efd92f32b276295e214dcf524eef3bfd0989d97a0b70b05ba7ff385f7cce3f7c1a860cc0236f7f8c8141ce3fc27ccbb6985607f92eb7d62550925c339c33739b669698b88dbe077141e9c741340073abe4af12e89389bf150fb75093fed2da599a0e6b25392e11e2796ba9830b072364b8a36e3e311faadd61a92818404f95f9fd4b72085bbf736b61ed315ab1427d6ea8c999b2a6c14b9250eaabe6decdd40a4a67939117bd0eb826dd2699d4e9582dce1520f135661c91bf92ae5594604e50aa0e668925472128124f94c50f3d610c68baabd43e5137f0927db79ad3c7dea16177c88a49d5120d707579fc7329588e1663e2db1469c2e49b7e41bc7bb57342f85ba7f2acab53c7a7a91424027874a21cd98e7cc78f594f6ebdc50cb2f7ebed73c8eefb1a877b9098921f3c459d3c5b9e5f928ed679389bfa7d12ab340b03589c2b778c08680aa8e7d664d74e5eb33119afcad4cc11dc8121aa3aa701ed57598534d994e80c7520eabd25028cdcaf744bab884ebbaf0d78eeeb07366a4485829c72cb93e94f04d0ef0618b7f1db235a44043bbfd3bfc402e10aa89de6350a6bbea1f5b95ba7c44334e87b549d429c821d414688c1bfb80304a456de979d3955586b7cfa7871dca069689be841b37fde6c05a89f2c4c83626ef5718775c6b51243e85f47cd48785970ba855fd0ea911a3665e986f605be065a030fc78694a1df2afe425161d6860796c63012855d965bca774b9550bc876f3e8587169ef5b4bbfb518273ae8aa262d18d9010ac576860a1edf4e887e7fa57c8722878409501d9a7e08383351cfb2ee882681df187a759616ae641b0474165a949cb563545e6d70b650a2fcdf059d9314ada5e043027b171093dc87ae304295879ae1884b7995935bcd62fe8f0d41b2d0f097450c0654d5eb9685dc2cab8a383d347e46280139ac16f120c1acf2a5d9445fb5d0c65b72d4f6432855bb8ae37844207709c8306ef92fe1152d8dc131574ca96fdd3bded72673d584419a80485de11d346d811800eeee88fb17be826fea56fbb1526979757e9144d15d9d1bb11680756ef8d973c200832c33a615dbe07e58c2a64db02cdd57422042306115074f7d6593e6690649d4ad031f66ee84e6ffe786dd60e61ceb18146a59d32f11f889356136bc25524ce7439c07932dfaf2b614005ac756389a64f55e8a6990f26b6483e6f1804c9ab5368ec995165d15ae765d850158819b2cd91dfd5aa302833f1812946af4539abed5d64250d7369850f0451713b7d3a095ef93724fde136bc8e8aefbf5d518ac4bc028b6be3d869ed7bbe1bff525a990b0e2b0734bd32904c630487c1ff6c7ac3c243fb3f0829fccdcf84f95daa66b0e3511132140ff705c3695c8be7b6501740ec0cecfea4c468563622b4afd509f230e2db61c84fc82349ed7fd4a4070babb8ecaf7797ccbf4720b48ce98f2737956245ed82b4e78154e0174742cf9824909f54057de48ece8a2c54e692cb56ead0c4e2dc6cf8c2bf0157eeeac2b6c23269229904bd859ddbc14242d38642dde6344b9b3cc43a0ecb5841e29b8e9f7fa414f31580cf7ad1e0610db9cd9de3037ca235d8a3b3a2ae2b4461fbfc3da986c4cd0c6024cf3b0a39f5afb48a99a21e2e54050d3cb853924ad253282805563b440d30d5ab33c4c952a2cbe5b0e23f1f2f87a8a47e792663ca689a454757147bfeb9a4ad4f15dbb3c0630f8bb05a8e8e776a85ec2da37b20fb56dd405b1596be7b5ba4f79e5869f570a0810d06616766f88a52ebebd6f088ab96a6884b423fa068e724ea2506bc8f5e7c25c6057236b0eff947d9472929da4f8833f08fc4d99cb74114b7ae6cbf065b6ee4ee174de6cda4c189c7589a76b4f66088661fb69320afd6a37034e310d81ee96b901a7a2dea965da7720d396bf1946b5087a41616874416de5b3d08ae4a445d14758823a385513ccc30c671dc809dec071f094f84142a74e7d59796d5b5957c06ae6b37ae0e27e5f0a6165fe689df734a92aeafbfb35d6d5771cbd75477ec6b56df132351fc315cf66289b0850b9b061d3cfb83acf107d46a5e2266851431119481e1adb83d7c5c946be0080a9fe601f00def4206fc768ac965045ff42a780b69924b936602179960a816dc0ea3e3cf94c3346235935e0343277eb005453b90e9dc6f7ef504b960f281a77c07e84873caa6a59d8e5e0dd248b6addaf4d6d722f605a69e3182f8c7327cf29fb859da14dd113145d28c2697d9fb88099d721e108533aa4db6b641e28a3d566559c21de6dc81504fdcab79bf11f9e54975cfc7ab30e77eecf32f60d367a13f77cc7036d0b6b676c87cd4f5ef9e413f7bf446ee9e036ca44464db01de44e11860c1ae46c9797bc16ae7181884173fe802c5e01810cc8e54a19f5c478fdd122408384163f8ac8ea1843e3607e91ed4618ee53f580091af136ccbdd015d4841f0ede9505076ec0811a3f64a266ba782383686d9a21d576a860fa6e39f0cc470e1d9c6599db3baac77b8c7648fd4838370cade04b33ac6636dcbed31d3c4c36d85de564c573eae6adcc25b94d4906918c9af54834fcb4c808f6a4010707390bf4327e2aad01ed85000548d21109aec806fbcfe8e375ea40b0f6ea7d110fed757859b03857dd1be65c84b70a9a9c9ad06cc5ccc30125b42316a1ac5b40a184021ec019fe66b7dc4b242950718148f20a478ef65fe73825c6b782c6e5d6cffd098439c4fc733eded6c0f8d1b260a9cb10fac3dce78ce1af894519e0b4d3265e99915470f2a43b5422cc38d74418fc09c3518aab708d8149dcf761744f8474121c4c903940ee1a481e217172c6b486845cedd37e52a492d0f2e34822a732350e76ba856c44b74ec3eea1c856c8d039cbfefa37e9a1acc2b049bec451910493968445aafec90234354c0b8bbce9f7326a9d758bb6a04f080e85f70b140cd381eb12bbcb619814f7d206d91f0e571b766d7e80c22a4db344b72bad134fad3bbc7a205e9dac214373579a3a6d8189c816751096bca10d97ceffd2de992e3172dfcaef77bc6db085701c0b08f69224052022d91e269be0b3f92c7143d083c1f9a950cec351da47549160c67ea3b51dd0a3a5f1c36f672cb5da8695aed4195ce138a98757af91a4833a979e0923d444c220f63b7c3fff98bb9bc5e4ae4b4fe414d03cf46a42d0c02c34dd7b17baa44cbc6f9cbe5b13dabd7a5d29d956b375478bde5a05ad89b7b9a1d2363b759e9aff357d23fd91dd2172b16f41a511cd5e95c29f69b16523767da6cd3566d60deacb86db3b54f5b9b836f13847938c59290dddeed41f2639590b2ec1841e1d432ca1a8d3b9f6a98662f7253dfa409c8e41d34428c7ecc51555cbd5eacc59ded1f6c96a6bdfa8e577a5e19e72385392820b3e9a8178b31180e8586a7854f380c03a2b590dd44b50401692b68108846a62efb6812226980ce43383f6b28bc7ea91560442144adfce4f03bd13548e08e9ee210f1ee43fe776a1f40b58af28369c1eb9672e5a2803dbd12816951d9db16ef9ebb2967bcbf74c0a13ae18e6c3d152a17bfa21b013ad1b145caff58a487e6b9beea9952e96e3c47aeeeb1f1a9bfe200f39f1d5334bf1a1c9693f9bb5e95c4d8bc1d86119412f841e43c17d73f51cd6950cebaf6009c18903d536d97abfb5412a9521781a94de6e1c1283c1022ba3f2389eb8cf3625d7a4216bb205423d4506939114c22724935b311faf92e1b4a8d551343dbe918288ad6e222343f45eee8fff422fec938d37a1084f567ae730d22dc914f41fcb70eb7b09e0e406340019f7e3e0d269165c29f1fcb436f92b5368e9ba344f8c7a3c0a9364d78d8102118580fe457dc7faab1aacf81dbc0859a247d0f801471164880c06fb4c7221ad518c582d3d45e11eb5d19acf2c1fb307e0acc89a10bbeb1eaeae2c513dd7d47c82dcbf23e60b3df3cc031cd6d608f3b8bf9d94f6651c13a6b42bd33d6b78ba4d3fc007a3d2a5f3d26315e953a99141dbf8a4ddef6e857024f918fec235ac0c5d85b6556bce41fd588dc0268f5554349adef82a58688c1ceec3508dae95bff12230b177bd4d26d8f433870cb12a789c604bcde1a07b54dd4385bc872ee24bb2bbe49a48689806fdb0e7b0901f9df87087ecfa2d435d3888ceea0c2688cf4fae570e79748c4cc4ca8844e4b28100473ab84c3a1b9ad33a5712ba8dc2650e96d76f09b2a26c87b1a5c063ebdee9d99f300df6854f13723275988f67467b3d390acfd098607d40a14122a5954b4e75e3a77b0c907f7bff47812afad6c898e25c0cc9bedfbd6b8a5422d9a0cbd93a0b8a0dd3d446e5aa2c3fd3555a29711fbdec17956bae1eb9a9f00d771ae63af773b753d95d15134d78bff472e92dfe13c28b2affb05a16c153f284af75f784f38e3fa7db1e94d708b054d850eb8417600aeb307e9c09ef2a558efd560668e3fe88e7fde98afef674453e5cf7bf4bdbc3cb3d20a8ccfecc212112e95fdb4d47e7146178ecf77da75d90ab615739ddb4836251225b5a7c734480ced1d601f1cef6e7ec9e4e018284ceac331bd82df1fa386629e9aa9269ff13ed61c00822a11b350ee09de26384560447a56e67179719362e0b29d6559624e0eb7f5c8ad5a369803af617d5867ea6e5e850bab7afcc4f1603c211ad7799458c088ce7a146c9efa7e0dea0b4c3d1b981f3d813b2004d043a82221246ad9fabc09ed6b93aa074673c4cf9795004e58dece1e4e74cdf3a57691b06012b7c8b7ca43c690ddadbc76aa9acc25ab540caaee91560296ef104210b3ea04a527bf790f52b202a221edb07ada675e7e3be1de2976e12a69e9008b45da374289ba6f3954c1694427eb07e358bf33b8e8e87bd53875b426f4367e376120b57b500ac3d589c5b1bebbce195f87c27f8dce4a6147408b313fc94468552a9276cb81162d9f9e160cc909103fcf8ccae3487755b04620bf7ff10584a8e5ab2d6ad79f44ecf3736f495ef789b5cd7050dae1845013f4206400e10356bddb1582e91ad74e28ebb1e388236ed319d18235b0a7667c5eb632641e591ea2a877781ba721a8f1f6c72d25da07829ab3cf6df400b9c7065513c052b555c5227778bc1820964ece43e0beba0550f092c9443acb82558d320aacb8b5882498721f791bc9294428e881362f41ee5b135bd0dbc84c9761ce1c139462b51ef8dc478a7cb0b6fc69da0240335fa546a02f1b5bbe379ec7c707c37cee3a1559b83e7efdc31f7feeab2e1b2f838ab1a35fd98c44d7855b195c9d974e8dbc82f6d30de2b7c0eb175e3b7b646f1e70dfebf931315603fc53c024682ef805dd332a76f0431cd2817221bc1b61e65cb9b0cf3c98f222f463d28defb9e9d3c861e0bcab70bf0ce029bdbb34ca1089baabeb2926a6255855e822c656d4916085092763535693f80f797eea80ffadf1e6ed8ea551116c67134f705a56d5192db67516ff667f8f2cf442c25074571cc001ac5e8615b4143a22cecf4927b3d29126e12a58612790983c2f5d2f43d968fa8f063896f31cf72fc96d15965c9b424b03f61d9664d2142fd33f8fa49af9df3dbb207a968125c1462b0b34bb6daf87ed74944bdb6588a7690ebd146eb616ee56a845053ca95b6d82c820809ef591640c12c448c2b3a2938c5d5ce583745b4c72f7ab8765ce2ab29a30dbdc8af964a50c735e4ddd22557aece7ae16bd848af27300ddb2ef01c8f722d0a8bd46484e1d2a0f3cacf20dc85a7ecf7d51da56b6d0fcbb56640fb7f9e0780d1cc93c284c8bb97bac9a0b3511469508836ddfe3ecb1b83b6f62c846d5b82c18da22d2782f2acd9456fdbfceb1910997151a25d3df770b5e85c3a9be798000e73838a02a4626fa3f11758b68738110ce00a7861caee11e60b5b67561ddb8f6b4273c585625a4fb24a37a4c7e8796189e43391f58f68b398db9ffa80caaa38efb20197582304e25149b32b12a5fb4fa1a3de8a74761fabd60e9f09707afdfebf2c1a82f301bb6c8504ff9009ef682a28156930b27ff59d3586b01ed535e86d2fa8c078b20f8381380a21502eac643cab0d776dc9ebf831226744230604899090dc171c2932b1e6492d72cb8325c35e9f3d385d8c7cbbbe50cb9b7cebca0e4b3a7ecce97badf71720df7203e0f02826ea5e5af2a3373430cb86305cb2a47fd16b9ca3fdcca73c0558113188ba763646e7f31d52bee858d301335d9fdc623efcc20b8206a61ebbdbf258f0bd224d5be89b618a3bd6e77cfa205497411f5223739a52cbddb7bbf6a7f21a7528d16f9bc24f76e4dff78937b962ce0ebb97c74f3b93cd5213884792b29d837c857909225c15b7b5fe4540753d8ca210273b87749edbea1f3283f8fdf51d89c0246d361e95dd8bdc3f68ea2f6128281dbcddfeee0f3443dd8c5a68d00c25a3587678386ddff6267aed7ded301c7954a2be531b08c76f2182957a5cf6324c01057bf104ba9868574f369275e7a47d7efd5554fd00e7630a9ef080e0e1e4ad7e5ab54f841f4c1cf038eb8b4122fb8ddee749073b7aca54f717cc4f2f73a6e2b5ed142414a2618d1cba4995bb3ffd17864956a8f2b0ddc4972391ed360f02d07b3aa1347887744dea58ae3e37fa1f09615888c8fb28cb25cbd09c5704b7ba54907c30523899a5a72b6e72a4598ae0b56bc5f5a99b2620ffea629b8aabe7bf1e2f3894085ecda66d7c8a27ef2f2b8c6cde9c4cfe2be109a769f7c2f71244a2960c6de201d449ba6da7cb2f09b1add68506551e1d0b116828c09ca3721c60fe399dcd122bcf087864d08bc74dcd55617ed69ec41236f9fcf2d695bfc3b55b7d082ba9d870c7490a30a5a414dbc28d97723d71f44c22618f26409110e3eaac918f6f476f21ba6c3a0db4e2f7bf18f46ac74b1a649bd37e84049a8f8287b4665278981b1d815a075f1c510fa1b638a9c95e00ef6421522aacc89b89535538081ecc21d61a43c1ac315c7408ed075a9d4a438305a1908c0e605a258054a73a3369b6918f6f2eb45ce6c7b7de84d9c938f572edc390daa4818d2352f009f6f849307395b6f9ab174c9f2038906390cc0504dbc65c709ee33bc29f87a51c214b99b75c842cbbd9cc4f9fdebb627290b123ab9288aca20c7ecc6cb6e4a70c27888c7a4bdf66677729bcc2ce5b8812d03d5963dcfbc65c2f0294192e289beef334045582e2420460233e881ca89772b22f0219ae88f5226ab503cbf4da5e2b7d32b55ad2f84042d752ea4fae8e22375f86689643b8e3cc7fe59d65e02474f948447d3fd60d63099fdbc5fbde18844a6420b8c7df175db8a3d6e546aec5e297ba6c7b79e54a99f7ab85d9533f81b1b404dad8a0cfcad681d029970daafad11765ceaa1460aee8eb9cae5f4c840766174c903f7f02484dbec935457a0e8584ba1bdd83898dbf77a5546fdf6bb0aebe8c1641b8083ce6cc00713ed1b1009f79a71a42fcf1b5cdc5cfee939535a8ea94f468366ef5df1c37581fb344132d202a4373ec04152b2c03e0b8377e984efd33da5864f4fcaf4e61ec250d8d9c9a80afc19f6b9448323943e86e301d431f309c28c13bbea80d4b73f86f67d7161d0bff5b562025b24fc7b8966ce4d1d137a7cdc7001a9b027c7d0b3902252bea54eaf1ee9d3d0fa39c279770471262076a3cb3dfd566e89ce96bedb5b519e84005a8525ce20440eda012c86b9a68eafa0c5aa570c39fc774537d3758d0adf3201d88649ac4772fe5ca46482dd011343adb6c9b58b4939c9ed91d79d2d69086c2d62d2cba9abac5222da7ae88b32a4eaad9f385c3c260a46de5eae6d30326dcd006cc8a51228b47bffdad3b7932ff68e2a6b77fbac1555e12224c996b18bf3aec5d98b78dfd0592ee678c18687070b09f5104f558afa76a5f84b9ccad11fa41944419f68dd0f83aa0127893414bdf3e9069fdc96f4733783f0a98e9d13e7d7dafa756740d2b1a2a35210686e174920027e454d73c91a92a5462307bfb6da2e039f0e08fffa02f36f54342270f9913ab123f697eb004424e5072cde7758de3816dcec8287ff3950a68bd0915ba6113df36d072d7cb7a46ff0fbc6356e843a37070f1e880f8f66eba50ffc213eed67723c4c6611321e516552632dea00996f5136eaae71bd76cedb1730af6b8b7ad0b3240a656860589c5e68ea2c7684db8f50b29510112c07dc745bf054d45cd8cb887403d3daf5f804cbaf3adc1b4cb1eed02b5f180a92cfa5c76241e264933de5f8f03a811d4d1e07fe23ef7e076104c30a27008c5ec071090f7384d05ee27712a2d4964a6b12cf10e731c6726ae5ed60acd99fd190d426e2ccfaa63ba23412e0e9e3970ffed636ab8771d5abfad1b6011e1c9890ea2e52d734e0b2863f72bd2804476636a3e58fce016cbd09adadf786cf386b6b4addbe998e8c752b05497ed83debe837341974e8deeebdd9cec8886817d963327c8e6d2bd1a74af73d260382ec21d1d5c9af6c3b7160cd01ef4572772ba5885241ade770b4045745e60e2a270a0cca771539da52188dcb32f163c775be0e477f308497ce599a284dc70a88a6218df7eb34799b635f8ba6a54b6d3045dbdd931489b35ce5398f4d4d8053fdfed9d2db448d881a2da57b707c044e4cd096c2e21957aab3ebf6e83c56caa736ea03a25c6b13a3dc6d2af22cf2dc75fc55aab6b43c53cb235c5456c6b9c954aa1784e912f2474bee04303274e61e3c6244204459c42760618c7e9f3dce31acb4dcc7bae9e033dcbabc7b57bd96b71739f7128381c5166894112ab76873d03fd3eba1f5000db839f3f6db82bf79193d3e9471cc0e4f7d40a2e115f6aa617f3773e901e3eccb3e5bb0e646ec05978411997e215f83708f77617e4cbd14ab196bd8984a1b338c9d9ec7e920e49f6cee0396484bfdd36f1bc7c6f241206ed5f91600effc503749233483d4d7adbb12a4167e4fa8463706b3de411f0ab2165090ac1534d682e86c060fe1adfe727b1cb5ffc0b7dcace0ed1e982ac3e439738648391524e837ed7ffef5e2eb4ae84f1982110d13f8d0b76d06b74e238ee3c881f41c376f156ae81c5cd127780d1c4bb0e9515fd98f629e5298284e61d82088f58ddf9d9648b8c138a6df3d7dec0693725f737f9f59ba3231bf8778713952955a510aee797a1e91fc18d4374b03a0eed3af34b29f26162bb0dfeb962895c22918b2ace30f420270cfd536e54fa91c41b8b2ae6f05f2d599615c0ca267f8d6fe408556703fb7c56b2e53492ce1dd7e0539e0495e044e24b72e411ba8453d85a85330816b7fe0305237387195b34f8a37f865a64dd6076c487a3be9b13dabb3ed022fddb9523e024f41fc6d0ba8117c224aafb888945f19d7a3004004ccc17c142ab961c687ff136039ccee154504218b5abf454826b76b07cdf93dc237eb82fd33e87a63a484929b4684ac865e54482d0b48d94cf7b4809cd9494ff19e1e0dd21b78f48c81b74b918c9b0fbc3329e887aad662ecc6d152d5d0a26c6773c8b5b6f9730d4f0a4fb03ce4c1daa4e58b12b392bc2dae5080be7383baccc5a3314df47cc29e212beb9954b27607728d80a604ff68ef7e52d50f842c2d4ea30f80a93b670b472c7fd4df149512f8e5ddc0c22734f9492315b5b7050930ffa499401c9e4e85b5bd19f5f8e6ba7369bff1a251382aa4c008ecd45df43e98084712f4720c31bef428c809e2d63db11b6185916c4f4a0221a0c3d27de765af1c86627e4d9028bda55511594650c9aa25b97c38380183dd7b3f2d42ecbb7b9671e6d5a2d4b56fcf392b054080e0248718cfbfe55025e5171d6b5436fb710073f4b0f69638c269b1c4853c10accc4f77d82b3427472549518308d9d4d7e488e266f3774e3a5e27efc652c8d8995ad2a377cc9adc8662dc376979e7547275b4665c21f11ff043231c8df4f993c8f791c241b0aa192384c89fc755ad82d5d041773f021757e24170adab3bc824ddf8bd105f5d13bd0af6e4a5752cb8fb800206ba07b53afe956f3deb8133180c98f85cfde13a9ab95ed30eae5499abac51d54ff48d1c202c247bb12ef2e7b1e8361926a5d17a8a2c85d4d15cf64731927ec9a3e7fee814a0734d6613950201b461a184e5118b676110dd3cc71e5b7ba1e3c7a7128d1e927a0f7271d3fbca3f8658e2e54cdfaf07eaa707dfb0405b66c9fea75b0234ba1fb848279cc667cfb50d036ad1364c72cb0347b07249ec95d3aba715d98f9a3a072ab7a238bdd67b149c65d5223b9ff73f61ab1cf77ba3b772ef19a1c7157c23cd367a3e9c980599dd3579fe4cd93152331048e37228e452aeb17547354823c6f1bf715fc98fd70b976828a057015df2aaefcc7f546978e2c9535c095e6c464042508756aa1ccf7730574f729141c95037c8ed05c4055825b881d04ee07a673f36509b75bb96939320ce9211343ec25ea4034358f5ec5d7a40612a63266a0dee592b4362c4895cbdbee2e532891f84d4286fab7d26f281d84037d6418d71adf7722e50347770abc6876747e4a044c379b2203b879e50fb4377863a1bcebbbd944edc4964e721ab187b63018040f673879067f8f8e2846ef8b88fc774a0fe14aebd1b24ec9d256feee1cbc495109dd43bc8aacfa3fae6ce6a75b2a0001dc2a7b9191ba4218953a4b6d7f9aed6f79f5f6cfd2cbc98c701bd3ea73614f2f8536b06fe9c14da48b90c88d2c5540a28f728eb33529446e4627131000427eae737c17781be8c5820cddcf4ccaa2057c1deeb7368881cfdaa2028470281b165255836cdb93edc281594a35d30d8a403e43f8826c34b2733612fbf280cbce968ba29b7b16774b2c78a1f03d99067436d7346a78dc0e0d69bffb51fa7b91d6fbf741f17f109a107bc190b2bfc93dc937c03ca4b2bf017b32b1de6f01a3ebc3e860e0becda89ba4d80746f1eb776fb85fca40b45881bcc00f991cef1ec1deb0bfe740915b2c51e6316c70c935d5ee7287c633f75e1705d2e8e5b0030cc4d0df36a9987d59181792ea21b88cbd8b77ee0940f8319dab5c29e99c2aa3b2f4d4e10fb9e8e2991c249c426ffe9d9003b038742f28bbcbc16578c68afcc707cc96b60430d619ba1982b4c2a3031c8b554983e808c105a14cc6da51c0f6709b8ae7f828d97b9876a19cd568d8ed0a93bb88c3a7a239dedc55be68cf50445279ff1a5a103e438686075298b31e6560bc95dfcdec1c412850b57a0774ee7e753b25c35eb807fcd417d3d937b15ab65cb11021f2bb0734b0189bf481673d28250db4a152c739f528b8b58856d727e685e262f1f1ccbbeb8b748866878005d72fbd4d9bbe517d9433bd590518b03ddbe1e2d247d83e3624aabb107d2c61565acf904568459f4980b99892279adc4bea4413db6c77fcf5160c0ee98f3471db923ee6ea9ab59c50308d636d41aa379920c417ec0c384ade328bff17967bea30b43354ba021b302eac6a9cceb35eede94a888cbbda802bd9ce06e998ddf1e0da4256e6f2d67229c2089302282ab1bd4148db94c00bc6c4384547b0cb65dc06c02d61bbb5979a9ce3f71767ae6aa46213639dfcfc35c8f69f39c8f5b469321e66541654d612a2bbd3ec7aec54c657e75236165e85bee44759cdc070591a1413c5579aaea022b3060293cae71d3ac5e74703c5f7d2bd38e6ea117fc1624c6a37c2e3eb39b59d1c9e39dd375313a719fbfdd30b1baba5afeded8c52171cb222dc9861c3ec59dffcc91616d7706cb5f0b44a6680e2547fe8cd69fabbcd932bf9b78587c59a29793ad8f0a0a2132c03425962c8c4812f2b81f00bd32f50848251e781d1b928849ed7726573daf2b227ad20336b9c5b77eb158c729b002bfab08b464a495889ea2a55ee766832df96f4e884e4c6321d7d2da076b782e9812a92aaf19a72c3bf5bd72972e1469be2000434a9e1168cf67f6339581c98cfb21c0466b44fff09051ccc4c7e30c6cd04f097bda3898f1533b68c234eac2217adc0ee422e4eb6d41097783a559c1e16ff2bcc2f09a938454be183374075abb596c697aaf8b81d198101f4e278cc5dd45d106a2dfb1bc42ddc9718bfcfd66557d54ee773abdff4b4104c8a36cf6fa771a1fa69fb4e391bc99f3150c96d5eae95fe821c37ac68054ef0b236e246adf3b4c540af76dc2b78783dbabd72409f97e8b383caffcc842f997ee6f67e7e998859dad9ec7b6802c309e6f36b223655178fa3841cb313cd1bed6085ffb2bd6919d2badba6d1a205aa0ef7490c62b8fbd9d37a6f5e9ad13e608d66db22af5b9c87b510a6e2b81bc0b5989f949178f049c9b81d87898a6896f5e6665221d93a5fbee7b3799be5267bed7bc11104938ce6b4907bdf4f8c187183698ff19c382a26cdb14a1f41a8a816ca1369fa0981dfd9ec73ccd5c093d0291cc5d87b5bc2f8c1a40088c30fa96dc3edd7ac163c57754702c4f35df474dc384e1f3339bbf1f34bdeb1f97ed9be3f4a22c24092d27713a3b1472b905e8cf79f4c953260f05d8451fb4e7ea67ec679f7b0934c8ffeb28c5ec7917fb33d20091ccfb86fab0d117012dd97f122060dff6b2344c72a51012d8e6a08111036dc1d8f359d30e04847612e20f0ac3046037cd9d44b5b2be6a4e3e058476a5d7851d25063bb67704f7b306aa7c84e79ed9d52983e23c61163b25db311614d25f5d5afeb7871e8b3f9998ff503f2a4c43e46bfc8c0159f849f9a03c9dda54d1a410b3504729d24710036964e73b35a61c5b94110bdea61189d5ebc55bc00bb558247c275b4b38434b6446bb6ac61f82777cbb14a439567e535ec89681cbb3f8b3ca7b2de98bde6d843615e4eb4e491a8f65f7a1e45104df2e13b584ae4b01c6d28b3d3773c25a99ad50992fcb4634d7e37c4bfe294d640e3bbe347f87ad0c0d32e9a1aeed7577e14fd070c4fb94faa551b2b66adbd3c939357b922bcdc2f5fe1be8ea2eed451125635ed87f5c14a3489b976ccb8c0807e9a661b489bd68b6048a4c8a991a0b4e14708ecacff5a302e046c52c7bf457b577e8818c744611d20483a4e82f3c2be1398a1d04bd4c23e6c31bd1f5f27a730abde0e66af91ff0999d4515bab02892f04515e75b592523eeade87010c3045dd6b8276a40e18eb421d33ce6f8845a22c168813478d74086be84c5ebc88bc45590f5d6b798cb7e068d830749c7f956e1d1712f8c0b70b40dfd6bc924ac9066fd4c690ac9d88936f63342281ab407f2e36504130d24bc75c8931d28680f9265d910077c4329a13ba13eac0de575387afb28d2cc067df7c3b3d785501bd6349c9f171eaf5b45bb1c0eb8c24e4675962f18a03dd4b3f101bd4973882009fa066d453fc0328be1f3c055ea792e48f37635bd5797759779b929580d2b29aeb74944812b30dbe7b3c1a0e77f4c3800d04d78ca3c5a60bcd56889ac7cb0352874bd8b9fa6fd9def99753c2380b3eea104ef9341b5933927410284302d8403f9e801a5864fd0b0f196acb98d9f6d352cc48876dbd61f491edd351a456dac56fed86880fa08ca78851eb88925a1111140d71b71f8be3a20e366a5d626644c1a55b91e829603c567e907326ff4019c5ab0676a388d9c8028358d4239a2369d9575f9a62a1c8f86383c915e37db5b60c7e33937b513b22847771f7ea63b972e3d66e66cb7f0a1876eb4036d7825edddc71fa9336dffaa986d99b12e2186fcf06456ed95df14f600dd004196fe9f90051fd036051361adf9c28149d42fc7080f757eb89929919836049abc16cd1f6c29654a912cca8d21747ad8a38ae9ddd8c3e589a79302be55fcbd9aebb8605cf7aa09afe4fdb8348007aaffa7a4c556efda6e4ffbbebc131e5c48e55525430cc38f7b84aa5eae0ff6c0b5f255a0a243c2941b0a3accf1eeaadd2d2893ab25a93a45c5992cd3771bc25590bc6eb8008584b98ae6edf73089ea7c79892cc7f63cb939d1549d383b027d9ee017987b4aafaa95899e65ab017ff7c2307f7a534c0a2cf57ffe77d7d31798f1cc27ab27e3d965ae119639dcc987edef2306fdd07c5df96fae815f21228c3916c0dcb6372a8e639e0c8b69c02a0319f2d315dae1f48e5c6dd3b00cb8aed8e831a8c69da5028175379c039430aca7f2f96edf0a2458a2b923bd8f49019735fbef27ad2eee26eb6bbb258e128d94d198004507984cb86204efbde610cbee8a8090745090191d711e0f478861815df67d497dc10e10f2406b86c52b6b3ebaaf2b59c26659cdb35856d4b52459382351772b246081ea150130b323ac46bc8e14ec3560d82a64a6e710df8762ff7ff7012368fdca09e22117450f94f58ece76a2e7e8c7b61663297a133a3233b14ffe6504f2a0f8dcaa7426da5766bb2bfdb3b17f67447a2a65a543121ef87e6c81b68f67905cad0680d93cd3430b99de801549e8746244d9b324a6aed0194d044b520730a90a3b75753067c789aa3dae41f3ee5cc0baffafd50b6ab69f8e2c7604902425a14a7a44616eef9baba7a97bb9be93bd9741f08a14513378d39b07c932369994c3736d03d95451cfb51f72fd952139b79bebf41ee7476cb32f200a4dadbd83a45609c5f7c9e0de4d488f7b402eb4ec7be770f320d9368302fe81f00b51b99b97a127d9e9c17cdefd7af296d686e47fb4ad270fab8c02bfa4498d0d3da6dcc8719d0377557228ee251d116944b823c42b019a5d46f3e6bd06ab319d0f35fea178d5a357a2759c2d9eb6cd3bc868bdcca9cff437b30117cbb509679d159f06cf78ae0ab2c47acf2d5553fc5ea527c898da100498b57a8d627cc3ce00f43480c53d23f7ce9b4426d321d843751fa86505480c40814e7ca6bbf66c01f2c9703151976754d08c75d01e66eb09c5bd289bbb0646a8af3b73ee56bd6851d9ae7edf9836744f7c0027e037d9044d56a30aa848727ff195f46bcf2242e6248600b923cf4640690dbe2983bdbc7ce831e723bb3e01121b77e5bdb92a9983a58b30716a734cd295f733ab63a9a28857a8dd33b82943875ddac187862467dca8aa0f5c97151cb490ee0c14b6528808900037544ea46729369a2f296a93f9b3cace6e1d4d8371d40351e35ad74ed38218a4722d9ceccf329bfa9cf8fcd0c8bfcf21640fa39996e25d83934c9e67339fe4796a5c7d25f9c18b23ae31934d76f84f504a9d95c9158313890c65b13571baf3a99eaea0617e6d8a8473a5ad5513229aa71248262c4b5213827f5e620bf1e914238206424ee04b1bbf2d6f8c17c00db33f1431aad51cd1edfd3aa15292bb77763e20f6fa882b31641ceddb1cf93fd14b53f6e51c891b974503e86f94d8caa2a00bdee66ad9b7647f7366810f8f97cf2fae4857647fc705cb780665234e0fedb50da9f284e5fd7cc4bde6027e4f1b71cbb01fca2fb6a633f4fae2efcd7b800f123603b0a9dbc3b7f9ca9fcab2e0220e83321161d42efb6b504d79fdb4edbf8e9d99d6328d520f5a86f96d41f86f804433f53f797fc1fc7a3906acc174db2e356ea3243d6039bbb27cdf6e8f503c9158a45d25165c30f8edfc6861e98632774d550c431f6039a16f4c36273092ddf5b3fb803d263b1c2d70f1f0f7154c742e397c60f5c5c79726d5ab50ddc25a72af2a8bb765af03b3234ad062d4897750eb6b1f0d219ba3194de4447981b079637d3b3fcc7133da534dde83ff41cdb52c5893f967ac6bddc19d9b4759568cbe3e9671e92573d97a198ac3fdded72ce05f409716d32df57c761cf3c1d7fbc7fee6e4a5919fa7916a787c0ece0d65a8aa2139f05ca039deb80e6fd3482c4490e20bac784eba17067b8af31744065d77781d2d51612fffbdb1a0f1f77efe205e6926baa518b580474bbd992e5cf7f2334e967e2878c97b1fab4f91259763566ae77eaf5836e95831d9f6074099e959f1ae1a5c173779ef421d1f6922947cdcaafad7c9416e5e40d3ee6e261590fe55486c4ed45ee60626f61447164eb3281fb46378fdcfd438ec4beb995f88fc55c52fbc06f667e19bb3a3f7acb40096c3a7e9f51956e6f8d1169f1c61a4a6f367c536155a6c1ab619f1c6d9a592e69bca9116a2298c8fc789bb3ed78aa56963507c490e48e1ad81edb7497a485e829863fcfc0aca5450f0aef5293bb3e0562386e8359737133abc0b28a9fbb81493b63b250371b98768d6d38547ea267d5c5e9bdb3e68dcab06491943ced6b7e7c39ff94b10aaaa995de5843ca951683e47cfef31533cabbcad3e10e55b8a11780fd7ea250f8f4f767a6ebbfe3b44703afbd0665106c4a9a12f3d5c4854751048fd9d4d3ca2eb83a4bea0a5604fef7b73cf304e153ac44830430c0244833c6fcf83096f9aa37b45ca7260ac7e3206f4decb8be5352b223b8599e4cab8982254e3ea0de0f41a177c9ac06dacebaee48f3a80721dbb96903991aaae86070f332726e1cc6c004f8d93e1314c977944d245944fb74eba5c55ce14203636d53d11b39100ddb3e77d4f570fba16aebe26dae3516279666b0ea352e11edb47b46088bc9022ec0c5b94c5618ee058527f1e6c2090da5665a45328c3ff475ca4db70058f788704783d4347d8e2c7ffed670b049f7615e9b24e2d49ebfe38003b2d68a79a35b9073c6aa3847d31b4d13c24195e9d70c8d0ccfeef94a840649840a753cb676f5ebaf46ef9a6fcf950cb33fdf5ccaaa37694686280b7305be7ad44bb0c4504c7abc22f4e20179ddc6f98a0e652e0053229841893745a56ebf303474af7c222b0318b04cbc5edee9caba9d9c988e94c141986a60a8a08802202b96884b39084b28ebb8c88ca1deae22064dc0281cb473ab417fc58352d5b3ead5ada4469eacd18223a731b0c2e82c172356302215a2d90a090e03ae6037211241c027ab28ebc81c48a1404edec9b2a2d11c7581f1b7e0fc2c92b3b65c8a61fefd412c4d8f47ec2a9914366cf04e11dea00f90e26781dd56bbb88ff0c16bbb5513307a8542f02398c7a2d5dcd395b2ce1beea57e7be78681e333aa068c0e6deaec3382d4d519c2b62de13acccc44fe71f7d01b6291575c51cc6b56ba5e6d2d1ad5508a6c83a2dbe0b21ee719833e2b3d43bd61aac07e62f826552fd9a81de9cab8f5f87feb279fcdb078c7d70d30d3cfd09c4d2b54702a05bb2d631230afb061eb336ba1b50a00f1af4e15318fb4dc01ce54aab05dbe4c975b6a2452362106bf9403638a7b1d9593491b3c44177fea02c9539e8dbb958ae190649a03af0f119af12bc8c322bda8d4c81b338c103d66ded2e8ead774106ce24517ebbe49d7ef4c20e6f7e43581b56c86f962e1d3561cb3ec252bc1574e24be332b26fff19e27a97d1d48e5fbb3cf69e7009b59c382ff6f1f2d12cab6a75de04c6a0c30f5818924582d0b136747c213caa6bed6c0ffd27bcc2e8fd35d91e573ba01bc17f26087aa9582cb64e684b23a8e2cdbcd44ab8cb5733ddac61c496a5bffc02404685526982264be6e3270da008de017b1b7f82a6c9402b9d3dd764770230c045ca0c17f4e5894e6d7fbc816fe72064d1c0c8cc6946aba34a702256b7119142a2f63e4c200164cc6780ac4cbd3f827822caa05afcc6f41d2efea44b448863d57cb4c6a2959084bdce616a7e283713839e01a58ff88383d2aa4f15f3e5d92ad9979fe806293283a19b7ed14b19a9c0c6dc60db11cbd135b5983f1597cef210410a90030a2a2df3b50e8b5a5dfad0166375ddf4cbecfa18499ac51f659b215fda3f8c7f435abbfd90ddba64cc6b12348600587a01f25e4ff4e9402d98741573e46c4d231d5326f32807c9b8dfdc00d2407e1040fb776b9e969444e50cb2daa341c6661cedb4de1451bcf9bb5a3520b573c03cdb13c16dbafa180f0536712f983dfa252b9cb9af9b278ac921083256c0b34d06d2488695b3dee6c6ef06cf224086283b19a81aac5f2d8bc3ccad29c15b22e168725813e0904bbf14a3d466a1866cd896892a4aa9649d99502e21f6d89d1654be639b1660f1415bbd39fb746663bfe3d1e2f5315078bf6b364733b184513297775809c735d9e3bbf87c5b80f73749891d4ca802103d098b6bcd2920163ea62ec78738e7ec89915d66daa227936d4866fbe09b63d17696c7a4bfc1d52fa3a9ee2a23b8c948e380f7df062ddf33453691fd292ad5c50fb4ac075bdf0fb5d2b1a394cfc37d8f649afc469eb1906c32f128ea2a9b80e6c9e15ac81873986e06b6ed06b9effa389e63d408606f479a8bbe420cfec1e88adbb0db01fe2a81f0eb8310590a3e3246bcfa04390fa65c1eab9b90ea48a25cf49a6fafb75227c5b8318bcb9444b726d12b0821bdb42daa52d3d99b064d0a1744f2924887af88d0fe82666522e55e907805b9054372019ef4f174420b6f2eef02940a1d8a3fe19e7c20cde1467ab11e91b95cf08b1a44106299e0e7f67247413daf0d9cda4ff64437de5d94d05f1f02c3cb46c039fe52a12a73cb03ccf4697ba052c4ace7bf1c7bd05927a0d96f4dcc540cfa6db34d9b53368a0535c610d18f90fe2b78052b70ee4eae9dc4a9204eb4850c607c47188c7f32ea742c966e8d7a3348f7d2250492a485d476c0e21dccf0372a6e6f0c160eb4fe5ee4c3921002b0bb41028f348f67450de0eab5331ae85b99246eb576a59002a3f33c3b9b2a09eeaf163637beb13df95a289b8f53e1666e40d629bbc76550e1bd84121be115516bde7b2d86c4b8e62c4d95fd8340448f77ea01876c8cee64b8526d23c2acf12efc0c9a51e5d372ec3660afad75932613d31df8badb010d015bc660c72a6464edf5dd3921587ae841bb96704b7247d4338245b7c7a96d5d0dbc08a2111ec9a49f29a83342dd8452515bc9830dd5318581fccd5a7ca660df6adfd01c08b8c665d3f4f201b4a9a62b18cc6ffbf9d41285ef0cec642a21b9130c2197003842ce3c2585e068d9564135486432bf479a982a559a3a0f7e68cfcd761a538fed1e6e8eba298955583744862b098769be3f47d0b00a91241c85f0bf727493aa922ce16dc86f673d240d9cc7ea34731d5a24e9d821592590056acc63266b3af248296c544fd8a803c89008804f7e5ffc3091fd15d11d4190fc517fe6cef97300f29bef7431864f4fc52ae02e92ed61693770176664a5a5dc00a0e0d110e8b41e461ee5fdc107558672c2b38b67b31e5fab096d6d077d5f09048ec1989d45e62b03faf2ab2de41191c90c7b4adf74cf2a910876036277d1dd0eee2c52f2a23686602059b8583902471a53e2a84eeadd8731a2b7a7e1ab9b43cb045f5f364560e87e832f262ef8632e87614b5aca2b450c316b01623dde61e65c9e448f349c7f3b6168f31dde8683efb042caf87683968f9e0e3ce6d505e515161ad3eda0b3547fd021bffdbc4dddcb1a751372810b1072658a996c15f5b78d9476a306c8805a127590930240ba0d933b66736edf2b77bdb5f1e8b139019432dcb94ff8bcd9117f7f1b4c0a3f7fb892db1c4a4e5c9bccf30f3d574ab600b01cc92b5bf793a138e4399cad5b00be35f678628175ef87d8a73d29e0487c2dc37bd3bcec76143256225a7a8f443eb15663c6d219bdd4b18a8cbce9f71c467bf8fe6db72ab9a5d5e17a64b244e29c9e84480bafe8ef19e9b6547dd2abafc9b37d8d2691324bab84897bf47a4adac8292c20531eae4b58925c009ef8dc391f67594acd8ac8fe827d85e1679d835046afa35f597e6fb2fb3f87e6f9ee859e9b5e189dcf64bd09481f9b4979c21cca88e657d56d98d349c35868658f5b2a5355173844ccd0a048b5fbd608d0d5eded424cb3aeaa568770183df90dd91f447c3eec28519f916c4185b5bbbf6a47ec27a59c0bc8f9cad6ae6851d77461ee3375fd2d2d1d5b0ac232e770dcc705eea9586d3e023de21b095abaf45622557f92e7cdca4dd2aaf01b6f39541d82c20b96cecb33b623be81dbac6342a03e37852ead2b69b8e4bebb3874121524aebf500dabecc50e8e2ccc2fb7264b6e38660f1fb7d032b43bee77c99793ad883e7614c5e44577c6fe8c5dca9cc2017a0897b6bdeceb6ff13fad32f7273514f538d842d73416ca8f3325ecd45197a6e2fcecd2085ca03b9d6e0aefe956c878ae970abd3672cd2788a8aa2600d07e52e523e490ca4331743413b5ea356e8c54e33588eeba833cdae448ecfad42149dbe671b61a0e9bb077fde6d12d73a72a5d1b665185b4d3bb17d0b626a4640d748ed646abb3603199c8d928d0e8549a036683d36730f3602b57f72c900efdcb2eac0af1125c08a7c2130f180bb7bfb9fc67a78ebb68715ec6f2d12f5091cefae5b5860d3bab5d8db6939a691d0dc2f66c87ac32ba49e70e592d683fab4daae0870ef8d944a8a93340f9cf3ef565b1cb9309ea42ad4016d40ddd024e47712a24754b1b2949cc3c0d04c2abbbc6568614dd56de548cc9f775798511d5e223d17e7eb463c60a62619c333b1dacea8e66f3f42bc1c443da89ae6ce1d165211567774d561080c6ec3084b763088cfc4800ee1c9f2c6373a804d6b603ef2ea631f0142b380a726f1f7b5679acd86a2845fb3e2310876d304b489131d358e2d92a5ce044d11cbefde8dad062a1f40a5862b4d71d6595a526cd4c834f18b50cdd4a4199024daf52653556582e23ad33b03d6dbac41368d1f4a3866f3be1533dcef2b975ec78dad9ebbd3763a1e953691544479feee9c436b8cd35ed81d20a8d6f7944fab772a0f81d405fd79f9b48dde8c4e35578337f76d581cc4e1051b96cc45fd2ca931677604042e332cd5751310a280deef37673fa6ee7eff7becaebba3236bea39c5506486405d2dac4a0d109c30d37edd8ca452d79d9d2593e6b319a6356eb0a96a6c5f61c842c1a82f6aef9862a77739f0eb5616c5c71c99fc909489968fefe8dcf628816f6fe9b7b6858bf9065cbd52616b6d3b81020536b15f53e7a4f04624905a4bd817dd817d29f276dcf1eaa8601eed6a5c32d16f2cdf371b8968ea4605336afec6667b3ecdcff575b0ade3c9c43a1867b7f6d256ad01f76fed538c14517a0a78fed6ff5d4c3c5a2fdbef9dcfc1b2a0e6964db2cef6737b04eca369331e800989602d656167b5a2264bd1260beb8a8ea19afa723db61362276e78ca527288dd378f4bd0230e8710551d76a5f6d6ee2da53ce39e87970080c2b78ea0744fcb514fb2b1f51662ee7cf4229549fde84fda2538c12d73c2662ef8fc57246ecee092dbb2e68be60cb2abe491b136df6656389b95b14cd7537ba6d8658229829dd3d66ec68951ba87391b6ddede2487c871d796d6a310a15f335096a95eead2d13e5d9bbb0a244d927360c44e8f1731b83d1a11a85d82402d00f35a7623dfad4df8cfbc05213280a7bb6993ea3035a47a91f5298cc5d843d5247c5808aaa7eefe2537d89cf8d195ef1de2ddcad946f7cd0a55fcba07df49a72b00fff372983f84937c01f4ed02ac018efdf8ebc2f9e1d697576f3a1aecd4fe16c20b37659d16177be49d3f271f3534c4ad66f650e562bbed08a513516da911d5fd3b26b22d6fc3e3181264811d5e865af3cb631e096b652baf6919014948f677a4ce5d9e7f626aaaad202e0f1dcf3a5bddbcce034b9f6c2a0a1bb2d618ecf432abddfd7403ccae221c08b0a8c0487b90b2b7b16f189dd2f8d00b3339c010d68a00727102904668c4860e0c04e30a4f0d0757cb0ea2eba27305ac6caaa9942dd9b27aed4fea5e9ec5d35773a95f360cb2531ddb89a824ab3c1daa7ced30b236a144ffe5caa994b48e9410eb4c5bc4b8f396040da59c86570dea45d50fe95eed4c39b03bfc05644a1d3cb1d8ef9b254fac944826ef838fe01e63ddcf9055cae01e35a7c68ea1cb207f2134f856c5c92e4b233c1e9d7ba568091745cfb2b6e4c4cb6ba8e98a5c847d61e0db9866102da0ea5f47df8fbe5c9047e74a89514c2fc7f1f65ce9d85750129d3cf1216c6ca0a2057903a3e23bdd4ec3a5ed6ff7b1c113d3ea3fd3e7020af3ebcf10b75fdf30de4fc83d16e7c2606d53e4f0d243a3b34bdb038fab9782933b67b7de0f686c339fd84aa0a19569361021918ac4842379fcc6453a4aada2f22ddacb6e9d9052f41a717dc8b7e4b9d6a32969ff9b1c3768ce85c42662d61ee2f267f6cbda4d719fa3e2296d665b92df35408f4f31689385fae20928bb147c675400288c252abbe030dbf0a25bfd5c656f282ddfeaa5efa7ffa1650f3693dad58f631244eb617bda98d0b45442c82661dff49f348c88d5120b593b1624567ad636278814d956e56ed393964dfd33c2d13e73ab692d956b81608ebfd5c2492253657097640dc424e41d6dbd5ecfdb0aea2a1a0d55d7303c334454d6c6e89b59fb4e77a67818a3a247867ca3a0050293b56fe0b8f9e1b3ce1c4b2375ba135cdcd17bf384dd86790992c9b9276393b0b164adfeee2d517c14f95bd746209893b763f30286fc4bc3222ae5a10817c0d6d655976cfa1542a4a93b5f317f427a9d51aada1d238ad885672f720a703602eee7240cced9541068b17dfa0e55089b3a0b4deaf73e9b63e13261245f49358924386904a8522369689f4f490baad24f11b37c0ddc1483fd4ca1a9bf351aac593bef7c8a63e795bbb33b8327e254843f373e0dd71f4d13e954e3f81cf87680435b169b39fbd08f4536848f78df127feb88baa94cc369071ceb9014e0a33ab27786e460aa3eccda3b0eff9c0ed9b279388414dc6197894bcc5abe570f82ed5eb83da34fa9c684726bef5ed98723b839740f7d8125d418371fb54c2b667590e80b66c2aeec398662a06c67ef465a9687b3fc38ff08e40fb16d15679273e110e17e02d3d6d568904ccebae2ae96fee29f4397f118cacd3f3fbda03710d2592da5c2792ebae96ad78102811c118218603331a0cc1ef9b094f7a1ca7e2030595b24876b5c16f8a96f5cb132011b2244d7a22b44b6edddc367793c6f1039f661a43b64b1456de0f43b8aa0684a02ce507fc151ee199e2145c73618dc85249101798e96ac1cd5c0c37d7df90d7bfb51a45a076fec1245d209f5547d9380320cf08a76f3da396694a8e2a74a7e9735175f7052fffc4c2d066044bbdf504d86dac0bf093c78cf193ac86be05a29e133bc35a0aad29a3628a659f3033bc0cccb867685b66957806a9f65e8d6a3da997c4eb7ff4c3f0474e59dcad1cc564270ba97ddf835834d2bdc4039736bd2cec6b7b38e87f94182bf7f792e45a8bb9fd938b213da38c8f7a451204ffa6d4eac3c12177a82fecbe4057d2b77d7cfb261c9ffd0916705d207c2e3d103228dea96ff4d37e0515297fe1e607b637d5063b10b90d76ab02ab752b4746e841b6d9a07a0ed7ed1590982738992bf666210a48caba68197281568cdc7925de7d5e14c42936563d0f7dbe896d7d3bbac60bb375918a7e030a1ce9b85a30ebe4874959579e3f9a901971ce7c8803814a4758dcd57d0147e2f0dadc663288cfcb910a9f1433d0c3c5eec7a7d7b322b24992015bd441a8eeb1cc6ae6917d1036b31bed76b2db60a8d6b5b38992aede2df5587ed94a4f946ff99590e03da714fc32d58dc366913140973fe5a91f4401c15f051afd5caf9335d74178c47565c5be0ac8b06439942900bd1e62841b073c8a5d54d0c0fbb98a90a7da0a93d82fb276a6112be25b8aacbca7a29536081335c97a618ccfeb2f179ce5260eff63d216cb917765a18bef01a7f055bcbc9c5401c952ef20075854d8d2471295cf8807a1fa989246c2842c90defee3cb640bb1862793ecae94939d6edeaaed088cbc63da3e4be7f946508b415463e927fee6d7195eed6dc772f339d8bcac3d8255ce9fca34b9a3857cd21dfbfb0b43963dd5a4a826cb8868f9d6e856089cebe0c9507b05cf6683b2f990eb414a9ebc9efd1e3753555a7a8e0c542bb993fddf7d7d98e77da715ae5307f1393931e0dad084dd34f709db322c545f4fd451cf8d43f4e0aa731f574e2557695f173f54cf11a5440e16b73ffc2976981dcf1eb102ccc6be61474e09449f8d983bfe10fe3d242d93fe7f1439da247e0a6b5dd152c1f68e0b78e4875238684475d1c1653bf6818f1fb613e3bdc7b69664547e2c7f027780f249b392b483e5efec5c2435302d44212cb01d89761dbc6d799f2f68892e7decd5f441b62c7a89277f27f84b4a423f0d4d26db85e4240e3ba273056228f075acf8b8e27cd19e886652327e4efbd03e3a1184852be100da8fdccd4f8f3c4aac64e8bdf3dcb4a97e44e343c97b409696e20fdaa78b09ea29abd8527bfaccff8383b11ef5c63da57a0a75e7fef98a643495900e5d9885baca66096d19cd6ea60e46050c34e7bdad2273d1a8faf3e34d0b7073b5dbcce9fdeac34ae1f71019da0b8c3a83d44a46bfc86489e2c20303febfa8f51c161f8558f7218dda23a9dba2a1ef18741bd809e20a4b1023d6adf9087a8f2688fa6d27521e4c1692c69b7f0de27e394e6ae22770fe35a3070bae73445e0f68da53c686e15d47af3ed4a0f38a87e4ce172a450c77e9b406a85041197c6987989a33f7b2f46be5a0e1bfac440c3beb52a980fef14a0fc67b57be2a84d852b7e39ae3b1bcffac78da99e6982c7cfd08585557c558b94dd180e04f763484b5a63184dd6edf3f8d9e83dcb86797999bdc883353599e01c04488423ec5f7a8c55f1c4f1685627c2f55f66f95e1a45759b5959bd3686ff929b8b771fd4dcaf4b3c650709c07b43cc183d6c138eeb0cc9ce366444c107dd463685190987082b4c089bb0ce4b0b04e776b8af11af363c193bed3b98ebf93023f539b62e10e247e85460a23c9355ecdfe82832c686c5024c20bd84d1a256149e869486043a91b560da885154b9e868e09eda726869e845cf26220823f2af482c92ed308790a7efb4968046190d42fad524c24217ebb7ccc45edf051c1df51169126971286506859424a76540a40f85cfabfea4cd600b78387149d0ca6a88aea8a38ea188f69dad0e033384f8eb28551e7856caa7b6adf66459f2f82366ef92f80313ba641f33d1f135877ab9a337dd2cef569c35c272aebed01f2c298e606d66e724fbce8f9cf7cfe95e90adc50a7dc903cedbcb1e6908c030efdad771979c8bc89d9d7f63c3ad2404cbae9859369c64bfff73870570d4650191704e876d8202096d76f962648998783b71aa7d4ab0d3882e8e6b66ee57eb696e77bb046b2d74920f92c89ea60f7dd1c08620ffa169623057bbca64de4ad390e09cf69cf2f450e995c2beaa287ed4191c00219653266e52cf051ea14132869a8fa6c8fd4ed1f19bc4a7a3967f5af547ef81cace5866a39ed601342143d59332b8a27aeffd6935942033ad971f24df1f25b1b0f835fc098b04b2180f24bce1570f2b423f6dc44d4f14af2c1ab852cd7a27bf9e909d6147298c1c630575a16bfee1828b3199b6458469e8e46e30c0e327b42e8ba635c966e87efc65bc22116387f7d4ad1e602dca81ca3ff1a699574db74604e269f9b22fb3e15e9d366f6af514c7ab7d162b067bf012ff2c931c365e669dd83199852bbe30cab698e06aa57be6abe13641d450e8b071293edffb750627f77c4b6aa2657a7feb9fee471d98202b9e46d6ba13cac3380dd6c803d474b9d4eb192e01ee9e891e4990a9f19c967d3ad700e196c0c8cbc100d3d034a5dd3490edccbb5d56acc19db926fd17cddc6b5227b415940a5b89f329797dd147b2cb8a18932e8165e823a8abcb4195ed6bbb9dbb4fb21e275dd519d01518b2374e1d9e3aed23d1ff07c8757d0a648f0029468fb3dfb2cbc7a695bcbde9d97698beb011e43bc2feac56c83800e3c68c04c7a9aa6d3360ff85f24bbc92da6c9ed8f30c19f0612584a4d59671f22f4f26c35a077ed6896faa3b70da1441db252b5ae8df8df41e079c3df54ea608dbff0cb1763f321c950e263beb3de075cf2de12f9257a214179b22f71e4bd740394b0b2ac849a73279b5e7ee5712670fa6a77977a49845fc6024382082724fba8b2f41419065501fef89678febaa53b8208d2413f4f7769130cf41210cde0a64270d00186df3a5d017e5860d6357405d90d7d5e6ff9325b0318484db31a923543cc5eb2ba9ef0c6078ad35989a08be427a9c7d566607b061c08f39012dd3ff6b8b11fda1e16b69304a5121c7cb559557d4e8e88983315a12b8caee168e272ca6ec92510aa6ae31768324876041d9ae1fe60d7150fb6c5689eb46f639a7bc9fb546d2cf8da38a3195757f36112245899e21e48eeb3d4c7b0a9ddb222163aaf22fc1e1d50c822cf1d9305566556f9a1f7e6d98754dc34c8034977924bd965617a5b48a2977cdc2882ed3fb1af7825c4b234da0412a69bc74d9e268553a6f7be396c678a12d213fcdf4058b552f88674954e4ad853933b8a4ccd49c135e017c62eb0e4c8a81d89913c74e290e29997343a0f91d78555401cbc817dd62f39a1a39d97e0a4f28431638765a5aa180b47556802f57bafb280648fb226b718e86693395971f2616bd5f579ede1c5aebc8cf753551119b8da90ac0939658f684ba3643148469719cee43ba8d79c5ab33136ef07f96fd842ca1791490cbb87e44bedb2e354afbcda2b71c498122b484e79e8e5842269f2217d098b47e4edd2b23846f7d659a38929f00bcb862795bf3c0e01ee63e1a9ad25e500a1f4b7b110818c08a5da83e02a60c661a7435e9cd12ec90a102e291e7ca29e540074d6f27865b4c448aa5fa059f555c0e6358cb8df75fe02b8ebe56932d1072f50779c86cb6b3544dae9df88a9b36e8f108f509ce975fb5640e2e8b25015d76f957fb43dc34ee99959e18fe32ea9ef8d912ec10907b73dcc1a6601495a79fb68210c61040f6b3d2237a476af486a6b86e3a918cfca9ff79dabe051a7d2f41b67dc946d6a83e1cf7001416dce66e3a4ca3aac2924650ad42e7037174031ff9349f5ac4276d15fda9a52f1bf7bb5e7d88fa0b6495156e65614070ad8ebb75b71a130d8c2cb4ab334112bb8552b82bdd975a859a55993d26be31b190c1566a2fe7caa1afff8d9b5b4d16323451c77dc98a27134f03ff5f6388d2d4f86065de71b4d50fb0d3fe9682350ea60b34d37ea5ea95fe27f1a4f48c00af13bb92e8c6fadfed00543c505048e317971a4485bd42c050a5097f1ac8e5806fa8db1ebd07f0ddfd99667aff754257def099633d15bcea3b64dfb9d91ff72454e5a153ec94b471ed99016f3d23af4e03e870e2fd8a137f8e15432af4ce6b776d83fe6d9b4aa9b96d89620024f1bbeaeef63c47bac7ba94152ef1f5152383acdcbb5b752511b5b7402514247e45c4521ed817dddaa1c763d5937fac3a8ea6872e681bb2f37e651820ba4565dce55a90907edcaf4f320ec8317198330ef78f81ee18444a1468bec24e96276e39e9846ce13ab449016059b4c4a56e0f9bd4033425f3bc1ca270fff333e7c2e7d33565980ec19b742237decc5e4df04e1403a3944531a703353c46c55df01c7c2e5718217007a91f3cbeeec06565961c7f4ed46636d510e3eab186f3d5b346fc49b5909c65162ccc48f47e28f56632445a9e4ae49f6157513132aa6cce04ea11f0e697e38e2847cbecc9e20dc38f8bc721cafe511a4bc6c33baf8639dcf3718987cb]]></content>
      <categories>
        <category>面试经历</category>
      </categories>
      <tags>
        <tag>面试总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象]]></title>
    <url>%2F2019%2F12%2F17%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象三大特征：封装性，继承性，多态性。继承是多态的前提，如果没有继承，就没有多态继承主要解决的问题是：共性抽取继承父类也可以叫基类，超类子类也可以叫派生类子类可以访问父类的属性和方法，反之父类不能访问子类的属性和方法直接通过子类对象访问成员变量：等号左边是谁，就优先用谁，没有则向上找。间接通过成员方法访问成员变量：该方法属于谁，就优先用谁，没有则向上找。成员变量方法局部变量：直接写成员变量名本类的成员变量：this.成员变量名父类的成员变量：super.成员变量名成员方法的访问在父子类的继承关系当中，创建子类对象，访问成员方法的规则：创建的对象是谁，就优先用谁，如果没有则向上找。注意事项：无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类。方法的重载和重写重写（Override）概念：在继承关系当中，方法的名称一样，参数列表也一样。对比重写（Override）：方法的名称一样，参数列表【也一样】。也称覆盖、覆写。重载（Overload）：方法的名称一样，参数列表【不一样】。方法的覆盖重写特点：创建的是子类对象，则优先用子类方法。方法覆盖重写的注意事项：1.必须保证父子类之间方法的名称相同，参数列表也相同。@Override：写在方法前面，用来检测是不是有效的正确覆盖重写。这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。2.子类方法的返回值必须【小于等于】父类方法的返回值范围。提示：java.Lang.Object类是所有类的公共最高父类（祖宗类），java.Lang.String就是object的子类。3.子类方法的权限必须【大于等于】父类方法的权限修饰符。提示：public &gt; protected &gt;（default）&gt; private备注：（default）不是关键字default，而是什么都不写，留空例子图继承关系中，父子类构造方法的访问特点1.子类构造方法当中有一个默认隐含的“super（）”调用，所以一定是先调用的父类构造，后执行的子类构造。2.子类构造可以通过super关键字来调用父类重载构造。3.super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。总结：子类必须调用父类构造方法，不写则系统会自动分配一个super（）；写了则用写的指定的super调用，super只能有一个，还必须是第一个。super关键字的用法1.在子类的成员方法中，访问父类的成员变量。2.在子类的成员方法中，访问父类的成员方法。3.在子类的构造方法中，访问父类的构造方法。This关键字的用法1.在本类的成员方法中，访问本类的成员变量。2.在本类的成员方法中，访问本类的另一个成员方法。3.在本类的构造方法中，访问本类的另一个构造方法。在第三种用法当中要注意：A.this（…）调用也必须是构造方法的第一个语句，唯一一个。B.super和this两种构造调用，不能同时使用。关键字图解Java继承的特点单继承：一个类的直接父类只能有唯一个多级继承抽象方法抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。使用抽象类和抽象方法：1.不能直接创建new抽象类对象。2.必须用一个子类来继承抽象父类。3.子类必须覆盖重写抽象父类当中所有的抽象方法。覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上厉法体大括号了4.创建子类对象进行使用。注意事项1.抽象类不能创建对象，如果创建，偏译无法通过而报错。只能创建其非抽象子类的对象。理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。2.抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。理解：子类的构造方法中，有默认的super（），需要访问父类构造方法。3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。4.抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。接口接口就是一种公共的规范标准基本定义格式接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。public interface 接口名称{ //接口内容 }备注：换成了关键字interface之后，编译生成的字节码文件仍然是：Java--&gt;.class。如果是Java 7，那么接口中可以包含的内容有：1.常量2.抽象方法如果是Java 8，还可以额外包含有：3.默认方法4.静态方法如果是Java 9，还可以额外包含有：5.私有方法接口使用步骤1.接口不能直接使用，必须有一个”实现类”来实现该接口。格式：public class 实现类名称 implements 接口名称{//…}2.接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。实现：去掉abstract关键字，加上方法体大括号.3.创建实现类的对象，进行使用。注意事项：如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。接口的默认方法从Java 8开始，接口里允许定义默认方法。格式：public default 返回值类型 方法名称（参数列表）{方法体....}备注：接口当中的默认方法，可以解决接口升级的问题。1.接口的默认方法，可以通过接口实现类对象，直接调用。2.接口的默认方法，也可以被接口实现类进行覆盖重写。接口的私有方法从Java 9开始，接口当中允许定义私有方法。1.普通私有方法，解决多个默认方法之间重复代码问题格式：private 返回值类型 方法名称（参数列表）{方法体....}2.静态私有方法，解决多个静态方法之间重复代码问题格式：private static 返回值类型 方法名称（参数列表）{方法体}接口的常量定义和使用接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。从效果上看，这其实就是接口的【常量】。格式：public static final 数据类型 常量名称 = 数据值；备注：一旦使用final关键字进行修饰，说明不可改变。注意事项：1.接口当中的常量，可以省略public static final，注意：不写也照样是这样。2.接口当中的常量，必须进行赋值；不能不赋值。3.接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则则注意事项使用接囗的时候，需要注意：1.接口是没有静态代码块或者构造方法的。2.一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。格式：public class MyInterfaceImpl implements MyInterfaceA，MyInterfaceBf{//覆盖重写所有抽象方法}3.如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。4.如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。5.如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。6.一个类如果父类当中的方法和接口当中的默认方法产生了冲突，优先用父类当中的方法。接口间的多继承1.类与类之间是单继承的。直接父类只有一个。2.类与接口之间是多实现的。一个类可以实现多个接口。3.接口与接口之间是多继承的。注意事项：1.多个父接口当中的抽象方法如果重复，没关系。2.多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】多态多态格式代码当中体现多态性，其实就是一句话：父类引用指向子类对象。格式：父类名称 对象名 = new 子类名称();接口名称 对象名 = new 实现类名称();多态中的成员变量1.直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。2.间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。多态中的成员方法在多态的代码当中，成员方法的访问规则是：看new的是谁，就优先用谁，没有则向上找。口诀：编译看左边，运行看右边。成员变量：编译看左边，运行还看左边。成员方法：编译看左边，运行看右边。对象的向上和向下转型说明：如何才能知道一个父类引用的对象，本来是什么子类格式：对象 instanceof 类名称这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基本知识]]></title>
    <url>%2F2019%2F12%2F11%2Fjava%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[方法12345// 定义方法的格式修饰符 返回值类型 方法名称(参数类型 参数名称，....)&#123; 方法体; return 返回值;&#125;修饰符：现阶段的固定方法，public static返回值类型：也就是方法最终产生的数据结果是什么类型方法名称：方法的名字，规则和变量一样，小驼峰参数类型：进入方法的数据对应的变量名称方法体：方法需要做的事情，若干行代码return：两个作用。停止当前方法将后面的结果数据返回值返还给调用处返回值：也就是方法执行后最终产生的数据结果return后面的“返回值”，必须和方法名称前面的“返回值类型”，保持对应注意事项方法应该定义在类中，但是不能在方法 在定义方法。不能嵌套方法定义的前后顺序无所谓方法定义之后不会执行，若要执行，必须调用：单独调用，打印调用，赋值调用如果方法有返回值，那么必须写上“return 返回值”，不能缺失return后面的返回值类型必须和方法的返回值类型相同，对应。对于一个void没有返回值的方法，没有返回值。一个方法中可以含有多个return语句，但是必须保证同时只有一个会被执行到。方法重载多个方法的名称一样，但是参数列表不一样优点：只需要记住唯一一个方法名称，就可以实现类似的多个功能相关因素参数个数不同参数类型不同参数的多类型顺序不同无关因素与参数的名称无关与方法的返回值类型无关数组数组的概念：是一种容器，可以同时存放多个数据值。数组的特点：1.数组是一种引用数据类型2.数组当中的多个数据，类型必须统一3.数组的长度在程序运行期间不可改变数组声明数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。两种常见的初始化方式：1.动态初始化（指定长度）2.静态初始化（指定内容）动态初始化数组的格式：声明格式：数据类型[]数组名称=new数据类型[数组长度]；静态初始化数组的格式：声明格式(标准)：数据类型[] 数组名称 = new 数据类型[] {元素1，元素2，...}省略格式：数据类型[] 数组名称 = {元素1，元素2，...}注意事项：1.静态初始化没有直接指定长度，但是仍然会自动推算得到长度。2.静态初始化标准格式可以拆分成为两个步骤。3.动态初始化也可以拆分成为两个步骤。4.静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值。规则如下：如果是整数类型，那么默认为0如果是浮点类型，那么默认为0.0如果是字符类型，那么默认为&#39;\u0000&#39;如果是布尔类型，那么默认为false如果是引用类型，那么默认为null静态初始化其实也有默认值的过程，只不过系统自动马上将默认值替换成为了大括号当中的具体数值。数组的长度一旦创建，程序运行期间，长度不可变Java中的内存划分1.栈（Stack）：存放的都是方法中的局部变量。方法的运行一定要在栈当中运行。局部变量：方法的参数，或者是方法内部的变量作用域：一旦超出作用域，立刻从栈内存当中消失。2.堆（Heap）：凡是new出来的东西，都在堆当中。堆内存里面的东西都有一个地址值：16进制堆内存里面的数据，都有默认值。规则：如果是整数默认为0如果是浮点数默认为0.0如果是字符默认为&#39;\u0000&#39;如果是布尔默认为false如果是引用类型默认为null3.方法区（Method Area）：存储.class相关信息，包含方法的信息。4.本地方法栈（Native Method Stack）：与操作系统相关。5.寄存器（PC Register）：与CPU相关。一个数组的内存图所有的引用类型变量，都可以赋值为一个null值。代表其中什么都没有。面向对象类是对一类事物的描述，是抽象的对象是对一类事物的实例，是具体的类是对象的模板，对象是类的实体类的定义类：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物属性：就是该事物的状态信息行为：就是该事物能做什么一个类的对象的内存图使用对象类型作为方法的参数成员变量和局部变量的区别1.定义的位置不一样【重点】局部变量：在方法的内部成员变量：在方法的外部，直接写在类当中2.作用范围不一样【重点】局部变量：只有方法当中才可以使用，出了方法就不能再用成员变量：整个类全都可以通用。3.默认值不一样【重点】局部变量：没有默认值，如果要想使用，必须手动进行赋值成员变量：如果没有赋值，会有默认值，规则和数组一样4.内存的位置不一样（了解）局部变量：位于栈内存成员变量：位于堆内存5.生命周期不一样（了解）局部变量：随着方法进栈而诞生，随着方法出栈而消失成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失面向对象三大特征：封装，继承，多态封装性在Java当中的体现：1.方法就是一种封装2.关键字private也是一种封装封装就是将一些细节信息隐藏起来，对于外界不可见。private关键字的作用一旦使用了private关键字修饰，在同一个类中可以访问。但是其他类别不能直接访问间接访问定义一对Getter/Setter方法必须叫setXxx或者是getxxx[如果是布尔值（那么用isXXX的命名会泽）]命名规则。对于Getter来说，不能有参数，返回值类型和成员变量对应；对于setter来说，不能有返回值，参数类型和成员变量对应。This关键字的作用当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，优先使用局部变量如果要访问类的成员变量需要用关键字：This格式This.成员变量名构造方法构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。格式：123public 类名称（参数类型参数名称）&#123; 方法体&#125;注意事项：1.构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样2.构造方法不要写返回值类型，连void都不写3.构造方法不能return一个具体的返回值4.如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，没有参数、方法体什么事情都不做。5.一旦编写了至少一个构造方法，那么编译器将不再赠送。6.构造方法也是可以进行重载的。重载：方法名称相同，参数列表不同。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// java标准类package object.oriented;/** * @author Luenci * @version 1.0 * @date 2019/12/6 10:50 */public class BaseStudent &#123; private String name; private int age; private char sex; // 无参数的构造方法 public BaseStudent() &#123; System.out.println("我是一个无参数的构造方法"); &#125; // 全参数的构造方法 public BaseStudent(String name, int age, char sex) &#123; this.name = name; this.age = age; this.sex = sex; System.out.println("我是一个全参数的构造方法"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public char getSex() &#123; return sex; &#125; public void setSex(char sex) &#123; this.sex = sex; &#125;&#125;API笔记引用类型的一般使用步骤：1.导包import 包路径.类名称；如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。只有java.lang包下的内容不需要导包，其他的包都需要import语句。2.创建类名称 对象名 = new 类名称（）；3.使用对象名.成员方法名()匿名对象只有右边的对象，没有左边的名字和赋值运算符。new 类名称().属性名12345678910111213141516171819202122232425262728293031323334package object.oriented;import java.util.Scanner;/** * @author Luenci * @version 1.0 * @date 2019/12/7 17:34 */public class AnonymousDemo &#123; public static void main(String[] args) &#123; // 匿名对象 new Student().eat(); // 匿名对象作为参数// methiordParam(new Scanner(System.in)); // 匿名对象作为返回值 Scanner sc = methodReturn(); int num = sc.nextInt(); System.out.println("您输入的是：" + num); &#125; public static void methiordParam(Scanner sc) &#123; int num = sc.nextInt(); System.out.println("输入的是：" + num); &#125; public static Scanner methodReturn() &#123; return new Scanner(System.in); &#125;&#125;对象数组任何数据类型都可以作为数组里面的存储元素。数组有一个缺点：一旦创建，程序运行期间长度不可以发生改变ArrayList集合概述和使用ArrayList集合的长度是可以随意变化的。对于ArrayList来说，有一个尖括号&lt;E&gt;代表泛型。泛型：也就是装在集合当中的所有元素，全都是统一的什么类型。注意：泛型只能是引用类型，不能是基本类型常用的ArrayList方法：public boolean add（E e）：向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。备注：对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用。但是对于其他集合（今后学习）来说，add添加动作不一定成功。public E get（int index）：从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。public E remove（int index）：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。public int size（）：获取集合的尺寸长度，返回值是集合中包含的元素个数。如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的“包装类”。基本类型包装类（引用类型，包装类都位于java.lang包下）shortShortintInteger【特殊】longLongcharCharacter【特殊】floatFloatdoubleDoublebooleanBoolean从 JDK 1.5+ 开始，支持自动装箱、自动拆箱。自动装箱：基本类型–&gt;包装类型自动拆箱：包装类型–&gt;基本类型字符串的概述和特点字符串的特点：1.字符串的内容永不可变（字符串是常量）。【重点】2.正是因为字符串不可改变，所以字符串是可以共享使用的。3.字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组。创建字符串的常见3+1种方式。三种构造方法：public String（）：创建一个空白字符串，不含有任何内容。public String（char[] array）：根据字符数组的内容，来创建对应的字符串。public String（byte[] array）：根据字节数组的内容，来创建对应的字符串。一种直接创建：string str=&quot;Hello&quot;； 右边直接用双引号字符串常量池字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中对于基本类型来说，==是进行数值的比较。对于引用类型来说，==是进行[地址值]的比较。内存划分：常用的API方法==是进行对象的地址值比较，如果需要字符串的内容比较，可以使用两个方法：public boolean equals（Object obj）：参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给true；否则返回false。注意事项：1.任何对象都能用Object进行接收。2.equals方法具有对称性，也就是a.equals（b）和b.equals（a）效果一样。3.如果比较双方一个常量一个变量，推荐把常量字符串写在前面。推荐：&quot;abc&quot;.equals（str不推荐：str.equals（&quot;abc&quot;）public boolean equalsIgnoreCase（String str）：忽略大小写，进行内容比较。static关键字的介绍如果一个成员变量使用了static关键字，那么这个变量不再属于对象自己，而是属于所在的类。多个对象共享同一份数据。static关键字修饰成员变量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package luenci.staticclass;/** * @author Luenci * @version 1.0 * @date 2019/12/12 16:18 * @info 学生类 */public class Student &#123; private int id; private String name; private int age; static String room = "Java一班"; private static int idCount = 0; public Student() &#123; this.id = ++idCount; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; this.id = ++idCount; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public static String getRoom() &#123; return room; &#125; public static void setRoom(String room) &#123; Student.room = room; &#125;&#125;12345678910111213141516171819package luenci.staticclass;/** * @author Luenci * @version 1.0 * @date 2019/12/12 16:22 * @info 实例化例子 */public class Demo1 &#123; public static void main(String[] args) &#123; Student stu1 = new Student("Luenci", 22); Student stu2 = new Student("Lynn", 22); System.out.println("学号：" + stu1.getId() + "姓名：" + stu1.getName() + "年龄：" + stu1.getAge() + "班级：" + Student.room); System.out.println("学号：" + stu2.getId() + "姓名：" + stu2.getName() + "年龄：" + stu2.getAge() + "班级：" + Student.room); &#125;&#125;static关键字修饰成员方法一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。静态变量：类名称.静态变量静态方法：类名称.静态方法（）12345678910111213141516171819202122232425package luenci.staticclass;/** * @author Luenci * @version 1.0 * @date 2019/12/12 16:49 * @info 自定义方法类 */public class myClass &#123; int num; static int age; public void method() &#123; System.out.println("普通的成员方法"); System.out.println(num); System.out.println(age); &#125; public static void methodStatic() &#123; System.out.println("静态方法"); // 错误访问 /*System.out.println(num);*/ System.out.println(age); &#125;&#125;1234567891011121314151617181920212223242526package luenci.staticclass;/** * @author Luenci * @version 1.0 * @date 2019/12/12 16:50 * @info static关键字修饰方法 */public class Demo2 &#123; public static void main(String[] args) &#123; myClass obj = new myClass(); // 普通成员方法 对象名.成员方法（） obj.method(); // 静态方法 推荐用：类名称.静态方法（）调用 myClass.methodStatic(); // 在本类中调用自己的静态方法，可以省略类名称 myMethod(); &#125; public static void myMethod()&#123; System.out.println("自己的方法"); &#125;&#125;注意事项：1.静态不能直接访问非静态。原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容。“先人不知道后人，但是后人知道先人。”2.静态方法当中不能用this关键字。原因：this代表当前对象，通过谁调用的方法，谁就是当前对象。static内存图静态代码块特点：当第一次用到本类时，静态代码块执行唯一的一次。静态内容总是优先于非静态，所以静态代码块比构造方法先执行。静态代码块的典型用途：用来一次性地对静态成员变量进行赋值。Arrays类常用方法java.util.Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。public static String tostring（数组）：将参数数组变成字符串（按照默认格式：[元素1，元素2，元素3…]）public static void sort（数组）：按照默认升序（从小到大）对数组的元素进行排序。1234567891011121314151617181920212223242526272829package luenci.array;import java.util.Arrays;/** * @author Luenci * @version 1.0 * @date 2019/12/12 17:25 * @info Arrays类的常见的使用方法 */public class ArraysDemo &#123; public static void main(String[] args) &#123; int[] array = &#123;1,2,3,4&#125;; String str = Arrays.toString(array); System.out.println(str); int[] array1 = &#123;1,4,5,9,2,5,7,0&#125;; Arrays.sort(array1); System.out.println(Arrays.toString(array1)); String[] array2 = &#123;"aaa","ccc","bbb"&#125;; Arrays.sort(array2); System.out.println(Arrays.toString(array2)); &#125;&#125;out [1, 2, 3, 4] [0, 1, 2, 4, 5, 5, 7, 9] [aaa, bbb, ccc]备注：1.如果是数值，sort默认按照升序从小到大排序2.如果是字符串，sort默认按照字母升序3.如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。Math相关的类方法java.util.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作。public static double abs（double num）：获取绝对值。有多种重载。public static double ceil（double num）：向上取整。public static double floor（double num）：向下取整。public static long round（double num）：四舍五入。final关键字final关键字代表最终、不可改变的。常见四种用法修饰类当final关键字用来修饰一个类的时候，格式：public final class 类名称（//…}含义：当前这个类不能有任何的子类。（太监类）注意事项：一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写。（没法继承，没有儿子）修饰方法当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。格式：修饰符final 返回值类型方法名称（参数列表）（//方法体}注意事项：对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。修饰局部变量一旦使用final用来修饰局部变量，那么这个变量就不能进行更改。“一次赋值，终生不变”对于基本类型来说，不可变说的是变量当中的【数据】不可改变对于引用类型来说，不可变说的是变量当中的【地址值】不可改变修饰成员变量由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。四种权限修饰符类别 \ 关键字publicprotected（default）默认private同一个类YESYESYESYES同一个类YESYESYESNO不同包子类YESYESNONO不同包非子类YESNONONO注意事项：（default）并不是关键字“default”，而是根本不写。内部类如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。例如：身体和心脏的关系。又如：汽车和发动机的关系。分类：成员内部类局部内部类（包含匿名内部类）成员内部类成员内部类的定义格式：1234567修饰符 class 外部类名称&#123; 修饰符 class 内部类名称&#123; // … &#125; // ...&#125;注意：内用外，随意访问外用内，需要内部类对象如何使用成员内部类：1.间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。2.直接方式，公式：类名称 对象名=new 类名称（）；【外部类名称.内部类名称对象名=new外部类名称（）.new内部类名称（）；】内部类同名变量的访问如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名局部内部类如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。“局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。定义格式：1234567修饰符 class 外部类名称&#123; 修饰符 返回值 类型外部类方法名称（参数列表）&#123; class 局部内部类名称&#123; //… &#125; &#125;&#125;局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】备注：从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。原因：1.new出来的对象在堆内存当中。2.局部变量是跟着方法走的，在栈内存当中。3.方法运行结束之后，立刻出栈，局部变量就会立刻消失。4.但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。匿名内部类如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】。匿名内部类的定义格式：123接口名称 对象名 = new 接口名称（）&#123; //覆盖重写所有抽象方法&#125;；对格式“new 接口名称（）{..}”进行解析：1.new表示创建对象的动作2.接口名称就是匿名内部类需要实现哪个接口3.{.…}这才是匿含内部类的内容注意几点问题：1.匿名内部类，在【创建对象】的时候，只能使用唯一一次。如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了。2.匿名对象，在【调用方法】的时候，只能调用唯一一次。如果希望同一个对象，调用多次方法，那么必须给对象起个名字。3.匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】强调：匿名内部类和匿名对象不是一回事注意事项小节一下类的权限修饰符：public &gt; protected &gt;（default）&gt; private定义一个类的时候，权限修饰符规则：1.外部类：public/（default）2.成员内部类：public/protected/（deffult）/private3.局部内部类：什么都不能加]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java语言概述]]></title>
    <url>%2F2019%2F12%2F04%2Fjava%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Java语言简史Java语言是美国Sun公司（Stanford University Network），在1995年推出的高级编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。Java语言发展历史1995年Sun公司发布Java1.0版本1997年发布Java1.1版本1998年发布Java1.2版本2000年发布Java1.3版本2002年发布Java1.4版本2004年发布Java5版本（更新频率较大）2006年发布Java6版本2009年Oracle甲骨文公司收购Sun公司，并于2011发布Java7版本2014年发布Java8版本（更新频率较大，市场占有率最大）2017年9月发布Java9版本2018年3月发布Java10版本Java 平台的三个版本作用：这使软件开发人员、服务提供商和设备生产商可以针对特定的市场进行开发：Java SE（Java Platform，Standard Edition）Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为 Java Platform，Enterprise Edition（Java EE）提供基础。Java EE（Java Platform，Enterprise Edition）这个版本以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 2.0 应用程序。Java ME（Java Platform，Micro Edition）这个版本以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。开发环境，推荐Eclipse,NetBeans,这两个IDE可以挂接对应的插件，进行开发。还有一点，那就是这三个应用，se,标准应用，以学习为主，由于界面，开发成本，速度等问题，很少用来做程序，但不是说，他不能做程序，Eclipse,NetBeans,都是javase写起来的。Me,移动设备应用，对于一些中高端应用还好了！以前用他做过手机游戏，呵呵呵！EE,企业级解决方案，开发套件全部免费，可控性好，安全性高，乃是当前B2B的规范。再者，这三个应用，都需要虚拟机的支持。字节位（bit）：一个数字0或者一个数字1，代表一位。字节（Byte）：每逢8位是一个字节，这是数据存储的最小单位。123456781 Byte = 8 bit1 KB = 1024 Byte1 MB = 1024 KB1 GB = 1024 MB1 TB = 1024 GB1 PB = 1024 TB1 EB = 1024 PB1 ZB = 1024 EBJava虚拟机——JVMJVM（Java Virtual Machine）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java最具吸引力的特性之一。我们编写的Java代码，都运行在JVM之上。跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上。Java的虚拟机本身不具备跨平台功能的，每个操作系统下都有不同版本的虚拟机。JRE和JDKJRE（Java Runtime Environment）：是Java程序的运行时环境，包含Jvm和运行时所需要的核心类。JDK（Java Development Kit）：是Java程序开发工具包，包含JRE]和开发人员使用的工具。我们想要运行一个已有的Java程序，那么只需安装JRE即可。我们想要开发一个全新java程序，那么必须安装JDK。Java程序运行步骤编写源程序， 后缀名为.java的文件编译源程序， 用javac命令将后缀名为.java的源程序编译成.class的字节码文件运行源程序， 用java命令 将.class文件在计算机上解释出来（JVM上运行）。Java标识符标识符：是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。命名规则：硬性要求标识符可以包含英文字母26个（区分大小写）、0-9数字、$（美元符号）和_（下划线）。标识符不能以数字开头。标识符不能是关键字。命名规范：软性建议(代码命名规范建议)类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。方法名规范：同变量名。123456789101112131415161718192021222324252627282930package Luenci.demo;/** * @author Luenci * @version 1.0 * @date 2019/11/30 18:18 */public class DemoCode1 &#123; public static void main(String[] args)&#123; // 字符串常量 和 字符常量（里面有且仅有一个字符） System.out.println("我是字符串常量"); System.out.println('h'); // 整数常量 System.out.println(200); System.out.println(-500); // 浮点数常量 System.out.println(0.22); System.out.println(0.8989); // 布尔常量 System.out.println(true); System.out.println(false); // 空常量:不能用来打印输出 // System.out.println(null); &#125;&#125;Java数据类型Java的数据类型分为两大类：基本数据类型：整数、浮点数、字符、布尔。引用数据类型：类、数组、接口。基本数据类型整数型 byte short int log浮点型 float double字符型 char布尔型 boolean数据类型关键字内存占用取值范围字节型byte1个字节-128 - 127短整型short2个字节-32768 - 32767整型int（默认）4个字节-2^31 - 2^31-1长整型long8个字节-2^63 - 2^63.1单精度浮点数float4个字节1.4013E - 45-3.4028E+38双精度浮点数double（默认）8个字节4.9E-324 ~ 1.7977E+308字符型char2个字节0-65535布尔类型honlean1个字节true false注意事项：字符串不是基本类型，而是引用类型。浮点型可能只是一个近似值，并非精确的值。数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节。浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F。如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L。推荐使用大写字母后缀。【作用域】：从定义变量的行开始，一直到直接所属的大括号结束为止。数据类型转换自动类型转换（隐式）特点：代码不需要进行特殊处理，自动完成规则：数据范围从小到大强制类型转换（显示）特点：代码需要进行特殊的格式处理，不能自动完成格式：范围小的类型 范围小的变量名 = （范围小的类型） 原本范围大的数据;强制类型转换 （注意）使用时注意精度损失和数据溢出等情况byte/short/char这三种类型都可以发生数学运算，例如加法“+”.byte/short/char这三种类型在运算的时候，都会被首先提升成为int类型，然后再计算。boolean类型不能发生数据类型变换ASCII码字符表0 对应的ascill码值为 32A 对应的ascill码值为 65a 对应的ascill码值为 97其余的向后推理即可运算符算数运算符包括解释+加法运算，字符串连接运算-减法运算*乘法运算\除法运算%取模运算，两个数字相除1取余数++, --自增自减运算1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package Luenci.demo;/** * @author Luenci * @version 1.0 * @date 2019/12/2 20:45 */public class OperatorDemo &#123; public static void main(String[] args)&#123; // 四则运算符 int a = 10,b = 25; System.out.println(a + b); System.out.println(a - b); System.out.println(a * b); System.out.println(a / b); // 用字符串进行连接的时候结果都会变成字符串 String str = "Luenci"; System.out.println(str + 404); // 单独使用的时候++在前和++在后没什么区别 // 和变量等在一起使用的时候是++在前的时候【先加后用】 // 和变量等在一起使用的时候是++在后的时候【先用后加】 int num=0; num++; System.out.println(num); System.out.println("-------------- 分割线 -----------------"); int num1 = 20; System.out.println(num1++); // 20 System.out.println(num1); // 21 int num2 = 30; System.out.println(++num2); // 31 &#125;&#125;out: 35 -15 250 0 Luenci404 1 -------------- 分割线 ----------------- 20 21 31常量不可使用 ++，–赋值运算符其中 隐含了一个强制类型转换比较运算符比较运算符类别解释==比较两边的数据是否相等，相等结果为True&lt;比较左边的数据是否小于右边的数据，小于结果为True&gt;比较左边的数据是否大于右边的数据，大于结果为True&lt;=比较左边的数据是否小于或等于右边的数据，小于或等于结果为True&gt;=比较左边的数据是否大于或等于右边的数据，大于或等于结果为True!=比较两边的数据是否相等，不相等结果为True逻辑运算符与（并且）&amp;&amp;全都是true，才是true；否则就是false或（或者）||至少一个是true，就是true；全都是false， 才是false非（取反）！本来是true，变成false；本来是false，变成true编译器的两点优化对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐含地为我们补上一个（byte）（short）（char）。1.如果没有超过左侧的范围，编译器补上强转。2.如果右侧超过了左侧范围，那么直接编译器报错。编译器的常量优化在给变量进行赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。如:short result=5+8；//等号右边全都是常量，没有任何变量参与运算编译之后，得到的.class字节码文件当中相当于【直接就是】：short result=13；程序流程控制判断语句1234567891011121314151617181920212223242526272829303132package Luenci.method;import java.util.Scanner;/** * @author Luenci * @version 1.0 * @date 2019/12/3 17:39 */public class ProcessControl &#123; public static void main(String[] args)&#123; // 从键盘处获得成绩值 Scanner sc = new Scanner(System.in); System.out.println("请输入您的成绩"); String score = sc.nextLine(); // 判断成绩优秀否 if ( Integer.parseInt(score) &gt;= 90)&#123; System.out.println("您的成绩优秀"); &#125; else if (Integer.parseInt(score) &gt; 80 &amp;&amp; Integer.parseInt(score) &lt; 90)&#123; System.out.println("你的成绩良好"); &#125; else if (Integer.parseInt(score) &gt; 60 &amp;&amp; Integer.parseInt(score) &lt;80)&#123; System.out.println("您的成绩合格"); &#125; else &#123; System.out.println("您的成绩不合格"); &#125; &#125; public static String getType(Object o)&#123; return o.getClass().toString(); &#125;&#125;选择结构switch语句使用的注意事项：​ 1.多个case后面的数值不可以重复。​ 2.switch后面小括号当中只能是下列数据类型：​ 基本数据类型：byte/short/char/int​ 引用数据类型：String字符串、enum枚举12345678910111213141516171819202122232425262728293031323334353637package Luenci.method;import java.util.Date;import java.text.SimpleDateFormat;/** * @author Luenci * @version 1.0 * @date 2019/12/4 11:30 */public class SwitchDemo &#123; public static void main(String[] args)&#123; // 设置日期格式 // SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); // new Date()为获取当前系统时间 Date date = new Date(); // 使用SimpleDateFormat格式化日期 SimpleDateFormat df = new SimpleDateFormat("EEEE"); String currSun = df.format(date); switch (currSun)&#123; case "星期一": System.out.println(currSun + "开始上班"); break; case "星期六": System.out.println(currSun + "休息第一天"); break; case "星期五": System.out.println(currSun + "放假前夕"); break; default: System.out.println(currSun + "上班中"); break; &#125; &#125;&#125;循环语句1234567891011121314151617package Luenci.method;/** * @author Luenci * @version 1.0 * @date 2019/12/4 15:00 */public class ForDemo &#123; public static void main(String[] args)&#123; int i,a; a = 0; for ( i = 1; i &lt;= 100; i++)&#123; a += i; &#125; System.out.println(a); &#125;&#125;whlie循环12345678910111213141516171819package Luenci.method;import com.sun.jmx.snmp.internal.SnmpSubSystem;/** * @author Luenci * @version 1.0 * @date 2019/12/4 15:10 */public class WhileDemo &#123; public static void main(String[] args)&#123; // 初始化语句 int a = 1; while (a &lt; 10)&#123; System.out.println("打印" + a + "遍"); a++; &#125; &#125;&#125;do …while 循环123456789101112131415161718package Luenci.method;/** * @author Luenci * @version 1.0 * @date 2019/12/4 15:13 */public class DowhlieDemo &#123; public static void main(String[] args)&#123; // do ..... while 循环的第一次是 无条件执行 int i = 1; do &#123; System.out.println("打印" + i + "遍"); i++; &#125; while (i &lt; 10); &#125;&#125;三种循环的区别1.如果条件判断从来没有满足过，那么for循环和while循环将会执行0次，但是do-while循环会执行至少一次。2.for循环的变量在小括号当中定义，只有循环内部才可以使用。while循环和do-while循环初始化语句本来就在外面，所以出来循环之后还可以继续使用。break关键字的用法有常见的两种1.可以用在switch语句当中，一旦执行，整个switch语句立刻结束。2.还可以用在循环语句当中，一旦执行，整个循环语句立刻结束。打断循环。关于循环的选择，有一个小建议：凡是次数确定的场景多用for循环；否则多用while循环。另一种循环控制语句是continue关键字。一旦执行，立刻跳过当前次循环剩余内容，马上开始下一次循环]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在前面]]></title>
    <url>%2F2019%2F12%2F04%2FREADME%2F</url>
    <content type="text"><![CDATA[写在前面About ME此博客记录了我的一些学习过程和一些项目的源码和学习笔记。有兴趣的朋友可在菜单的分类中找寻自己感兴趣的内容。有些内容可能过于浅显或者有误，欢迎大家指教和斧正。​ 学无止境，希望大家都能学有所成。​ 每一种编程语言都是一种艺术，希望大家选择编程语言不要纠结不前，还不如先出发。一直在路上。​ 2018/12/4]]></content>
      <categories>
        <category>个人随感</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基本知识]]></title>
    <url>%2F2019%2F11%2F23%2FJavaScript%E7%9A%84%E7%AE%80%E4%BB%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[JavaScript作用表单动态检验（密码强度检测）网页特效服务端开发（Node.js）桌面程序（Electron）APP（Cordova）控制硬件 - 物联网（Ruff）游戏小程序（cocos2d-js）HTML/CSS/JS的关系HTML/CSS标记语言–描述类语言HTML决定网页结构和内容（决定看到什么），相当于人的身体CSS决定网页呈现给用户的模样（决定好不好看），相当于给人穿衣服、化妆JS脚本语言-编程类语言实现业务逻辑和页面控制（决定功能），相当于人的各种动作浏览器执行js浏览器分成两部分：渲染引擎和JS引擎渲染引擎：用来解析HTML与CSS，俗称内核，比如chrome浏览器的blink，老版本的webkitJS引擎：也称为JS解释器。用来读取网页中的JavaScript代码，对其处理后运行，比如chrome浏览器的V8浏览器本身并不会执行JS代码，而是通过内置JavaScript引擎（解释器）来执行JS代码。JS引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以JavaScript语言归为脚本语言，会逐行解释执行。JS组成1.ECMAScriptECMAScript是由ECMA国际（原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMAScript语言的实现和扩展。ECMAScript:ECMAScript规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。2.DOM——文档对象模型文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过DOM提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）。3.BOM——浏览器对象模型BOM（Browser Object Model，简称BOM）是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。JS有3种书写1.行内式JS可以将单行或少量JS代码写在HTML标签的事件属性中（以on开头的属性），如：onclick注意单双引号的使用：在HTML中我们推荐使用双引号，JS中我们推荐使用单引号可读性差，在html中编写JS大量代码时，不方便阅读；引号易错，引号多层嵌套匹配时，非常容易弄混；特殊情况下使用2.内嵌JS123&lt;script&gt; alert（'Hello World~！'）；&lt;/script&gt;可以将多行JS代码写到&lt;script&gt;标签中内嵌JS是学习时常用的方式3.外部JS文件利于HTML页面代码结构化，把大段JS代码独立到HTML页面之外，既美观，也方便文件级别的复用引用外部JS文件的script标签中间不可以写代码适合于JS代码量比较大的情况12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 2. 内嵌式的js --&gt; &lt;script&gt; //alert('Hello') &lt;/script&gt; &lt;script src="my.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 1. 行内式的JS 直接写到元素内部 --&gt; &lt;!-- &lt;input type="button" value="Luenci" onclick="alert('hello world')"&gt; --&gt; &lt;/body&gt;&lt;/html&gt;JavaScript注释123//1.单行注释 ctrl + //*2.多行注释默认的快捷键 shift + alt + a */2.多行注释vscode中修改多行注释的快捷键：ctrl + shift + /JavaScript输入输出语句12345678&lt;script&gt; // 这是一个输入框 prompt('请输入您的年龄'); //alert 弹出警示框 alert('计算的结果是：'); // console 控制台输出 给程序员测试用 console.log('我是程序员')&lt;/script&gt;变量声明变量//声明变量var age；//声明一个名称为age的变量var是一个JS关键字，用来声明变量（variable变量的意思）。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序最管age是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间变量命名规范由字母（A-Za-z）、数字（0-9）、下划线（）、美元符号（$）组如：usrAge，num01，_name严格区分大小写。var app；和var App；是两个变量不能以数字开头。18age是错误的不能是关键字、保留字。例如：var、for、while变量名必须有意义。MMDBBD nl → age遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName数据类型JavaScript是一种弱类型或者说动态语言。JS把数据类型分为两类简单数据类型（Number，string，Boolean，Undefined，Null）复杂数据类型（object）### 数字型Infinity，代表无穷大，大于任何数值Infinity，代表无穷小，小于任何数值NaN，Not a number，代表一个非数值isNaN（）这个方法用来判断非数字并且返回一个值如果是数字返回的是false如果不是数字返Turn1234567891011121314151617181920212223242526&lt;script&gt; var num=1e；//num 数字型 var PI=3.14//PI数字型 //1.八进制0~7我们程序里面数字前面加0表示八进制 var numl=010； console.1og（num1）；// 010八进制转换为10进制就是8 var num2=012； console.1og（num2）； //2.十六进制e～9a~f#ffffff数字的前面加0x表示十六进制 var num3=0x9； console.1og（num3）； var num4=0xa； console.1og（num4）； // 数字型的最大值 console.log(Number.MAX_VALUE); // 数字型的最小值 console.log(Number.MIN_VALUE); &lt;/script&gt;out: 8 10 9 10 1.7976931348623157e+308 5e-324字符串型String1.字符串引号嵌套JS可以用单引号嵌套双引号，或者用双引号嵌套单引号（外双内单，外单内双)2.字符串转义符类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。转义符都是\头的，常用的转义符及其说明如下：转义符解释说明\n换行符，n是newline的意思\斜杠 \\&#39;单引号\&quot;双引号\ttab缩进\b空格，b是blank的意思布尔型布尔类型有两个值：true和false，其中true表示真（对），而false表示假（错）。布尔型和数字型相加的时候，true的值为1，false的值为0。Undefined 和Null一个声明后没有被赋值的变量会有一个默认值undefined（如果进行相连或者相加时，注意结果）数据类型的转换转换为字符串类型方式说明案例toString()转成字符串var num=1; alert(num.toString()）String()强制转换转成字符串var num=1；alert(String(num))；加号拼接字符串和字符串拼接的结果都是字符串var num=1；alert(num+”我是字符串”)；toString()和String()使用方式不一样。三种转换方式，我们更喜欢用第三种加号拼接字符串转换方式，这一种方式也称之为隐式转换。转换为数字型方式方式案例parselnt(string)函数将string类型转成整数数值型parselnt(‘78’)parseFloat（string）函数将string类型转成浮点数数值型parseFloat（”78.21”）Number（）强制转换函数将string类型转换为数值型Number(‘12’)js隐式转换（- * / ）利用算术运算隐式转换为数值型‘12’ - 0转换为布尔型方式说明案例Boolean()函数其他类型转成布尔值Boolean(‘var’);代表空、否定的值会被转换为false如”、0、NaN、null、undefined其余值都会被转换为true编译型语言和解释型语言编译器在代码执行之前进行编译，生成中间代码文件解释器在运行时进行及时解释，并立即执行（当编译器以解释方式运行的时候，也称之为解释器）]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[京东全网爬虫]]></title>
    <url>%2F2019%2F11%2F22%2F%E4%BA%AC%E4%B8%9C%E5%85%A8%E7%BD%91%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[完整代码见： https://github.com/Lucareful/JingDongSpider写在前面：折腾了很久的用python做爬虫项目到现在也该告一段落了，看视频学，遇到bug自己查找，代码思路不对重新写，环境不对自己配置….一路上跌跌撞撞，过程很艰苦，所幸结果为好。代码就像一面明镜，照见我自身的不足。继续加油需求抓取首页的分类信息大分类的url中分类的url小分类的url抓取商品信息商品名称价格评论信息店铺促销选项图片开发环境和技术技术选择：由于全网爬虫，抓取页面非常多，为了提高抓的速度，选择使用scrapy框架+scrapy_redis分布式组件由于京东全网的数据量达到了亿级，存储又是结构化数据，数据库，选择使用MongoDB；京东全网爬虫的实现步骤采取广度优先策略，我们把类别和商品信息的抓取分开来做优点，提高程序的稳定性总体设计实现步骤创建爬虫项目根据需求，定义数据数据模型实现分类起虫保存分类信息实现商品爬虫保存商品信息实现随机User-Agent和代理IP下载器中间件，解决IP反爬。创建爬虫项目scrapy startproject jingDong定义数据模型（要抓取的数据）类别数据模型类用于存储类别信息（Category）-字段：b.category_name：大类别名称。b_category_url：大类别URL。m_category_name：中分类名称。m_category_url：中分类URL。s_category_name：小分类名称s_category_url：小分类URL商品数据模型商品数据模型类：用于存储商品信息（Product）字段：oproduct_category：商品类别product_sku_id：商品IDproduct_name：商品名称product_img_url：商品图片URLproduct_book_info：图书信息，作者，出版社product_option：商品选项product_shop：商品店铺product_comments：商品评论数量product_ad：商品促销product_price：商品价格商品的分类爬虫创建爬虫进入项目目录：cd mall_spider创建爬虫：scrapy genslider category_spider jd.com指定起始URL修改起始URL: https://dc.3.cn/category/get实现保存分类的pipeline类open_spider 方法中，链接MongoDB数据库，获取要操作的集合process_item 方法中，向MongoDB中插入类别数据close_spider 方法中，关闭MongoDB的链接实现商品爬虫步骤分析，确定数据所在的URL代码实现（核心）商品爬虫实现分布式分析，确定数据所在的URL解析列表页，提取商品sku_id，实现翻页，确定翻页的URL获取商品的基本信息，通过手机抓包（APP），确定URLPC详情页面，确定商品的促销信息的URLPC详情页面，确定评论信息的URLPC详情页面，确定商品价格信息的URL代码实现1.重写start_requests方法，根据分类信息构建列表页的请求2.解析列表页，提取商品的skuid，构建商品基本的信息请求；实现列表翻页1.确定商品基本的信息请求1.URL:https://cdnware.m.jd.com/c1/skuDetail/apple/7.3.0/32962088964.json2.请求方法：GET3.参数/数据：32962088964商品的skuid2.解析列表页，提取商品的skuid3.构建商品基本的信息请求4.实现列表翻页解析促销信息，构建商品评价信息的请求1.解析促销信息1.produft_ad：商品促销2.构建商品评价信息的请求1.准备评价信息的请求解析商品评价信息，构建价格信息的请求解析商品评价信息1.product_comments：商品评论数量2.评价数量，好评数量，差拜数量，好评率2.构建价格信息的请求准备价格请求：1.URL:https://p.3.cn/prices/mgets?skulds=J_69334292.2.请求方法：GET3.参数：skulds=J_6933429，j后跟这个商品的sku_id解析价格信息1.product_price：商品价格2.把商品数据交给引擎商品爬虫实现分布式修改爬虫类修改继承关系指定redis_key把重写start_requests改为重写make_request from data I在settings文件中配置scrapy_redis直接拷贝scrapy_redis配置信息，到settings.py中.写一个程序用于把MongoDB中分类信息，放入到爬虫redis_key指定的列表中保存商品数据实现存储商品Pipeline类在open_spider方法，建立MongoDB数据库连接，获取要操作的集合在process_item方法，把数据插入到MongoDB中在close_spider方法，关闭数据库连接在settings.py中开启这个管道实现下载器中间件实现随机User-Agent的中间件在settings.py中开启上面的下载器中间件]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>scrapy框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的进阶学习]]></title>
    <url>%2F2019%2F11%2F19%2FPython%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[import导入模块路径问题存在的问题：当我们把模块文件放到工程文件夹的外部的文件，发现无法正常引入模块原因：外部的文件夹的路径，没有放到环境变量中。查看环境变量1.导入sys模块2.sys.path查看环境变量返回值是列表把自己写的模块的路径加入到环境变量中1234# 将模块路径追加到末尾 sys.path.append(r"模块的路径")# 将模块路径追加到开头sys.path.insert(0,r"模块的路径")12345678910111213141516171819# import module# # module -- 模块名# # name 模块 modele 中的变量# print(module.name)import sys# 查看python解释器搜索的环境变量# 将模块路径追加到末尾# sys.path.append(r"C:\Users\Luenci\Desktop")# 将模块路径追加到开头有sys.path.insert(0, r"C:\Users\Luenci\Desktop")for i in sys.path: print(i) import appprint(app.name)import导入模块import会防止重复导入在同一个程序中多次import同一个模块，只会执行一次重新导入模块为什么需要重新导入模块?模块被导入后，import module不能重新导入模块，重新导入需用reload重新加载模块代码创建模块对象准备一个模块 reload_test 并定义一个函数 test 代码如下：12def demo(): print(&quot;---------- 111 -----------&quot;)1234567891011121314151617181920# 在 ipython 的交互模式下In [5]: import reload_testIn [6]: reload_test.demo()---------- 111 -----------In [7]: reload_test.demo()---------- 111 -----------# 重新加载之后，改变的内容就可以显示In [14]: from imp import reloadIn [15]: reload(reload_test)Out[15]: &lt;module 'reload_test' from 'D:\\pythonStudy\\import笔记\\reload_test.py'&gt;In [16]: reload_test.demo()---------- 222 -----------from XX import XX的私有化问题123456789# modele.py内容name = "Luenci"# 类中定义私有属性# self._name = XXX# 私有化处理# 如果模块中的变量不希望以 from .. import .. 导入_age = 121234567891011# import module## print(module.name)# 私有化有效from module import *# 私有化无效from module import _ageprint(_age)import 和from..…import的区别import XXX此种方式是直接引用from XXX import xxx此种方式是把XXX的内容复制一份到程序中，若修改不应用到原来的模块可变参数的拆包12345678910111213141516171819202122232425262728def func1(*args, **kwargs): print("---- func1 ----") print("args:", args) print("kwargs:", kwargs)def func2(*args, **kwargs): print("args:", args) print("kwargs:", kwargs) # 调用func1 # 此处没有进行拆包，导致参数传递不过去不符合要求 # func1(args, kwargs) # 此处进行了拆包，阐述传递正确 func1(*args, **kwargs)if __name__ == '__main__': func2(10, 20, 30, a=10, b=20)out: args: (10, 20, 30) kwargs: &#123;'a': 10, 'b': 20&#125; ---- func1 ---- args: (10, 20, 30) kwargs: &#123;'a': 10, 'b': 20&#125;单继承的supersuper（）使用的时候，传递参数的时候，self不用传递super（）调用顺序，按照__mro__顺序来完成Grandson.mro是一个元组当在类中使用super在__mro__列表中找到当前类的下一个元素，调用该元素的方法。1234567891011121314151617181920212223242526272829303132333435363738class Parent(object): def __init__(self, name): self.name = name print('parent的init结束被调用')class Son1(Parent): def __init__(self, name, age): self.age = age super().__init__(name) print('Son1的init结束被调用')class Grandson(Son1): def __init__(self, name, age, gender): self.gender = "男" # 单继承不能提供全部参数 super().__init__(name, age) print('Grandson的init结束被调用')gs=Grandson('grandson', 12, "男")print(Grandson.__mro__)print('姓名:', gs.name)print('年龄:', gs.age)print('性别:', gs.gender)out: parent的init结束被调用 Son1的init结束被调用 Grandson的init结束被调用 (&lt;class '__main__.Grandson'&gt;, &lt;class '__main__.Son1'&gt;, &lt;class '__main__.Parent'&gt;, &lt;class 'object'&gt;) 姓名: grandson 年龄: 12 性别: 男多继承和MRO顺序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 定义父类class Parent(object): def __init__(self, name): self.name = name print('parent的init结束被调用')# 定义子类--》继承父类的 name属性class Son1(Parent): def __init__(self, name, age): # 定义age属性 self.age = age Parent.__init__(self, name) print('Son1的init结束被调用')# 定义子类--》继承父类的 name属性class Son2(Parent): def __init__(self, name, gender): # 定义 gender 属性 self.gender = gender Parent.__init__(self, name) print('Son2的init结束被调用')class Grandson(Son1, Son2): def __init__(self, name, age, gender): # 调用父类的初始化方法 Son1.__init__(self, name, age) Son2.__init__(self, name, gender) print('Grandson的init结束被调用')gs = Grandson('grandson', 12, "男")print(Grandson.__mro__)print('姓名:', gs.name)print('年龄:', gs.age)print('性别:', gs.gender)out: parent的init结束被调用 Son1的init结束被调用 parent的init结束被调用 Son2的init结束被调用 Grandson的init结束被调用 (&lt;class '__main__.Grandson'&gt;, &lt;class '__main__.Son1'&gt;, &lt;class '__main__.Son2'&gt;, &lt;class '__main__.Parent'&gt;, &lt;class 'object'&gt;) 姓名: grandson 年龄: 12 性别: 男使用super()调用父类MRO顺序通过上述代码，我们发现由于多继承情况，parent类被的属性被构造了两次，如果在更加复杂的结构下可能更加严重。为了解决这个问题，Python官方采用了一个算法将复杂结构上所有的类全部都映射到一个线性顺序上，而根据这个顺序就能够保证所有的类都会被构造一次这个顺序就是MRO顺序。MRO查看类名.mro()类名.__mro__1234567891011121314151617181920212223242526272829303132333435363738394041424344# 定义父类class Parent(object): def __init__(self, name, *args, **kwargs): self.name = name print('parent的init结束被调用')# 定义子类--》继承父类的 name属性class Son1(Parent): def __init__(self, name, age, *args, **kwargs): # 定义age属性 self.age = age super().__init__(name, *args, **kwargs) print('Son1的init结束被调用')# 定义子类--》继承父类的 name属性class Son2(Parent): def __init__(self, name, gender, *args, **kwargs): # 定义 gender 属性 self.gender = gender super().__init__(name, *args, **kwargs) print('Son2的init结束被调用')class Grandson(Son1, Son2): def __init__(self, name, age, gender): # 调用父类的初始化方法 super().__init__(name, age, gender) # Son1.__init__(self, name, age) # Son2.__init__(self, name, gender) print('Grandson的init结束被调用')gs = Grandson('grandson', 12, "男")print(Grandson.__mro__)out: parent的init结束被调用 Son2的init结束被调用 Son1的init结束被调用 Grandson的init结束被调用 (&lt;class '__main__.Grandson'&gt;, &lt;class '__main__.Son1'&gt;, &lt;class '__main__.Son2'&gt;, &lt;class '__main__.Parent'&gt;, &lt;class 'object'&gt;)注意当在类中使用super（）在 mro列表中找到当前类的下一个元素，调用该元素的方法多继承中，不建议使用类名直接调用父类的方法@property装饰方法定义时，在实例方法的基础上添加@property 装饰器；并且仅有一个self参数调用时，无需括号方法：foo_obj.func()property属性：foo_obj.prop12345678910111213141516171819class Foo(object): # 初始化方法 def __init__(self, num): self.num = num # 获取值得方法 @property def prop(self): return self.numfoo = Foo(100)# print(foo.prop())# @property 像使用属性一样获取值print(foo.prop)out: 100property的其它功能1234567891011121314151617181920212223242526272829303132333435363738class Goods(object): def __init__(self): # 初始化原价 self.org_price = 1000 # 初始化折扣 self.discount = 0.7 # 获取价格的方法 @property def price(self): return self.org_price * self.discount # 设置价格的方法 @price.setter def price(self, val): if val &gt; 0: self.org_price = val # 删除价格的方法 @price.deleter def price(self): print("执行了 deleter 方法")# 创建对象goods = Goods()print(goods.price)goods.price = 500print(goods.price)del goods.priceout: 700.0 350.0 执行了 deleter 方法property的另一种使用方法1BAR = property（get_price, set_price, del_price, &quot;BAR是一个property对象&quot;）#property（第一个参数，第二个参数，第三个参数，第四个参数）#第一个参数，当我们foo.BAR自动调用第一个参数的方法#第二个参教，当我们foo.BAR=100，自动调用第二个参数的方法#第三个参数，当我们del foo.BAR，自动调用第三个参数的方法#第四个参数，当我们Foo.BAR.doc，自动获取第四个参数的内容魔法属性和方法魔术属性__doc__ 描述类的信息和类方法的信息获取类名 类名.__doc__获取对象 对象.方法名.__doc____model__ 获取所属的模块（对象名.__module__）直接运行该文件 获取main__class__ 获取对象所属的类 对象名.__class____dict__ 获取对象或类的信息通过__dict__获取对象信息，对象.__dict__ 返回字典通过__dict__获取类信息 类名.__dict__返回值是一个字典魔术方法__init__初始化方法 类名（）自动调用__del__删除对象的时候， 会调用__del__方法__call__() 使用对象名()会调用该方法__str__() 打印对象的会调用print(obj) __str__方法一定要return，而且必须return字符串内容用字典的书写格式操作对象的方法__getitem__ 对象[‘XX’]__setitem__ 对象[‘XX’] = xx__delitem__ del 对象[‘xx’]1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Goods(object): """这是一个商品的类""" # 类属性 sell = True def __init__(self): self.price = 100 self.category = "吃的" def set_price(self): """设置价格方法""" pass def __call__(self, *args, **kwargs): print("__call__ 方法被调用") def __str__(self): return "我是一个对象" def __getitem__(self, item): print("key:", item) def __setitem__(self, key, value): print("key:%s, value:%s" % (key, value)) def __delitem__(self, key): print("要删除key：", key) def __del__(self): print("__del__ 正在执行")goods = Goods()# 对象名（） 会去调用对象的 __call__() 方法goods()# print 打印对象的时候，默认输出 &lt;__main__.Goods object at 0x000002356857E080&gt;print(goods)# 通过dict获取对象信息，对象.__dict__ 返回字典print(goods.__dict__)# 通过dict 获取类信息 类名.__dict__返回值是一个字典print(Goods.__dict__)# dict1=&#123;&#125;# dictI['a']=10# goods['a']调用 __getitem__ 方法goods['a']# goods['a']=10用 __setitem__ key，valuegoods['a'] = 10# del goods['a'] 调用 __delitem__ keydel goods['a']out： &#123;'price': 100, 'category': '吃的'&#125; &#123;'__module__': '__main__', '__doc__': '这是一个商品的类', 'sell': True, '__init__': &lt;function Goods.__init__ at 0x00000238CE0F5598&gt;, 'set_price': &lt;function Goods.set_price at 0x00000238CE0F5620&gt;, '__call__': &lt;function Goods.__call__ at 0x00000238CE0F56A8&gt;, '__str__': &lt;function Goods.__str__ at 0x00000238CE0F5730&gt;, '__getitem__': &lt;function Goods.__getitem__ at 0x00000238CE0F57B8&gt;, '__setitem__': &lt;function Goods.__setitem__ at 0x00000238CE0F5840&gt;, '__delitem__': &lt;function Goods.__delitem__ at 0x00000238CE0F58C8&gt;, '__del__': &lt;function Goods.__del__ at 0x00000238CE0F5950&gt;, '__dict__': &lt;attribute '__dict__' of 'Goods' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Goods' objects&gt;&#125; key: a key:a, value:10 要删除key： a __del__ 正在执行]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>进阶知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解释器的GIL锁]]></title>
    <url>%2F2019%2F11%2F17%2FGIL%E9%94%81%2F</url>
    <content type="text"><![CDATA[GlL锁定义Gll锁：Global Interpreter Lock，又称：全局解释器锁任何Python线程执行前，必须先获得GlL锁，然后，每执行100条字节码，解释器就自动释放GL锁，让别的线程有机会执行。这个GlL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。GlL不是Python特性GlL是Pythn解释器（Cpython）时引入的概念，在JPython、PyPy中没有GlL。GIL并不是Python的语言缺陷。是解释器层级的锁，跟Python语言特性无关言外之意，就是全局解释器就是为了锁定整个解释器内部的全局资源，每个线程想要运行首先获取GlL，而GlL本身又是一把互斥锁，造成所有线程只能一个一个one-by-one-并发-交替的执行。GlL存在的原因早期计算机都是单核设计CPython在执行多线程的时候并不是线程安全的，所以为了程序的稳定性，加一把全局解释锁，能够确保任何时候都只有一个Python线程执行GlL产生的背景在CPython解释内部运行多个线程的时候，每个线程都需要解释器内部申请相应的全局资源，由于C语言本身比较底层造成CPython在管理所有全局资源的时候并不能应对所有线程同时的资源请求，因此为了防止资源竞争而发生错误，对所有线程申请全局资源增加了限制-全局解释器锁。GlL锁什么时候释放？在当前线程执行超时后会自动释放在当前线程执行阻塞操作时会自动释放当前执行完成时Guido对GIL锁的看法：https://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235关于GIL面试题描述Python GL的概意，以及它对python多线程的影响？编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否可比单线程性能有提升，并解释原因。Python语言和GlL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机（解释器），难以移除GlL。GlIL：全局解释器锁。每个线程在执行的过程都需要先获取GlL，保证同一时刻只有一个线程可以执行代码。线程释放GL锁的情况：在IO操作等可能会引起阻塞的system call之前，可以暂时释放GIL，但在执行完毕后，必须重新获取GlLPython 3.x使用计时器（执行时间达到阔值后，当前线程释放GlL）或Python 2.x，tickets计数达到100Python使用多进程是可以利用多核的CPU资源的。多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁严重问题：既然CPython解释存在GL是否意味每个线程在全局变量就不用加Lock互斥锁了呢？这是一个严重错误的想法，为什么用户操作全局数据还需要加Lock，因为GlL的释放时机我们无法控制-操作非常可能并没有完成，而不像Lock那样我们用完才释放（操作完整）举例线程1取出全局变量g_number==0一直加到20000，但是还没有来得及将20000写入g_number中，就超时了自动释放GIL 而线程2取出g_number==19999加到39999由于超时自动释放GlL此时线程2获取到GIL继续着未完成的事业将20000写入g_number….这就是之前的多线程案例没有加互斥锁的情况晨终结果是140w东右的盾因GIL锁解决方案解决方案一（不推荐）：我们换一个解释器执行程序就行了（jython：用JAVA写的python解释器）解决方案二（推荐）使用多进程替换多线程multiprocessing是一个多进程模块，开多个进程，每个进程都带一个GlL，就相当于多线程来用了。解决方案三（推荐）使用python语言的特性：胶水.我们让子线程部分用c来写，就ok。（实质上也相当于那部分代码绕过了cython解释器）第一步，编写C语言文件：测试代码，C语言写的死循环，文件名为test2.c：123456void Loop()&#123; while(1) &#123; ; &#125;&#125;然后我们把将其编译成.so文件（share object）需要执行如下命令(Linux下)：1gcc test.c -shared -o libtets.so-shared：将其编译成so文件-o：表示output，用来输出的文件名库文件是以lib开头编译过后，在当前的文件夹下就会生成一个.so文件第二步，编写python文件04-04_GIL锁解决方案.py：12345678import ctypes import threading#加载动态库my_lib=ctypes，cdll.LoadLibrary（"./libtest2.so"）#创建子线程t=threading.Thread（target=my_lib.Loop）t.start（）#主线程while True：pass第三步，执行pvthon文件就可避开Cpython解释器的GIL锁总结GIL锁称为：“全局解释器锁“，是CPytrton解释器中的锁机制，也是历史遗留问题要提升多线程执行效率，解决方案：更换解释器改为进程替换多线程子线程使用C语言实现（绕过GL锁）必须要知道的是：CPU密集型不太适合多线程I/O密集型适合多线程（Gil锁会释放）]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>GIL锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的闭包和装饰器]]></title>
    <url>%2F2019%2F11%2F17%2F%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[闭包引入函数名是一个特殊的变量，保存了函教的地址和自定义一个变量可以获取函数地址自定义变量调用函数 “函数名（）”12345678910111213141516171819def work(): print("我是一个测试函数")ret = workprint(ret)print("地址：%X" % id(ret))print("地址：%X" % id(work))ret()work()out: &lt;function work at 0x00000161E3091E18&gt; 地址：161E3091E18 地址：161E3091E18 我是一个测试函数 我是一个测试函数当我们定义函数test1后，函数名test1保存的是函数在内存的首地址函数名就是一个特殊的变量，函数名（）调用函数，执行函数体test1()和ret()都会调用函数，并执行函数体和变量名一样的，函数名数名只是函数代码空间的引用，当函数名赋值给一个对象的时候就是引用传递。闭包概念在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包维基百科中关于闭包的概念：在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。闭包构成条件必须有一个内嵌函数（函数里定义的函数）–这对应函数之间的嵌套内嵌函数必须引用一个定义在闭合范围内（外部函数里）的变量–内部函数引用外部变量外部函数必须返回内嵌函数–必须返回那个内部函数123456789101112131415161718192021def function_out(num): print("1.function_out num = ", num) def function_in(num_in): print("2.---------- function_in -----------------num", num) print("3.---------- function_in -----------------num_in", num_in) return function_in# function_out(10)# 调用function_out获取内层函数的地址，保存到retret = function_out(100)# 调用内层函数ret(88)out: 1.function_out num = 100 2.---------- function_in -----------------num 100 3.---------- function_in -----------------num_in 88通俗理解：存在函数的嵌套关系内层函数引用了外层函数的临时变量外层函数返回内层函数的引用闭包中的变量123456789101112131415161718192021def function_out(num): def function_in(): # 如果在内层定义了和外层变量同名的变量，但是要使用外层变量 # nonlocal 不使用内层函数的，而是使用外层的变量 nonlocal num print("function_in num", num) # 内部自定义的变量 num = 88 return function_in# 调用外部函数ret = function_out(99)ret()out: function_in num 99装饰器入门装饰器作用：在不改变函数的代码前提下，给函数添加新的功能装饰器的使用：存在闭包需要装饰的函数写代码要道循开放封闭原则，虽然在这个原则是用的面向对象开发，但是也适用于函数式编程，简单来说它规定已经实现的功能代码不允许被修改，但可以被扩展，即：封闭：已实现的勤能代码块开放：对扩展开放12345678910111213141516171819202122def function_out(func): def function_in(): print("开始验证") func() return function_in@function_out# @function_out装饰了 login() 函数# 底层实现# login = function_out(login)def login(): print("开始登陆！")# 通过闭包调用外层函数# login = function_out(login)login()out: 开始验证 开始登陆！通用版装饰器1234567891011121314151617181920212223242526272829def function_out(func): def function_in(*args, **kwargs): print("开始验证") print("function_in user=", args) print("function_in password=", kwargs) return func(*args, **kwargs) return function_in@function_outdef login(*args, **kwargs): print("开始登陆 user=", args) print("开始登陆 password=", kwargs) return 10# 装饰完 login == function_inresult = login(20, a=18)print(result)out: 开始验证 function_in user= (20,) function_in password= &#123;'a': 18&#125; 开始登陆 user= (20,) 开始登陆 password= &#123;'a': 18&#125; 10在原装饰器增加外部变量1234567891011121314151617181920212223242526272829303132333435363738def test(path): print(path) def function_out(func): def function_in(): print("开始验证") func() return function_in # 返回装饰器的引用（装饰器工厂） return function_out@test("login.py")# @test（"login.py"）分解为2步# 1）test（"login.py"）--&gt;function out 引用(地址)# 2）@ 第一步的结果--&gt;@function outdef login(): print("开始登陆")@test("register.py")def register(): print("开始注册")login()register()out: login.py register.py 开始验证 开始登陆 开始验证 开始注册多重装饰器给一个函数进行多次装饰装饰原则：就近原则（靠近待装饰函数的先装饰，随后一层一层装饰）123456789101112131415161718192021222324252627282930313233343536373839404142# &lt;b&gt;helloWord&lt;/b&gt;# 定义一个让文字加粗的装饰器def makeBlod(func): def function_in(): return '&lt;b&gt;' + func() + '&lt;/b&gt;' return function_in# 定义一个让文字倾斜的装饰器def makeItalic(func): def function_in(): return '&lt;i&gt;' + func() + '&lt;/i&gt;' return function_in@makeBloddef demo(): return "helloWord"@makeItalicdef demo2(): return "Luenci"@makeBlod@makeItalicdef demo3(): return "LYnn"print(demo())print(demo2())print(demo3())out: &lt;b&gt;helloWord&lt;/b&gt; &lt;i&gt;Luenci&lt;/i&gt; &lt;b&gt;&lt;i&gt;LYnn&lt;/i&gt;&lt;/b&gt;类装饰器装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象在Python中一般callable对象都是函数，但也有例外。只要某个对象重写了__call__（）方法，那么这个对象就是callable的。类的书写：必须有两个方法1）__init__方法，必须接收装饰器传递的参数func2）__call__方法格式：@类名待装饰的函数对象名()调用对象的__call__（）方法123456789101112131415161718192021222324252627282930# 装饰器类class Demo(object): def __init__(self, func): print("__init__方法") print("-- func --", func) self.func = func def run(self): print("正在奔跑") def __call__(self, *args, **kwargs): print("-- 开始验证 --") # 调用原来login内容 self.func()@Demo# login = demo(login)def login(): print("正在登陆")login()out: __init__方法 -- func -- &lt;function login at 0x0000024E64D857B8&gt; -- 开始验证 -- 正在登陆]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的协程]]></title>
    <url>%2F2019%2F11%2F16%2F%E5%8D%8F%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[可迭代对象可遍历对象就是可迭代对象列表、元组、字典、字符串都是可迭代对象100和自定义myclass 默认都是不可以迷代的myclass对象所属的类MyClass如果包含了__iter__（）方法，此时myclass就是一个可送代对象可送代对象的本质：对象所属的类中包含了__iter__（）方法检测一个对象是否可以送代，用isinstance（）函数检测。迭代器我们发现选代器最核心的功能就是可以通过next0函数的调用来返回下一个数据值。如果每次返回的数据值不是在一个已有的数据集合中读取的，而是通过程序按照一定的规律计算生成的，那么也就意味着可以不用再依赖一个已有的数据集合，也就是说不用再将所有要迭代的数据都一次性缓存下来供后续依次读取，这样可以节省大量的存储（内存）空间。举个例子，比如，数学中有个著名的斐波拉契数列（Fibonacci），数列中第一个数为0，第二个数为1，其后的每一个数都可由前两个数相加得到：特点记录遍历的位置提供下一个元素的值（配合next（）函数）迭代器生成斐波那契数列12345678910111213141516171819202122232425262728293031323334353637class Fibanacci(object): def __init__(self, num): # 实例化生成列属性 self.num = num self.a = 1 self.b = 1 self.current_index = 0 def __iter__(self): # 返回自己 return self def __next__(self): if self.current_index &lt; self.num: # 生成斐波那契数列 # 定义变量保存a的值 data = self.a self.a, self.b = self.b, self.a + self.b self.current_index += 1 return data else: raise StopIterationif __name__ == '__main__': fib = Fibanacci(8) value = next(fib) for i in fib: print(i)out: 1 2 3 5 8 13 21生成器生成器是一类特殊的迭代器。利用选代器，我们可以在每次迭代获取数据（通过next()方法）时按照特定的规律进行生成。但是我们在实现一个迭代器时，关于当前迭代到的状态需要我们自己记录，进而才能根据当前状态生成下一个数据。为了达到记录当前状态，并配合next()函数进行迭代使用，我们可以采用更简便的语法，即生成器（generator)。创建生成器方法1要创建一个生成器，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成（）12345678910111213141516171819202122232425262728# 列表推导式data_list = [x*2 for x in range(5)]for i in data_list: print(i)# 生成器的创建data_list1 = (x*2 for x in range(5))# 通过next()获取下一个值value = next(data_list1)print("--------&gt;", value)for j in data_list1: print(j) out: 0 2 4 6 8 --------&gt; 0 2 4 6 8函数中使用yield关键字生成生成器1234567891011121314151617181920def test(): return 10def test2(): yield 10if __name__ == '__main__': m = test() print("m:", m) n = test2() print("n", n) value = next(n) print(value) out： m: 10 n &lt;generator object test2 at 0x000002A2C4C6D0F8&gt; 10生成器生成斐波那契数列123456789101112131415161718192021222324252627282930313233def fibnacci(n): # 初始化a, b的值 a = 1 b = 1 # 纪录迭代位置 current_index = 0 print("-----1------") while current_index &lt; n: # 保存a的值 data = a a, b = b, a+b current_index += 1 print("-----2------") yield data print("-----3------")if __name__ == '__main__': fib = fibnacci(6) print(next(fib)) print(next(fib)) print(next(fib)) out: -----1------ -----2------ 1 -----3------ -----2------ 1 -----3------ -----2------ 2yield作用充当return作用保存程序的运行状态并且暂停程序执行当next的时候，可以继续唤醒程序从yield位置继续向下执行生成器中使用return问题生成器客户以使用return关键字，语法上没有问题，但是如果执行到return语句以后，生成器会停止迭代，抛出停止迭代的异常send作用生成器.send(传递给生成器的值)传递1a = fib.send(1)接收1xxx = yield data协程协程，又称微线程，纤程。英文名Coroutine。从技术的角度来说，“协程就是你可以暂停执行的函数”。如果你把它理解成“就像生成器一样”，那么你就想对了。线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作则是程序员。协程存在的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程（单线程），在一个线程中规定某个代码块执行顺序。协程应用场景协程的适用场景：当程序中存在大量不需要CPU的操作时（IO），适用于协程；通俗的理解：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定协程和线程差异不开辟新的线程的基础上，实现多个任务在实现多任务时，线程切换从系统层面远不止保存和恢复CPU上下文这么简单。操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。1234567891011121314151617181920212223242526# ------------------ 携程的原始实现 --------------------import timedef work1(): while True: print("work1正在工作....") yield time.sleep(0.5)def work2(): while True: print("work2正在工作.............") yield time.sleep(0.5)if __name__ == '__main__': t1 =work1() t2 = work2() print(t1) while True: next(t1) next(t2)greenlet库greenlet 可以实现协程Greenlet是python的一个C扩展，来源于Stackless python，旨在提供可自行调度的“微线程’，即协程。generator实现的协程在yield value时只能将value返回给调用者（caller）。而在greenlet中，target.switch（value）可以切换到指定的协程（target），然后yield value。greenlet用switch来表示协程的切换，从一个协程切换到另一个协程需要显式指定。GNI GREENLE T为了更好使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变的更加简单1234567891011121314151617181920212223242526272829import timefrom greenlet import greenlet# work1生成器def work1(): while True: print("work1正在工作....") time.sleep(2) # 切换到第二个任务 g2.switch()# work1生成器def work2(): while True: print("work2正在工作.............") time.sleep(2) # 切换到第一个任务 g1.switch()if __name__ == '__main__': g1 = greenlet(work1) g2 = greenlet(work2) #执行work1 g1.switch()gevent 库自动调度协程，自动识别程序中的耗时操作greenlet已经实现了协程，但是这个还的人工切换python还有一个比greenlet更强大的并且能够自动切换任务的第三方库 gevent其原理是当一个greenlet遇到IO（指的是input/ output 输入输出，比如网络、文件操作等）操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待使用步骤导入模块Iimport gevent指派任务g1= gevent.spawn（函数名，参数1，参数2，…）join（）让主线程等待协程执行完毕后再退出g1.join()打猴子补丁补丁给程序打补丁（猴子补丁）关于猴子补丁为啥叫猴子补丁，据说是这样子的：这个叫法起源于Zope框架，大家在修正Zope的Bug的时候经常在程序后面追加更新部分，这些被称作是“杂牌军补丁（guerilla patch）”，后来guerilla就渐渐的写成了gorlia（塑猩），再后来就写了monkey（猴子）：所以猴子补丁的叫法是这么莫名其妙的得来的。猴子补丁主要有以下几个用处：1.在运行时替换方法、属性等2.在不修改第三方代码的情况下增加原来不支持的功能3.在运行时为内存中的对象增加patch而不是在盏盘的源代码中增加12345678910111213141516171819202122232425262728293031# 打补丁from gevent import monkey# 破解所有monkey.patch_all()import timeimport geventdef work1(): while True: print(&quot;work1正在工作....&quot;) time.sleep(0.5)def work2(): while True: print(&quot;work2正在工作.............&quot;) # gevent.sleep(0.5) time.sleep(0.5)if __name__ == &apos;__main__&apos;: # 指派任务 g1 = gevent.spawn(work1) g2 = gevent.spawn(work2) # 让主线程等待协程执行完毕再运行 g1.join() g2.join()小福利1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# 妹子图爬虫多协程版# coding=utf-8from gevent import monkeymonkey.patch_all()import geventimport requestsfrom bs4 import BeautifulSoupimport osimport reall_url = 'http://www.mzitu.com'# http请求头Hostreferer = &#123; 'User-Agent': 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)', 'Referer': 'http://www.mzitu.com'&#125;Picreferer = &#123; 'User-Agent': 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)', 'Referer': 'http://i.meizitu.net'&#125;# 此请求头破解盗链start_html = requests.get(all_url, headers=Hostreferer)# 保存地址path = "E:\\mzitu\\"# 找寻最大页数soup = BeautifulSoup(start_html.text, "html.parser")page = soup.find_all('a', class_='page-numbers')max_page = page[-2].textsame_url = 'http://www.mzitu.com/all/'def download_img(pic_url): html = requests.get(pic_url, headers=Picreferer) file_name = pic_url.split(r'/')[-1].replace('"', "") print(file_name) f = open(file_name, 'wb') f.write(html.content) f.close()for n in range(1, int(max_page) + 1): ul = same_url + str(n) start_html = requests.get(ul, headers=Hostreferer) soup = BeautifulSoup(start_html.text, "html.parser") all_a = soup.find('div', class_='all').find_all('a', target='_blank') for a in all_a: # 提取文本 title = a.get_text() if title != '': print("准备扒取：" + title) # win不能创建带？的目录 if os.path.exists(path + title.strip().replace('?', '')): # print('目录已存在') flag = 1 else: os.makedirs(path + title.strip().replace('?', '')) flag = 0 os.chdir(path + title.strip().replace('?', '')) href = a['href'] html = requests.get(href, headers=Hostreferer) mess = BeautifulSoup(html.text, "html.parser") pic_max = mess.find_all('span') try: # 最大页数 pic_max = pic_max[9].text if flag == 1 and len(os.listdir(path + title.strip().replace('?', ''))) &gt;= int(pic_max): print('已经保存完毕，跳过') continue except Exception: pass pic_url = [] for num in range(1, int(pic_max) + 1): pic = href + '/' + str(num) html = requests.get(pic, headers=Hostreferer) mess = BeautifulSoup(html.text, "html.parser") pic_url.append(mess.find('img', alt=title)) # print("图片路径：", pic_url['src']) pic_url = re.findall(r"[a-zA-z]+://[^\s]*", str(pic_url)) print(pic_url) # 将列表编程迭代器 a = pic_url.__iter__() # 开启多个协程 Coroutine = [] for i in range(len(pic_url)): Coroutine.append(gevent.spawn(download_img(next(a)))) gevent.joinall(Coroutine) print('完成') print('第', n, '页完成')]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>协程知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的进程，线程和协程对比]]></title>
    <url>%2F2019%2F11%2F16%2F%E8%BF%9B%E7%A8%8B%2C%E7%BA%BF%E7%A8%8B%2C%E5%8D%8F%E7%A8%8B%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[概念进程​ 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。线程​ 线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。协程​ 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。三者关系应用场景多进程：密集CPU任务，需要充分使用多核CPU资源（服务器，太量的并行计算）的时候，用多进程。缺陷：多个进程之间通信成本高，切换开销大。多线程：密集I/O任务（网络I/O，磁盘以I/O，数据库I/O）使用多线程合适。缺陷：同一个时间切片只能运行一个线程，不能做到高并行，但是可以做到高并发。协程：当程中存在太量不需要CPU的操作时（IO），适用于协程；多线程请求返回是无序的，那个线程有数据返回就处理那个线程，而协程返回的数据是有序的。缺陷：单线程执行，处理密集CPU和本地磁盘IO的时候，性能较低。处理网络I/O性能还是比较高。]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>进程,线程,协程总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python类中的 私有变量 和 私有方法]]></title>
    <url>%2F2019%2F11%2F15%2Fpython%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Python中的类原文转自：https://blog.csdn.net/sxingming/article/details/52875125默认情况下，Python中的成员函数和成员变量都是公开的(public),在python中没有类似public,private等关键词来修饰成员函数和成员变量。在python中定义私有变量只需要在变量名或函数名前加上 __两个下划线，那么这个函数或变量就是私有的了。在内部，python使用一种 name mangling 技术，将 __membername替换成_classname__membername，也就是说，类的内部定义中,所有以双下划线开始的名字都被”翻译”成前面加上单下划线和类名的形式。例如：为了保证不能在class之外访问私有变量，Python会在类的内部自动的把我们定义的__spam私有变量的名字替换成为_classname__spam(注意，classname前面是一个下划线，spam前是两个下划线)，因此，用户在外部访问__spam的时候就会提示找不到相应的变量。python中的私有变量和私有方法仍然是可以访问的访问方法如下：私有变量:实例._类名__变量名私有方法:实例._类名__方法名()其实，Python并没有真正的私有化支持，但可用下划线得到伪私有。尽量避免定义以下划线开头的变量！（1）_xxx “单下划线 “ 开始的成员变量叫做保护变量，意思是只有类实例和子类实例能访问到这些变量，需通过类提供的接口进行访问；不能用’from module import *’导入（2）__xxx 类中的私有变量/方法名 （Python的函数也是对象，所以成员方法称为成员变量也行得通。）,“ 双下划线 “ 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。（3）__xxx__系统定义名字，前后均有一个“双下划线” 代表python里特殊方法专用的标识，如 __init__（）代表类的构造函数。下面我们看几个例子：123456789101112131415161718192021222324252627282930313233class A(object): def __init__(self): #翻译成 self._A__data=[] self.__data=[] def add(self,item): #翻译成 self._A__data.append(item) self.__data.append(item) def printData(self): #翻译成 self._A__data print(self.__data) a=A()a.add('hello')a.add('python')a.printData()#外界不能访问私有变量 AttributeError: 'A' object has no attribute '__data'#print a.__data #通过这种方式，在外面也能够访问“私有”变量；这一点在调试中是比较有用的！print a._A__data out: ['hello', 'python'] ['hello', 'python']12345678910111213141516171819202122232425262728293031323334353637383940# 获取实例的所有属性 print a.__dict__# 获取实例的所有属性和方法 print dir(a) class A(): def __init__(self): #私有变量，翻译成 self._A__name='python' self.__name='python' #私有方法,翻译成 def _A__say(self) def __say(self): #翻译成 self._A__name print(self.__name) a=A()#访问私有属性,报错!AttributeError: A instance has no attribute '__name'#print a.__name#查询出实例a的属性的集合print(a.__dict__)#这样，就可以访问私有变量了print(a._A__name)#调用私有方法，报错。AttributeError: A instance has no attribute '__say'#a.__say()#获取实例的所有属性和方法print(dir(a))#这样，就可以调用私有方法了a._A__say() out: &#123;'_A__name': 'python'&#125; python ['_A__name', '_A__say', '__doc__', '__init__', '__module__'] python从上面看来,python还是非常的灵活，它的oop没有做到真正的不能访问，只是一种约定让大家去遵守，比如大家都用self来代表类里的当前对象，其实，我们也可以用其它的，只是大家习惯了用self 。小漏洞：派生类和基类取相同的名字就可以使用基类的私有变量12345678910111213141516171819202122232425262728class A(): def __init__(self): self.__name='python' #翻译成self._A__name='python' class B(A): def func(self): #翻译成print self._B__name print(self.__name ) instance=B()#报错：AttributeError: B instance has no attribute '_B__name'#instance.func()print(instance.__dict__)print(instance._A__name)out: &#123;'_A__name': 'python'&#125; python1234567891011121314151617181920212223class A(): def __init__(self): #翻译成self._A__name='python' self.__name='python' class A(A): #派生类和基类取相同的名字就可以使用基类的私有变量。 def func(self): #翻译成print self._A__name print(self.__name) instance=A()instance.func()out: python]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>面向对象编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的进程概念]]></title>
    <url>%2F2019%2F11%2F14%2F%E5%A4%9A%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程进程概念进程（Process）是资源分配的最小单位，是线程的容器。程序是固定不变的，而进程会根据运行需要，让操作系统动态分配各种资源的CPU的时间片轮转，在不同的时间段切换执行不同的进程，但是切换进程是比较耗时的；就引来了轻量级进程，也就是所谓的线程，一个进程中包括多个线程（代码流，其实也就是进程中同时跑的多个方法体）程序：例xxx.py这是程序，是一个静态的进程：一个程序运行起来后，代码+用到的资源称之为进程，它是操作系统分配资源的基本单元。进程状态工作中，任务数往往大于cpu的核数，即一定有一些任务正在执行，而另外一些任务在等待cpu进行执行，因此导致了有了不同的状态进程状态就绪态：运行的条件都已经满足，正在等在cpu执行执行态：cpu正在执行其功能等待态：等待某些条件满足，例如一个程序sleep了，此时就处于等待态进程的创建 - multiprocessingmultiprocessing模块就是跨平台版本的多进程模块，提供了一个Process类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情。·创建子进程跟创建线程十分类似，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start0方法后动Process语法结构如下：Process([group [，target[，name，[args[，kwargs]]]）target：如果传递了函数的引用，这个子进程就执行这里（函数）的代码args：给target指定的函数传递的参数，以元组的方式传递kwargs：给target指定的函数传递命名参数name：给进程设定一个名字，可以不设定group：指定进程组，大多数情况下用不到Process创建的实例对象的常用方法：start()：后动子进程实例（创建子进程）is_alive：判断进程子进程是否还在活着join([timeout]）：是否等待子进程执行结束，或等待多少秒oterminate：不管任务是否完成，立即终止子进程Process创建的实例对象的常用属性：name：当前进程的别名，默认为Process-N，N为从1开始递增的整数pid：当前进程的pid（进程号）linux系统可使用kill命令结束进程123456789101112131415161718192021222324252627282930313233343536373839404142import multiprocessingimport osimport timedef work1(): for i in range(10): # 获取进程的父id print("正在运行work1 第&#123;&#125;次..进程id&#123;&#125;，父进程id&#123;&#125;".format(i, os.getpid(), os.getppid())) time.sleep(2)if __name__ == '__main__': # 获取主进程名称 print("主进程名称", multiprocessing.current_process()) # 获取进程的编号 # 1.获取进程id multiprocessing.current_process().pid print("主进程编号", multiprocessing.current_process().pid) # 2. 模块os # print(os.getpid()) process_obj = multiprocessing.Process(target=work1, name="进程一") process_obj.start() print("XXXX") out: 主进程名称 &lt;_MainProcess(MainProcess, started)&gt; 主进程编号 31776 XXXX 正在运行work1 第0次..进程id43088，父进程id31776 正在运行work1 第1次..进程id43088，父进程id31776 正在运行work1 第2次..进程id43088，父进程id31776 正在运行work1 第3次..进程id43088，父进程id31776 正在运行work1 第4次..进程id43088，父进程id31776 正在运行work1 第5次..进程id43088，父进程id31776 正在运行work1 第6次..进程id43088，父进程id31776 正在运行work1 第7次..进程id43088，父进程id31776 正在运行work1 第8次..进程id43088，父进程id31776 正在运行work1 第9次..进程id43088，父进程id31776进程参数，全局变量进程间不能共享全局变量子进程在运行时候，会将主进程的内容复制到自己进程中，修改只限自己进程有效。不影响其他进程和主进程12345678910111213141516171819202122232425262728293031import multiprocessing# 定义全局变量import timeg_num = 10def work1(): global g_num for i in range(10): g_num += 1 print("work1---------", g_num)def work2(): print("work1---------", g_num)if __name__ == '__main__': p1 = multiprocessing.Process(target=work1) p2 = multiprocessing.Process(target=work2) p1.start() p2.start() time.sleep(3) print("---------main-----------", g_num)out: work1--------- 20 work1--------- 10 ---------main----------- 10守护进程p1.daemon=True设置子进程p1守护主进程，当主进程结束的时候，子进程也随之结束p1.terminate（）终止进程执行，并非是守护进程123456789101112131415161718192021222324252627import multiprocessingimport timedef work1(): for i in range(10): print("正在运行work1...&#123;&#125;".format(time.ctime())) time.sleep(0.5)if __name__ == '__main__': process_obj = multiprocessing.Process(target=work1) # 开启守护 # process_obj.daemon = True process_obj.start() print("我睡两秒就结束", time.ctime()) time.sleep(2) # 终止进程 process_obj.terminate() exit()out: 我睡两秒就结束 Thu Nov 14 16:04:29 2019 正在运行work1...Thu Nov 14 16:04:29 2019 正在运行work1...Thu Nov 14 16:04:30 2019 正在运行work1...Thu Nov 14 16:04:30 2019 正在运行work1...Thu Nov 14 16:04:31 2019进程线程对比功能进程，能够完成多任务，比如在一台电脑上能够同时运行多个QQ线程，能够完成多任务，比如一个QQ中的多个聊天窗口使用区别进程是系统进行资源分配和调度的一个独立单位。线程是进程的一介实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.一个程序至少有一个进程，一个进程至少有一个线程.线程的划分尺度小于进程（资源比进程少），使得多线程程序的并发性高。进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率线程不能独立运行，必须依赖于线程对比维度多进程多线程总结数据共享，同步数据共享复杂，需要用IPC；数据是分开因为共享进程数据，数据共享简单因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂各有千秋内存、CPU占用内存多，切换复杂，CPU利用率低占用内存少，切换简单，PU利用率高CPU线程占优创建销毁、切换创建销毁、切换复杂，速度慢创建销毁、切换简单，速度很快线程占优编程，调试编程简单，调试简单编程复杂，调试复杂进程占优可靠性进程间不会互相影响一个线程挂掉将导致整个进程挂掉进程占优分布式适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单应用于多核分布式进程占优进程线程取舍需要频繁创建销毁的先使用线程；（如：Web服务器）线程的切换速度快，所以在需要大量计算，切换频繁时用线程（如图像处理、算法处理）因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。都满足需求的情况下，用你最熟悉、最拿手的方式需要提醒的是：虽然有这么多的选择原则，但实际应用中基本上都是“进程+线程”的结合方式在Python的原始解释器CPython中存在着GlL（Global Interpreter Lock，全局解释器锁），因此在解释执行python代码时，会产生互斥锁来限制线程对共享资源的访问，直到解释器遇到I/O操作或者操作次数达到一定数目时才会释放GlL。造成了即使在多核CPU中，多线程也只是做着分时切换而已消息队列可以使用multiprocessing模块的Queue实现多进程之间的数据传递Queue本身是一个消息列队程序1234567891011121314151617181920212223242526272829303132333435363738import multiprocessing# 创建队列(指定长度)queue = multiprocessing.Queue(5)# 向队列中放值queue.put("Luenci")queue.put(1)queue.put([5, 2])queue.put((9, 8, 7))queue.put(&#123;"a": 6, "b": 8&#125;)# 判断队列是否全满isfull = queue.full()print("队列为全满：", isfull)# 长度为5，放入第6个数据后，队列就进行入了阻塞状态，默认会等待以列先取出值再放入新的值# queue.put(22)# 不等待的放入# queue.put_nowait(11)# 向队列中取值# 当队列为空的时候，再取值的时候，程序会进行阻塞状态，等待队列中有值再取value = queue.get()print(value)# 当队列为空的时候，再取值的时候，程序会直接报错# value = queue.get_nowait()# 队列元素个数num = queue.qsize()print(num)# 判断队列是否为空empty = queue.empty()print("队列为空？：", empty)进程池进程池概述当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务。进程池实现方式同步方式：pool.apply()异步方式pool.apply_async（copy_work）核心方法multiprocessing.Pool常用函数解析：apply（）：–进程池中进程以同步方式执行任务apply_async（func[，args[，kwds]]）：–使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表进程池中的进程通信12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import multiprocessingimport timedef write_queue(queue): for i in range(10): if queue.full(): print("队列已满") break else: queue.put(i) print("成功添加：", i) time.sleep(0.5)def read_queue(queue): while True: if queue.qsize() == 0: print("队列已空") break value = queue.get() print("已经读取", value)if __name__ == '__main__': # 创建进程池 pool = multiprocessing.Pool(3) # 创建进程池中的队列 queue = multiprocessing.Manager().Queue(10) # 同步的方式执行 # pool.apply(write_queue, args=(queue,)) # pool.apply(read_queue, args=(queue,)) # 异步的方式执行 # apply_async（）返回值ApplyResult对象，该对象有一个wait（）的方法 result = pool.apply_async(write_queue, args=(queue,)) result.wait() pool.apply_async(read_queue, args=(queue,)) # 不再接收新的任务 pool.close() pool.join()out: 成功添加： 0 成功添加： 1 成功添加： 2 成功添加： 3 成功添加： 4 成功添加： 5 成功添加： 6 成功添加： 7 成功添加： 8 成功添加： 9 已经读取 0 已经读取 1 已经读取 2 已经读取 3 已经读取 4 已经读取 5 已经读取 6 已经读取 7 已经读取 8 已经读取 9 队列已空]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>进程概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python多线程，并发和锁]]></title>
    <url>%2F2019%2F11%2F13%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多任务同一个时间有多个任务在执行python程序默认是单任务线程线程概念线程，可简单理解为是程序执行的一条分支，也是程序执行流的最小单元。线程是被系统独立调度和分底的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程为其它线程共享进程所拥有的全部资源。主线程当一个程序后动时，就有一个进程被操作系统（OS）创建，与此同时一个线程也立刻运行，该线程通常叫做程序的主线程，简而言之；程序后动就会创建一个主线程。Copy主线程的重要性有两方面：1）是产生其他子线程的线程；2）通常它必须最后完成执行比如执行各种关闭动作·子线程可以看做是程序执行的一条分支，当子线程后动后会和主线程一起同时执行主线程会等待所以子线程结束之后再结束123456789101112131415161718192021222324252627282930313233343536import threadingfrom time import *def loop0(): print('start loop0 at:', ctime()) sleep(4) print('loop0 done at:', ctime())def loop1(): print('start loop1 at:', ctime()) print('loop1 done at:', ctime())def main(): print('starting at :', ctime()) # 使用threading.Thread创建对象（子进程对象） # threading.Thread（target=函数名） thread_1 = threading.Thread(target=loop0) thread_2 = threading.Thread(target=loop1) thread_1.start() thread_2.start() print('all done at:', ctime())if __name__ == '__main__': main() out： starting at : Wed Nov 13 14:21:27 2019 start loop0 at: Wed Nov 13 14:21:27 2019 start loop1 at: Wed Nov 13 14:21:27 2019 loop1 done at: Wed Nov 13 14:21:27 2019 all done at: Wed Nov 13 14:21:27 2019 loop0 done at: Wed Nov 13 14:21:31 2019线程数量目标能够如何查看正在活动的线程数量1.查看线程数量threading.enumerate（）获取当前所有活跃的线程对象列表。使用len()对列表求长度可以看到当前活跃的线程的个数12345678910111213141516171819202122232425262728293031323334353637383940import threadingfrom time import *def loop0(): print('&#123;&#125;start loop0 at&#123;&#125;:'.format(threading.current_thread(), ctime())) sleep(4) print('loop0 done at:', ctime())def loop1(): print('&#123;&#125;start loop1 at&#123;&#125;:'.format(threading.current_thread(), ctime())) print('loop1 done at:', ctime())def main(): print('starting at :', ctime()) # 使用threading.Thread创建对象（子进程对象） # threading.Thread（target=函数名） thread_1 = threading.Thread(target=loop0) thread_2 = threading.Thread(target=loop1) thread_1.start() thread_2.start() print('all done at:', ctime())if __name__ == '__main__': main() thread_list = threading.enumerate() print("当前线程数量：%d" % len(thread_list))out: starting at : Wed Nov 13 14:41:20 2019 &lt;Thread(Thread-1, started 9916)&gt;start loop0 atWed Nov 13 14:41:20 2019: &lt;Thread(Thread-2, started 2868)&gt;start loop1 atWed Nov 13 14:41:20 2019: loop1 done at: Wed Nov 13 14:41:20 2019 all done at: Wed Nov 13 14:41:20 2019 当前线程数量：2 loop0 done at: Wed Nov 13 14:41:24 2019线程参数及顺序线程中传递参数有三种方法1.使用元组传递threading.Thread(target=fun_name,args=(参数。。。))thread_1 = threading.Thread(target=loop0, args=(10, 21, 22))2.使用字典传递 threading.Thread(target=fun_name,kwargs={&quot;参数名&quot;: &quot;参数值&quot;....})thread_1 = threading.Thread(target=loop0, kwargs={&quot;a&quot;: 10, &quot;b&quot;: 21, &quot;c&quot;: 22})3.混合使用元组和字典传递 threading.Thread(target=fun_name,args=(10, 21, 22), kwargs={&quot;参数名&quot;: &quot;参数值&quot;....})thread_1 = threading.Thread(target=loop0, args=(10, 21), kwargs={&quot;c&quot;: 22})123456789101112131415161718192021222324252627282930313233343536373839404142434445import threadingfrom time import *def loop0(a, b, c): print("参数：", a, b, c) print("start loop0 at:", ctime()) sleep(4) print("loop0 done at:", ctime())def loop1(): print("start loop1 at:", ctime()) print("loop1 done at:", ctime())def main(): print("starting at :", ctime()) # 线程中传递参数有三种方法 # 1.使用元组传递 threading.Thread(target=fun_name,args=(参数。。。)) # thread_1 = threading.Thread(target=loop0, args=(10, 21, 22)) # 2.使用字典传递 threading.Thread(target=fun_name,kwargs=&#123;"参数名": "参数值"....&#125;) # thread_1 = threading.Thread(target=loop0, kwargs=&#123;"a": 10, "b": 21, "c": 22&#125;) # 3.混合使用元组和字典传递 threading.Thread(target=fun_name,args=(10, 21, 22), kwargs=&#123;"参数名": "参数值"....&#125;) thread_1 = threading.Thread(target=loop0, args=(10, 21), kwargs=&#123;"c": 22&#125;) thread_2 = threading.Thread(target=loop1) thread_1.start() thread_2.start() print("all done at:", ctime())if __name__ == "__main__": main()out: starting at : Wed Nov 13 15:00:00 2019 参数： 10 21 22 start loop0 at: Wed Nov 13 15:00:00 2019 start loop1 at: Wed Nov 13 15:00:00 2019 loop1 done at: Wed Nov 13 15:00:00 2019 all done at: Wed Nov 13 15:00:00 2019 loop0 done at: Wed Nov 13 15:00:04 2019守护线程守护线程：如果在程序中将子线程设置为守护线程，则该子线程会在主线程结束时自动退出，设置方式为threaj.setDaemon（True），要在thread.start0之前设置，默认是false的，也就是主线程结束时，子线程依然在执行。对于python应用我们都知道main方法是入口，它的运行代表着主线程开始工作了，我们都知道Python虚拟机里面有垃圾回收器的存在使得我们放心让main运行，然而这背后是垃圾回收线程作为守护着主线程的守护线程。1234567891011121314151617181920212223242526272829import threadingimport timedef work1(): for i in range(10): print("正在执行work1...", i) time.sleep(0.5)if __name__ == '__main__': # 创建子线程 thread_woek1 = threading.Thread(target=work1) # 将子线程设置为守护线程 thread_woek1.setDaemon(True) thread_woek1.start() # 睡眠 time.sleep(2) print("game over") # 让程序退出，主线程主动结束 exit() out: 正在执行work1... 0 正在执行work1... 1 正在执行work1... 2 正在执行work1... 3 game over并行和并发多任务的原理剖析操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒…….这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。并发：指的是任务数多于cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一超执行而已）真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。并发：任务数量大于CPU的核心数并行：指的是任务数小于等于cpu核数，即任务真的是一起执行的并行：任务数量小于或等于CPU的核心数多线程——共享全局变量当多个线程修改同一个资源的时候，会出现资源竞争，导致计算结果有误调用join方法优先让某个线程先执行缺点：将多线程变成了单线程，影响执行效率12345678910111213141516171819202122232425262728293031323334import threadingimport timeg_num = 0def work1(): # 声明g_num是一个全局变量 global g_num for i in range(10000000): g_num += 1 print("work1-----------------", g_num)def work2(): global g_num for i in range(10000000): g_num += 1 print("work2-----------------", g_num)if __name__ == '__main__': work_1 = threading.Thread(target=work1) work_2 = threading.Thread(target=work2) work_1.start() # 优先让t1线程先执行， t1执行完毕后，t2才能执行 work_1.join() work_2.start() while len(threading.enumerate()) != 1: time.sleep(1) print("main-----------", g_num)同步和异步同步：多任务，多个任务之间执行的时候要求有先后顺序，必须一个先执行完成之后，另一个才能继续执行，只有一个主线。如：你说完，我再说（同一时间只能做一件事情）异步，指的是：多个任务之间执行没有先后顺序，可以同时运行，执行的先后顺序不会有什么影响，存在的多条运行主线。如：发微信（可以不用等对方回复，继续发）、点外卖（点了外卖后，可以继续忙其他的事情，而不是坐等外卖，啥也不做）线程锁互斥锁当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制线程同步能够保证多个线程安全访问竞争源，最简单的同步机制是引入互斥锁。互斥锁为资源引入一个状态：锁定/非锁定某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import threadingimport timeg_num = 0def work1(): # 声明g_num是一个全局变量 global g_num for i in range(10000000): # 上锁 lock1.acquire() g_num += 1 # 释放锁 lock1.release() print("work1-----------------", g_num)def work2(): global g_num for i in range(10000000): # 上锁 lock1.acquire() g_num += 1 # 解锁 lock1.release() print("work2-----------------", g_num)if __name__ == '__main__': print(time.ctime()) # 创建一把互斥锁 lock1 = threading.Lock() work_1 = threading.Thread(target=work1) work_2 = threading.Thread(target=work2) work_1.start() work_2.start() while len(threading.enumerate()) != 1: time.sleep(1) print("main-----------", g_num) print("总时间:", time.ctime())死锁在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。注意：使用完毕及时释放1234567891011121314151617181920212223import threadingdef get_value(index): data_list = [1, 3, 5, 7, 9] lock1.acquire() if index &gt;= len(data_list): print("下标越界", index) # 若不释放就产生死锁 lock1.release() return print(data_list[index]) lock1.release()if __name__ == '__main__': # 创建一把锁 lock1 = threading.Lock() for i in range(10): t1 = threading.Thread(target=get_value, args=(i, )) t1.start()]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>线程概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket网络编程实战-斗鱼弹幕获取]]></title>
    <url>%2F2019%2F10%2F31%2F%E6%96%97%E9%B1%BC%E5%BC%B9%E5%B9%95%E6%8A%93%E5%8F%96%2F</url>
    <content type="text"><![CDATA[asyncore模块介绍这个模块为异步socket的服务器客户端通信提供简单的接口。该模块提供了异步socket服务客户端和服务器的基础架构。相比python原生的socket api，asyncore具备有很大的优势，asyncore对原生的socket进行封装，提供非常简洁优秀的接口，利用asyncore覆写相关需要处理的接口方法，就可以完成一个socket的网络编程，从而需要处理复杂的socket网络状况以及多线程处理等等。实现流程客户端 Socket 开发基本使用1.定义类继承自asyncore.dispatcher2.实现类中的回调代码实现构造函数调用父类方法创建 Socket对象连接服务器实现handle_connect回调函数当socket连接服务器成功时回调该函数实现writable回调函数描述是否有数据需要被发送到服务器。返回值为True表示可写，False表示不可写，如果不实现默认返回为True，当返回True时，回调函数handle_write将被触发实现handle_write 回调函数当有数据需要发送时（writable回调函数返回True时），该函数被触发，通常情况下在该函数中编写send方法发送数据实现readable回调函数描述是否有数据从服务端读取。返回True 表示有数据需要读取，False表示没有数据需要被读取，当不实现默认返回为True，当返回True 时，回调函数handle_read将被触发实现handle_read回调函数当有数据需要读取时触发（readable回调函数返回True时），该函数被触发，通常情况下在该函数中编写recv方法接收数据实现handle_error回调函数当程序运行过程发生异常时回调实现handle_close回调函数当连接被关闭时触发3.创建对象并且执行asyncore.loop进入运行循环timeout表示一次循环所需要的时长12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import asyncoreimport sys# 定义类继承自 asyncore.dispatherclass scoket_client(asyncore.dispatcher): # 实现类中的回调代码 def __init__(self, host, port): # 调用父类的方法 asyncore.dispatcher.__init__(self) # 创建 Scoket 服务器 self.create_socket() # 连接地址 address = (host, port) self.connect(address) pass # 实现handle_connect回调函数 def handle_connect(self): print("连接成功") # 实现writable函数 def writable(self): return False # 实现handle_write回调函数 def handle_write(self): # 内部实现对服务器发送数据代码 # 调用 send 方法发送数据，参数是字节数据 self.send("hello world".encode('utf-8')) # self.send("hello world") # 实现readable回调函数 def readable(self): return True # 实现handle_read回调函数 def handle_read(self): # 主动接收数据 result = self.recv(1024) print(result) # 实现handle_error回调函数 def handle_error(self): # 编写处理错误方法 t, e, trace = sys.exc_info() # 实现handle_close回调函数 def handle_close(self): print("连接关闭") self.close()# 创建对象并且执行asyncore.loop 进入循环if __name__ == '__main__': client = scoket_client('127.0.0.1', 9000) # 开始启动运行循环 asyncore.loop(timeout=5)斗鱼弹幕实战文档资料斗鱼弹幕服务器第三方接入协议V1.6.2.pdf 官方提供协议文档弹幕客户端开发流程连接初始化使用TCP连接服务器IP地址：openbarrage.douyutv.com端口：8601客户端向弹幕服务器发送登录请弧，登录弹幕服务器弹幕服务器收到客户端登录请求并完成登录后，返回登录成功消息给客户端客户端收到登录成功消息后发送进入弹幕分组请求给弹幕服务器弹幕服务器接受到客户端弹幕分组请求后将客户端添加到请求指定的弹幕分组中服务过程客户端每隔45秒发送心跳给弹幕服务器，弹幕服务器回复心跳信息给客户端弹幕服务器如有广播信息，则推送给客户端，服务器消息协议断开连接客户端发送登出消息客户端关闭TCP连接数据发送和接收流程数据包讲解消息长度：4 字节小端整数，表示整条消息（包括自身）长度（字节数）消息长度出现两遍，二者相同消息类型：2 字节小端整数，表示消息类型。取值如下：689 客户端发送给弹幕服务器的文本格式数据690 弹幕服务器发送给客户端的文本格式数据。加密字段：暂时未用，默认为 0。保留字段：暂时未用，默认为 0。数据部分：斗鱼独创序列化文本数据，结尾必须为‘\0’。详细序列化、反序列化算法见下节。（所有协议内容均为 UTF-8 编码）数据包的封装对数据包进行对象化封装，对数据的封装方便以后使用，实现对象和二进制数据之间的转换通过参数构建数据包对象实现获取数据包长度的方法实现获取二进制数据的方法实现发送数据包构建发送数据包的容器实现回调函数，判断容器中有数据就发送没有数据不发送实现登录函数构建登录数据包把数据包添加到发送数据包容器中实现接收数据构建接收数据包队列读取回调函数中读取数据读取长度读取内容构建数据包对象把数据包放入接收数据包容器中构建处理数据包线程构建线程实现回调函数处理数据实现外部传入回调函散通过外部指定回调函数实现自定义数据处理添加参数callback构造函数中添加参数外部传入自定义回调函数在处理接收数据包的线程中调用回调函数数据内容序列话与反序列化1 键 key 和值 value 直接采用‘@=’分割2 数组采用‘/’分割3 如果 key 或者 value 中含有字符‘/’，则使用‘@S’转义4 如果 key 或者 value 中含有字符‘@’ ，使用‘@A’转义举例：多个键值对数据：key1@=value1/key2@=value2/key3@=value3/数组数据：value1/value2/value3/不同消息有相同的协议头、序列化方式加入弹幕分组​ 第三方平台建议选择-9999（即海量弹幕模式 )心跳机制作用是让服务器解决假死连接问题，客户端必须每隔45秒发送一次请求，否则就会被主动断开。实现发送心跳函数构建心跳数据包把数据包添加到发送数据包容器队列中构建心跳线程构建心跳线程添加触发机制添加暂停机制]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令集合]]></title>
    <url>%2F2019%2F10%2F28%2Fgit%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git config配置 Git 的相关参数。Git 一共有3个配置文件：仓库级的配置文件：在仓库的 .git/.gitconfig，该配置文件只对所在的仓库有效。全局配置文件：Mac 系统在 ~/.gitconfig，Windows 系统在 C:\Users\&lt;用户名&gt;\.gitconfig。系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 /usr/local/git）的 etc 文件夹中的 gitconfig。123456789101112131415161718192021222324252627282930313233343536373839404142# 查看配置信息# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; -l# 查看当前生效的配置信息$ git config -l# 编辑配置文件# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; -e# 添加配置项# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; --add &lt;name&gt; &lt;value&gt;# 获取配置项$ git config &lt;--local | --global | --system&gt; --get &lt;name&gt;# 删除配置项$ git config &lt;--local | --global | --system&gt; --unset &lt;name&gt;# 配置提交记录中的用户信息$ git config --global user.name &lt;用户名&gt;$ git config --global user.email &lt;邮箱地址&gt;# 更改Git缓存区的大小# 如果提交的内容较大，默认缓存较小，提交会失败# 缓存大小单位：B，例如：524288000（500MB）$ git config --global http.postBuffer &lt;缓存大小&gt;# 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态$ git config --global color.ui true# 配置可以缓存密码，默认缓存时间15分钟$ git config --global credential.helper cache# 配置密码的缓存时间# 缓存时间单位：秒$ git config --global credential.helper 'cache --timeout=&lt;缓存时间&gt;'# 配置长期存储密码$ git config --global credential.helper storegit clone从远程仓库克隆一个版本库到本地。12345678# 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下$ git clone &lt;远程仓库的网址&gt;# 指定本地仓库的目录$ git clone &lt;远程仓库的网址&gt; &lt;本地目录&gt;# -b 指定要克隆的分支，默认是master分支$ git clone &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt;git init初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。12# 初始化本地仓库，在当前目录下生成 .git 文件夹$ git initgit status查看本地仓库的状态。1234567# 查看本地仓库的状态$ git status# 以简短模式查看本地仓库的状态# 会显示两列，第一列是文件的状态，第二列是对应的文件# 文件状态：A 新增，M 修改，D 删除，?? 未添加到Git中$ git status -sgit remote操作远程库。123456789101112131415161718# 列出已经存在的远程仓库$ git remote# 列出远程仓库的详细信息，在别名后面列出URL地址$ git remote -v$ git remote --verbose# 添加远程仓库$ git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的URL地址&gt;# 修改远程仓库的别名$ git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;# 删除指定名称的远程仓库$ git remote remove &lt;远程仓库的别名&gt;# 修改远程仓库的 URL 地址$ git remote set-url &lt;远程仓库的别名&gt; &lt;新的远程仓库URL地址&gt;git branch操作 Git 的分支命令。1234567891011121314151617181920# 列出本地的所有分支，当前所在分支以 "*" 标出$ git branch# 列出本地的所有分支并显示最后一次提交，当前所在分支以 "*" 标出$ git branch -v# 创建新分支，新的分支基于上一次提交建立$ git branch &lt;分支名&gt;# 修改分支名称# 如果不指定原分支名称则为当前所在分支$ git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;# 强制修改分支名称$ git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;# 删除指定的本地分支$ git branch -d &lt;分支名称&gt;# 强制删除指定的本地分支$ git branch -D &lt;分支名称&gt;git checkout检出命令，用于创建、切换分支等。123456789101112# 切换到已存在的指定分支$ git checkout &lt;分支名称&gt;# 创建并切换到指定的分支，保留所有的提交记录# 等同于 "git branch" 和 "git checkout" 两个命令合并$ git checkout -b &lt;分支名称&gt;# 创建并切换到指定的分支，删除所有的提交记录$ git checkout --orphan &lt;分支名称&gt;# 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响$ git checkout &lt;文件路径&gt;git cherry-pick把已经提交的记录合并到当前分支。12# 把已经提交的记录合并到当前分支$ git cherry-pick &lt;commit ID&gt;git add把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交。1234567891011121314# 把指定的文件添加到暂存区中$ git add &lt;文件路径&gt;# 添加所有修改、已删除的文件到暂存区中$ git add -u [&lt;文件路径&gt;]$ git add --update [&lt;文件路径&gt;]# 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录$ git add -A [&lt;文件路径&gt;]$ git add --all [&lt;文件路径&gt;]# 查看所有修改、已删除但没有提交的文件，进入一个子命令系统$ git add -i [&lt;文件路径&gt;]$ git add --interactive [&lt;文件路径&gt;]git commit将暂存区中的文件提交到本地仓库中。123456789101112# 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息$ git commit# 把暂存区中的文件提交到本地仓库中并添加描述信息$ git commit -m "&lt;提交的描述信息&gt;"# 把所有修改、已删除的文件提交到本地仓库中# 不包括未被版本库跟踪的文件，等同于先调用了 "git add -u"$ git commit -a -m "&lt;提交的描述信息&gt;"# 修改上次提交的描述信息$ git commit --amendgit fetch从远程仓库获取最新的版本到本地的 tmp 分支上。12345# 将远程仓库所有分支的最新版本全部取回到本地$ git fetch &lt;远程仓库的别名&gt;# 将远程仓库指定分支的最新版本取回到本地$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;git merge合并分支。12# 把指定的分支合并到当前所在的分支下$ git merge &lt;分支名称&gt;git diff比较版本之间的差异。123456789101112131415161718# 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改$ git diff# 比较暂存区中的文件和上次提交时的差异$ git diff --cached$ git diff --staged# 比较当前文件和上次提交时的差异$ git diff HEAD# 查看从指定的版本之后改动的内容$ git diff &lt;commit ID&gt;# 比较两个分支之间的差异$ git diff &lt;分支名称&gt; &lt;分支名称&gt;# 查看两个分支分开后各自的改动内容$ git diff &lt;分支名称&gt;...&lt;分支名称&gt;git pull从远程仓库获取最新版本并合并到本地。首先会执行 git fetch，然后执行 git merge，把获取的分支的 HEAD 合并到当前分支。12# 从远程仓库获取最新版本。$ git pullgit push把本地仓库的提交推送到远程仓库。123456# 把本地仓库的分支推送到远程仓库的指定分支$ git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;# 删除指定的远程仓库的分支$ git push &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;$ git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt;git log显示提交的记录。12345678# 打印所有的提交记录$ git log# 打印从第一次提交到指定的提交的记录$ git log &lt;commit ID&gt;# 打印指定数量的最新提交的记录$ git log -&lt;指定的数量&gt;git reset还原提交记录。12345678910111213141516# 重置暂存区，但文件不受影响# 相当于将用 "git add" 命令更新到暂存区的内容撤出暂存区，可以指定文件# 没有指定 commit ID 则默认为当前 HEAD$ git reset [&lt;文件路径&gt;]$ git reset --mixed [&lt;文件路径&gt;]# 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改$ git reset &lt;commit ID&gt;$ git reset --mixed &lt;commit ID&gt;# 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改# 相当于调用 "git reset --mixed" 命令后又做了一次 "git add"$ git reset --soft &lt;commit ID&gt;# 将 HEAD 的指向改变，撤销到指定的提交记录，文件也修改了$ git reset --hard &lt;commit ID&gt;git revert生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。12# 生成一个新的提交来撤销某次提交$ git revert &lt;commit ID&gt;git tag操作标签的命令。1234567891011121314151617181920212223# 打印所有的标签$ git tag# 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录$ git tag &lt;标签名称&gt; [&lt;commit ID&gt;]# 添加带有描述信息的附注标签，可以指定之前的提交记录$ git tag -a &lt;标签名称&gt; -m &lt;标签描述信息&gt; [&lt;commit ID&gt;]# 切换到指定的标签$ git checkout &lt;标签名称&gt;# 查看标签的信息$ git show &lt;标签名称&gt;# 删除指定的标签$ git tag -d &lt;标签名称&gt;# 将指定的标签提交到远程仓库$ git push &lt;远程仓库的别名&gt; &lt;标签名称&gt;# 将本地所有的标签全部提交到远程仓库$ git push &lt;远程仓库的别名&gt; –tagsgit mv重命名文件或者文件夹。12# 重命名指定的文件或者文件夹$ git mv &lt;源文件/文件夹&gt; &lt;目标文件/文件夹&gt;git rm删除文件或者文件夹。12345678# 移除跟踪指定的文件，并从本地仓库的文件夹中删除$ git rm &lt;文件路径&gt;# 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除$ git rm -r &lt;文件夹路径&gt;# 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件$ git rm --cachedGit操作场景示例1. 删除掉本地不存在的远程分支多人合作开发时，如果远程的分支被其他开发删除掉，在本地执行 git branch --all 依然会显示该远程分支，可使用下列的命令进行删除：123456# 使用 pull 命令，添加 -p 参数$ git pull -p# 等同于下面的命令$ git fetch -p$ git fetch --prune origin来源：https://www.jianshu.com/p/93318220cdce]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Python语言的IP代理池]]></title>
    <url>%2F2019%2F10%2F27%2FIP%E4%BB%A3%E7%90%86%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[环境：python3.6MongoDBflaskrequests等第三方库完整代码见： https://github.com/Lucareful/IPProxyPool代理池概述什么是代理池代理池就是有代理IP组成的池子，它可以提供多个稳定可用的代理IP为什么要实现代理池我们在做爬虫的时候，最常见的一种反爬虫手段就是：IP反爬；也就是当同一个IP访问这个网站的次数过多，频率过高，就会限制这个IP的访问。就是需要经常换IP；使用IP代理池是其中一个比较常用的方案免费代理都是非常不稳定的，有10%是可用就很不错了一些收费代理稳定性也不好目的：从一堆不稳定的代理IP中，抽取高可用代理IP，给爬虫使用代理池开发环境python3开发语言requests：发送请求，获取页面数据lxml：使用XPATH从页面提取我们想要的书籍pymonge：把提取到代理IP存储到MongoDB数据库中和MongoDB数据库中读取代理IP，给爬虫使用Flask：用于提供WEB服务代理池工作流程1.代理池工作渡程描述：代理IP采集模块-&gt;采集代理IP-&gt;检测代理IP-&gt;如果不可用用，直接过滤掉，如果可用，指定默认分数-&gt;存入数据库中代理IP检测模块-&gt;从数据库中获取所有代理IP-&gt;检测代理IP-&gt;如果代理IP不可用用，就把分数-1，如果分数为0从数据库中删除，否则更新数据库，如果代理IP可用，恢复为默认分值，更新数据库代理API模块-&gt;从数据库中高可用的代理IP给爬虫使用；代理池的模块及其作用五大核心模块爬虫模块从代理IP网站上采集代理IP进行校验（获取代理响应速度，协议类型，匿名类型）把可用代理IP存储到数据库中代理IP的校验模块：获取指定代理的响应速度，支持的协议以及匿名程度原因：网站上所标注的响应速度，协议类型和匿名类型是不准确的这里使用httpbin.org进行检测数据库模块：实现对代理IP的增删改查操作这里使用MongoDB来存储代理IP检测模块：定时的对代理池中代理进行检测，保证代理池中代理的可用性.从数据库读取所有的代理IP对代理IP进行逐一检测，可用开启多个协程，以提高检测速度如果该代理不可用，就让这个代理分数-1，当代理的分数到0了，就删除该代理；如果检测到代理可用就恢复为满分.代理IP服务接口：提供高可用的代理IP给爬虫使用根据协议类型和域名获取随机一个高质量代理IP根据协议类型和域名获取多个高质量代理IP根据代理IP不可用域名，告诉代理池这个代理IP在该域名下不可用，下次获取这个域名的代理IP时候，就不会再获取这个代理IP了，从而保证代理IP高可用性.代理池的其它模块数据模型：domain.py代理IP的数据模型，用于封装代理IP相关信息，比如ip，端口号，响应速度，协议类型，匿名类型，分数等程序启动入口：main.py·代理池提供一个统一的启动入口工具模块：、日志模块：用于记录日志信息http模块：用于获取随机User-Agent的请求头配置文件：settings.py用于默认代理的分数，配置日志格式，文件，启动的爬虫，检验的间隔时间等.代理池的项目结构12345678910111213141516171819202122--IPProxyPoo1 --core --db --__init__.py --mongo_pool.py --proxy_validate --__init__.py --httpbin_validator.py --proxy_spider --__init__.py --base_spider.py --proxy_kpiders.py --run_spiders.py --proxy_test.py --proxy_api.py --domain.py --utils --__init__.py --http.py --log.py --main.py --settings.py定义代理IP的数据模型类定义Proxy类，继承object实现_init_方法，负责初始化，包含如下字段：ip：代理的IP地址port：代理IP的端口号protocol：代理IP支持的协议类型，http是0，https是1，https和http都支持是2nick_type：代理IP的匿名程度，高匿：0，匿名：1，透明：2speed：代理IP的响应速度，单位sarea：代理IP所在地区score：代理IP的评分，用于衡量代理的可用性；默认分值可以通过配置文件进行配置.在进行代理可用性检查的时候，每遇到一次请求失败就减1份，减到0的时候从池中删除.如果检查代理可用，就恢复默认分值disable_domains：不可用域名列表，有些代理IP在某些域名下不可用，但是在其他域名下可用在配置文件：settings.py中定义MAX_SCORE=50，表示代理IP的默认最高分数提供_str方法，返回数据字符串代理池的工具模块日志模块http模块日志模块能够方便的对程序进行调试能够方便记录程序的运行状态能够方便记录错误信息日志的实现目标：实现日志模块，用于记录日志把日志相关配置信息放到配置文件中修改日志代码，使用配置文件中的配置信息Http模块我在从代理IP网站上抓取代理IP和检验代理IP时候，为了不容易不服务器识别为是一个爬虫，我们最好提供随机的User-Agent请求头.目标：获取随机User-Agent的请求头步骤：1.准备User-Agent的列表2.实现一个方法，获取随机User-Agent的请求头代理池的检验模块目标：检查代理IP速度，匿名程度以及支持的协议类型.步骤：检查代理IP速度和匿名程度；代理IP速度：就是从发送请求到获取响应的时间间隔匿名程度检查：对http://httpbin.org/get 或https://httpbin.org/get 发送请求如果响应的origin中有 ，分割的两个IP就是透明代理IP如果响应的headers 中包含Proxy-Connection 说明是匿名代理IP否则就是高匿代理IP。检查代理IP协议类型如果http://httpbin.org/get 发送请求可以成功，说明支持http协议如果https://httpbin.org/get 发送请求可以成功，说明支持https协议代理池的数据库模块作用：用于对proxies集合进行数据库的相关操作目标：实现对数据库增删改查相关操作、步骤：1.在init中，建立数据连接，获取要操作的集合，在del方法中关闭数据库连接2.提供基础的增删改查功能实现插入功能实现修改该功能实现删除代理：根据代理的IP删除代理查询所有代理IP的功能3.提供代理API模块使用的功能实现查询功能：根据条件进行查询，可以指定查询数量，先分数降序，速度升序排，保证优质的代理IP在上面.实现根据协议类型和要访问网站的域名，获取代理IP列表实现根据协议类型和要访问完整的域名，随机获取一个代理IP实现把指定域名添加到指定IP的disable_domain列表中.实现代理池的爬虫模块爬虫模块的需求需求：抓取各个代理IP网站上的免费代理IP进行检测，如果可用存储到数据库中需要抓取代理IP的页面如下：西刺代理：https://www.xicidaili.com/nn/1ip3366代理：http://www.ip3366.net/free/?stype=1&amp;page=1快代理：https://www.kuaidaili.com/free/inha/1/oproxylistplus代理:https://list.proxylistplus.com/Fresh-HTTP-Proxy-List-166ip代理：http://www.66ip.cn/1.html爬虫模块的设计通用爬虫：通过指定URL列表，分组XPATH和组内XPATH，来提取不同网站的代理IP原因代理IP网站的页面结构几乎都是Table，页面结构类似具体爬虫：用于抓取具体代理IP网站通过继承通用爬虫实现具体网站的抓取，一般只需要指定爬取的URL列表，分组的XPATH和组内XPATH就可以了.如果该网站有特殊反爬手段，可以通过重写某些方法实现反爬爬虫运行模块：启动爬虫，抓取代理IP进行检测，如果可用，就存储到数据库中；通过配置文件来控制启动哪些爬虫，增加扩展性；如果将来我们遇到返回json格式的代理网站，单独写一个爬虫配置下就好了.实现通用爬虫目标：实现可以指定不同URL列表，分组的XPATH和详情的XPATH，从不同页面上提取代理的IP端口号和区域的通用爬虫；步骤：1.在base_spider.py文件中，定义一个BaseSpider类，继承object2.提供三个类成员变量：urls：代理IP网址的URL的列表group_xpath：分组XPATH，获取包含代理IP信息标签列表的XPATHdetail_xpath：组内XPATH，获取代理IP详情的信息XPATH，格式为：{“ip’:’xx’，’port’：’xx’，‘area’：’xx’}3.提供初始方法，传入爬虫URL列表，分组XPATH，详情（组内）XPATH4.对外提供一个获取代理IP的方法遍历URL列表，获取URL根据发送请求，获取页面数据解析页面，提取数据，封装为Proxy对象返回Proxy对象列表实现具体爬虫目标：通过继承通用爬虫，实现多个具体爬虫，分别从各个免费代理IP网站上抓取代理IP1.实现西刺代理爬虫：http://www.xicidaili.com/nn/1定义一个类，继承通用爬虫类（BasicSpider）提供urls，group_xpath 和detail_xpath2.实现ip3366代理爬虫：http://www.ip3366.net/free/？stype=1&amp;page=1定义一个类，继承通用爬虫类（BasicSpider）提供urls，group_xpath 和detail_xpath3.实现快代理爬虫：https://www.kuaidaili.com/free/inha/1/定义一个类，继承通用爬虫类（BasicSpider）提供urls，group_xpath和detail_xpath4.实现 proxylistplus代理爬虫：https://list.proxylistplus.com/Fresh-HTTP-Proxy-List-1定义一个类，继承通用爬虫类（BasicSpider）提供urls，group_xpath 和detail_xpath5.实现66ip爬虫：http://www.66ip.cn/1.html定义一个类，继承通用爬虫类（BasicSpider）提供urls，group_xpath和detail_xpath由于66ip网页进行js+cookie反爬，需要重写父类的get_page_from_url 方法PS：实现66ip爬虫：http://www.66ip.cn/1.html核心：通过加密的js，生成需要cookie信息1.从响应页面中，提取：​ 1.执行生成真正js语句​ 2.生成真正js的函数.2.网页中，是通过eval执行真正js，加载页面；而我们要获取真正的js；我们就需要把eval语句，替换为return，把真正js返回.3.使用js2py，获取执行js的环境，使用js执行环境加载这个函数4.使用这个执行环境，执行调用调用，生成真正js，赋值给一个变量5.从真正的js代码中，提取我们需要cookie信息.实现爬虫的运行模块目标：根据配置文件信息，加载爬虫，抓取代理IP，进行校验，如果可用，写入到数据库中思路：在run_spider.py中，创建RunSpider类提供一个运行爬虫的run方法，作为运行爬虫的入口，实现核心的处理逻辑根据配置文件信息，获取爬虫对象列表.遍历爬虫对象列表，获取爬虫对象，遍历爬虫对象的get_proxies方法，获取代理IP检测代理IP（代理IP检测模块）如果可用，写入数据库（数据库模块）处理异常，防止一个爬虫内部出错了，影响其他的爬虫.使用异步来执行每一个爬虫任务，以提高抓取代理IP效率在init 方法中创建协程池对象把处理一个代理爬虫的代码抽到一个方法使用异步执行这个方法调用协程的join方法，让当前线程等待队列任务的完成.使用schedule模块，实现每隔一定的时间，执行一次爬取任务定义一个start的类方法创建当前类的对象，调用run方法使用schedule模块，每隔一定的时间，执行当前对象的run方法实现代理池的检测模块目的：检查代理IP可用性，保证代理池中代理IP基本可用思路1.在proxy_test.py中，创建Proxy Tester类2.提供一个run 方法，用于处理检测代理命核心逻辑从数据库中获取所有代理IP遍历代理IP列表检查代理可用性如果代理不可用，让代理分数-1，如果代理分数等于0就从数据库中删除该代理，否则更新该代理IP如果代理可用，就恢复该代理的分数，更新到数据库中3.为了提高检查的速度，使用异步来执行检测任务在init方法中，创建队列和协程池把要检测的代理IP，放到队列中i.把检查一个代理可用性的代码，抽取到一个方法中；从队列中获取代理IP，进行检查；检查完毕，调度队列的task_done方法ii.通过异步回调，使用死循环不断执行这个方法，iv.开启多个一个异步任务，来处理代理IP的检测；可以通过配置文件指定异步数量调用队列的join方法，让当前线程等待队列任务完成4.使用schedule模块，每隔一定的时间，执行一次检测任务定义类方法start，用于启动检测模块在start方法中i.创建本类对象i.调用run方法i.每间隔一定时间，执行一下，run方法实现代理池的API模块目标：为爬虫提供高可用代理IP的服务接口步骤：实现根据协议类型和域名，提供随机的获取高可用代理IP的服务实现根据协议类型和域名，提供获取多个高可用代理IP的服务实现给指定的IP上追加不可用域名的服务实现在proxy_api.py中，创建ProxyApi类实现初始方法s初始一个Flask的Web服务实现根据协议类型和域名，提供随机的获取高可用代理IP的服务可用通过protocol和domain参数对IP进行过滤protocol：当前请求的协议类型domain：当前请求域名实现根据协议类型和域名，提供获取多个高可用代理IP的服务·可用通过protocol和domain参数对IP进行过滤实现给指定的IP上追加不可用域名的服务如果在获取IP的时候，有指定域名参数，将不在获取该IP从而进一步提高代理IP的可用性.实现run方法，用于启动Flask的WEB服务实现start的类方法，用于通过类名，启动服务实现代理池的程序入口目标：把启动爬虫，启动检测代理IP，启动WEB服务统一到一起思路：开启三个进程，分别用于启动爬虫，检测代理IP，WEB服务步骤：定义一个run方法用于启动动代理池定义一个列表，用于存储要启动的进程创建启动爬虫的进程，添加到列表中创建启动检测的进程，添加到列表中创建启动提供API服务的进程，添加到列表中遍历进程列表，启动所有进程遍历进程列表，让主进程等待子进程的完成在if__name__==&#39;__main__&#39;：中调用run方法]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>爬虫实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言笔记（3）]]></title>
    <url>%2F2019%2F10%2F22%2Fc%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[结构体结构体声明1234567struct Book&#123; 结构体成员1; 结构体成员2; 结构体成员3; ......&#125;;定义结构体类型变量struct 结构体名称 结构体变量名访问结构体变量要访问结构体成员，我们需要引入一个新的运算符——点号(.)运算符。比如book.title就是引用book结构体的title成员，它是一个字符数组。初始结构体的指定成员值其语法和数组指定初始化元素类似，不过结构体指定初始化成员使用点号（.）运算符和成员名123456789101112131415161718192021222324252627282930313233343536//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;struct Book&#123; char title[128]; char author[40]; float price; unsigned int data; char publisher[40];&#125;book;int main(void)&#123;// struct Book book1; printf("请输入书名："); scanf("%s", book.title); printf("请输入作者："); scanf("%s", book.author); printf("请输入售价："); scanf("%f", &amp;book.price); printf("请输入出版日期："); scanf("%d", &amp;book.data); printf("请输入出版社："); scanf("%s", book.publisher); printf("\n====数据录入完毕====\n\n"); printf("书名：%s\n", book.title); printf("作者：%s\n", book.author); printf("售价：%.2f\n", book.price); printf("出版日期：%d\n", book.data); printf("出版社：%s\n", book.publisher); return 0;&#125;结构体嵌套123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;struct Data&#123; int year; int month; int day;&#125;;struct Book&#123; char title[128]; char author[40]; float price; struct Data data; char publisher[40];&#125;book = &#123; // 初始化 "c学习", "Luenci", 48.8, &#123;2019,11,13&#125;, "文华出版社"&#125;;int main(void)&#123; printf("\n====数据录入为====\n\n"); printf("书名：%s\n", book.title); printf("作者：%s\n", book.author); printf("售价：%.2f\n", book.price); printf("出版日期：%d%d%d\n", book.data.year, book.data.month, book.data.day); printf("出版社：%s\n", book.publisher); return 0;&#125;out书名：c学习作者：Luenci售价：48.80出版日期：20191113出版社：文华出版社结构体数组第二种方法是先声明一个结构体类型（如上例子中Book），再用此类型定义一个结构体数组：12345678910111213struct 结构体名称&#123; 结构体成员;&#125;;struct 结构体名称 数组名[长度];// 初始化结构体数组struct Book book[3] = &#123; &#123;"《零基础学c》", "Luenci", 49.5, &#123;2016, 11, 22&#125;, "清华大学出版社"&#125;， &#123;"《零基础学c》", "Luenci", 49.5, &#123;2016, 11, 22&#125;, "清华大学出版社"&#125;， &#123;"《零基础学c》", "Luenci", 49.5, &#123;2016, 11, 22&#125;, "清华大学出版社"&#125;， &#125;；结构体指针12struct Book *ptr；ptr = &amp;book；通过结构体指针访问结构体成员(*结构体指针).成员名结构体指针-&gt;成员名1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;struct Data&#123; int year; int month; int day;&#125;;struct Book&#123; char title[128]; char author[40]; float price; struct Data data; char publisher[40];&#125;book = &#123; // 初始化 "c学习", "Luenci", 48.8, &#123;2019,11,13&#125;, "文华出版社"&#125;;int main(void)&#123; struct Book *ptr; ptr = &amp;book; printf("\n====数据录入为====\n\n"); printf("书名：%s\n", (*ptr).title); printf("作者：%s\n", (*ptr).author); printf("售价：%.2f\n", (*ptr).price); printf("出版日期：%d%d%d\n", (*ptr).data.year, (*ptr).data.month, (*ptr).data.day); printf("出版社：%s\n", (*ptr).publisher); printf("书名：%s\n", ptr-&gt;title); printf("作者：%s\n", ptr-&gt;author); printf("售价：%.2f\n", ptr-&gt;price); printf("出版日期：%d%d%d\n", ptr-&gt;data.year, ptr-&gt;data.month, ptr-&gt;data.day); printf("出版社：%s\n", ptr-&gt;publisher); return 0;&#125;out:====数据录入为====书名：c学习作者：Luenci售价：48.80出版日期：20191113出版社：文华出版社链表单链表12345graph LRhead --&gt; AA[信息域- 指针] --&gt; B[信息域- 指针]B[信息域- 指针] --&gt; c[信息域- 指针]c[信息域- 指针] --&gt; NULL头插法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// ------------ 头插法实现链表的插入 ---------------//// Created by Luenci on 2019/10/14.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Book&#123; char title[128]; char author[40]; struct Book *next;&#125;;void getInput(struct Book *book)&#123; printf("请输入书名："); scanf("%s", book-&gt;title); printf("请输入作者："); scanf("%s", book-&gt;author);&#125;void add_book(struct Book **library)&#123; struct Book *book, *temp; book = (struct Book *)malloc(sizeof(struct Book)); if(book == NULL)&#123; printf("分配内存失败"); exit(1); &#125; getInput(book); if (*library != NULL)&#123; temp = *library; *library = book; book-&gt;next = temp; &#125; else&#123; *library = book; book-&gt;next = NULL; &#125;&#125;void printLibrary(struct Book *library)&#123; struct Book *book; int count = 1; book = library; while(book != NULL)&#123; printf("Book%d: ", count); printf("书名：%s", book-&gt;title); printf("作者:%s", book-&gt;author); book = book-&gt;next; count++; &#125;&#125;void releaseLibrary(struct Book *library)&#123; while(library != NULL)&#123; library = library-&gt;next; free(library); &#125;&#125;int main(void)&#123; struct Book *library = NULL; int ch; while (1)&#123; printf("请问你是否需要录入书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; add_book(&amp;library); &#125; else&#123; break; &#125; &#125; printf("请问你是否需要打印书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; printLibrary(library); &#125; releaseLibrary(library); return 0;&#125;尾插法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//// Created by Luenci on 2019/10/14.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Book&#123; char title[128]; char author[40]; struct Book *next;&#125;;void getInput(struct Book *book)&#123; printf("请输入书名："); scanf("%s", book-&gt;title); printf("请输入作者："); scanf("%s", book-&gt;author);&#125;void add_book2(struct Book **library)&#123; /* ------------ 尾插法 ------------- */ struct Book *book,*temp; book = (struct Book *)malloc(sizeof(struct Book)); if(book == NULL)&#123; printf("分配内存失败"); exit(1); &#125; getInput(book); if (*library != NULL)&#123; temp = *library; // 定位单链表的尾部位置 while (temp-&gt;next != NULL)&#123; temp = temp-&gt;next; &#125; // 插入数据 temp-&gt;next = book; book-&gt;next = NULL; &#125; else&#123; *library = book; book-&gt;next = NULL; &#125;&#125;void printLibrary(struct Book *library)&#123; struct Book *book; int count = 1; book = library; while(book != NULL)&#123; printf("Book%d: ", count); printf("书名：%s", book-&gt;title); printf("作者:%s", book-&gt;author); book = book-&gt;next; count++; &#125;&#125;void releaseLibrary(struct Book **library)&#123; struct Book *temp; while(library != NULL)&#123; temp = *library; *library = (*library)-&gt;next; free(temp); &#125;&#125;int main(void)&#123; struct Book *library = NULL; int ch; while (1)&#123; printf("请问你是否需要录入书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; add_book2(&amp;library); &#125; else&#123; break; &#125; &#125; printf("请问你是否需要打印书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; printLibrary(library); &#125; releaseLibrary(&amp;library); return 0;&#125;尾插法改进123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178//// Created by Luenci on 2019/10/14.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct Book&#123; char title[128]; char author[40]; struct Book *next;&#125;;void getInput(struct Book *book);void add_book(struct Book **library);void getInput(struct Book *book);void add_book2(struct Book **library);void printLibrary(struct Book *library);struct Book *searchBook(struct Book *library, char *target);void releaseLibrary(struct Book **library);void printBook(struct Book *book);void getInput(struct Book *book)&#123; printf("请输入书名："); scanf("%s", book-&gt;title); printf("请输入作者："); scanf("%s", book-&gt;author);&#125;void add_book(struct Book **library)&#123; /* ----------- 头插法 ------------- */ struct Book *book, *temp; book = (struct Book *)malloc(sizeof(struct Book)); if(book == NULL)&#123; printf("分配内存失败"); exit(1); &#125; getInput(book); if (*library != NULL)&#123; temp = *library; *library = book; book-&gt;next = temp; &#125; else&#123; *library = book; book-&gt;next = NULL; &#125;&#125;void add_book2(struct Book **library)&#123; /* ------------ 尾插法 ------------- */ struct Book *book; static struct Book *tail; book = (struct Book *)malloc(sizeof(struct Book)); if(book == NULL)&#123; printf("分配内存失败"); exit(1); &#125; getInput(book); if (*library != NULL)&#123; tail-&gt;next = book; book-&gt;next = NULL; &#125; else&#123; *library = book; book-&gt;next = NULL; &#125; tail = book;&#125;void printLibrary(struct Book *library)&#123; struct Book *book; int count = 1; book = library; while(book != NULL)&#123; printf("Book%d: ", count); printf("书名：%s", book-&gt;title); printf("作者:%s", book-&gt;author); book = book-&gt;next; count++; &#125;&#125;void releaseLibrary(struct Book **library)&#123; struct Book *temp; while(library != NULL)&#123; temp = *library; *library = (*library)-&gt;next; free(temp); &#125;&#125;struct Book *searchBook(struct Book *library, char *target)&#123; struct Book *book; book = library; while (book != NULL)&#123; // C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false if (!strcmp(book-&gt;title, target) || !strcmp(book-&gt;author, target))&#123; break; &#125; book = book-&gt;next; &#125; return book;&#125;void printBook(struct Book *book)&#123; printf("书名: %s\n", book-&gt;title); printf("作者: %s\n", book-&gt;author);&#125;int main(void)&#123; struct Book *library = NULL; struct Book *book; char *input[128]; int ch; while (1)&#123; printf("请问你是否需要录入书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; add_book2(&amp;library); &#125; else&#123; break; &#125; &#125; printf("请问你是否需要打印书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; printLibrary(library); &#125; printf("\n请输入书名或作者："); scanf("%s", input); book = searchBook(library, input); if(book == NULL)&#123; printf("很抱歉没能找到！\n"); &#125; else&#123; do&#123; printf("已找到符合条件的书籍...\n"); printBook(book); &#125; while ((book = searchBook(book-&gt;next, input)) != NULL); &#125; releaseLibrary(&amp;library); return 0;&#125;链表的插入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//// Created by Luenci on 2019/10/16.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Node&#123; int value; struct Node *next;&#125;;void insertNode(struct Node **head, int value);void printNode(struct Node *head);void insertNode(struct Node **head, int value)&#123; struct Node *previous; struct Node *current; struct Node *new; current = *head; previous = NULL; while (current != NULL &amp;&amp; current-&gt;value &lt; value)&#123; previous = current; current = current-&gt;next; &#125; new = (struct Node *)malloc(sizeof(struct Node)); if (new == NULL)&#123; printf("分配内存失败！\n"); exit(1); &#125; new-&gt;value = value; new-&gt;next = current; if (previous == NULL)&#123; *head = new; &#125; else&#123; previous-&gt;next = new; &#125;&#125;void printNode(struct Node *head)&#123; struct Node *current; current = head; while (current != NULL)&#123; printf("%d ", current-&gt;value); current = current-&gt;next; &#125; putchar('\n');&#125;int main()&#123; struct Node *head = NULL; int input; while (1)&#123; printf("请输入一个整数（-1结束）："); scanf("%d", &amp;input); if(input == -1)&#123; break; &#125; insertNode(&amp;head, input); printNode(head); &#125; return 0;&#125;链表的删除123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//// Created by Luenci on 2019/10/16.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Node&#123; int value; struct Node *next;&#125;;void insertNode(struct Node **head, int value);void printNode(struct Node *head);void delectNode(struct Node **head, int value);void insertNode(struct Node **head, int value)&#123; struct Node *previous; struct Node *current; struct Node *new; current = *head; previous = NULL; while (current != NULL &amp;&amp; current-&gt;value &lt; value)&#123; previous = current; current = current-&gt;next; &#125; new = (struct Node *)malloc(sizeof(struct Node)); if (new == NULL)&#123; printf("分配内存失败！\n"); exit(1); &#125; new-&gt;value = value; new-&gt;next = current; if (previous == NULL)&#123; *head = new; &#125; else&#123; previous-&gt;next = new; &#125;&#125;void delectNode(struct Node **head, int value)&#123; struct Node *previous; struct Node *current; current = *head; previous = NULL; while (current != NULL &amp;&amp; current-&gt;value != value)&#123; previous = current; current = current-&gt;next; &#125; if (current == NULL)&#123; printf("找不到匹配的节点"); return; &#125; else&#123; if(previous == NULL)&#123; *head = current-&gt;next; &#125; else&#123; previous-&gt;next = current-&gt;next; &#125; free(current); &#125;&#125;void printNode(struct Node *head)&#123; struct Node *current; current = head; while (current != NULL)&#123; printf("%d ", current-&gt;value); current = current-&gt;next; &#125; putchar('\n');&#125;int main()&#123; struct Node *head = NULL; int input; printf("开始测试插入整数...\n"); while (1)&#123; printf("请输入一个整数（-1结束）："); scanf("%d", &amp;input); if(input == -1)&#123; break; &#125; insertNode(&amp;head, input); printNode(head); &#125; printf("开始测试删除整数...\n"); while (1)&#123; printf("请输入一个整数（-1结束）："); scanf("%d", &amp;input); if(input == -1)&#123; break; &#125; delectNode(&amp;head, input); printNode(head); &#125; return 0;&#125;内存池优点：设计内存池的目标是为了保证服务器长时间高效的运行，通过对申请空间小而申请频繁的对象进行有效管理，减少内存碎片的产生，合理分配管理用户内存，从而减少系统中出现有效空间足够，而无法分配大块连续内存的情况。结论：内存池基本上满足初期设计目标，但是她并不是完美的，有缺陷，比如,不能申请大于256字节的内存空间，无内存越界检查，无内存自动回缩功能等。只是这些对我们的影响还不是那么重要。typedef基础相比起宏定义的直接替换， typedef是对类型的封装。1234567891011121314151617181920//// Created by Luenci on 2019/10/16.//#include&lt;stdio.h&gt;typedef int integer;int main(void)&#123; integer a; int b; a = 1; b = a; printf("a = %u\n", a); printf("b = %d\n", b); printf("size of a = %d\n", sizeof(a)); return 0;&#125;123456789101112131415161718192021222324252627//// Created by Luenci on 2019/10/16.//#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Data&#123; int year; int mouth; int day;&#125; DATA, *PDATA;int main(void)&#123; struct Data *data; data = (PDATA)malloc(sizeof(DATA)); if (data == NULL)&#123; printf("内存分配失败！\n"); exit(1); &#125; data-&gt;year = 2019; data-&gt;mouth = 10; data-&gt;day = 16; printf("%d-%d-%d\n", data-&gt;year, data-&gt;mouth, data-&gt;day);&#125;进阶Typedef在变成中使用typedef目的一般有两个：一个是给变量起一个容易记住且意义明确的别名另一个是简化一些比较复杂的类型声明共用体共用体的所有成员共享同一个内存地址。123456union 共用体名称&#123; 共用成员1； 共用成员2； 共用成员3；&#125;;123456789101112131415161718192021222324252627282930313233343536373839//// Created by Luenci on 2019/10/19.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;union Test&#123; int i; double pi; char str[6];&#125;;int main(void)&#123; union Test test; test.i = 50; test.pi = 1.2; strcpy(test.str, "Luenci"); printf("addr of test.i:%p\n", &amp;test.i); printf("addr of test.pi:%p\n", &amp;test.pi); printf("addr of test.str:%p\n", &amp;test.str); printf("value of test.i:%d\n", test.i); printf("value of test.i:%.2f\n", test.pi); printf("value of test.i:%s\n", test.str); return 0;&#125;out：addr of test.i:0061FF18addr of test.pi:0061FF18addr of test.str:0061FF18value of test.i:1852142924value of test.i:0.00value of test.i:Luenci​枚举类型如果一个变量只有几种可能的值，那么就可以将其定义为枚举（enumeration）类型。12345// 声明enum 枚举类型名称 &#123;枚举值名称, 枚举值名称...&#125;// 定义enum 枚举类型名称 枚举变量1, 枚举变量;​123456789101112131415161718192021222324252627282930313233343536//// Created by Luenci on 2019/10/19.//#include &lt;stdio.h&gt;#include &lt;time.h&gt;int main(void)&#123; enum Week &#123;sun, mon, tue, wed, thu, fri, sat&#125;; enum Week today; struct tm *p; time_t t; time(&amp;t); p = localtime(&amp;t); today = p-&gt;tm_wday; switch (today)&#123; case mon: case tue: case wed: case thu: case fri: printf("学习！！！\n"); break; case sat: case sun: printf("放假！\n"); break; default: printf("Error!\n"); &#125; return 0;&#125;位域使用位域的做法是在结构体定义时，在结构体成员后面使用冒号（：）和数字来表示该成员所占的位数。无名位域位域成员可以没有名称，只要给出数据类型和位宽即可1234567struct Test&#123; unsigned int x:100; unsigned int y:200; unsigned int z:300; unsigned int :424;&#125;;单片机单片机（Microcontrollers）是一种集成电路芯片，是采用超大规模集成电路技术把具有数据处理能力的中央处理器CPU、随机存储器RAM、只读存储器ROM、多种I/0口和中新系统、定时器/计数器等功能（可能还包括显示驱动电路、脉宽调制电路、模拟多路转换器、A/D转换器等电路）集成到一块硅片上构成的一个小而完善的微型计算机条统，在工业控制领域广泛应用。位操作逻辑位运算符按位取反（~）逻辑位运算符中优先级最高的是按位取反运算符，它的运算符是一个~符号，作用是将1变成0，将0变成1：按位与（&amp;）优先级第二高的是按位与运算符，它的运算符是一个&amp;符号（而逻辑与是两个&amp;符号）按位异或（^）优先级排第三的是按位异或运算符，它的运算符是一个个符号，只有当两个操作数对应的二进制位不同时，它的结果才为1，否则为0：按位或（|）逻辑位运算符中优先级最低的是按位或运算符，它的运算符是一个|符号（而逻辑或是两个I符号）和赋值号结合这四个运算符，除了按位取反只有一个操作数之外，其它三个都可以跟赋值号（=）结合到一块，使得代码更加简洁！1234567891011121314151617181920212223242526//// Created by Luenci on 2019/10/19.//#include &lt;stdio.h&gt;int main(void)&#123; int mask = 0xFF; int v1 = 0xABCDEF; int v2 = 0xABCDEF; int v3 = 0xABCDEF; v1 &amp;= mask; v2 |= mask; v3 ^= mask; printf("v1 = 0x%x\n", v1); printf("v2 = 0x%x\n", v2); printf("v3 = 0x%x\n", v3); return 0;&#125;out:v1 = 0xefv2 = 0xabcdffv3 = 0xabcd10移位运算符A = 0011 1100左移位运算符二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。A &lt;&lt; 2 将得到 240，即为 1111 0000右移位运算符二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。A &gt;&gt; 2 将得到 15，即为 0000 1111一些未定义行为左移、右移运算符右边的操作数如果是为负数，或者右边的操作数火于左边操作数支持的最大宽度，那么表达式的结果均是属于“未定义行为”。左边的操作数是有符号还是无符号数其实也对移位运算符有着不同的影响。无等号数肯定没问题，因为这时候变量里边所有的位都用于表示该数值的大小。但如果是有符号数，那就要区别对待了，因为有符号数的左边第一位是符号位，所以如果恰好这个操作数是个负数，那么移动之后是否覆盖符号位的决定权还是落到了编译器上。文件操作文件概念计算机文件（或称文件、电脑档案、档亲），是存储在基种长期储存设备或临时存储设备中的一段数据流，并且归属于计算机文件系统管理之下。所谓“长期储存设备”一般指磁盘、光盘、磁带等。而“短期存储设备”一般指计算机内存。需要注意的是，存储于长期存储设备的文件不一定是长期存储的，有些也可能是程序或条统运行中产生的临时数据，并于程序或系统退出后删除。打开文件您可以使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：1FILE *fopen( const char * filename, const char * mode );在这里，filename 是字符串，用来命名文件，访问模式 mode 的值可以是下列值中的一个：模式描述r打开一个已有的文本文件，允许读取文件。w打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。a打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。r+打开一个文本文件，允许读写文件。w+打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。a+打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：1"rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b"关闭文件为了关闭文件，请使用 fclose( ) 函数。函数的原型如下：1int fclose( FILE *fp );如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量。C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。写入文件下面是把字符写入到流中的最简单的函数：1int fputc( int c, FILE *fp );函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：1int fputs( const char *s, FILE *fp );函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。您也可以使用 int fprintf(FILE *fp,const char *format, …) 函数来写把一个字符串写入到文件中。读写单个字符fgetc函数描述C 库函数 char *fgets(char *str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。声明下面是 fgets() 函数的声明。1char *fgets(char *str, int n, FILE *stream)参数str – 这是指向一个字符数组的指针，该数组存储了要读取的字符串。n – 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。返回值如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。如果发生错误，返回一个空指针。getc函数描述C 库函数 int getc(FILE *stream) 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。声明下面是 getc() 函数的声明。1int getc(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要在上面执行操作的流。返回值该函数以无符号 char 强制转换为 int 的形式返回读取的字符，如果到达文件末尾或发生读错误，则返回 EOF单个字符写入fputc函数描述C 库函数 int fputc(int char, FILE *stream) 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。声明下面是 fputc() 函数的声明。1int fputc(int char, FILE *stream)参数char – 这是要被写入的字符。该字符以其对应的 int 值进行传递。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符的流。返回值如果没有发生错误，则返回被写入的字符。如果发生错误，则返回 EOF，并设置错误标识符。puts函数描述C 库函数 int putc(int char, FILE *stream) 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。声明下面是 putc() 函数的声明。1int putc(int char, FILE *stream)参数char – 这是要被写入的字符。该字符以其对应的 int 值进行传递。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符的流。返回值该函数以无符号 char 强制转换为 int 的形式返回写入的字符，如果发生错误则返回 EOF。区别fgetc（fputc）函数和getc （putc）函数两个的功和描述基本上是一模一样的，它们的区别主要在于实现上：fgetc（fputc）是一个函数；而getc （putc）则是一个宏的实现一般来说宏产生较大的代码，但是避免了函数调用的堆栈操作，所以速度会比较快。由于getc是由宏实现的，对其参数可能有不止一次的调用，所以不能使用带有副作用（side effects）的参数。123456789101112131415161718192021222324252627282930//// Created by Luenci on 2019/10/20.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; FILE *fp1; FILE *fp2; int ch; if ((fp1 = fopen("D:\\c_study\\test.txt", "r")) == NULL)&#123; printf("打开文件失败！\n"); exit(EXIT_FAILURE); &#125; if ((fp2 = fopen("D:\\c_study\\demo2.txt", "w")) == NULL)&#123; printf("打开文件夹失败！\n"); exit(EXIT_FAILURE); &#125; while ((ch = fgetc((fp1))) != EOF)&#123; fputc(ch, fp2); &#125; fclose(fp1); fclose(fp2); return 0;&#125;读写整个字符串fgets函数描述C 库函数 char *fgets(char *str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。声明下面是 fgets() 函数的声明。1char *fgets(char *str, int n, FILE *stream)参数str – 这是指向一个字符数组的指针，该数组存储了要读取的字符串。n – 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。返回值如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。如果发生错误，返回一个空指针。fputs函数描述C 库函数 int fputs(const char *str, FILE *stream) 把字符串写入到指定的流 stream 中，但不包括空字符。声明下面是 fputs() 函数的声明。1int fputs(const char *str, FILE *stream)参数str – 这是一个数组，包含了要写入的以空字符终止的字符序列。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符串的流。返回值该函数返回一个非负值，如果发生错误则返回 EOF。feof()函数描述C 库函数 int feof(FILE *stream) 测试给定流 stream 的文件结束标识符。声明下面是 feof() 函数的声明。1int feof(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。返回值当设置了与流关联的文件结束标识符时，该函数返回一个非零值，否则返回零。123456789101112131415161718192021222324252627282930313233343536//// Created by Luenci on 2019/10/20.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX 1024int main(void)&#123; FILE *fp1; char buff[MAX]; if ((fp1 = fopen("D:\\c_study\\demo3.txt", "w")) == NULL)&#123; printf("打开文件失败！\n"); exit(EXIT_FAILURE); &#125; fputs("Luenci 的文件操作1 。\n", fp1); fputs("Luenci 的文件操作2 。\n", fp1); fclose(fp1); if ((fp1 = fopen("D:\\c_study\\demo3.txt", "r")) == NULL)&#123; printf("打开文件失败！\n"); exit(EXIT_FAILURE); &#125; while (!feof(fp1))&#123; fgets(buff, MAX, fp1); printf("%s", buff); &#125; fclose(fp1); return 0;&#125;格式化读写文件fprintf（）函数描述C 库函数 int fprintf(FILE *stream, const char *format, …) 发送格式化输出到流 stream 中。声明下面是 fprintf() 函数的声明。1int fprintf(FILE *stream, const char *format, ...)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。format – 这是 C 字符串，包含了要被写入到流 stream 中的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是1%[flags][width][.precision][length]specifier，具体讲解如下：specifier（说明符）输出c字符d 或 i有符号十进制整数e使用 e 字符的科学科学记数法（尾数和指数）E使用 E 字符的科学科学记数法（尾数和指数）f十进制浮点数g自动选择 %e 或 %f 中合适的表示法G自动选择 %E 或 %f 中合适的表示法o有符号八进制s字符的字符串u无符号十进制整数x无符号十六进制整数X无符号十六进制整数（大写字母）p指针地址n无输出%字符flags（标识）描述-在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。+强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。(space)如果没有写入任何符号，则在该值前面插入一个空格。#与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。 与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。0在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。width（宽度）描述(number)要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。*宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。.precision（精度）描述.number对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。 对于 g 和 G 说明符：要输出的最大有效位数。 对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 对于 c 类型：没有任何影响。 当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。.*精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。length（长度）描述h参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。l参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。L参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。附加参数 – 根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。返回值如果成功，则返回写入的字符总数，否则返回一个负数。fread()函数描述C 库函数 size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 从给定流 stream 读取数据到 ptr 所指向的数组中。声明下面是 fread() 函数的声明。1size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)参数ptr – 这是指向带有最小尺寸 size*nmemb 字节的内存块的指针。size – 这是要读取的每个元素的大小，以字节为单位。nmemb – 这是元素的个数，每个元素的大小为 size 字节。stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。返回值成功读取的元素总数会以 size_t 对象返回，size_t 对象是一个整型数据类型。如果总数与 nmemb 参数不同，则可能发生了一个错误或者到达了文件末尾。fwrite（）函数描述C 库函数 size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) 把 ptr 所指向的数组中的数据写入到给定流 stream 中。声明下面是 fwrite() 函数的声明。1size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)参数ptr – 这是指向要被写入的元素数组的指针。size – 这是要被写入的每个元素的大小，以字节为单位。nmemb – 这是元素的个数，每个元素的大小为 size 字节。stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。返回值如果成功，该函数返回一个 size_t 对象，表示元素的总数，该对象是一个整型数据类型。如果该数字与 nmemb 参数不同，则会显示一个错误。文件随机读写ftell（）函数描述C 库函数 long int ftell(FILE *stream) 返回给定流 stream 的当前文件位置。声明下面是 ftell() 函数的声明。1long int ftell(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。返回值该函数返回位置标识符的当前值。如果发生错误，则返回 -1L，全局变量 errno 被设置为一个正值。rewind() 函数描述C 库函数 void rewind(FILE *stream) 设置文件位置为给定流 stream 的文件的开头。声明下面是 rewind() 函数的声明。1void rewind(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。fseek() 函数描述C 库函数 int fseek(FILE *stream, long int offset, int whence) 设置流 stream 的文件位置为给定的偏移 offset，参数 offset 意味着从给定的 whence 位置查找的字节数。声明下面是 fseek() 函数的声明。1int fseek(FILE *stream, long int offset, int whence)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。offset – 这是相对 whence 的偏移量，以字节为单位。whence – 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一：常量描述SEEK_SET文件的开头SEEK_CUR文件指针的当前位置SEEK_END文件的末尾返回值如果成功，则该函数返回零，否则返回非零值。可移植性问题想要编写可移植的代码，就需要考虑以下问题：对于以二进制模式打开的文件，fseek函数在某些操作系统可能不支持SEEK_END位置。一对于以文本模式打开的文件，fseek函数的whence参数只能取SEEK_SET才是有意义的，并且传递给offset参数的值要么是0，要么是上一次对同个文件调用fte11函数获得的返回值。标准流和错误处理文件流标准输入（stdin）标准输入（stdout）标准错误输出（stderr）重定向由于标准输出和标准错误输出通常都是直接打印到屏幕上，为了区分宅们，我们可以使用Linux shell的重定向功能：重定向标准输入使用 &lt;重定向标准输出使用 〉重定向标准错误输出使用 2〉错误处理错误指示器 - ferror（）描述C 库函数 int ferror(FILE *stream) 测试给定流 stream 的错误标识符。声明下面是 ferror() 函数的声明。1int ferror(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。返回值如果设置了与流关联的错误标识符，该函数返回一个非零值，否则返回一个零值。使用clearerr函数可以人为地清除文件末尾指示器和错误指示器的状态。ferror函数只能检测是否出错，但无法获取错误原因。不过，大多数系统函数在出现错误的时候会将错误原因记录在errno中。perror函数可以直观地打印出错误原因。描述C 库函数 void perror(const char *str) 把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 str，后跟一个冒号，然后是一个空格。声明下面是 perror() 函数的声明。1void perror(const char *str)参数str – 这是 C 字符串，包含了一个自定义消息，将显示在原本的错误消息之前。返回值该函数不返回任何值strerror（）函数直接返回错误码对应的错误信息。描述C 库函数 char *strerror(int errnum) 从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。strerror 生成的错误字符串取决于开发平台和编译器。声明下面是 strerror() 函数的声明。1char *strerror(int errnum)参数errnum – 错误号，通常是 errno。返回值该函数返回一个指向错误字符串的指针，该错误字符串描述了错误 errnum。12345678910111213141516171819202122232425//// Created by Luenci on 2019/10/20.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;int main(void)&#123; FILE *fp; if(fp = fopen("bucunzai.txt", "r") == NULL)&#123; printf("出错啦，原因就是：%d\n", errno); fprintf(stderr, "出错啦，原因就是：%s", strerror(errno) ); perror("出错啦，原因就是：");// fputs("打开文件失败！\n", stderr); exit(EXIT_FAILURE); &#125; fclose(fp); return 0;&#125;I/O 缓冲区标准I/O提供的三种类型的缓冲模式按块执行按块缓存也称为全缓存，即在填满缓冲区后才进行实际的设备读写操作；按行执行按行缓存是指在接收到换行符（’\n’）之前，数据都是先缓存在缓冲区的；不缓存也就是允许你直接读写设备上的数据。setvbuf()函数描述C 库函数 int setvbuf(FILE *stream, char *buffer, int mode, size_t size) 定义流 stream 应如何缓冲。声明下面是 setvbuf() 函数的声明。1int setvbuf(FILE *stream, char *buffer, int mode, size_t size)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流。buffer – 这是分配给用户的缓冲。如果设置为 NULL，该函数会自动分配一个指定大小的缓冲。mode – 这指定了文件缓冲的模式：模式描述_IOFBF全缓冲：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充。_IOLBF行缓冲：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符。_IONBF无缓冲：不使用缓冲。每个 I/O 操作都被即时写入。buffer 和 size 参数被忽略。size –这是缓冲的大小，以字节为单位。返回值如果成功，则该函数返回 0，否则返回非零值。fflush（）函数描述C 库函数 int fflush(FILE *stream) 刷新流 stream 的输出缓冲区。声明下面是 fflush() 函数的声明。1int fflush(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个缓冲流。返回值如果成功，该函数返回零值。如果发生错误，则返回 EOF，且设置错误标识符（即 feof）]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C结构体打包技艺]]></title>
    <url>%2F2019%2F10%2F19%2FC%E8%AF%AD%E8%A8%80%E6%89%93%E5%8C%85%E6%8A%80%E8%89%BA%2F</url>
    <content type="text"><![CDATA[失传的 C 结构体打包技艺（转）转自： https://fishc.com.cn/forum.php?mod=viewthread&amp;tid=83418&amp;extra=page%3D2%26filter%3Dtypeid%26typeid%3D571作者：Eric S. Raymond原文链接：http://www.catb.org/esr/structure-packing谁应阅读本文如果你在内存容量受限的嵌入式系统中写程序，或者编写操作系统内核代码，就有必要了解这项技术。如果数据集巨大，应用时常逼近内存极限，这项技术会有所帮助。倘若你非常非常关心如何最大限度地减少处理器缓存段（cache-line）未命中情况的发生，这项技术也有所裨益。2013 年底，我大量应用了一项 C 语言优化技术，这项技术是我早在二十余年前就已掌握的，但彼时之后，鲜有使用。通过精心调整结构成体员的顺序，可以在这种情况下大幅减少内存占用。其效果显著——在上述案例中，可以减少 40% 的内存空间。程序应用于更大的软件仓库，也不会因内存耗尽而崩溃。事出有因。计算机科学课程（正确地）引导人们远离微观优化，转而寻求更理想的算法。计算成本一路走低，令压榨内存的必要性变得越来越低。旧日里，黑客们通过在陌生的硬件架构中跌跌撞撞学习 —— 如今已不多见。首先需要了解的是，对于现代处理器，C 编译器在内存中放置基本 C 数据类型的方式受到约束，以令内存的访问速度更快。用行话来说，x86 和 ARM 上的基本 C 类型是“自对齐（self-aligned）”的。关于指针，无论 32 位（4 字节）还是 64 位（8 字节）也都是自对齐的。我提到“现代处理器”，是因为有些老平台强迫 C 程序违反对齐规则（例如，为 int 指针分配一个奇怪的地址并试图使用它），不仅令速度减慢，还会导致非法指令错误。例如 Sun SPARC 芯片就有这种问题。事实上，如果你下定决心，并恰当地在处理器中设置标志位（e18），在 x86 平台上，也能引发这种错误。你还可以通过 pragma 指令（通常为 ）强迫编译器不采用处理器惯用的对齐规则。但请别随意运用这种方式，因为它强制生成开销更大、速度更慢的代码。通常，采用我在下文介绍的方式，可以节省相同或相近的内存。#pragma pack我们来看一个关于变量在内存中分布的简单案例。思考形式如下的一系列变量声明，它们处在一个 C 模块的顶层。然而实际情况（在 x86、ARM 或其他采用自对齐类型的平台上）如下。存储 p 需要自对齐的 4 或 8 字节空间，这取决于机器字的大小。这是指针对齐 —— 极其严格。1234561. char *p; /* 4 or 8 bytes */2. char c; /* 1 byte */3. char pad[3]; /* 3 bytes */4. int x; /* 4 bytes */字符数组 pad[3] 意味着在这个结构体中，有 3 个字节的空间被浪费掉了。老派术语将其称之为“废液（slop）”。1231. char *p;2. char c;3. short x;在这个例子中，实际分布将会是：1231. char *p;2. char c;3. long x;我们将得到：1231. char c;2. char *p;3. int x;假如实际内存分布可以写成下面这样：首先，在此例中，N 将为 0，x 的地址紧随 p 之后，能确保是与指针对齐的，因为指针的对齐要求总比 int 严格。不过更有可能的情况是，c 将被映射为机器字的首字节。于是乎 M 将会用于填充，以使 p 指针对齐——32 位系统中为 3 字节，64 位系统中为 7 字节。倘若你希望这些变量占用的空间更少，那么可以交换 x 与 c 的次序。在讲述这部分内容前，我们先对标量数组做个说明。在具有自对齐类型的平台上，char、short、int、long 和指针数组都没有内部填充，每个成员都与下一个成员自动对齐。通常情况下，结构体实例以其最宽的标量成员为基准进行对齐。编译器之所以如此，是因为此乃确保所有成员自对齐，实现快速访问最简便的方法。假如你对此有疑惑，ANSI C 提供了一个 宏，可用于读取结构体成员位移。123451. struct foo1 &#123;2. char *p;3. char c;4. long x;5. &#125;;假定处在 64 位系统中，任何 struct fool 的实例都采用8字节对齐。不出所料，其内存分布将会像下面这样：12345678910111. struct foo2 &#123;2. char c; /* 1 byte */3. char pad[7]; /* 7 bytes */4. char *p; /* 8 bytes */5. long x; /* 8 bytes */6. &#125;;如果成员是互不关联的变量，c便可能从任意位置起始，pad的大小则不再固定。因为struct foo2的指针需要与其最宽的成员为基准对齐，这变得不再可能。现在 c 需要指针对齐，接下来填充的7个字节被锁定了。结构体尾填充的通用法则是：编译器将会对结构体进行尾填充，直至它的跨步地址。这条法则决定了 sizeof() 的返回值。12345671. struct foo3 &#123;2. char *p; /* 8 bytes */3. char c; /* 1 byte */4. &#125;;5. 6. struct foo3 singleton;7. struct foo3 quad[4];复制代码你以为 的值是 9，但实际是 16。它的跨步地址是 。于是，在 quad 数组中，每个成员都有 7 字节的尾填充，因为下个结构体的首个成员需要在 ８ 字节边界上对齐。内存分布就好像这个结构是这样声明的：12341. struct foo4 &#123;2. short s; /* 2 bytes */3. char c; /* 1 byte */4. &#125;;因为 s 只需要 2 字节对齐，跨步地址仅在 c 的 1 字节之后，整个 struct foo4 也只需要 1 字节的尾填充。形式如下：的返回值将为 4。12345671. struct foo5 &#123;2. short s;3. char c;4. int flip:1;5. int nybble:4;6. int septet:7;7. &#125;;关于位域需要了解的是，它们是由字（或字节）层面的掩码和移位指令实现的。从编译器的角度来看，struct foo5 中的位域就像 ２ 字节、16 位的字符数组，只用到了其中 12 位。为了使结构体的长度是其最宽成员长度 的整数倍，接下来进行了填充。1234567891. struct foo6 &#123;2. char c;3. struct foo5 &#123;4. ​ char *p;5. ​ short x;6. &#125; inner;7. &#125;;内层结构体成员 char *p 强迫外层结构体与内层结构体指针对齐一致。在 64 位系统中，实际的内存分布将类似这样：理解了编译器在结构体中间和尾部插入填充的原因与方式后，我们来看看如何榨出这些废液。此即结构体打包的技艺。消除废液最简单的方式，是按对齐值递减重新对结构体成员排序。即让所有指针对齐成员排在最前面，因为在 64 位系统中它们占用 8 字节；然后是 4 字节的 int；再然后是 2 字节的 short，最后是字符。123451. struct foo7 &#123;2. char c;3. struct foo7 *p;4. short x;5. &#125;;将隐含的废液写明，形式如下：12345671. struct foo8 &#123;2. struct foo8 *p;3. short x;4. char c;5. &#125;;考虑到自对齐，我们看到所有数据域之间都不需填充。因为有较严对齐要求（更长）成员的跨步地址对不太严对齐要求的（更短）成员来说，总是合法的对齐地址。重打包过的结构体只需要尾填充：注意，重新打包不能确保在所有情况下都能节省空间。将这项技术应用于更靠前 struct foo6 的那个例子，我们得到：123456789101. struct foo9 &#123;2. struct foo9_inner &#123;3. char *p; /* 8 bytes */4. int x; /* 4 bytes */5. char pad[4]; /* 4 bytes */6. &#125; inner;7. char c; /* 1 byte */8. char pad[7]; /* 7 bytes */9. &#125;;结果还是 24 字节，因为 c 无法作为内层结构体的尾填充。要想节省空间，你需要得新设计数据结构。棘手的标量案例#define请当心，重打包结构体时，枚举型变量通常是 int，这与编译器相关；但也可能是 short、long、甚至默认为 char。编译器可能会有 预处理指令或命令行选项指定枚举的尺寸。以上两种情况，最好用 来检查存储尺寸。尽管按尺寸重排是最简单的消除废液的方式，却不一定是正确的方式。还有两个问题需要考量：可读性与缓存局部性。笨拙地、机械地重排结构体可能有损可读性。倘若有可能，最好这样重排成员：将语义相关的数据放在一起，形成连贯的组。最理想的情况是，结构体的设计应与程序的设计相通。为保持可读性所做的工作（将相关和同时访问的数据放在临近位置）也会提高缓存段的局部性。这些都是需要明智地重排，并对数据的存取模式了然于心的原因。是的，某些时候，这种做法与前文将相关数据放入与缓存段长度相同块的做法矛盾。多线程的确是个难题。缓存段弹跳和其他多线程优化问题是很高级的话题，值得单独为它们写份指导。这里我所能做的，只是让你了解有这些问题存在。其他打包技术你可能会有一点儿存取时间的损失，但只要将工作集合压缩得足够小，那点损失可以靠避免缓存未命中补偿。这不仅减小了结构体的可见尺寸，还可以消除废液和/或创造额外的机会来进行重新排序。这种良性串连的效果不难被触发。clang 编译器有个 Wpadded 选项，可以生成有关对齐和填充的信息。读者可以下载一段程序源代码 ，验证上文有关标量和结构体尺寸的结论。理解这些规则的第二个层次是，知其何时及如何会被打破。在我学习它们的日子里（1980 年代早期），我们把不理解这些规则的人称为“所有机器都是 VAX 综合症”的牺牲品。记住，世上所有电脑并非都是 PC。]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>扩展知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言笔记（2）]]></title>
    <url>%2F2019%2F10%2F13%2FC%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[先举三反一，再举一反三，学习就应该是这样，先模仿，再改进，最后实现自己的创意！ –小甲鱼论坛递归调用函数本身设置递归结束条件12345678910111213141516171819202122232425262728293031323334353637383940//// Created by Luenci on 2019/10/11.//#include &lt;stdio.h&gt;void fun(void);long fact(int num);void fun(void)&#123; static int count = 10; printf("Hi\n"); if (count--)&#123; fun(); &#125;&#125;long fact(int num)&#123; long result; if(num &gt; 0)&#123; result = num * fact(num-1); &#125; else&#123; result = 1; &#125; return result;&#125;int main(void)&#123;// fun(); int num; long re; printf("请输入您要求阶乘的数："); scanf("%d", &amp;num); re = fact(num); printf("%d", re); return 0;&#125;汉罗塔123456789101112131415161718192021222324#include&lt;stdio.h&gt;void hanoi(int n, char x, char y, char z);void hanoi(int n, char x, char y, char z)&#123; if(n==1)&#123; printf("%c --&gt; %c \n", x,z); &#125; else&#123; // 将前n-1个圆盘借助z移动到y hanoi(n-1, x, z, y); printf("%c --&gt; %c \n", x,z); // 将前n-1个圆盘借助x移动到z hanoi(n-1, y, x, z); &#125;&#125;int main(void)&#123; int n; printf("请输入您的层数："); scanf("%d", &amp;n); hanoi(n, 'X', 'Y', 'Z'); return 0;&#125;快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//// Created by Luenci on 2019/10/11.//#include &lt;stdio.h&gt;void quick_sort(int array[], int left, int right);void quick_sort(int array[], int left, int right) &#123; int i = left, j = right; int temp; // 交换的中间变量 int pivot; // 基准点 pivot = array[(left + right) / 2]; while (i &lt;= j) &#123; // 从右往左找到大于等于基准点的元素 while (array[i] &lt; pivot) &#123; i++; &#125; // 从右到左找到小于等于基准点的元素 while (array[j] &gt; pivot) &#123; j--; &#125; // 如果 i &lt;= j,则互换 if (i &lt;= j) &#123; temp = array[i]; array[i] = array[j]; array[j] = temp; i++; j++; &#125; &#125; if (left &lt; j) &#123; quick_sort(array, left, j); &#125; if (i &lt; right) &#123; quick_sort(array, i, right); &#125;&#125;int main(void)&#123; int array[] = &#123;73, 108, 111, 101, 78, 109, 66, 48, 88, 135&#125;; int i, length; // 计算数组的长度 length = sizeof(array) / sizeof(array[0]); quick_sort(array, 0, length-1); printf("排序后的结果是："); for (i = 0; i &lt; length; i++)&#123; printf("%d ,", array[i]); &#125; putchar('\n'); return 0;&#125;动态内存管理malloc申请动态内存空间free释放动态内存空间calloc申请并初始化一系列内存空间realloc重新分配内训空间malloc函数函数原型void *malloc（size_t size）malloc函数向系统申请分配size个字节的内存空间，并返回一个指向这块空间的地址。如果函数调用成功，返回一个指向申请的内存空间的指针，由于返回类型是void 指针（void * ）， 所以它是可以被转换成任何类型的数据；如果函数调用失败，返回值是NULL。另外，如果size的参数设置为0，返回值也可能是NULL，但这并不意味着函数调用失败。free函数函数原型void free（void *ptr）free函数释放ptr参数指向的内存空间。该内存空间必须是有malloc，calloc或realloc函数申请的。否则，该函数将导致未定义行为。如果ptr参数是NULL，则不执行任何操作。注意：该函数并不会修改ptr参数的值，所以调用后仍然指向原来的地方（变为非法空间）。123456789101112131415161718192021222324252627//// Created by Luenci on 2019/10/12.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int *ptr; ptr = (int *)malloc(sizeof(int)); if(ptr == NULL)&#123; printf("分配内存失败"); exit(1); &#125; printf("请输入一个整数："); scanf("%d", ptr); printf("您输入的整数是:%d\n", *ptr); free(ptr); printf("您输入的整数是:%d\n", *ptr); return 0;&#125;内存泄漏隐式内存泄漏用完内存块没有及时使用free函数释放丢失内存块的地址初始化内存空间mem开头的函数被编入字符串标准库，函数的声明包含在string.h这个头文件中：memset – 使用一个常量字节填充空间memcpy – 拷贝内存空间memmove – 拷贝内存空间memcmp – 比较内存空间memchr – 在内存空间中搜索一个字符123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by Luenci on 2019/10/12.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define N 10int main(void)&#123; int *ptr = NULL; int i; ptr = (int *)malloc(N * sizeof(int)); if(ptr == NULL)&#123; exit(1); &#125; memset(ptr, 0, N * sizeof(int)); for (i= 0; i &lt; N; i++) &#123; printf("%d ", ptr[i]); &#125;// putchar("\n"); putchar('\n'); free(ptr); return 0;&#125;/*1、含义不同。用单引号引起的一个字符实际上代表一个整数，整数值对应于该字符在编译器采用的字符集中的序列值。而一般我们的编译器采用的都是ASCII字符集。因此's'的含义其实和十进制数115的含义是一致的。而用双引号引起的字符串，代表的是一个指向无名数组起始字符的指针。2、大小不同。用单引号引起的一个字符大小就是一个字节。而用双引号引起的字符串大小是字符的总大小+1，因为用双引号引起的字符串会在字符串末尾添加一个二进制为0的字符'\0'。*/calloc函数函数原型void *calloc(size_t nmemb, sizet_t size);calloc函数在内存中动态地申请nmemb个长度为size的连续内存空间（即申请的总空间尺寸为nmemb * size），这些内存空间全部被初始化为 0.calloc函数与malloc函数的一个重要区别是：calloc函数在申请完内存后，自动初始化该内存空间为零malloc函数不进行初始化操作，里面数据是随机的12345678// 两者等价// calloc() 分配内存空间并初始化int *ptr = （int *）calloc（8， sizeof（int））；//malloc()分配内存空间并用memset（）初始化int *ptr = (int *)malloc(8 * sizeof(int))；memset(prt, 0, 8 * sizeof(int));realloc函数如果ptr参数为NULL，那么调用该函数就相当于调用malloc（size）如果size参数为0，并且ptr参数不为NULL，那么调用该函数就相当于调用free（ptr）除非ptr参数为NULL，否则ptr的值必须由先前调用malloc，calloc或realloc函数返回。1234567891011121314151617181920212223242526272829303132//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int i, num; int count = 0; int *ptr = NULL;// 注意这里必须初始化为NULL do &#123; printf("请输入一个整数：（输入-1表示结束）"); scanf("%d", &amp;num); count++; ptr = (int *)realloc(ptr, count * sizeof(int)); if(ptr == NULL)&#123; exit(1); &#125; ptr[count-1] = num; &#125;while(num != -1); printf("输入的整数分别是："); for (int i = 0; i &lt;count ; i++) &#123; printf("%d ", ptr[i]); &#125; free(ptr); return 0;&#125;c语言的内存布局代码段代码段（Text segment）通常是指用来存放在程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读。在代码段中，也有可能包含一些只读的常熟变量，例如字符串常量等。BSS段BSS段（BSS segment/Uninitialized data segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BBS是英文Block Started Symbol的简称，这个区段中的数据在程序运行前将被自动初始化为数字0。堆堆是用于存放进程中被动态分配的内存段，它的大小并不固定，可动态扩展或缩小。当进程调用malloc等函数分配内存时，新分配的内存就被动态调价到对上；当利用free等函数释放内存时，被释放的内存从堆中被剔除。栈栈是函数执行的内存区域，通常和堆共享同一片区域。堆和栈的区别申请方式堆是由程序员手动申请栈时系统自动分配释放方式堆是由程序员手动释放栈由系统自动释放生存周期堆的生存周期由动态申请到程序员主动释放位置，不同函数之间均可自由访问。栈的生存周期由函数调用开始到函数返回时结束，函数之间的局部变量不能互相访问。高级宏定义本质就是替换内联函数在程序函数调用时，直接展开，而不是去查找调用。内联函数嵌入调用者代码中的操作是一种优化操作，因此只有进行优化编译时才会执行代码嵌入处理。若编译过程中没有使用优化选项‘-o’，那么内联函数的代码就不会真正地嵌入到函数调用者代码中，而是只作为普通函数调用来处理。内联函数虽然节省了函数调用的时间消耗，但由于每一个函数出现的地方都要进行替换，因此增加了代码的编译时间。另外，并不是所有的函数都能变成内联函数现在的编译器也很智能，就算你不写inline，它也会自动将一些函数优化成内联函数不带参数的宏定义为了和普通的变量进行区分，宏的名字通常我们约定是由大写字母组成宏定义只是简单地进行替换，并且由于预处理是在编译之前进行，而编译工作的任务之一就是语法检查，所以编译器不会对宏定义进行语法检查宏定义不是说明或语句，在末尾不必加分号宏定义的作用是从定义的位置开始到整个程序的结束可以用 #undef 来终止宏定义的作用域宏定义允许嵌套12345678910111213141516171819//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define PI 3.14int main()&#123; int r; float s; printf("请输入圆的半径："); scanf("%d", &amp;r);// #undef PI 终止宏定义 s = PI * r * r; printf("圆的面积是：%.2f\n", s);&#125;123456789101112131415//// Created by Luenci on 2019/10/13.//// 宏定义的嵌套#include &lt;stdio.h&gt;#define R 6371#define PI 3.14#define V PI * R * R * R * 4 / 3int main()&#123; printf("地球的体积是：%.2f\n", V);&#125;带参数的宏定义12345678910111213141516//// Created by Luenci on 2019/10/13.////带参数的宏定义#include &lt;stdio.h&gt;#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))int main()&#123; int x,y; printf("请输入两个数："); scanf("%d%d", &amp;x, &amp;y); printf("%d是最大的那个数！\n", MAX(x, y));&#125;‘#’ 和 ‘##’‘#’ 和 ‘##’是两个预处理运算符在带参数的宏定义中， #运算符后面应该跟着一个参数，预处理器会把这个参数转换为一个字符串。1234567891011121314//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define STR(s) # sint main(void)&#123; printf(STR(Hlloc %s num = %d), STR(Luenci), 520); return 0;&#125;out :Hlloc Luenci num = 520‘##’运算符被称为记号连接运算符，我们可以使用’##’运算符连接两个参数。123456789101112131415161718192021222324252627 //// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define TOGETHER(x,y) x ## yint main(void)&#123; printf("%d\n", TOGETHER(2,50)); return 0;&#125;//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define TOGETHER(x,y) x ## yint main(void)&#123; printf("%d\n", TOGETHER(2,50)); return 0;&#125;out:250可变参数之前学习了如何让函数支持可变参数，带参数的宏定义是使用可变参数的：1#define SHOWLIST（...） printf（#__VA_ARGS__）其中…表示可变参数，1#__VA_ARGS__在预处理中被实际的参数集所替代。123456789101112#include &lt;stdio.h&gt;#define SHOWLIST(...) printf(#__VA_ARGS__)int main(void)&#123; SHOWLIST(Luenci,5 20, 3.14 \n); return 0;&#125;out:Luenci,5 20, 3.1412345678910111213#include &lt;stdio.h&gt;#define SHOWLIST(format, ...) printf(#format, ##__VA_ARGS__)int main(void)&#123; SHOWLIST(num = %d\n,520); SHOWLIST(hello Luenci\n); return 0;&#125;out:num = 520hello Luenci]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言笔记（1）]]></title>
    <url>%2F2019%2F10%2F13%2FC%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[ps:先举三反一，再举一反三，学习就应该是这样，先模仿，再改进，最后实现自己的创意！ –小甲鱼论坛C语言中各种数据类型所占用的存储空间的大小int—32位 四个字节float —32位 四个字节char—8位 一个字节double—-64位 8个字节bool—-16位 2个字节long—-32位 四个字节整数类型下表列出了关于标准整数类型的存储大小和值范围的细节：类型存储大小值范围char1 字节-128 到 127 或 0 到 255unsigned char1 字节0 到 255signed char1 字节-128 到 127int2 或 4 字节-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647unsigned int2 或 4 字节0 到 65,535 或 0 到 4,294,967,295short2 字节-32,768 到 32,767unsigned short2 字节0 到 65,535long4 字节-2,147,483,648 到 2,147,483,647unsigned long4 字节0 到 4,294,967,295浮点类型下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：类型存储大小值范围精度float4 字节1.2E-38 到 3.4E+386 位小数double8 字节2.3E-308 到 1.7E+30815 位小数long double16 字节3.4E-4932 到 1.1E+493219 位小数void 类型void 类型指定没有可用的值。它通常用于以下三种情况下：序号类型与描述1函数返回为空 C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);2函数参数为空 C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);3指针指向 void 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。C语言运算符优先级优先级运算符名称或含义使用形式结合方向说明1[]数组下标数组名[常量表达式]左到右()圆括号（表达式）/函数名(形参表).成员选择（对象）对象.成员名-&gt;成员选择（指针）对象指针-&gt;成员名2-负号运算符-表达式右到左单目运算符(类型)强制类型转换(数据类型)表达式++自增运算符++变量名/变量名++单目运算符–自减运算符–变量名/变量名–单目运算符*取值运算符*指针变量单目运算符&amp;取地址运算符&amp;变量名单目运算符!逻辑非运算符!表达式单目运算符~按位取反运算符~表达式单目运算符sizeof长度运算符sizeof(表达式)3/除表达式/表达式左到右双目运算符*乘表达式*表达式双目运算符%余数（取模）整型表达式/整型表达式双目运算符4+加表达式+表达式左到右双目运算符-减表达式-表达式双目运算符5&lt;&lt;左移变量&lt;&lt;表达式左到右双目运算符&gt;&gt;右移变量&gt;&gt;表达式双目运算符6&gt;大于表达式&gt;表达式左到右双目运算符&gt;=大于等于表达式&gt;=表达式双目运算符&lt;小于表达式&lt;表达式双目运算符&lt;=小于等于表达式&lt;=表达式双目运算符7==等于表达式==表达式左到右双目运算符!=不等于表达式!= 表达式双目运算符8&amp;按位与表达式&amp;表达式左到右双目运算符9^按位异或表达式^表达式左到右双目运算符10|按位或表达式|表达式左到右双目运算符11&amp;&amp;逻辑与表达式&amp;&amp;表达式左到右双目运算符12||逻辑或表达式||表达式左到右双目运算符13?:条件运算符表达式1? 表达式2: 表达式3右到左三目运算符14=赋值运算符变量=表达式右到左/=除后赋值变量/=表达式*=乘后赋值变量*=表达式%=取模后赋值变量%=表达式+=加后赋值变量+=表达式-=减后赋值变量-=表达式&lt;&lt;=左移后赋值变量&lt;&lt;=表达式&gt;&gt;=右移后赋值变量&gt;&gt;=表达式&amp;=按位与后赋值变量&amp;=表达式^=按位异或后赋值变量^=表达式|=按位或后赋值变量|=表达式15,逗号运算符表达式,表达式,…左到右从左向右顺序运算注：同一优先级的运算符，运算次序由结合方向所决定。break和continue语句区别break语句结束当前循环continue语句跳过本次循环二维下标直接索引和指针间接索引的相互转化1234*（array + i） = array[i]*(*(array + i) + j) = array[i][j]*(*(*(array + i) + j) + K) = array[i][j][k] ...二维数组和数组指针的关系12345678910111213141516171819202122//// Created by Luenci on 2019/10/5.//#include &lt;stdio.h&gt;int main()&#123; int array[2][3] = &#123;&#123;0, 1, 2&#125;, &#123;4, 5, 6&#125;&#125;; int (*p)[3] = array; printf("**(p+1): %d\n", **(p+1)); printf("**(array+1): %d\n", **(array+1)); printf("array[1][0]: %d\n", array[1][0]); printf("*(*(p+1)+2): %d\n", *(*(p+1)+2)); printf("*(*(array+1)+2): %d\n", *(*(array+1)+2)); printf("array[1][2]: %d\n", array[1][2]); return 0;&#125;void指针和NULL指针Void指针void指针我们把它称之为通用指针，就是可以指向任意类型的数据。也就是说，任何类型的指针都可以赋值给void指针。123456789101112131415161718192021//// Created by Luenci on 2019/10/5.//#include &lt;stdio.h&gt;int main()&#123; int num = 1024; int *pi = &amp;num; char *ps = "Luenci"; void *pv; pv = pi; printf("pi:%p, pv:%p\n", pi,pv); printf("*pv:%d\n", *(int *)pv); pv = (char *)ps; printf("ps:%p, pv:%p\n", ps, pv); printf("*pv:%s\n", (char *)pv); return 0;&#125;NULL指针当你还不清楚要将指针初始值为什么地址时，请先将它初始化为NULL；在对指针进行解引用时，先检查该指针是否为NULL。这种策略可以为今后编写大型程序 节省大量的 调试时间。1#define NULL ((void *)0)1234567891011121314//// Created by Luenci on 2019/10/5.//#include &lt;stdio.h&gt;int null_pointer()&#123; int *p1; int *p2 = NULL; printf("%d\n", *p1); printf("%d\n", *p2); return 0;&#125;指向指针的指针123456789101112131415161718192021int main()&#123; int num = 520; int *p = &amp;num; int **pp = &amp;p; printf("num: %d\n", num); printf("*p: %d\n", *p); printf("**PP: %d\n", **pp); printf("&amp;p: %p, pp:%p\n", &amp;p, pp); printf("&amp;num:%p, p:%p, *pp:%p\n", &amp;num,p,*pp); return 0;&#125; out: num: 520 *p: 520 **PP: 520 &amp;p: 0061FF14, pp:0061FF14 &amp;num:0061FF18, p:0061FF18, *pp:0061FF18指针数组和指向指针的指针123456789101112131415161718192021222324252627282930313233343536373839int pointer_array()&#123; char *cBooks[] = &#123; &quot;&lt;c程序设计语言&gt;&quot;, &quot;&lt;c专家编程&gt;&quot;, &quot;&lt;c和指针&gt;&quot;, &quot;&lt;c prime plus&gt;&quot;, &quot;&lt;C study&gt;&quot; &#125;; char **byLuenci; char **byGood[4]; byLuenci = &amp;cBooks[4]; byGood[0] = &amp;cBooks[0]; byGood[1] = &amp;cBooks[1]; byGood[2] = &amp;cBooks[2]; byGood[3] = &amp;cBooks[3]; printf(&quot;Luenci拥有的书: %s\n&quot;, *byLuenci); printf(&quot;Luenci喜欢的图书有：\n&quot;); int i; for (int i = 0; i &lt; 4; ++i) &#123; printf(&quot;%s\n&quot;,*byGood[i]); &#125; return 0;&#125;out: Luenci拥有的书: &lt;C study&gt;Luenci喜欢的图书有：&lt;c程序设计语言&gt;&lt;c专家编程&gt;&lt;c和指针&gt;&lt;c prime plus&gt;常量定义1234567891011520，‘a’, 3.14#define price 520#define A 'a'#define PI 3.14 // 使用const关键字修饰 const int price = 520;const char A = 'a';const float pi = 3.14;指向常量的指针指针可以修改为指向不同的常量指针可以修改为指向不同的变量可以通过解引用来读取指针指向的数据不可以通过解引用修改指针指向的数据123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int num =520; const int cnum = 880; const int *pc = &amp;cnum; printf("cnum:%d, &amp;cum:%p \n", cnum, &amp;cnum); printf("*pc:%d, pc:%p\n", *pc, pc); pc = &amp;num; printf("num:%d, &amp;num:%p \n", num, &amp;num); printf("*pc:%d, pc:%p\n", *pc, pc); return 0;&#125;函数结构1234类型名 函数名（参数列表）&#123; 函数体&#125;函数的声明所谓的声明（Declaration），就是告诉编译器我要是用这个函数，你现在没有找到它的定义不要紧，请不要报错，稍后我将会把它补上。函数的参数和返回值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;void print_c();int sum(int n);int max(int x, int y);int max(int x, int y)&#123; // a？b:c 当a的值为真时，返回b的值；否则返回c的值 return x &gt; y ? x:y;&#125;int sum(int n)&#123; int result = 0; do &#123; result += n; &#125;while (n-- &gt; 0); return result;&#125;void print_c()&#123; printf(" ###### \n"); printf("## ##\n"); printf("## \n"); printf("## \n"); printf("## ##\n"); printf(" ###### \n");&#125;int main()&#123; print_c(); int n,x,y;// printf("请输入n的值："); printf("请输入x,y的值：");// scanf("%d", &amp;n); scanf("%d%d", &amp;x, &amp;y);// printf("1+2+3+...+(n-1)+n的结果是：%d\n",sum(n)); printf("x,y中最大值的值为：%d\n", max(x,y)); return 0;&#125;形参和实参用于数据传输，形参就相当与一个占位符，只在函数内部有效。传值和传址1234567891011121314151617181920212223242526//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;void swap(int *x, int *y);void swap(int *x, int *y)&#123; int *temp; printf("In swap 互换前：x %d, y %d\n", *x,*y); temp = *x; *x = *y; *y = temp; printf("In swap 互换后：x %d, y %d\n", *x,*y);&#125;int main()&#123; int x = 3, y = 5; printf("In main 互换前：x %d, y %d\n", x,y); swap(&amp;x,&amp;y); printf("In main 互换后：x %d, y %d\n", x,y); return 0;&#125;传数组实际上传过去的是数组的地址123456789101112131415void get_array(int b[10])&#123; printf("sizeof b: %d\n", sizeof(b));&#125;int main()&#123; int a[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; printf("sizeof a:%d\n", sizeof(a)); get_array(a); out:sizeof a:40sizeof b: 4可变参数引入 头文件#include&lt;stdarg.h&gt;123456789101112131415161718192021222324252627282930313233343536373839//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;int sum(int n, ...);int sum(int n, ...)&#123; int i; int sum = 0; va_list vap; va_start(vap, n); for(i = 0; i &lt; n; i++)&#123; sum += va_arg(vap, int); &#125; va_end(vap); return sum;&#125;int main()&#123; int result,result2,result3; result = sum(3,1,2,-3); printf("result:%d\n", result); result2 = sum(4,2,2,4,2); printf("result2:%d\n", result2); result3 = sum(4,2,8,4,-2); printf("result3:%d\n", result3); return 0;&#125;指针函数使用指针变量作为函数的返回值，就是指针函数123456789101112131415161718192021222324252627282930313233343536373839//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;char *getchartchar();char *getchart(char c)&#123; switch (c) &#123; case &apos;A&apos;: return &quot;Apple&quot;; case &apos;B&apos;: return &quot;Banana&quot;; case &apos;C&apos;: return &quot;Cat&quot;; case &apos;D&apos;: return &quot;Dog&quot;; default: return &quot;None&quot;; &#125;&#125;int main()&#123; char input; printf(&quot;请输入一个字母：&quot;); scanf(&quot;%c&quot;, &amp;input); printf(&quot;%s\n&quot;, getchart(input)); return 0;&#125;in:Aout:ApplePS:不要返回局部变量的指针函数指针指针函数 - - &gt; int *p();函数指针 - - &gt; int (*p)();函数指针作为参数12345678910111213141516171819202122232425262728//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;int add(int, int);int sub(int, int);int clac(int (*fp)(int, int), int, int);int add(int num1, int num2)&#123; return num1 + num2;&#125;int sub(int num1, int num2)&#123; return num1 - num2;&#125;int clac(int (*fp)(int, int), int num1, int num2)&#123; return (*fp)(num1, num2);&#125;int main()&#123; printf("3 + 5 = %d\n", clac(add, 3,5)); printf("3 - 5 = %d\n", clac(sub, 3,5)); return 0;&#125;函数指针作为返回值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//// Created by Luenci on 2019/10/10.//#include &lt;stdio.h&gt;int add(int, int);int sub(int, int);int calc(int (*)(int, int), int, int);int (*slect(char))(int,int);int add(int num1, int num2)&#123; return num1 + num2;&#125;int sub(int num1, int num2)&#123; return num1 - num2;&#125;int calc(int (*fp)(int, int),int num1, int num2)&#123; return (*fp)(num1, num2);&#125;int (*slect(char op))(int, int)&#123; switch(op)&#123; case '+': return add; case '-': return sub; &#125;&#125;int main()&#123; int num1, num2; char op; int (*fp)(int, int); printf("请输入一个式子 (如 1+3) :"); scanf("%d%c%d", &amp;num1, &amp;op, &amp;num2); fp = slect(op); printf("%d %c %d = %d\n", num1, op, num2, calc(fp, num1, num2)); return 0;&#125;局部变量和全局变量局部变量不同函数的变量无法相互访问全局变量如果不对全局变量进行初始化，那么它会自动初始化为0.如果函数在内部存在一个与全局变量同名的局部变量，编译器不会报错，而是在函数中屏蔽全局变量。exsten关键字告诉编译器我等下会定义变量，不要报错不要大量的使用全局变量使用全局变量会使你的程序占用更多的内存，因为全局变量从定义时候开始，知道程序退出才释放。污染命名空间提高了程序耦合性作用域和链接属性当变量被定义在不同的位置时，它的作用域的范围是不一样的，这个作用范围就是我们所说的作用域C语言编译器可以确认四种不同类型的作用域：代码块的作用域文件作用域原型作用域函数作用域代码块作用域（Block scope）在代码块中定义的变量，具有代码块作用域。作用范围是从变量定义的位置开始，到标志代码块结束的大括号（}）处。文件作用域（file scope）任何在代码块之外声明的标识符都具有文件作用域，作用域的范围是从他们的声明位置开始，到文件的结尾处都是可以访问的。原型作用域（prototype scope）原型作用域只适用于那些在函数原型中声明的参数名。函数作用域（function scope）函数作用域只适合于goto语句的标签，作用将goto语句得标签限制在同一个函数内部，以防止出现重名的标签。定义和声明当一个变量被定义的时候，编译器为变量申请内存空间并填充值当一个变量被声明的时候，编译器就知道该变量被定义在其他地方声明是通知编译器该变量名及相关的类型已经存在，不需要再为此申请内存空间。局部变量即是定义又是声明定义只能来一次，否则就叫做重复定义某个同名的变量；而声明可以由你很多次。链接属性external（外部的）多个文件中声明的同名标识符表示一个实体internal（内部的）单个文件中声明的同名标识符表示同一个实体none（无）声明的同名标识符被当做独立的不同实体只有具备文件作用域的标识符才能拥有external或internal的链接属性，其他作用域的标识符都是none属性。默认情况下，具备文件的作用域的标识符拥有external属性。也就是说该标识符允许跨文件访问。对于external属性的标识符，无论在不同文件中声明多少次，表示的都是一个实体。使用static关键字可以使得原先拥有的external属性的标识符变为internal属性。这里有两点需要注意：使用static关键字修改链接属性，只对具有文件作用域的标识符生效（对于拥有其他作用域的标志符是另一种功能）链接属性只能修改一次，也就是说一旦将标识符的链接属性改为internal，就无法变回external。生存期和存储类型C语言变量拥有两种生存周期静态存储器自动存储器具有文件作用域的变量属于静态存储器，函数也属于静态存储器。属于静态存储器的变量在程序执行期间将一直占据存储空间，直到程序关闭才释放具有代码块作用域的变量一般情况下属于自动存储器。属于自动存储期的变量在代码块结束时将自动释放。存储类型存储类型其实是指存储变量值的内存类型，C语言提供了五种类型。autoregisterstaticexterntypedef]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django之编写URL]]></title>
    <url>%2F2019%2F10%2F07%2Fdjango%E4%B9%8Burl%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[编写URL编写规则​ 为了使其规范性，在每个新创建的App中设置独立的静态资源和模板文件夹并添加一个空白的.py文件，命为urls.py。如下是创建app中的文件结构：1234567891011121314frist/ migrations/ # 数据库前后是否有变化，生成出迁移文件 static/ # 创建App后存放App中的静态资源文件，自己手动添加 templates/ # 创建App后存放App中的模板文件，自己手动添加 __init__.py admin.py apps.py models.py tests.py urls.py # 创建App后由系统总路由映射到App的路由文件，自己手动添加 view.py系统总路由和app的路由分发配置12345678# 根目录的urls.pyfrom django.contrib import adminfrom django.urls import path,adminurlpatterns = [ path('admin/', admin.site.urls), path('',include('frist.urls')) # 引入app中的urls.py]代码详解:from django.contrib import admin:导入Admin功能模块.from django.urls import path,admin:导入URL编写模块.urlpatterns:整个项目的URL集合,每个元素代表一条URL信息.path(&#39;admin/&#39;, admin.site.urls):设定Admin的URL.&#39;admin/&#39;代表127.0.0.1/admin地址信息,admin后面的斜杠是路径分隔符;admin.site.urls是URL的处理函数,也称为视图函数.path(&#39;&#39;,include(&#39;frist.urls&#39;)):URL为空,代表网站的域名,即127.0.0.1,通常是网站的首页;include将该URL分发给app的urls.py处理.1234567# app下的urls.pyfrom django.urls import pathfrom . import viewsurlpatterns = [ path('',views.index) # 调用和url匹配的视图函数]当根目录的URL分发给app中的URL处理后,下一步就是根据所匹配的URL进行视图的调用.在Views中编写相应的视图函数。如下：12345# index的views.pyfrom django.http import HttpResponse# creat you views here.def index(request): return HttpResponse("hello world")视图函数的参数必须设置为request，该参数代表当前用户的请求对象，该对象包含用户名，请求内容和请求方式等信息，执行完成后必须使用return将处理结果返回。带变量的URL​ 在日常开发中，有时候一个URL可以代表多个不同的页面，如编写带有日期的URL，若根据前面的编写方式，按一年计算，则需要开发者编写365个不同的URL才能实现。这种做法是不可取的，因此，Django在编写URL时，可以对URL设置变量值，使URL具有多样性。​ URL的变量类型有字符类型，整型，slug和uuid，常用的是字符类型和整型。说明如下：字符类型：匹配任何非空字符串，但不含斜杠。如果没有指定类型，默认使用该类型。整形：匹配0和正整数slug：可理解为注释，后缀或附属等概念，常作为URL的解释性字符。可匹配任何ASCII字符以及连接符和下画线，能使URL更加清晰易懂。比如网页的标题是“13岁的孩子”，其URL地址可以设置为“13-sui-de-hai-zi“。uuid：匹配一个uuid格式的对象。为了防止冲突，规定必须使用破折号并且所有字母必须小写，例如0201203-3213-31e-321c34d435（未待完续）]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django简介]]></title>
    <url>%2F2019%2F10%2F07%2Fdjango%E9%85%8D%E7%BD%AE%E5%88%9D%E5%90%AF%2F</url>
    <content type="text"><![CDATA[Django简介背景2003诞生 它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的MVT（框架）Models 模型 数据库Views 视图 放和拿Template 模板 前端From 表单 django 会根据你后台数据库字段及表单层的设计对应的给你创建HTML关于表单的代码Django优点对象关系映射（Object Relational Mapping ORM）：通过定义映射类来构建数据模型，将模型与关系型数据库连接起来，使用ORM框架内置的数据库接口可实现复杂的数据操作。（简单来说就是把数据库的语句换成了python可识别的语言）URL设计：开发者可以设计任意的URL（网站地址）， 而且支持使用正则表达式设计。模板系统：提供可扩展的模板语言，模板之间具有可继承性。表单处理：可以生成各种表单模型，而且表单具有有效性检验功能。Cache系统：完善的缓存系统，可支持多种缓存方式用户管理系统：提供用户认证，权限设置和用户组功能，功能扩展性强。国际化：内置国际化系统，方便开发出多语言的网站。admin管理系统：内置admin管理系统，系统的扩展性强。Django项目目录1234567891011121314用django-admin startproject demo 创建一个demo项目文件结构如下：demo/ # 最外层 这个是整个项目的容器文件夹，可以随意改名字 demo/ # 内层的demo 是这个项目中关于配置文件的一个管理文件夹，这个不允许改名字 __init__.py #初始化文件，代表这个文件夹是一个包，一个模块，demo文件夹就是一个模块了 settings.py # 这个是整个项目的配置文件，配置中间，配置邮件等 urls.py # django项目的总路由配置文件。网站的地址信息 wsgi.py # 全称为Python Web Server Gateway Interface，即为python服务器网关接口， 是python应用与Web服务器之间的接口，用于Django项目在服务器上的部署和上线，一 般不需要修改 manage.py # 命令行工具，允许以多种方式与项目交互。 可输入 python manage.py help 查看 该工具的具体用法Django的创建的App目录使用命令创建app： python manage.py startapp frist创建了App必须把App名称添加到INSTALL_APPS里面。1234567891011121314frist/ migrations/ # 数据库前后是否有变化，生成出迁移文件 static/ # 创建App后存放App中的静态资源文件，自己手动添加 templates/ # 创建App后存放App中的模板文件，自己手动添加 __init__.py admin.py apps.py models.py tests.py urls.py # 创建App后由系统总路由映射到App的路由文件，自己手动添加 view.pyDjango（settings）配置全览123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122"""Django settings for mysite project.Generated by 'django-admin startproject' using Django 2.1.2.For more information on this file, seehttps://docs.djangoproject.com/en/2.1/topics/settings/For the full list of settings and their values, seehttps://docs.djangoproject.com/en/2.1/ref/settings/"""import os# 项目路径# Build paths inside the project like this: os.path.join(BASE_DIR, ...)BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))# Quick-start development settings - unsuitable for production# See https://docs.djangoproject.com/en/2.1/howto/deployment/checklist/# 密匙配置# SECURITY WARNING: keep the secret key used in production secret!SECRET_KEY = '#g$qgqkee8csvp67l$(8ugkx%+i_9k%mbykw-%9zpbnyn!bb!='# 调试模式# SECURITY WARNING: don't run with debug turned on in production!DEBUG = True# 域名访问权限ALLOWED_HOSTS = ['*']# App列表# Application definitionINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'myblog', 'article',]MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]ROOT_URLCONF = 'mysite.urls'TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [BASE_DIR, 'templates'], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', # 自定义模版全局变量(默认变量) 'article.views.global_settings', ], &#125;, &#125;,]WSGI_APPLICATION = 'mysite.wsgi.application'# Database# https://docs.djangoproject.com/en/2.1/ref/settings/#databasesDATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125;# Password validation# https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validatorsAUTH_PASSWORD_VALIDATORS = [ &#123; 'NAME':'django.contrib.auth.password_validation.UserAttributeSimilarityValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator', &#125;,]# Internationalization# https://docs.djangoproject.com/en/2.1/topics/i18n/LANGUAGE_CODE = 'zh-Hans'TIME_ZONE = 'Asia/Shanghai'USE_I18N = TrueUSE_L10N = TrueUSE_TZ = True# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/2.1/howto/static-files/STATIC_URL = '/static/'STATIC_ROOT = os.path.join(BASE_DIR, "static/")项目路径 BASE_DIR：主要通过os模块读取当前项目在系统的具体路径，该代码在创建项目时自动生成，一般情况无需修改密匙配置SECRET_KEY：是一个随机值，在项目创建的时候自动生成，一般情况下无需修改。主要用于重要的数据 加密处理，提高系统的安全性，避免遭到攻击者的恶意破坏。密匙主要用于用户密码，CSRF机制和会话Session等数据加密。12345* 用户密码：Django内置一套用户管理系统，该系统具有用户认证和存储用户信息等功能，在创建用户的时候，将用户的密码通过密匙进行加密处理，保证用户的安全性。* CSRF机制：该机制主要用于表单提交，防止窃取网站的用户信息来制造恶意请求* 会话Session：Session的信息存放在Cookies，以一串随机的字符串表示，用于标识当前访问网站的用户身份，记录相关用户信息。调试模式DEBUG：该值为布尔类型。如果在开发调试阶段应设置为True，在开发调试过程中会自动检测代码是否 发生更改，根据检测结果执行是否刷新重启系统。如果项目部署上线，将其改为False，否则会泄露系统的相关信息。域名访问权限ALLOWED_HOSTS:设置可访问的域名，默认值为空。当DEBUG为True并且ALLOWED_HOSTS为空时，项目只允许以localhost或127.0.0.1在浏览器上访问启动。当DEBUG为False时，ALLOWED_HOSTS为必填项，否则程序无法启动，如果想允许所有域名访问，可设置ALLOW_HOSTS=[‘*’]。App列表INSTALLED_APPS：告诉Django有哪些App。在创建项目时已有admin，auth，和session等配置等信息，这些都是Django内置的应用功能，各个功能说明如下。123456* admin:内置的后台管理系统。* auth：内置的用户认证系统。* contenttypes：记录项目中所有的model元数据（Django的ORM框架）。* session：Session会话功能，用于标识当前访问网站的 用户身份，记录相关用户信息。* message：消息提示功能。* staticfiles：查找静态资源路径。静态资源（static）123456789101112# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/2.1/howto/static-files/STATIC_URL = '/static/' STATIC_ROOT = os.path.join(BASE_DIR, "static/")# 设置根目录的静态资源文件夹staticSTATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'),# 设置App的静态资源文件夹 os.path.join(BASE_DIR, '/static')， ]​​ CSS也称层叠样式表（Cascading Style Sheets），是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。​ JavaScript是一种直译式脚本语言，也是一种动态类型，弱类型，基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。STATIC_URL是必须配置的属性而且属性值不能为空。如果没有配置STATICFILES_DIRS，则STATIC_URL只能识别App里的static静态资源文件夹。STATICFILES_DIRS是可选配置属性，属性值为列表或元组格式，每个列表（元组）元素代表一个静态资源文件夹，这些文件夹可行命名。在浏览器上访问项目的静态资源时，无论项目的静态资源文件夹是如何命名的，在浏览器上，静态资源的上级目录必须为static，而static而STATIC_URL的属性值,因为STATIC_URL也是静态资源的起始URL。​ 除此之外，静态资源配置还有STATIC_ROOT，其作用是方便在服务器上部署项目，实现服务器和项目之间的映射。STATIC_URL和STATICFILES_DIRS区别STATIC_URL是必须配置的属性而且属性的值不能为空。如果没有配置STATICFILES_DIRS,则STATIC_URL只能识别App里面的static静态资源文件夹。STATICFILES_DIRS是可选配置属性，属性值为列表或元组格式，每个列表（元组）元素代表一个静态资源文件夹，这些文件夹可自行命名。在浏览器上访问项目的静态资源时，无论项目的静态资源文件夹是如何命名的，在浏览器上，静态资源的上级目录必须为static，而static是STATIC_URL的属性值，因为STATIC_URL也是静态资源的起始URL。模板路径（template）在web开发中，模板是一种较为特殊的HTML文档。这个HTML文档嵌入了一些能够让Python识别的变量和指令，然后程序解析这些变量和指令，生成完整的HTML网页并返回给用户浏览。模板是Django里面的MTV框架模式的T部分，配置模板路径是Django在解析模板时，如何找到模板所在的位置。创建项目时，Django以有初始的模板配置信息。如下：123456789101112131415161718TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [BASE_DIR, 'templates'], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', # 自定义模版全局变量(默认变量) 'article.views.global_settings', ], &#125;, &#125;,]模板信息是以列表格式呈现的，每个元素具有不同的含义，说明如下：BACKEND：定义模板引擎，用于识别模板里面的变量和指令。内置的模板引擎有DjangoTemplate和jinjia2.Jinjia2，每个模板引擎都有自己的变量和指令语法。DIRS：设置模板所在的路径，告诉Django在那个地方查找模板的位置，默认为空列表APP_DIRS:是否在App里面查找模板文件OPTIONS：用于填充在RequestContext中上下文调用函数，一般情况下不做任何修改。数据库设置（Databases）在settings文件下 有一个DATABASES属性123456789101112131415DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', # 数据库引擎 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), # 本地sqllite3数据库位置 'USER': # 用户名 'PASSWORD': # 数据库密码 'HOST': # 数据库主机地址 &#125; &#125;# 默认的django使用sqllite3作为数据库 # django提供四种 ENGINE 数据库引擎 # django.db.backends.mysql # django.db.backends.oracle # django.db.backends.splite3# 如果你使用的是 PostgreSQL 或者Mysql的话，已经是先创建了数据库，但是默认的SQLlite不需要sqlite3 轻量级数据库（数据存放在文件里面）在Django连接MYSQL数据库时候如果提示django.db.utils.OperationalError的错误信息，这是因为MYSQL8.0版本的密码加密方式发生了变化，8.0版本的用户密码采用的是cha2加密方法。解决方法，把SQL语句将8.0版本加密方法改回原来的加密方式。123# newpassword 是我们设置的用户密码ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'newpassword';FLUSH PRIVILEGES;中间件（Middlewere）中间件（Middleware）是处理Django的request和response对象的钩子。当用户在网站中进行单击某个按钮等操作时，这个动作是用户向网站发送请求（request）；而网页会根据用户的操作返回相关的网页内容，这个过程称为响应处理（response）。从请求到响应的过程中，当Django接收到用户的请求时，Django首先经过中间件处理请求消息，执行相关的处理，然后将处理结果返回给用户，中间件的执行流程如图：如上图，中间件的作用主要是处理用户的请求信息。开发者也可以根据自己的开发需求自定义中间件，只要将自定义的中间件添加到配置属性MIDDLEWARE中即可激活。一般情况下，Django默认的中间件配置均可满足大部分的开发需求。1234567'django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware','django.middleware.csrf.CsrfViewMiddleware','django.contrib.auth.middleware.AuthenticationMiddleware','django.contrib.messages.middleware.MessageMiddleware','django.middleware.clickjacking.XFrameOptionsMiddleware',配置属性MIDDLEWARE的数据格式为列表类型，每个中间件的设置顺序是固定的，如果随意变更中间件很容易导致程序异常，每个中间件的说明如下：SecurityMiddleware：内置的安全机制，保护用户与网站的通信安全。SessionMiddleware：会话Session。LocaleModdleware：支持中文语言。CommonMiddleware：处理请求信息，规范化请求内容。CsrViewMiddleware：开启CSRF防护功能。AuthenticationMiddleware：开启内置的用户认证系统。MessageMiddleware：开启内置的信息提示功能。XFrameOptionsMiddleware：防止恶意程序点击劫持。修改时区及语言LANGUAGE_CODE = ‘en-us’ #语言TIME_ZONE = ‘UTC’ #时区12LANGUAGE_CODE = 'zh-Hans'TIME_ZONE = 'Asia/Shanghai'开启测试服务器用来展示你创建出来的空项目/home/Publc_Class/5-17-django框架/python3 manage.py runserver 0.0.0.0:9090开启了一个测试服务器runserver 可以让你在浏览器看到效果，但是这个是测试服务器，压力不过百创建默认数据库因为django自带的admin界面，首先需要数据库来支持我们来先创建出一个数据库1234makemigrations 数据库前后是否有变化，生成出迁移文件migrate 根据迁移文件 来对应的执行SQL语句 python3 manage.py makemigrationspython3 manage.py migrate如果数据库创建完成，那么目录结构下和manage.py同级的就会有一个db.splite3文件有了这个数据库，就可以创建超级用户来管理admin界面啦！为admin界面创建超级用户数据库有了，要创建超级用户python3 manage.py createsuperuser12345Username (leave blank to use 'root'): rootEmail address: 2573799357@qq.com Password: Password (again): Superuser created successfully.]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高德无人机科技研发岗（测试工程师）面试总结]]></title>
    <url>%2F2019%2F09%2F30%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[输入密码，查看文章 306afd5a9a56959304fb76b0f88a9815787cb584d8d661d705e739a948add08c8a86695bf845cd2b4d616a686b59220027731a681da3c36794c32972ed7b608d79eabc69cbf89fbd483fe5dbd00debd4ed5963695b091101ee2cab1dda55dab94f1399d127ac465583ee06b23e6e22a84cb081132bcaf9fb0a875b6aad946498d27af66ac9051a3a1980f1e5b6f68f2aaf458389bfce7988dcf6b851bd43a1c44b601da4d35411f1df766d816136b9b658e9fd6f19e5f9794d4fb59b1f39b6b60143260f5e7cfc55e54c0ddb88a441d900ef139965775d612518db9f07712339bc5a6d5524deac3be7c144863a1aa809d2c57cee147aeec8e1fe45c53316ca5ffa0f0e29e18b1006e5116ec2edebea006819a89ae292715d1fcc74d9bdc50331eb95d6a5879208c137593f9431f8aaa60f3101662b915704bb16e42e1b00b1e02b670a13e09bf2e7c193748b6e77a1aae4ae0c4221cf20958833f4549ea5fc6a3285ef1213ae576e5e6e5402b31384e82ceab87c49a118b7492d1844c3759b9e9dd25e96faccff8a8f363174f1d33d36ccca48e8fadd51d578d86a98edeb46dee9af44b096f050b73c8698d4f879f7c618226d2fa3a26aac9535501c06192ee7926b9ddb522dfe3e4a8b7bdf9edf21136cb77d485cc1c9ed7eb187c67adff9da452f4ac188101283b4fc8cbcd6c9f30e46a46a58530ba696446ca39ef7ae7218b31d464e3f3b6ac74185f5546d5b9d16ba7da62baad27ad66867d23107ecdb1b9d9ffae59b3c1b8d0c1b48257d5a34b64483e5d548ad3a02467b19146dc0f169f3357031ec3cde1be3be3269554fc22049a6e850f0759d094a8f9e964dcf80ce436e497b1da326de78132aab73322df7cb9af820ce9531dd350c1b5f24c14c62d9093829a01ab6839c42943c9002cea0d4df97a53f4d7db7017a872275125f3404d912b92450e81017132f749006ab7311e64842025f086dca1fd3d260030ed51c4adfb932ade14d5224d9dfd8373f478ca20f91738c7de04366d10b456b9b4b665adff4b0c770e7264a6310e2ba5c1bb25242ee2eabe97e72b143451a347423c766535e77637fe4f31bf4c05e2eeb68b5fdf41aae4e53c85fcdf70deed869d74dce2f952e28622e1d0149d9eeb92fd8568a5ea2f04e3dfa42676ea36388deeea1331414955051448fa87a064f9728776435e0f0734234e9a2e7ae83c1ef0363faf01eda0812a546fa167df269f3d8ce336cdc87426d2fe1593a366d4664890d54a75e0e132d3fafb83ce57c6b466fffa1427dec69884887789695659e02bf151fca01df46c872066970372fc74173801266691c93e096c04417e2f58d86b7a340318697a5835dc54f178514a1af6bbec1efa7f16454f5fea9269361595f640a59b7a4b3baab2fabdcb65027258fd27d93d4aeeb374845b63539447872fb6587986a4c02d07ea75dd7b2d61f089f946b975e7176587bc4e1c36c4ca35f787a00fcf29bb5f6097c4cab515d601e4806159dc366b427a218711079e933066a0ac2dfdc39bff77a179fc2ca475ddc34918c5e404546c1cafa66e9157fb7ae209320391e52dbbac6fcb637bd6f94e776ce4a2c6f069a4fae6072d17a82a41b52e9163e62502be285d2c44e7c66344546231952252d8c263046053884f8b92d044ed6a64f0fd2d6d9bbec2d937076dd3a082025f9b510b6e512ff68af85a8742dac60bfbc8973c269130d20edb528e7639cf27d5262935a6f7e97c050b597a826d8b6acbb97fefc78e54daab33b3664b0ec788ae419bffaa5b271edb2536fe23b56777e34646966579567d3d2610d6cb94905e1115e1b25c27f2331334945c8604a8fe7b67ab8fbe24f190ac78194898ae4555e64f3bad080daa7207e493f12f332c0ba68e20d681a6474b69b595097bc2270fe01e7108a8ef9564b23503ca78739c4621ddad5efb5fd0db678113110f225157ad635a8c890d61b7d1378f42ea2106ddad8d77e134c99331f7425279d19a1289319d0434dd0a050090f9e8d141dacc921eebdf01fc705fdc1c19cb4a0faa0d2edb11a38785834cdbdcd115776759cddc77d187037b3eeceaf23c7e945376bb9e631166c32197b102747db149fccf97a29b995eb9c343fba9aba446b14d2bb003a4aad4b50c32314831fc576aa99c4334d126a4f96eb5fd3977d22a0ef5993fda414bac0b597ec6286ff65793575395e2adb00513871b0ab2073c002179ec9586be29aaf19c5b4a4f822cdfdfb0c72dead75d5837892f26b9a540235c62359e122f41b04c1ae4b5f49fd445c4e95fd88b86ce57bb255bc654da617b08efb2680dfabcd2dbc6b5baf6234f13d410b352755af42b250f4926912e4bd45fc7d45594dd23cc9aa4303b8c297c89e609ac3351808e624c01a69235e0101b136598febfd1b9e4bdbc60893317bb5c06326a923772b4941327ed48301f190d1e77c9e5cff9865e4821947e80d7196b8830b349cb731abbaf3eaa8c09229c6521768701c230074804383e9456df5bc9190ca2815ac575b09a60f937bff240329001afca90e84a4b63ad0dc16c8716e1fc5640040d4cd1d11b26566c6c237369216058a464a99342e683eab1cf23ec0508c75e852bbb0f95c82e45998cece5fb3c9ce20cbf30caea1da28b08548542ddca7f06cf0b7a48902766007f8b07d254193f1aeb7586a663ad1d0eeeeddebcf6ea573757f529fc5b4b166cb91ba56c2e1a1e95a312a1564c71d256eb65b35e552b975bf240546642d172aceb4dd7e679b7c926d8b5b08bb03d6ed0b9d0ba2b3e055f2fcca9e84a51d51094828c981a031d31006098d70ab6bda76fc492dc65eb611b4478de6a8395aefe83aad5cca8daa8e75e8b022ed840fa2f64023af3a7d8bc68f89fc097cdc1f484416dd2930c3e4a4b3cf8a4fe142f6f71921513eba5809f00051306011cdd259a1c4ef883389ba8f3828d3892f4195348891cddf2a870e7dfef1ee6ac0d07a300d918c6da09f7494bf0d6007eb39ad3a0a344f78a50837866e7de2a147f141b6e61f0350377e4f39d84d3a5cdc3c882754bf2b254181d121cd374adecae57e197e0447da774439f1f9b9e0b264dcda54059eb347a670c2a9236f79e0dbf94b1b09eb2a7a2069acb3013ac0bfe890e9334a82fa749c3cdcacffc3bce26ef24bcbee9a3c64d3da7888c881b8]]></content>
      <categories>
        <category>面试经历</category>
      </categories>
      <tags>
        <tag>面试总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 语言中 void* 详解及应用]]></title>
    <url>%2F2019%2F09%2F30%2FC%20%E8%AF%AD%E8%A8%80%E4%B8%AD%20void%20%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[C 语言中 void* 详解及应用void 在英文中作为名词的解释为 “空虚、空间、空隙”，而在 C 语言中，void 被翻译为“无类型”，相应的void * 为“无类型指针”。void 似乎只有”注释”和限制程序的作用，当然，这里的”注释”不是为我们人提供注释，而是为编译器提供一种所谓的注释。void 的作用1.对函数返回的限定，这种情况我们比较常见。2.对函数参数的限定，这种情况也是比较常见的。一般我们常见的就是这两种情况：当函数不需要返回值值时，必须使用void限定，这就是我们所说的第一种情况。例如：void func（int a,char *b）。当函数不允许接受参数时，必须使用void限定，这就是我们所说的第二种情况。例如：int func(void)。void 指针的使用规则\1. void 指针可以指向任意类型的数据，就是说可以用任意类型的指针对 void 指针对 void 指针赋值。例如：123int *a；void *p；p=a；如果要将 void 指针 p 赋给其他类型的指针，则需要强制类型转换，就本例而言：a=（int *）p。在内存的分配中我们可以见到 void 指针使用：内存分配函数 malloc 函数返回的指针就是 void * 型，用户在使用这个指针的时候，要进行强制类型转换，也就是显式说明该指针指向的内存中是存放的什么类型的数据 (int *)malloc(1024) 表示强制规定 malloc 返回的 void* 指针指向的内存中存放的是一个个的 int 型数据。\2. 在 ANSI C 标准中，不允许对 void 指针进行一些算术运算如 p++ 或 p+=1 等，因为既然 void 是无类型，那么每次算术运算我们就不知道该操作几个字节，例如 char 型操作 sizeof(char) 字节，而 int 则要操作 sizeof(int) 字节。而在 GNU 中则允许，因为在默认情况下，GNU 认为 void * 和 char * 一样，既然是确定的，当然可以进行一些算术操作，在这里sizeof(*p)==sizeof(char)。void 几乎只有”注释”和限制程序的作用，因为从来没有人会定义一个 void 变量，让我们试着来定义：1void a;这行语句编译时会出错，提示“illegal use of type ‘void’”。即使 void a 的编译不会出错，它也没有任何实际意义。众所周知，如果指针 p1 和 p2 的类型相同，那么我们可以直接在 p1 和 p2 间互相赋值；如果 p1 和 p2 指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的指针类型转换为左边指针的类型。123456float *p1;int *p2;p1 = p2;//其中p1 = p2语句会编译出错，//提示“&apos;=&apos; : cannot convert from &apos;int *&apos; to &apos;float *&apos;”，必须改为：p1 = (float *)p2;而 void * 则不同，任何类型的指针都可以直接赋值给它，无需进行强制类型转换。123void *p1;int *p2;p1 = p2;但这并不意味着，void * 也可以无需强制类型转换地赋给其它类型的指针。因为”无类型”可以包容”有类型”，而”有类型”则不能包容”无类型”。小心使用 void 指针类型:按照 ANSI(American National Standards Institute) 标准，不能对 void 指针进行算法操作，即下列操作都是不合法的：1234567void * pvoid;pvoid++; //ANSI：错误pvoid += 1; //ANSI：错误//ANSI标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指向数据类型大小的。//例如：int *pint;pint++; //ANSI：正确pint++ 的结果是使其增大 sizeof(int)。但是 GNU 则不这么认定，它指定 void * 的算法操作与 char * 一致。因此下列语句在 GNU 编译器中皆正确：12pvoid++; //GNU：正确pvoid += 1; //GNU：正确pvoid++ 的执行结果是其增大了 1。在实际的程序设计中，为迎合 ANSI 标准，并提高程序的可移植性，我们可以这样编写实现同样功能的代码：123void * pvoid;((char *)pvoid)++; //ANSI：错误；GNU：正确(char *)pvoid += 1; //ANSI：错误；GNU：正确GNU 和 ANSI 还有一些区别，总体而言，GNU 较 ANSI 更”开放”，提供了对更多语法的支持。但是我们在真实设计时，还是应该尽可能地迎合 ANSI 标准。 如果函数的参数可以是任意类型指针，那么应声明其参数为void *。注：void 指针可以任意类型的数据，可以在程序中给我们带来一些好处，函数中形为指针类型时，我们可以将其定义为 void 指针，这样函数就可以接受任意类型的指针。如：典型的如内存操作函数 memcpy 和 memset 的函数原型分别为：12void * memcpy(void *dest, const void *src, size_t len);void * memset ( void * buffer, int c, size_t num );这样，任何类型的指针都可以传入 memcpy 和 memset 中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型（参见 C 语言实现泛型编程）。如果 memcpy 和 memset 的参数类型不是 void *，而是 char *，那才叫真的奇怪了！这样的 memcpy 和 memset 明显不是一个”纯粹的，脱离低级趣味的”函数！void 的出现只是为了一种抽象的需要，如果你正确地理解了面向对象中”抽象基类”的概念，也很容易理解 void 数据类型。正如不能给抽象基类定义一个实例，我们也不能定义一个 void（让我们类比的称 void 为”抽象数据类型”）变量。原文地址：https://www.cnblogs.com/wuyudong/p/c-void-point.html]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>Void* 知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机系统组成及工作原理简介]]></title>
    <url>%2F2019%2F09%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[计算机系统组成及工作原理简介硬件系统中央控制器 CPU运算器 ALU又称算数逻辑部件，是计算机用来进行数据运算的部件算数运算加、减、乘、除四则运算逻辑运算与、或、非、异或等逻辑操作，以及移位、比较和传送等操作，亦称算术逻辑部件（ALU）控制器 Controller通过地址访问存储器，逐条取出选中单元的指令，分析指令，根据指令产生相应的控制信号，用于其他各个部件，控制其他部件完成指令要求的操作。存储器 Memory：计算机中具有记忆能力的部件，用来存放程序或数据内存储器内存，又称主存，是CPU能根据地址线直接寻址的存储空间，是计算机内部存放数据的硬件设备，是程序和数据存储的基本要素。外存储器外存，又称辅存，作为一种辅助存储设备，主要用来存放一些暂时不用而又需长期保存的程序或数据。输入设备 Input Device用来输入程序和数据的部件：常用的输入设备有键盘，鼠标，传声器（麦克风），扫描仪，手写板，数码相机，摄像头等。输出设备 Output Device显示输出结果的部件 显示器，音响，打印机，绘图仪。软件系统系统软件管理，监控，维护计算机正常工作和供用户操作使用的计算机软件。应用软件在某种具体应用，供最终用户使用的软件。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas函数]]></title>
    <url>%2F2019%2F08%2F25%2Fpandas%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[【python】Pandas中DataFrame基本函数整理构造函数DataFrame([data, index, columns, dtype, copy]) #构造数据框1属性和数据DataFrame.axes #index: 行标签；columns: 列标签DataFrame.as_matrix([columns]) #转换为矩阵DataFrame.dtypes #返回数据的类型DataFrame.ftypes #返回每一列的 数据类型float64:denseDataFrame.get_dtype_counts() #返回数据框数据类型的个数DataFrame.get_ftype_counts() #返回数据框数据类型float64:dense的个数DataFrame.select_dtypes([include, include]) #根据数据类型选取子数据框DataFrame.values #Numpy的展示方式DataFrame.axes #返回横纵坐标的标签名DataFrame.ndim #返回数据框的纬度DataFrame.size #返回数据框元素的个数DataFrame.shape #返回数据框的形状DataFrame.memory_usage() #每一列的存储12345678910111213类型转换1234DataFrame.astype(dtype[, copy, errors]) #转换数据类型DataFrame.copy([deep]) #deep深度复制数据DataFrame.isnull() #以布尔的方式返回空值DataFrame.notnull() #以布尔的方式返回非空值1234索引和迭代123456789101112131415161718DataFrame.head([n]) #返回前n行数据DataFrame.at #快速标签常量访问器DataFrame.iat #快速整型常量访问器DataFrame.loc #标签定位，使用名称DataFrame.iloc #整型定位，使用数字DataFrame.insert(loc, column, value) #在特殊地点loc[数字]插入column[列名]某列数据DataFrame.iter() #Iterate over infor axisDataFrame.iteritems() #返回列名和序列的迭代器DataFrame.iterrows() #返回索引和序列的迭代器DataFrame.itertuples([index, name]) #Iterate over DataFrame rows as namedtuples, with index value as first element of the tuple.DataFrame.lookup(row_labels, col_labels) #Label-based “fancy indexing” function for DataFrame.DataFrame.pop(item) #返回删除的项目DataFrame.tail([n]) #返回最后n行DataFrame.xs(key[, axis, level, drop_level]) #Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.DataFrame.isin(values) #是否包含数据框中的元素DataFrame.where(cond[, other, inplace, …]) #条件筛选DataFrame.mask(cond[, other, inplace, …]) #Return an object of same shape as self and whose corresponding entries are from self where cond is False and otherwise are from other.DataFrame.query(expr[, inplace]) #Query the columns of a frame with a boolean expression.123456789101112131415161718二元运算123456789101112131415161718192021222324DataFrame.add(other[,axis,fill_value]) #加法，元素指向DataFrame.sub(other[,axis,fill_value]) #减法，元素指向DataFrame.mul(other[, axis,fill_value]) #乘法，元素指向DataFrame.div(other[, axis,fill_value]) #小数除法，元素指向DataFrame.truediv(other[, axis, level, …]) #真除法，元素指向DataFrame.floordiv(other[, axis, level, …]) #向下取整除法，元素指向DataFrame.mod(other[, axis,fill_value]) #模运算，元素指向DataFrame.pow(other[, axis,fill_value]) #幂运算，元素指向DataFrame.radd(other[, axis,fill_value]) #右侧加法，元素指向DataFrame.rsub(other[, axis,fill_value]) #右侧减法，元素指向DataFrame.rmul(other[, axis,fill_value]) #右侧乘法，元素指向DataFrame.rdiv(other[, axis,fill_value]) #右侧小数除法，元素指向DataFrame.rtruediv(other[, axis, …]) #右侧真除法，元素指向DataFrame.rfloordiv(other[, axis, …]) #右侧向下取整除法，元素指向DataFrame.rmod(other[, axis,fill_value]) #右侧模运算，元素指向DataFrame.rpow(other[, axis,fill_value]) #右侧幂运算，元素指向DataFrame.lt(other[, axis, level]) #类似Array.ltDataFrame.gt(other[, axis, level]) #类似Array.gtDataFrame.le(other[, axis, level]) #类似Array.leDataFrame.ge(other[, axis, level]) #类似Array.geDataFrame.ne(other[, axis, level]) #类似Array.neDataFrame.eq(other[, axis, level]) #类似Array.eqDataFrame.combine(other,func[,fill_value, …]) #Add two DataFrame objects and do not propagate NaN values, so if for aDataFrame.combine_first(other) #Combine two DataFrame objects and default to non-null values in frame calling the method.123456789101112131415161718192021222324函数应用&amp;分组&amp;窗口12345678DataFrame.apply(func[, axis, broadcast, …]) #应用函数DataFrame.applymap(func) #Apply a function to a DataFrame that is intended to operate elementwise, i.e.DataFrame.aggregate(func[, axis]) #Aggregate using callable, string, dict, or list of string/callablesDataFrame.transform(func, *args, **kwargs) #Call function producing a like-indexed NDFrameDataFrame.groupby([by, axis, level, …]) #分组DataFrame.rolling(window[, min_periods, …]) #滚动窗口DataFrame.expanding([min_periods, freq, …]) #拓展窗口DataFrame.ewm([com, span, halflife, …]) #指数权重窗口12345678描述统计学12345678910111213141516171819202122232425262728293031323334DataFrame.abs() #返回绝对值DataFrame.all([axis, bool_only, skipna]) #Return whether all elements are True over requested axisDataFrame.any([axis, bool_only, skipna]) #Return whether any element is True over requested axisDataFrame.clip([lower, upper, axis]) #Trim values at input threshold(s).DataFrame.clip_lower(threshold[, axis]) #Return copy of the input with values below given value(s) truncated.DataFrame.clip_upper(threshold[, axis]) #Return copy of input with values above given value(s) truncated.DataFrame.corr([method, min_periods]) #返回本数据框成对列的相关性系数DataFrame.corrwith(other[, axis, drop]) #返回不同数据框的相关性DataFrame.count([axis, level, numeric_only]) #返回非空元素的个数DataFrame.cov([min_periods]) #计算协方差DataFrame.cummax([axis, skipna]) #Return cumulative max over requested axis.DataFrame.cummin([axis, skipna]) #Return cumulative minimum over requested axis.DataFrame.cumprod([axis, skipna]) #返回累积DataFrame.cumsum([axis, skipna]) #返回累和DataFrame.describe([percentiles,include, …]) #整体描述数据框DataFrame.diff([periods, axis]) #1st discrete difference of objectDataFrame.eval(expr[, inplace]) #Evaluate an expression in the context of the calling DataFrame instance.DataFrame.kurt([axis, skipna, level, …]) #返回无偏峰度Fisher’s (kurtosis of normal == 0.0).DataFrame.mad([axis, skipna, level]) #返回偏差DataFrame.max([axis, skipna, level, …]) #返回最大值DataFrame.mean([axis, skipna, level, …]) #返回均值DataFrame.median([axis, skipna, level, …]) #返回中位数DataFrame.min([axis, skipna, level, …]) #返回最小值DataFrame.mode([axis, numeric_only]) #返回众数DataFrame.pct_change([periods, fill_method]) #返回百分比变化DataFrame.prod([axis, skipna, level, …]) #返回连乘积DataFrame.quantile([q, axis, numeric_only]) #返回分位数DataFrame.rank([axis, method, numeric_only]) #返回数字的排序DataFrame.round([decimals]) #Round a DataFrame to a variable number of decimal places.DataFrame.sem([axis, skipna, level, ddof]) #返回无偏标准误DataFrame.skew([axis, skipna, level, …]) #返回无偏偏度DataFrame.sum([axis, skipna, level, …]) #求和DataFrame.std([axis, skipna, level, ddof]) #返回标准误差DataFrame.var([axis, skipna, level, ddof]) #返回无偏误差 12345678910111213141516171819202122232425262728293031323334从新索引&amp;选取&amp;标签操作12345678910111213141516171819202122232425DataFrame.add_prefix(prefix) #添加前缀DataFrame.add_suffix(suffix) #添加后缀DataFrame.align(other[, join, axis, level]) #Align two object on their axes with theDataFrame.drop(labels[, axis, level, …]) #返回删除的列DataFrame.drop_duplicates([subset, keep, …]) #Return DataFrame with duplicate rows removed, optionally onlyDataFrame.duplicated([subset, keep]) #Return boolean Series denoting duplicate rows, optionally onlyDataFrame.equals(other) #两个数据框是否相同DataFrame.filter([items, like, regex, axis]) #过滤特定的子数据框DataFrame.first(offset) #Convenience method for subsetting initial periods of time series data based on a date offset.DataFrame.head([n]) #返回前n行DataFrame.idxmax([axis, skipna]) #Return index of first occurrence of maximum over requested axis.DataFrame.idxmin([axis, skipna]) #Return index of first occurrence of minimum over requested axis.DataFrame.last(offset) #Convenience method for subsetting final periods of time series data based on a date offset.DataFrame.reindex([index, columns]) #Conform DataFrame to new index with optional filling logic, placing NA/NaN in locations having no value in the previous index.DataFrame.reindex_axis(labels[, axis, …]) #Conform input object to new index with optional filling logic, placing NA/NaN in locations having no value in the previous index.DataFrame.reindex_like(other[, method, …]) #Return an object with matching indices to myself.DataFrame.rename([index, columns]) #Alter axes input function or functions.DataFrame.rename_axis(mapper[, axis, copy]) #Alter index and / or columns using input function or functions.DataFrame.reset_index([level, drop, …]) #For DataFrame with multi-level index, return new DataFrame with labeling information in the columns under the index names, defaulting to ‘level_0’, ‘level_1’, etc.DataFrame.sample([n, frac, replace, …]) #返回随机抽样DataFrame.select(crit[, axis]) #Return data corresponding to axis labels matching criteriaDataFrame.set_index(keys[, drop, append ]) #Set the DataFrame index (row labels) using one or more existing columns.DataFrame.tail([n]) #返回最后几行DataFrame.take(indices[, axis, convert]) #Analogous to ndarray.takeDataFrame.truncate([before, after, axis ]) #Truncates a sorted NDFrame before and/or after some particular index value.12345678910111213141516171819202122232425处理缺失值123DataFrame.dropna([axis, how, thresh, …]) #Return object with labels on given axis omitted where alternately anyDataFrame.fillna([value, method, axis, …]) #填充空值DataFrame.replace([to_replace, value, …]) #Replace values given in ‘to_replace’ with ‘value’.123从新定型&amp;排序&amp;转变形态1234567891011121314DataFrame.pivot([index, columns, values]) #Reshape data (produce a “pivot” table) based on column values.DataFrame.reorder_levels(order[, axis]) #Rearrange index levels using input order.DataFrame.sort_values(by[, axis, ascending]) #Sort by the values along either axisDataFrame.sort_index([axis, level, …]) #Sort object by labels (along an axis)DataFrame.nlargest(n, columns[, keep]) #Get the rows of a DataFrame sorted by the n largest values of columns.DataFrame.nsmallest(n, columns[, keep]) #Get the rows of a DataFrame sorted by the n smallest values of columns.DataFrame.swaplevel([i, j, axis]) #Swap levels i and j in a MultiIndex on a particular axisDataFrame.stack([level, dropna]) #Pivot a level of the (possibly hierarchical) column labels, returning a DataFrame (or Series in the case of an object with a single level of column labels) having a hierarchical index with a new inner-most level of row labels.DataFrame.unstack([level, fill_value]) #Pivot a level of the (necessarily hierarchical) index labels, returning a DataFrame having a new level of column labels whose inner-most level consists of the pivoted index labels.DataFrame.melt([id_vars, value_vars, …]) #“Unpivots” a DataFrame from wide format to long format, optionallyDataFrame.T #Transpose index and columnsDataFrame.to_panel() #Transform long (stacked) format (DataFrame) into wide (3D, Panel) format.DataFrame.to_xarray() #Return an xarray object from the pandas object.DataFrame.transpose(*args, **kwargs) #Transpose index and columns1234567891011121314Combining&amp; joining&amp;merging12345DataFrame.append(other[, ignore_index, …]) #追加数据DataFrame.assign(**kwargs) #Assign new columns to a DataFrame, returning a new object (a copy) with all the original columns in addition to the new ones.DataFrame.join(other[, on, how, lsuffix, …]) #Join columns with other DataFrame either on index or on a key column.DataFrame.merge(right[, how, on, left_on, …]) #Merge DataFrame objects by performing a database-style join operation by columns or indexes.DataFrame.update(other[, join, overwrite, …]) #Modify DataFrame in place using non-NA values from passed DataFrame.12345时间序列12345678910DataFrame.asfreq(freq[, method, how, …]) #将时间序列转换为特定的频次DataFrame.asof(where[, subset]) #The last row without any NaN is taken (or the last row withoutDataFrame.shift([periods, freq, axis]) #Shift index by desired number of periods with an optional time freqDataFrame.first_valid_index() #Return label for first non-NA/null valueDataFrame.last_valid_index() #Return label for last non-NA/null valueDataFrame.resample(rule[, how, axis, …]) #Convenience method for frequency conversion and resampling of time series.DataFrame.to_period([freq, axis, copy]) #Convert DataFrame from DatetimeIndex to PeriodIndex with desiredDataFrame.to_timestamp([freq, how, axis]) #Cast to DatetimeIndex of timestamps, at beginning of periodDataFrame.tz_convert(tz[, axis, level, copy]) #Convert tz-aware axis to target time zone.DataFrame.tz_localize(tz[, axis, level, …]) #Localize tz-naive TimeSeries to target time zone.12345678910作图1234567891011121314DataFrame.plot([x, y, kind, ax, ….]) #DataFrame plotting accessor and methodDataFrame.plot.area([x, y]) #面积图Area plotDataFrame.plot.bar([x, y]) #垂直条形图Vertical bar plotDataFrame.plot.barh([x, y]) #水平条形图Horizontal bar plotDataFrame.plot.box([by]) #箱图BoxplotDataFrame.plot.density(**kwds) #核密度Kernel Density Estimate plotDataFrame.plot.hexbin(x, y[, C, …]) #Hexbin plotDataFrame.plot.hist([by, bins]) #直方图HistogramDataFrame.plot.kde(**kwds) #核密度Kernel Density Estimate plotDataFrame.plot.line([x, y]) #线图Line plotDataFrame.plot.pie([y]) #饼图Pie chartDataFrame.plot.scatter(x, y[, s, c]) #散点图Scatter plotDataFrame.boxplot([column, by, ax, …]) #Make a box plot from DataFrame column optionally grouped by some columns orDataFrame.hist(data[, column, by, grid, …]) #Draw histogram of the DataFrame’s series using matplotlib / pylab.1234567891011121314转换为其他格式123456789101112131415161718192021DataFrame.from_csv(path[, header, sep, …]) #Read CSV file (DEPRECATED, please use pandas.read_csv() instead).DataFrame.from_dict(data[, orient, dtype]) #Construct DataFrame from dict of array-like or dictsDataFrame.from_items(items[,columns,orient]) #Convert (key, value) pairs to DataFrame.DataFrame.from_records(data[, index, …]) #Convert structured or record ndarray to DataFrameDataFrame.info([verbose, buf, max_cols, …]) #Concise summary of a DataFrame.DataFrame.to_pickle(path[, compression, …]) #Pickle (serialize) object to input file path.DataFrame.to_csv([path_or_buf, sep, na_rep]) #Write DataFrame to a comma-separated values (csv) fileDataFrame.to_hdf(path_or_buf, key, **kwargs) #Write the contained data to an HDF5 file using HDFStore.DataFrame.to_sql(name, con[, flavor, …]) #Write records stored in a DataFrame to a SQL database.DataFrame.to_dict([orient, into]) #Convert DataFrame to dictionary.DataFrame.to_excel(excel_writer[, …]) #Write DataFrame to an excel sheetDataFrame.to_json([path_or_buf, orient, …]) #Convert the object to a JSON string.DataFrame.to_html([buf, columns, col_space]) #Render a DataFrame as an HTML table.DataFrame.to_feather(fname) #write out the binary feather-format for DataFramesDataFrame.to_latex([buf, columns, …]) #Render an object to a tabular environment table.DataFrame.to_stata(fname[, convert_dates, …]) #A class for writing Stata binary dta files from array-like objectsDataFrame.to_msgpack([path_or_buf, encoding]) #msgpack (serialize) object to input file pathDataFrame.to_sparse([fill_value, kind]) #Convert to SparseDataFrameDataFrame.to_dense() #Return dense representation of NDFrame (as opposed to sparse)DataFrame.to_string([buf, columns, …]) #Render a DataFrame to a console-friendly tabular output.DataFrame.to_clipboard([excel, sep]) #Attempt to write text representation of object to the system cli]]></content>
      <categories>
        <category>python数据挖掘</category>
      </categories>
      <tags>
        <tag>pandas函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[妹子图爬虫（爬取妹子图图片）]]></title>
    <url>%2F2019%2F07%2F22%2Fpython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[python实现妹子图爬虫（爬取妹子网图片）一个简单的小爬虫实现爬取妹子图网站上的图片。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#coding=utf-8import requestsfrom bs4 import BeautifulSoupimport osall_url = 'http://www.mzitu.com'#http请求头Hostreferer = &#123; 'User-Agent':'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)', 'Referer':'http://www.mzitu.com' &#125;Picreferer = &#123; 'User-Agent':'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)', 'Referer':'http://i.meizitu.net'&#125;#此请求头破解盗链start_html = requests.get(all_url,headers = Hostreferer)#保存地址path = "D:\\mzitu\\"#找寻最大页数soup = BeautifulSoup(start_html.text,"html.parser")page = soup.find_all('a',class_='page-numbers')max_page = page[-2].textsame_url = 'http://www.mzitu.com/all/'for n in range(1,int(max_page)+1): ul = same_url+str(n) start_html = requests.get(ul, headers = Hostreferer) soup = BeautifulSoup(start_html.text,"html.parser") all_a = soup.find('div',class_='all').find_all('a',target='_blank') for a in all_a: title = a.get_text() #提取文本 if(title != ''): print("准备扒取："+title) #win不能创建带？的目录 if(os.path.exists(path+title.strip().replace('?',''))): #print('目录已存在') flag=1 else: os.makedirs(path+title.strip().replace('?','').replace(':', '')) flag=0 os.chdir(path + title.strip().replace('?','').replace(':', '')) href = a['href'] html = requests.get(href,headers = Hostreferer) mess = BeautifulSoup(html.text,"html.parser") pic_max = mess.find_all('span') try: pic_max = pic_max[9].text #最大页数 if(flag == 1 and len(os.listdir(path+title.strip().replace('?',''))) &gt;= int(pic_max)): print('已经保存完毕，跳过') continue for num in range(1, int(pic_max)+1): pic = href+'/'+str(num) html = requests.get(pic,headers = Hostreferer) mess = BeautifulSoup(html.text,"html.parser") pic_url = mess.find('img',alt = title) print(pic_url['src']) #exit(0) html = requests.get(pic_url['src'],headers = Picreferer) file_name = pic_url['src'].split(r'/')[-1] f = open(file_name,'wb') f.write(html.content) f.close() except Exception: pass print('完成 ') print('第',n,'页完成')原文参考：https://blog.csdn.net/baidu_35085676/article/details/68958267]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>爬虫实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据之Hadoop]]></title>
    <url>%2F2019%2F07%2F14%2Fhadoop%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Hadoop介绍组成部分Hadoop主要由3部分组成：Mapreduce编程模型HDFS分布式文件存储YARN配置信息管理员密码：admin123DNS1=202.103.24.68DNS2=202.103.44.150export HADOOP_HOME=/usr/local/hadoop-2.6.4export PATH=$HADOOP_HOME/bin$PATH:/usr/java/jdk1.8.0_201-amd64/binHadoop HDFS 简介概念：namenode：负责记录 数据块 的分布情况– 数据元数据信息datanode:负责实际存储 数据块block：是Hadoop最小存储数据单位 默认 128Msecondarynamenode: 辅助namenode完成fsimage管理或者优化HDFS简单命令hadoop version //查看版本hadoop fs //文件系统客户端hadoop jar //运行jar包hadoop classpath //查看类路径hadoop checknative //检查本地库并压缩hadoop distcp // 远程递归拷贝文件hadoop credential //认证hadoop trace //跟踪$ hdfs dfs -mkdir-p /user/ubuntu/ //在hdfs上建立文件夹$ hdfs dfs -puthdfs.cmd /user/ubuntu/ //将本地文件上传到HDFS$ hdfs dfs -get/user/ubuntu/hadoop.cmd a.cmd //将文件从HDFS取回本地$ hdfs dfs -rm -r -f /user/ubuntu/ //删除$ hdfs dfs -ls -R/ //递归展示HDFS文件系统一、hadoop所在目录cd usr/local/hadoop1二、启动hadoopbash ./starth.sh% 运行start-dfs.sh% 运行start-yarn.sh123启动dfs，浏览器查看：172.16.31.17:500701启动脚本，浏览器查看：172.16.31.17:80881停止脚本：bash ./stoph.sh1三、常用命令1.显示hadoop目录结构hdfs dfs -ls -R /12.在hadoop指定目录内创建新目录hdfs dfs -mkdir /winnie13.将本地文件夹存储至hadoophdfs dfs -put [本地目录] [hadoop目录]14.将本地文件存储至hadoophdfs dfs -put [本地地址] [hadoop目录]15.查看指定目录下内容hdfs dfs -ls [文件目录]16.打开某个已存在文件hdfs dfs -cat [file_path]17.在hadoop指定目录下新建一个空文件hdfs dfs -touchz /winnie/test03.txt18.将hadoop上某个文件重命名hdfs dfs -mv /winnie/test03.txt /winnie/test.txt19.将hadoop上某个文件down至本地已有目录下hdfs dfs -get [文件目录] [本地目录]110.将hadoop指定目录下所有内容保存为一个文件，同时down至本地hdfs dfs -getmerge /winnie/hadoop-file /home/spark/hadoop-file/test.txt111.删除hadoop上指定文件hdfs dfs -rm [文件地址]112.删除hadoop上指定文件夹（包含子目录等）hdfs dfs -rm -r [目录地址]hdfs dfs -rmr [目录地址]1213.将正在运行的hadoop作业kill掉hadoop job -kill [job-id]114.查看帮助hdfs dfs -help1四、安全模式1.退出安全模式NameNode在启动时会自动进入安全模式，安全模式是NameNode的一种状态，在这个阶段，文件系统不允许有任何修改。系统显示Name node in safe mode，说明系统正处于安全模式，这时只需要等待几十秒即可，也可通过下面的命令退出安全模式：/usr/local/hadoop$bin/hadoop dfsadmin -safemode leave12.进入安全模式在必要情况下，可以通过以下命令吧HDFS置于安全模式：/usr/local/hadoop$bin/hadoop dfsadmin -safemode enter1五、补充1.对hdfs操作的命令格式是hdfs dfs1.1 -ls 表示对hdfs下一级目录的查看1.2 -lsr 表示对hdfs目录的递归查看1.3 -mkdir 创建目录1.4 -put 从Linux上传文件到hdfs1.5 -get 从hdfs下载文件到linux1.6 -text 查看文件内容1.7 -rm 表示删除文件1.7 -rmr 表示递归删除文件2.hdfs在对数据存储进行block划分时，如果文件大小超过block，那么按照block大小进行划分；不如block size的，划分为一个块，是实际数据大小。3.hadoop常用命令：hdfs dfs 查看Hadoop HDFS支持的所有命令hdfs dfs –ls 列出目录及文件信息hdfs dfs –lsr 循环列出目录、子目录及文件信息hdfs dfs –tail /user/sunlightcs/test.txt 查看最后1KB的内容hdfs dfs –copyFromLocal test.txt /user/sunlightcs/test.txt 从本地文件系统复制文件到HDFS文件系统，等同于put命令hdfs dfs –copyToLocal /user/sunlightcs/test.txt test.txt 从HDFS文件系统复制文件到本地文件系统，等同于get命令hdfs dfs –chgrp [-R] /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录所属群组，选项-R递归执行，跟linux命令一样hdfs dfs –chown [-R] /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录拥有者，选项-R递归执行hdfs dfs –chmod [-R] MODE /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录权限，MODE可以为相应权限的3位数或+/-{rwx}，选项-R递归执行hdfs dfs –count [-q] PATH 查看PATH目录下，子目录数、文件数、文件大小、文件名/目录名hdfs dfs –cp SRC [SRC …] DST 将文件从SRC复制到DST，如果指定了多个SRC，则DST必须为一个目录hdfs dfs –du PATH 显示该目录中每个文件或目录的大小hdfs dfs –dus PATH 类似于du，PATH为目录时，会显示该目录的总大小hdfs dfs –expunge 清空回收站，文件被删除时，它首先会移到临时目录.Trash/中，当超过延迟时间之后，文件才会被永久删除hdfs dfs –getmerge SRC [SRC …] LOCALDST [addnl] 获取由SRC指定的所有文件，将它们合并为单个文件，并写入本地文件系统中的LOCALDST，选项addnl将在每个文件的末尾处加上一个换行符hdfs dfs –test –[ezd] PATH 对PATH进行如下类型的检查：-e PATH是否存在，如果PATH存在，返回0，否则返回1；-z 文件是否为空，如果长度为0，返回0，否则返回1； -d 是否为目录，如果PATH为目录，返回0，否则返回1hdfs dfs –text PATH 显示文件的内容，当文件为文本文件时，等同于cat；文件为压缩格式（gzip以及hadoop的二进制序列文件格式）时，会先解压缩hdfs dfs –help ls 查看某个[ls]命令的帮助文档Mapreduce解释mapper的角色:hadoop将用户提交的mapper可执行程序或脚本作为一个单独的进程加载起来，这个进程我们称之为mapper进程，hadoop不断地将文件片段转换为行，传递到我们的mapper进程中，mapper进程通过标准输入的方式一行一行地获取这些数据，然后设法将其转换为键值对，再通过标准输出的形式将这些键值对按照一对儿一行的方式输出出去。虽然在我们的mapper函数中，我们自己能分得清key/value(比方说有可能在我们的代码中使用的是string key,int value)，但是当我们采用标准输出之后，key value是打印到一行作为结果输出的(比如sys.stdout.write(“%s\t%s\n”%(birthyear,gender)))，因此我们为了保证hadoop能从中鉴别出我们的键值对，键值对中一定要以分隔符’\t’即Tab(也可自定义分隔符)字符分隔，这样才能保证hadoop正确地为我们进行partitoner、shuffle等等过程。reducer的角色:hadoop将用户提交的reducer可执行程序或脚本同样作为一个单独的进程加载起来，这个进程我们称之为reducer进程，hadoop不断地将键值对(按键排序)按照一对儿一行的方式传递到reducer进程中，reducer进程同样通过标准输入的方式按行获取这些键值对儿，进行自定义计算后将结果通过标准输出的形式输出出去。在reducer这个过程中需要注意的是：传递进reducer的键值对是按照键排过序的，这点是由MR框架的sort过程保证的，因此如果读到一个键与前一个键不同，我们就可以知道当前key对应的pairs已经结束了，接下来将是新的key对应的pairs。]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop介绍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据科学之统计学习]]></title>
    <url>%2F2019%2F07%2F14%2F%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[统计学中心倾向均值（常用的额）中位数分位数：它表示少于数据中特定百分比的一个值众数离散度极差方差统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数概率论中方差用来度量随机变量)和其数学期望（即均值）之间的偏离程度计算公式$$s^2 = \frac{\sum_{}(x-u)^2}{N}$$标准差中文环境中又常称均方差，是离均差平方的算术平均数的平方根，用σ表示。标准差是方差的算术平方根计算公式$$σ = \sqrt\frac{\sum_{}(x-u)^2}{N}$$相关性协方差协方差（Covariance）在概率论和统计学中用于衡量两个变量的总体误差。而方差是协方差的一种特殊情况，即当两个变量是相同的情况。计算公式概率论不独立和独立如果事件E和事件F独立意味着两个事同时发生的概率等于它们分别发生的概率的乘积。$$P（E, F） = P(E)*P(F)$$条件概率如果事件E与事件F独立，那么定义：$$P（E, F） = P(E)*P(F)$$如果两者不一定独立（并且概率都不为0），那么概率公式为：（已知F发生，在此条件下E发生的概率）$$P（E|F） = P（E, F）/P（F）$$]]></content>
      <categories>
        <category>统计学和概率论</category>
      </categories>
      <tags>
        <tag>数学知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之百度接口语音识别]]></title>
    <url>%2F2019%2F07%2F12%2F%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[python编程之百度接口语音识别首先在百度AI开放平台上创建语音识别应用，创建完毕应用后，得到系统分配给用户的AppID， API Key， secret Key，均为字符串，用于标识用户，为访问做签名验证。得到验证后，开始编程1.记录自己声音2.将记录下来的音频文件上传至云端3.解析返回后的结果python实现相关包 pyaudio，baidu-aip123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from aip import AipSpeechimport wavefrom pyaudio import PyAudio, paInt16def save_wave_file(filename, data): '''save the date to the wavfile''' wf = wave.open(filename, 'wb') wf.setnchannels(channels) wf.setsampwidth(sampwidth) wf.setframerate(framerate) wf.writeframes(b"".join(data)) wf.close()def my_record(): pa = PyAudio() stream = pa.open(format=paInt16, channels=1, rate=framerate, input=True, frames_per_buffer=NUM_SAMPLES) my_buf = [] count = 0 print('录音开始') while count &lt; TIME*10: # 控制录音时间 string_audio_data = stream.read(NUM_SAMPLES) my_buf.append(string_audio_data) count += 1 print('录音结束') save_wave_file('01.pcm', my_buf) stream.close()if __name__ == "__main__": framerate = 16000 NUM_SAMPLES = 2000 channels = 1 sampwidth = 2 TIME = 2 my_record() """ 我的 APPID AK SK """ APP_ID = '16795182 ' API_KEY = '8io5s7uv8pjYPUrQp1i8PcIg' SECRET_KEY = 'gK2MljvbcF3SKS4p0C2ieq1SCBNY48BD' client = AipSpeech(APP_ID, API_KEY, SECRET_KEY) # 读取文件 def get_file_content(filePath): with open(filePath, 'rb') as fp: return fp.read() # 识别本地文件 result = client.asr(get_file_content('01.pcm'), 'pcm', 16000, &#123; 'dev_pid': 1536, &#125;) # print(type(result)) print("语音识别结果：", result['result'])]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>语音识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据科学之数据可视化]]></title>
    <url>%2F2019%2F07%2F11%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数据可视化概述可视化的目的，是对数据进行可视化处理，以更明确地，有效的传递信息。数据可视化意义数据可视化是为了从数据中寻找三个方面的信息。模式。指数据中的规律。关系。指数据间的相关性。数据间的比较数据的构成数据的分布或联系异常。指有问题的数据。数据可视化的作用记录信息。用图形的方式描述各种具体或抽象的事物。分析推理。有效的提升了信息认知的效率，从而有助于人们更快地分析和推理出有效信息。信息传播和协同。数据可视化的分类科学可视化信息可视化可视分析学数据可视化基础数据类型根据数据模型，可将数据分为浮点数，整数，字符等根据概念模型类别型数据，有序型数据，区间型数据和比值型数据类别型数据：用于区分物体有序型数据：用来表示对象间的顺序关系区间型数据：用于得到对象间的定量关系。用于比较数值间的比列关系，可以精确地定义比例数据预处理数据的预处理的目的是提升数据质量数据质量包含以下六方面有效性：数据与实际情况对应时，是否违背约束条件准确性：数据能否精确的反映现实。完整性：采集数据集是否包含了数据源中 的所有数据点：且样本的属性都是完整的。一致性：整个数据集中的数据的衡量标准要一致时效性：数据适合当下时间区间内的分析任务可行性：数据源中的数据是使用者可依赖的。数据预处理步骤如下数据清理：指修正数据中的错误，识别脏数据，更正不一致数据的过程。数据集成：指把来自不同数据的同类数据进行合并，减少数据冲突，降低数据冗余程度等。数据归约：指在保证数据挖掘结果准确性的前提下，最大限度地精简数据量，得到简化的数据集。数据转换：指对数据进行规范化处理数据组织与管理大数据存储利用的是分布式存储与访问计数，它具有高效，容错性强等特点。分布式文件系统分布式文件系统是指文件在物理上可能被分散存储在不同地点的节点上，各节点通过计算机网络进行通信和数据传输，但仍然是一个完整的文件。常用的分布式系统有HDFS（hadoop分布式文件系统），GFS（Google分布式文件系统）等。文档存储文档存储支持对结构化数据的访问，一般以键值对的方式进行存储。文档存储类型也支持数组和列值键列式存储列式存储是指以流的方式在列中存储所有的数据键式存储以Key-Value存储，简称KV存储图形数据库图形数据库是NOSQL数据库的一种，是一种非关系型的数据库，它应用图形理论存储实体间的关系信息。关系型数据库关系模型是最传统的数据存储模型，数据按行存储在有架构界定的表中。用户可使用基于关系代数演算的结构化查询语言提供相应的语法查找符合条件的记录。内存数据库内存数据库就是将数据放在内存中直接操作的数据库。特点速度快，能处理实时型业务数据仓库数据仓库是一种特殊的数据库，一般用于存储海量数据，并直接支持后续的分析和决策操作。数据分析与数据挖掘数据分析统计分析是指对数据进行统计描述和统计推断的过程探索性数据分析是对调查，观测所得到的一些初步的杂乱无章的数据，在尽量少的先验假设下进行处理，通过作图，制表等形式和方程拟合，计算某些特征量等手段，探索数据的结构和规律的一种数据分析方法。验证性数据分析是指在已经有事先假设的关系模型等情况下，通过数据分析来验证已提出的假设在线分析和处理是一种交互式探索大规模多维数据集的方法。数据挖掘数据挖掘一般是指从大量的数据中通过算法搜索隐藏于其中的信息的过程。常见的数据挖掘分析方法有分类与预测，聚类分析，关联性分析和异常分析等。分类与预测聚类分析关联分析异常分析数据挖掘的步骤确定业务对象数据准备数据挖掘结果分析知识的同化]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>数据可视化概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站概念]]></title>
    <url>%2F2019%2F07%2F06%2Fserven%2F</url>
    <content type="text"><![CDATA[网站的组成目前多数网站由域名，空间服务器，DNS域名解析，网站程序和数据库等组成空间服务器（以下三种类型）虚拟主机：指在网络服务器上划分一定的磁盘空间供用户放置站点和应用组件等，提供必要的站点功能，数据存放和传输功能。所谓虚拟主机，也叫“网站空间”，就是把一台运行在互联网上的服务器划分成多个”虚拟“的服务器独立服务器：指性能更强大，整体硬件完全独立的服务器，其cpu都在8核以上。VPS（虚拟专用服务器）：将一个服务器分区成多个虚拟独立专享服务器的技术。网站的程序:是建设与修改网站所使用的编程语言。网站的分类资讯门户类网站企业品牌网站交易类网站B2C（Business To Consumer）网站：商家——消费者，主要是购物网站，用于商家和消费者之间的买卖，如传统的百货商店和购物广场。B2B（Business To Business）网站：商家——商家，主要是商务网站，用于商家之间的买卖，如传统的原材料市场和大型批发市场C2C（Consumer To Consumer）网站：消费者——消费者，主要以拍卖网站为主，用于个人的物品的买卖，如传统的旧货市场，跳骚市场，废品收购站等。办公及政府机构网站企业办公事物类网站政府办公类事物网站互动游戏网站功能性网站这类网站的主要特征是将一个具有广泛需求的共能扩展开来，开发一套强大的功能体系，将功能的实现推向极致。如：百度，goolge网站开发的常用术语域名：用于标识一个或多个ip地址DNS：域名系统，用于跟踪计算机的域名及其在互联网上的相应的IP地址]]></content>
      <categories>
        <category>网站知识</category>
      </categories>
      <tags>
        <tag>网站的基本概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法时间复杂度和五大经典排序算法]]></title>
    <url>%2F2019%2F06%2F29%2Fsix%2F</url>
    <content type="text"><![CDATA[渐进时间度表O记法所代表的是渐进上界限，Ω记法代表的是渐进下界Θ代表的集合是上述符号的交集，Θ(g) = O(g)常见的渐进运行时间实例时间复杂度相关名称相关实例及说明Θ（1）常数级哈希表的查询和修改Θ（lg n）对数级二分搜索，其对数基数并不重要Θ（n）线性级列表的遍历Θ(nlgn)线性对数级任意值序列的最优化排序，其复杂度等同于Θ(lg n!)Θ(n^2)平方级拿n个对象进行互相比对Θ(n^3)立方级Floyd-Warshall算法O(n^k)多项式级基于n的k层嵌套循环（k为整数），且必须满足K &gt; 0Ω(K^n)指数级每n项产生一个子集（其中k = 2），且必须满足K &gt; 1Θ(n!)阶乘级对n个值执行全排列操作冒泡排序冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 冒泡排序算法的运作如下： 1、比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。 2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 3、针对所有的元素重复以上的步骤，除了最后一个。 4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 ‘’’冒泡排序的时间复杂度为O(n^2)。1234567891011121314151617181920212223def store(x): '''冒泡排序算法实现''' f=0 while f &lt; len(x): i=0 j=1 while j &lt; len(x): if x[i] &lt;= x[j]: i = i + 1 j = j + 1 elif x[i] &gt; x[j]: var1 = x[i] var2 = x[j] x[j] = var1 x[i] = var2 i = i + 1 j = j + 1 f = f + 1 return xif __name__ == "__main__": test = [2,4,6,5,9,7,12,15,13,19,20,1,3] print(store(test))归并排序归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表， 即把待排序序列分为若干个子序列，每个子序列是有序的。 然后再把有序子序列合并为整体有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。123456789101112131415161718192021222324252627282930313233def merge_extend(x): '''归并排序算法''' # 拆分列表 if len(x) &lt;= 1: # 向下取整数 return x mid = len(x)//2 left = merge_extend(x[:mid]) right = merge_extend(x[mid:]) print(left,right) return merge_add(left, right)def merge_add(a, b): '''和并列表''' result = [] i = 0 j = 0 while i &lt; len(a) and j &lt; len(b): if a[i] &lt; b[j]: result.append(a[i]) i += 1 else: result.append(b[j]) j += 1 #print("a",a[i:]) #print("b",b[j:]) result.extend(a[i:]) result.extend(b[j:]) return resultif __name__ == "__main__": test=[11,0,5,7,3,6,8,1,2] print(merge_extend(test))插入排序插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列， 对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。简单插入排序的时间复杂度也是O(n^2)123456789101112def insert_sort(x): # 取列表的第一个元素为单独的一个，已经排好序的列表 for i in range(1, len(x)): # 要排序的的牌 for j in range(0, i): if x[i] &lt; x[j]: x[i], x[j] = x[j], x[i] return xif __name__=="__main__": test = [2,3,5,7,9,1,20,0,4,12,19,11,8,1] print(insert_sort(test))选择排序选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置， 然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。 选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上， 因此对n个元素的表进行排序总共进行至多n-1次交换。 在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。选择排序的时间复杂度为O(n^2)1234567891011def select_sort(x): '''选择排序''' new = [] while x: new.append(min(x)) x.remove(min(x)) return newif __name__=="__main__": test = [2,3,5,7,9,1,20,0,4,12,19,11,8,1] print(select_sort(test))快速排序1.先从待排序的数组中找出一个数作为基准数（取第一个数即可）， 2.然后将原来的数组划分成两部分：小于基准数的左子数组和大于等于基准数的右子数组。 3.然后对这两个子数组再递归重复上述过程，直到两个子数组的所有数都分别有序。 4.最后返回“左子数组” + “基准数” + “右子数组”，即是最终排序好的数组。快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)1234567891011121314151617def quick_sort(x): '''快速排序''' if len(x) &lt;= 1: return x base = x[0] left = [] right = [] for var in x: if var &gt; base: right.append(var) elif var &lt; base: left.append(var) return quick_sort(left) + [base] + quick_sort(right)if __name__ == "__main__": # 存在重复值被覆盖 test = [2,6,7,8,12,56,36,89,45,3]]]></content>
      <categories>
        <category>算法</category>
        <category>五大经典排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的正则表达式]]></title>
    <url>%2F2019%2F06%2F26%2Ffour%2F</url>
    <content type="text"><![CDATA[匹配小数1[0-9]&#123;1,&#125;[.][0-9]*匹配整数1[0-9]中文的匹配1[\u4e00-\u9fa5]特殊符号和字符：123456789101112131415161718192021[A-Z0-9a-z]: A,1,a[abc]*: aaa,abc,acc,匹配前面的正则0次或多次a？: a,匹配前面的出现正则0次或一次.： 匹配任意字符\n\t1,2.3,4,5.a,c.*: acb,aaa,weaijdiajdw,desd.*?: 非贪婪匹配\d: 匹配任何数字 [0-9]*:002121,5498464\s: 匹配任意空白符 \n\t\v\r\f\w: 匹配任何数字，字母，字符 [A-Za-z0-9][u4e00-u9fa5] ：匹配中文a|b a,b1|2 1,2&#123;int&#125;:指明正则出现的次数+：匹配前面出现的正则一次或多次?：0次或一次*：0次或多次^:匹配开头$:匹配结尾^$:空[^A-Z]: 除了A-Z都匹配匹配双字节字符(包括汉字在内)：1[^\x00-\xff]匹配空白行的正则表达式：1\n\s*\r匹配HTML标记的正则表达式：1&lt;(\s*?)[^&gt;]*&gt;.*?|&lt;.*?&gt;匹配首尾空白字符的正则表达式：1^\s*|\s*$匹配Email地址的正则表达式：1\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*匹配网址URL的正则表达式：1[a-zA-z]+://[^\s]*匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：1^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$匹配国内电话号码：1\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;匹配腾讯QQ号：1[1-9][0-9]&#123;4,&#125;匹配中国邮政编码：12[1-9]\d&#123;5&#125;(?!\d)评注：中国邮政编码为6位数字匹配身份证：12\d&#123;15&#125;|\d&#123;18&#125;评注：中国的身份证为15位或18位匹配ip地址：12\d+\.\d+\.\d+\.\d+评注：提取ip地址时有用匹配特定数字：1234567891011^[1-9]\d*$ //匹配正整数^-[1-9]\d*$ //匹配负整数^-?[1-9]\d*$ //匹配整数^[1-9]\d*|0$ //匹配非负整数（正整数 + 0）^-[1-9]\d*|0$ //匹配非正整数（负整数 + 0）^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ //匹配正浮点数^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ //匹配负浮点数^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ //匹配浮点数^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ //匹配非负浮点数（正浮点数 + 0）^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$ //匹配非正浮点数（负浮点数 + 0）评注：处理大量数据时有用，具体应用时注意修正匹配特定字符串：12345^[A-Za-z]+$ //匹配由26个英文字母组成的字符串^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串^[a-z]+$ //匹配由26个英文字母的小写组成的字符串^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串^\w+$ //匹配由数字、26个英文字母或者下划线组成的字符串]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解释器介绍]]></title>
    <url>%2F2019%2F06%2F26%2Fthree%2F</url>
    <content type="text"><![CDATA[CPython当我们从Python官方网站下载并安装好Python 3.x后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。IPythonIPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。CPython用&gt;&gt;&gt;作为提示符，而IPython用In [序号]:作为提示符。JpythonJython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。PyPyPyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术（just-in-time compiler 即时编译器，通俗解释就是边编译边执行），对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。、IronPythonIronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>python编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2019%2F06%2F23%2Ftow%2F</url>
    <content type="text"><![CDATA[Linux管理文件和目录的命令命令功能命令功能pwd显示当前目录ls查看目录下的内容cd改变所在目录cat显示文件的内容grep在文件中查找某字符cp复制文件touch创建文件mv移动文件rm删除文件rmdir删除目录pwd命令该命令的英文解释为print working directory(打印工作目录)。输入pwd命令，Linux会输出当前目录。cd命令cd命令用来改变所在目录。1234cd / 转到根目录中 cd ~ 转到/home/user用户目录下 cd /usr 转到根目录下的usr目录中-------------绝对路径 cd test 转到当前目录下的test子目录中-------相对路径ls命令​ ls命令用来查看目录的内容。选项含义-a列举目录中的全部文件，包括隐藏文件-l列举目录中的细节，包括权限、所有者、组群、大小、创建日期、文件是否是链接等-f列举的文件显示文件类型-r逆向，从后向前地列举目录中内容-R递归，该选项递归地列举当前目录下所有子目录内的内容-s大小，按文件大小排序-h以人类可读的方式显示文件的大小，如用K、M、G作单位ls -l examples.doc列举文件examples.doc的所有信息cat命令123cat命令可以用来合并文件，也可以用来在屏幕上显示整个文件的内容。cat snow.txt 该命令显示文件snow.txt的内容，ctrl+D退出cat。grep命令12345grep命令的最大功能是在一堆文件中查找一个特定的字符串。 grep money test.txt 以上命令在test.txt中查找money这个字符串，grep查找是区分大小写的touch命令​123touch命令用来创建新文件，他可以创建一个空白的文件，可以在其中添加文本和数据。 touch newfile 该命令创建一个名为newfile的空白文件。cp命令​ cp命令用来拷贝文件，要复制文件，输入命令：12cp &lt;source filename&gt; &lt;target filename&gt;cp t.txt Document/t 该命令将把文件t.txt复制到Document目录下，并命名为t。选项含义-i互动：如果文件将覆盖目标中的文件，他会提示确认-r递归：这个选项会复制整个目录树、子目录以及其他-v详细：显示文件的复制进度mv命令​ mv命令用来移动文件。选项说明-i互动：如果选择的文件会覆盖目标中的文件，他会提示确认-f强制：它会超越互动模式，不提示地移动文件，属于很危险的选项-v详细：显示文件的移动进度​ mv t.txt Document 把文件t.txt 移动到目录Document中。rm命令​ rm命令用来删除文件。选项说明-i互动：提示确认删除-f强制：代替互动模式，不提示确认删除-v详细：显示文件的删除进度-r递归：将删除某个目录以及其中所有的文件和子目录​ rm t.txt 该命令删除文件t.txtrmdir命令​ rmdir命令用来删除目录。mkdir 命令1234567#单个文件夹创建mkdir 文件夹名称#例如：mkdir wenjianjia#多个文件夹创建mkdirs 文件夹1/文件夹2......\#例如：mkdirs wenjianjia1/wenjianjia2chmod命令详解作用：改变一个或多个文件的存取模式(mode)格式：chmod [options] mode files只能文件属主或特权用户才能使用该功能来改变文件存取模式。mode：可以是数字形式或以who opcode permission形式表示。who是可选的，默认是a(所有用户)。只能选择一个opcode(操作码)。可指定多个mode，以逗号分开。综上，包含options、who、opcode、permission等选项，下面分别进行介绍options：标识含义-c，–changes只输出被改变文件的信息-f，–silent，–quiet当chmod不能改变文件模式时，不通知文件的用户–help输出帮助信息。-R，–recursive可递归遍历子目录，把修改应到目录下所有文件和子目录–reference=filename参照filename的权限来设置权限-v，–verbose无论修改是否成功，输出每个文件的信息–version输出版本信息who标识含义u用户g组o其它a所有用户(默认)opcode标识含义+增加权限-删除权限=重新分配权限permission标识含义r读w写x执行s设置用户(或组)的ID号t设置粘着位(sticky bit)，防止文件或目录被非属主删除作为选择，我们多数用三位八进制数字的形式来表示权限，第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限。如6(4+2)代表有读写权，7(4+2+1)有读、写和执行的权限。还可设置第四位，它位于三位权限序列的前面，第四位数字取值是4，2，1，代表意思如下：4，执行时设置用户ID，用于授权给基于文件属主的进程，而不是给创建此进程的用户。2，执行时设置用户组ID，用于授权给基于文件所在组的进程，而不是基于创建此进程的用户。1，设置粘着位。实例：12345678$ chmod u+x file 给file的属主增加执行权限$ chmod 751 file 给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限$ chmod u=rwx,g=rx,o=x file 上例的另一种形式$ chmod =r file 为所有用户分配读权限$ chmod 444 file 同上例$ chmod a-wx,a+r file 同上例$ chmod -R u+r directory 递归地给directory目录下所有文件和子目录的属主分配读的权限$ chmod 4755 设置用ID，给属主分配读、写和执行权限，给组和其他用户分配读、执行的权限。linux下链接ln –s 源文件 目标文件]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
</search>
