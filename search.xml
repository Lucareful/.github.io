<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Django参数和模板]]></title>
    <url>%2F2020%2F06%2F14%2FDjango%E5%8F%82%E6%95%B0%E5%92%8C%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[render方法参数request: 是一个固定参数。template_name: templates 中定义的文件, 要注意路径名. 比如’templates\polls\index.html’, 参数就要写‘polls\index.html’context: 要传入文件中用于渲染呈现的数据, 默认是字典格式content_type: 生成的文档要使用的MIME 类型。默认为DEFAULT_CONTENT_TYPE 设置的值。status: http的响应代码,默认是200.using: 用于加载模板使用的模板引擎的名称。request对象方法和属性request.scheme # 代表请求的方案,http或者httpsrequest.body# 原始HTTP请求主体为字节串。这对于以不同于常规HTML格式的方式处理数据很有用：二进制图像，XML有效负载等。对于处理常规格式的数据，请使用 HttpRequest.POST。request.path # 请求的路径,比如请求127.0.0.1/org/list,那这个值就是/org/listrequest.get_full_path() # 获取完整的请求路径request.method # 表示请求使用的http方法,GET或者POST请求request.encoding # 表示提交数据的编码方式request.GET # 获取GET请求request.POST # 获取post的请求,比如前端提交的用户密码,可以通过request.POST.get()来获取NOTICED：如果使用 POST 上传文件的话，文件信息将包含在 FILES 属性中request.COOKIES #包含所有的cookierequest.META #一个标准的Python 字典，包含所有的HTTP 首部。具体的头部信息取决于客户端和服务器，下面是一些示例：123456789101112131415CONTENT_LENGTH —— 请求的正文的长度（是一个字符串）。CONTENT_TYPE —— 请求的正文的MIME 类型。HTTP_ACCEPT —— 响应可接收的Content-Type。HTTP_ACCEPT_ENCODING —— 响应可接收的编码。HTTP_ACCEPT_LANGUAGE —— 响应可接收的语言。HTTP_HOST —— 客服端发送的HTTP Host 头部。HTTP_REFERER —— Referring 页面。HTTP_USER_AGENT —— 客户端的user-agent 字符串。QUERY_STRING —— 单个字符串形式的查询字符串（未解析过的形式）。REMOTE_ADDR —— 客户端的IP 地址。REMOTE_HOST —— 客户端的主机名。REMOTE_USER —— 服务器认证后的用户。REQUEST_METHOD —— 一个字符串，例如"GET" 或"POST"。SERVER_NAME —— 服务器的主机名。SERVER_PORT —— 服务器的端口（是一个字符串）request.user #一个 AUTH_USER_MODEL 类型的对象，表示当前登录的用户。如果用户当前没有登录，user 将设置为 django.contrib.auth.models.AnonymousUser 的一个实例。你可以通过 s_authenticated()区分它们把request传给前端的时候,前端可以通过 if request.user.is_authenticated判断用户时候登录request.session #一个既可读又可写的类似于字典的对象，表示当前的会话response对象Httpresponse对象对于 Httpreques对象来说，是由django自动创建的，但是， Httpresponse对象就必须我们自己创建。每个view请求处理方法必须返回一个 Httpresponse对象。Httpresponse类在djangohttpHttprespons在 Httpresponse对象上扩展的常用方法：页面渲染render()render to response()页面跳转：redirect(&quot;路径&quot;)locals()：可以直接将函数中所有的变里传给模板内置变量过滤器filter​ 可以理解为python中的内置函数，过滤器是模板的特有语法，通过前端来过滤部分数据。注意filter只能传递一个参数(也可以说是两个参数，因为第一个个参数已经固定，就是被处理的那个)。格式：1`&#123;&#123;` var|method:parameter`&#125;&#125;`method表示过滤器部分过滤器如下过滤器说明举例first取列表第一个元素last取列表最后元素capfirst首字母大写logging配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#下面就是logging的配置LOGGING = &#123; 'version': 1, # 指明dictConnfig的版本，目前就只有一个版本 'disable_existing_loggers': False, # 表示是否禁用所有的已经存在的日志配置 'formatters': &#123; # 格式器 'verbose': &#123; # 详细 'format': '%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s' &#125;, 'standard': &#123; # 标准 'format': '[%(asctime)s] [%(levelname)s] %(message)s' &#125;, &#125;, # handlers：用来定义具体处理日志的方式，可以定义多种，"default"就是默认方式，"console"就是打印到控制台方式。file是写入到文件的方式，注意使用的class不同 'handlers': &#123; # 处理器，在这里定义了两个个处理器 'console': &#123; 'level': 'DEBUG', 'class': 'logging.StreamHandler', 'stream': 'ext://sys.stdout', # 文件重定向的配置，将打印到控制台的信息都重定向出去 python manage.py runserver &gt;&gt; /home/aea/log/test.log # 'stream': open('/home/aea/log/test.log','a'), #虽然成功了，但是并没有将所有内容全部写入文件，目前还不清楚为什么 'formatter': 'standard' # 制定输出的格式，注意 在上面的formatters配置里面选择一个，否则会报错 &#125;, 'file': &#123; 'level': 'DEBUG', 'class': 'logging.FileHandler', 'filename': os.path.join(BASE_DIR,'debug.log'), #这是将普通日志写入到日志文件中的方法， 'formatter': 'standard' &#125;, 'default': &#123; 'level':'DEBUG', 'class':'logging.handlers.RotatingFileHandler', 'filename': os.path.join(BASE_DIR,'All.log'), #日志输出文件 'maxBytes': 1024*1024*5, #文件大小 'backupCount': 5, #备份份数 'formatter':'standard', #使用哪种formatters日志格式 &#125;, # 上面两种写入日志的方法是有区别的，前者是将控制台下输出的内容全部写入到文件中，这样做的好处就是我们在views代码中的所有print也会写在对应的位置 # 第二种方法就是将系统内定的内容写入到文件，具体就是请求的地址、错误信息等，小伙伴也可以都使用一下然后查看两个文件的异同。 &#125;, 'loggers': &#123; # log记录器，配置之后就会对应的输出日志 # django 表示就是django本身默认的控制台输出，就是原本在控制台里面输出的内容，在这里的handlers里的file表示写入到上面配置的file-/home/aea/log/jwt_test.log文件里面 # 在这里的handlers里的console表示写入到上面配置的console-/home/aea/log/test.log文件里面 'django': &#123; 'handlers': ['console','file'], # 这里直接输出到控制台只是请求的路由等系统console，当使用重定向之后会把所有内容输出到log日志 'level': 'DEBUG', 'propagate': True, &#125;, 'django.request ':&#123; 'handlers': ['console','file'], 'level': 'WARNING', # 配合上面的将警告log写入到另外一个文件 'propagate': True, &#125;, 'django.db.backends': &#123; 'handlers': ['file'], # 指定file handler处理器，表示只写入到文件 'level':'DEBUG', 'propagate': True, &#125;, &#125;,&#125;ORM的增删改查增加数据12345678910111213141516#方式一创建记录b = Book(name="python基础", price=99, author="luenci", pub_date="2020-06-14")b.save()#方法二创建数据Book.objects.create(name="python基础", price=99, author="luenci", pub_date="2020-06-14")# 便捷方法dic = &#123;'name': 'go基础','price': 99,'author': 'luenci','pub_date': '2020-06-13'&#125;Book.objects.create(**dic)更新数据1234567891011# 方法一：(推荐用)Book.objects.filter(author='luenci').update(price=100)# 方法二b = Book.objects.get(name='go基础')print(b) # &lt;QuerySet [&lt;Book: Book object (3)&gt;]b.price = 8.9b.save()print(type(b)) # &lt;class 'app01.models.Book'&gt;return HttpResponse("修改成功")删除数据1Book.objects.filter(name="go基础").delete()查找数据1234567891011121314151617181920212223242526272829# 获取所有对象book_list = Book.objects.all()# 对name去重book_list = Book.objects.all().values("name").distinct()# 统计book_list = Book.objects.all().values("name").distinct().count()# 查询的是对象的集合，即使只有一个对象也是集合的形式book_list = Book.objects.filter(author='luenci') book_list = Book.objects.first()book_list = Book.objects.last()# 指定查询到一个对象book_list = Book.objects.get(id=7)# 查询作者为luenci出版的书名.（字典的集合）book_list1 = Book.objects.filter(author='luenci').values('name', 'price') # 查询作者为luenci出版的书名.（列表的集合）book_list2 = Book.objects.filter(author='luenci').values_list('name', 'price')# &lt;QuerySet [&#123;'name': 'go基础', 'price': 99.0&#125;, &#123;'name': 'python基础', 'price': 99.0&#125;, &#123;'name': 'python基础', 'price': 66.0&#125;&gt;print(book_list1) #&lt;QuerySet [('go基础', 99.0), ('python基础', 99.0), ('python基础', 66.0), ('docker基础', 8.9)]&gt;print(book_list2)]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库引擎和数据类型]]></title>
    <url>%2F2020%2F06%2F07%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据库引擎介绍前言1、存储引擎其实就是对于数据库文件的一种存取机制，如何实现存储数据，如何为存储的数据建立索引以及如何更新，查询数据等技术实现的方法。2、MySQL中的数据用各种不同的技术存储在文件（或内存）中，这些技术中的每一种技术都使用不同的存储机制，索引技巧，锁定水平并且最终提供广泛的不同功能和能力。在MySQL中将这些不同的技术及配套的相关功能称为存储引擎。3、根据需求可以在表中设置不同的存储引擎。查看mysql中的引擎MySQL中常用的几种存储引擎1．MyISAM存储引擎存放的位置MySQL如果使用MyISAM存储引擎，数据库文件类型就包括.frm、.MYD、.MYI，默认存放位置是C:\Documentsand Settings\All Users\Application Data\MySQL\MySQL Server 5.1\data存放的方式MyISAM 这种存储引擎不支持事务，不支持行级锁，只支持并发插入的表锁，主要用于高负载的select。索引的方式MyISAM也是使用B+tree索引但是和Innodb的在具体实现上有些不同。该引擎基于ISAM数据库引擎，除了提供ISAM里所没有的索引和字段管理等大量功能，MyISAM还使用一种表格锁定的机制来优化多个并发的读写操作，但是需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间，否则碎片也会随之增加，最终影响数据访问性能。MyISAM还有一些有用的扩展，例如用来修复数据库文件的MyISAMChk工具和用来恢复浪费空间的 MyISAMPack工具。MyISAM强调了快速读取操作，主要用于高负载的select，这可能也是MySQL深受Web开发的主要原因：在Web开发中进行的大量数据操作都是读取操作，所以大多数虚拟主机提供商和Internet平台提供商（Internet Presence Provider, IPP）只允许使用MyISAM格式。MyISAM类型的表支持三种不同的存储结构：静态型、动态型、压缩型。静态型：指定义的表列的大小是固定（即不含有：xblob、xtext、varchar等长度可变的数据类型），这样MySQL就会自动使用静态MyISAM格式。使用静态格式的表的性能比较高，因为在维护和访问以预定格式存储数据时需要的开销很低；但这种高性能是以空间为代价换来的，因为在定义的时候是固定的，所以不管列中的值有多大，都会以最大值为准，占据了整个空间。动态型：如果列（即使只有一列）定义为动态的（xblob, xtext, varchar等数据类型），这时MyISAM就自动使用动态型，虽然动态型的表占用了比静态型表较少的空间，但带来了性能的降低，因为如果某个字段的内容发生改变则其位置很可能需要移动，这样就会导致碎片的产生，随着数据变化的增多，碎片也随之增加，数据访问性能会随之降低。对于因碎片增加而降低数据访问性这个问题，有两种解决办法：a、尽可能使用静态数据类型；b、经常使用optimize table table_name语句整理表的碎片，恢复由于表数据的更新和删除导致的空间丢失。如果存储引擎不支持optimize table table_name则可以转储并 重新加载数据，这样也可以减少碎片；压缩型：如果在数据库中创建在整个生命周期内只读的表，则应该使用MyISAM的压缩型表来减少空间的占用。优缺点：MyISAM的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。2．innoDB存储引擎存储位置MySQL如果使用InnoDB存储引擎，数据库文件类型就包括.frm、ibdata1、.ibd，存放位置有两个，.frm文件默认存放位置是C:\Documents and Settings\All Users\ApplicationData\MySQL\MySQL Server 5.1\data，ibdata1、.ibd文件默认存放位置是MySQL安装目录下的data文件夹。innodb存储引擎的mysql表提供了事务，回滚以及系统崩溃修复能力和多版本迸发控制的事务的安全。innodb支持自增长列（auto_increment）,自增长列的值不能为空，如果在使用的时候为空的话怎会进行自动存现有的值开始增值，如果有但是比现在的还大，则就保存这个值。innodb存储引擎支持外键（foreign key） ,外键所在的表称为子表而所依赖的表称为父表。innodb存储引擎最重要的是支持事务，以及事务相关联功能。innodb存储引擎支持mvcc的行级锁。innodb存储引擎索引使用的是B+Tree优缺点：InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。3．MEMORY存储引擎memory存储引擎相比前面的一些存储引擎，有点不一样，其使用存储在内从中的数据来创建表，而且所有的数据也都存储在内存中。每个基于memory存储引擎的表实际对应一个磁盘文件，该文件的文件名和表名是相同的，类型为.frm。该文件只存储表的结构，而其数据文件，都是存储在内存中，这样有利于对数据的快速处理，提高整个表的处理能力。memory存储引擎默认使用哈希（HASH）索引，其速度比使用B-+ Tree型要快，如果读者希望使用B树型，则在创建的时候可以引用。memory存储引擎文件数据都存储在内存中，如果mysqld进程发生异常，重启或关闭机器这些数据都会消失。所以memory存储引擎中的表的生命周期很短，一般只使用一次。4．ARCHIVE存储引擎该存储引擎非常适合存储大量独立的、作为历史记录的数据。区别于InnoDB和MyISAM这两种引擎，ARCHIVE提供了压缩功能，拥有高效的插入速度，但是这种引擎不支持索引，所以查询性能较差一些。四种存储引擎比较InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。MyISAM：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率MEMORY：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果如果只有INSERT和SELECT操作，可以选择Archive，Archive支持高并发的插入操作，但是本身不是事务安全的。Archive非常适合存储归档数据，如记录日志信息可以使用Archiv注意，同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。数据类型数值类型MySQL支持所有标准SQL数值数据类型。这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。类型大小范围（有符号）范围（无符号）用途TINYINT1 byte(-128，127)(0，255)小整数值SMALLINT2 bytes(-32 768，32 767)(0，65 535)大整数值MEDIUMINT3 bytes(-8 388 608，8 388 607)(0，16 777 215)大整数值INT或INTEGER4 bytes(-2 147 483 648，2 147 483 647)(0，4 294 967 295)大整数值BIGINT8 bytes(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)(0，18 446 744 073 709 551 615)极大整数值FLOAT4 bytes(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)0，(1.175 494 351 E-38，3.402 823 466 E+38)单精度 浮点数值DOUBLE8 bytes(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)双精度 浮点数值DECIMAL对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2依赖于M和D的值依赖于M和D的值小数值日期和时间类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。TIMESTAMP类型有专有的自动更新特性，将在后面描述。类型大小 ( bytes)范围格式用途DATE31000-01-01/9999-12-31YYYY-MM-DD日期值TIME3‘-838:59:59’/‘838:59:59’HH:MM:SS时间值或持续时间YEAR11901/2155YYYY年份值DATETIME81000-01-01 00:00:00/9999-12-31 23:59:59YYYY-MM-DD HH:MM:SS混合日期和时间值TIMESTAMP41970-01-01 00:00:00/2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07YYYYMMDD HHMMSS混合日期和时间值，时间戳字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。类型大小用途CHAR0-255 bytes定长字符串VARCHAR0-65535 bytes变长字符串TINYBLOB0-255 bytes不超过 255 个字符的二进制字符串TINYTEXT0-255 bytes短文本字符串BLOB0-65 535 bytes二进制形式的长文本数据TEXT0-65 535 bytes长文本数据MEDIUMBLOB0-16 777 215 bytes二进制形式的中等长度文本数据MEDIUMTEXT0-16 777 215 bytes中等长度文本数据LONGBLOB0-4 294 967 295 bytes二进制形式的极大文本数据LONGTEXT0-4 294 967 295 bytes极大文本数据注意：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。]]></content>
      <categories>
        <category>SQL知识</category>
      </categories>
      <tags>
        <tag>SQL概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL索引和事务]]></title>
    <url>%2F2020%2F06%2F07%2F%E7%B4%A2%E5%BC%95%E5%92%8C%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[索引索引特点：创建与维护索引会消耗很多时间与磁盘空间，但查询速度大大提高！在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。例如，对于students表：idclass_idnamegenderscore11小明M9021小红F9531小军M88如果要经常根据score列进行查询，就可以对score列创建索引：12ALTER TABLE studentsADD INDEX idx_score (score);使用ADD INDEX idx_score (score)就创建了一个名称为idx_score，使用列score的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：12ALTER TABLE studentsADD INDEX idx_name_score (name, score);索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如gender列，大约一半的记录值是M，另一半是F，因此，对该列创建索引就没有意义。可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。MySQL索引的类型1. 普通索引这是最基本的索引，它没有任何限制，比如上文中为title字段创建的索引就是一个普通索引，MyIASM中默认的BTREE类型的索引，也是我们大多数情况下用到的索引。12345678910111213141516171801 –直接创建索引02 CREATE INDEX index_name ON table(column(length))03 –修改表结构的方式添加索引04 ALTER TABLE table_name ADD INDEX index_name ON (column(length))05 –创建表的时候同时创建索引06 CREATE TABLE `table` (07 `id` int(11) NOT NULL AUTO_INCREMENT ,08 `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,09 `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,10 `time` int(10) NULL DEFAULT NULL ,11 PRIMARY KEY (`id`),12 INDEX index_name (title(length))13 )14 –删除索引15 DROP INDEX index_name ON table2. 唯一索引与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。12345678910111213141501 –创建唯一索引02 CREATE UNIQUE INDEX indexName ON table(column(length))03 –修改表结构04 ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))05 –创建表的时候直接指定06 CREATE TABLE `table` (07 `id` int(11) NOT NULL AUTO_INCREMENT ,08 `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,09 `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,10 `time` int(10) NULL DEFAULT NULL ,11 PRIMARY KEY (`id`),12 UNIQUE indexName (title(length))13 );3. 全文索引（FULLTEXT）MySQL从3.23.23版开始支持全文索引和全文检索，FULLTEXT索引仅可用于 MyISAM表；他们可以从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE或CREATE INDEX被添加。对于较大的数据集，将你的资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的中速度更为快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。12345678910111213141501 –创建表的适合添加全文索引02 CREATE TABLE `table` (03 `id` int(11) NOT NULL AUTO_INCREMENT ,04 `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,05 `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,06 `time` int(10) NULL DEFAULT NULL ,07 PRIMARY KEY (`id`),08 FULLTEXT (content)09 );10 –修改表结构添加全文索引11 ALTER TABLE article ADD FULLTEXT index_content(content)12 –直接创建索引13 CREATE FULLTEXT INDEX index_content ON article(content)4. 单列索引、多列索引多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。5. 组合索引（最左前缀）平时用的SQL查询语句一般都有比较多的限制条件，所以为了进一步榨取MySQL的效率，就要考虑建立组合索引。例如上表中针对title和time建立一个组合索引：ALTER TABLE article ADD INDEX index_titme_time (title(50),time(10))。建立这样的组合索引，其实是相当于分别建立了下面两组组合索引：12–title,time–title为什么没有time这样的组合索引呢？这是因为MySQL组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这两列的查询都会用到该组合索引，如下面的几个SQL所示：1234561 –使用到上面的索引2 SELECT * FROM article WHREE title='测试' AND time=1234567890;3 SELECT * FROM article WHREE utitle='测试';4 –不使用上面的索引5 SELECT * FROM article WHREE time=1234567890;小结通过对数据库表创建索引，可以提高查询速度。通过创建唯一索引，可以保证某一列的值具有唯一性。数据库索引对于用户和应用程序来说都是透明的。有几个索引就有几组排序，索引越多占用空间越大，插入速度越慢查询的时候数据库自动分析然后挑一个最合适的索引MySQL 事务事务指逻辑上的一组操作，组成这个操作的各个单元，要么都成功，要么都不成功MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。事务用来管理 insert,update,delete 语句一般来说，事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。事务控制语句BEGIN 或 START TRANSACTION显式地开启一个事务；COMMIT 也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的；ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT；RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；ROLLBACK TO identifier 把事务回滚到标记点；SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和SERIALIZABLE。MYSQL 事务处理方法1、用 BEGIN, ROLLBACK, COMMIT来实现BEGIN 开始一个事务ROLLBACK 事务回滚COMMIT 事务确认2、直接用 SET 来改变 MySQL 的自动提交模式:SET AUTOCOMMIT=0 禁止自动提交SET AUTOCOMMIT=1 开启自动提交]]></content>
      <categories>
        <category>SQL知识</category>
      </categories>
      <tags>
        <tag>SQL概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows 配置同时使用 Gitlab、Github、Gitee(码云) 共存的开发环境（转载）]]></title>
    <url>%2F2020%2F06%2F02%2Fwindows%20%E9%85%8D%E7%BD%AE%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%20Gitlab%E3%80%81Github%E3%80%81Gitee(%E7%A0%81%E4%BA%91)%20%E5%85%B1%E5%AD%98%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[原文链接：https://blog.csdn.net/flowerspring/article/details/104962002清除 git 的全局设置（针对已安装 git）新安装 git 跳过。若之前对 git 设置过全局的 user.name 和 user.email。类似 (用 git config –global –list 进行查看你是否设置)12$ git config --global user.name "你的名字"$ git config --global user.email "你的邮箱"必须删除该设置12$ git config --global --unset user.name "你的名字"$ git config --global --unset user.email "你的邮箱"生成新的 SSH keys1）Gitee 密钥跳转到keygen目录，git bash here。先键入第二行命令第四行 指定 id 文件名称为id_rsa_gitee第五、六行 设置无密码，直接回车两次。会在keygen目录下生成文件 id_rsa_gitee 和 id_rsa_gitee.pub。id_rsa_gitee.pub中存放的是公钥。把公钥保存到gitee网页密钥中。123456789101112honey@honey MINGW64 /d/keygen$ ssh-keygen -t rsa -C yourmail@.comGenerating public/private rsa key pair.Enter file in which to save the key (/c/Users/honey/.ssh/id_rsa): id_rsa_giteeEnter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in id_rsa_gitee.Your public key has been saved in id_rsa_gitee.pub.The key fingerprint is:...The key's randomart image is:...也可指定文件路径，方便后面操作：~/.ssh/id_rsa.gitlabssh-keygen -t rsa -f ~/.ssh/id_rsa.gitee -C &quot;yourmail@.com&quot;直接回车3下，什么也不要输入，就是默认没有密码。注意 gitee 和 gitlab 的文件名是不同的。2）GitLab 密钥同上跳转到keygen目录，git bash here。先键入第二行命令第四行 指定 id 文件名称为id_rsa_gitlab第五、六行 设置无密码，直接回车两次。会在keygen目录下生成文件 id_rsa_gitlab 和 id_rsa_gitlab.pub。id_rsa_gitlab.pub中存放的是公钥。把公钥保存到gitlab网页密钥中。12345678910111213honey@honey MINGW64 /d/keygen$ ssh-keygen -t rsa -f id_rsa_gitlab -C "yourmail@.com"`Generating public/private rsa key pair.id_rsa_gitlab already exists.Overwrite (y/n)? yEnter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in id_rsa_gitlab.Your public key has been saved in id_rsa_gitlab.pub.The key fingerprint is:...The key's randomart image is:...ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitlab -C &quot;yourmail@.com&quot;3）GitHub 密钥同上ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C &quot;yourmail@.com&quot;4)完成后会在~/.ssh目录下生成以下文件id_rsa_githubid_rsa_github.pubid_rsa_gitlabid_rsa_gitlab.pubid_rsa_giteeid_rsa_gitee.pubconfig文件需要在.ssh文件夹下新建config文件，先新建config.txt，然后修改文件名去掉后缀。config文件内容如下：其中第二行和第三中 需要填写gitlab的仓库地址gitlabHost git.xxx.cn HostName git.xxx.cn PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitlab User gitgiteeHost gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitee User gitgithubHost github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github User git测试1）Gitee 测试$ ssh -T git@gitee.com步骤如下：在gitee注册用户登录，创建仓库。https://gitee.com/XXXX/c_demo在.ssh目录 git bash herehoney@honey MINGW64 ~/.ssh$ ssh -T git@gitee.comWarning: Permanently added the ECDSA host key for IP address ‘180.97.125.228’ to the list of known hosts.Hi fengmi! You’ve successfully authenticated, but GITEE.COM does not provide shell access.显示successfully。2）GitLab 测试git@git.XXX.cn 是gitlab的仓库地址$ ssh -T git@git.XXX.cn步骤如下：跳转到.ssh目录，git bash here。honey@honey MINGW64 ~/.ssh$ ssh -T git@git.XXX.cnThe authenticity of host ‘git.XXX.cn (111.203.245.108)’ can’t be established.ECDSA key fingerprint is ….Are you sure you want to continue connecting (yes/no/[fingerprint])? yesWarning: Permanently added ‘git.emapgo.cn,111.203.245.108’ (ECDSA) to the list of known hosts.Welcome to GitLab, @mygitlabhostname!显示welcome to gitlab。3）Github 测试同gitee4)~/.ssh / 目录下最终拥有如下文件windows .ssh目录 是 C:\Users\honey.ssh 即C:\Users\windows登录名.sshid_rsa_githubid_rsa_github.pubid_rsa_gitlabid_rsa_gitlab.pubid_rsa_giteeid_rsa_gitee.pubconfigknown_hosts4) 查看电脑中自己的配置信息$ cat confighoney@honey MINGW64 ~/.ssh$ cat config使用1）Gitlab在本地以后gitlab仓库，git pull ,git commit -m “XXX”,git push 会提示 tell me who you are此时需要填写local 用户名和邮箱，而不是 –global$ ssh git config –local user.name “你的名字”$ ssh git config –local user.email “你的邮箱”2）Gitee同上类似3）Github同上类似配置文件和配置字段信息解释Host它涵盖了下面一个段的配置，我们可以通过他来替代将要连接的服务器地址。这里可以使用任意字段或通配符。当ssh的时候如果服务器地址能匹配上这里Host指定的值，则Host下面指定的HostName将被作为最终的服务器地址使用，并且将使用该Host字段下面配置的所有自定义配置来覆盖默认的/etc/ssh/ssh_config配置信息。Port自定义的端口。默认为22，可不配置User自定义的用户名，默认为git，可不配置 ， User git #默认就是git，可以不写HostName真正连接的服务器地址PreferredAuthentications指定优先使用哪种方式验证，支持密码和秘钥验证方式IdentityFile指定本次连接使用的密钥文件]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 中的上下文管理器]]></title>
    <url>%2F2020%2F06%2F02%2FPython%20%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[with 这个关键字，对于每一学习Python的人，都不会陌生。操作文本对象的时候，我们用 with open ，这就是一个上下文管理的例子。12with open('test.txt') as f: print f.readlines()上下文管理器概念基本语法12with EXPR as VAR: BLOCK几个概念1231. 上下文表达式：with open('test.txt') as f:2. 上下文管理器：open('test.txt') 3. f不是上下文管理器，应该是资源对象。实现下文管理器要自己实现这样一个上下文管理，要先知道上下文管理协议。简单点说，就是在一个类里，实现了__enter__和__exit__的方法，这个类的实例就是一个上下文管理器。例如这个示例：123456789101112class Resource(): def __enter__(self): print('===connect to resource===') return self def __exit__(self, exc_type, exc_val, exc_tb): print('===close resource connection===') def operate(self): print('===in operation===') with Resource() as res: res.operate()我们执行一下，通过日志的打印顺序。可以知道其执行过程。123===connect to resource======in operation======close resource connection===从这个示例可以很明显的看出，在编写代码时，可以将资源的连接或者获取放在__enter__中，而将资源的关闭写在__exit__ 中。上下文管理器作用可以以一种更加优雅的方式，操作（创建/获取/释放）资源，如文件操作、数据库连接；可以以一种更加优雅的方式，处理异常；第一种，我们上面已经以资源的连接为例介绍了。而第二种，会被大多数人所忽略。这里会重点讲一下。大家都知道，处理异常，通常都是使用 try...execept.. 来捕获处理的。这样做一个不好的地方是，在代码的主逻辑里，会有大量的异常处理代理，这会很大的影响我们的可读性。好一点的做法呢，可以使用 with 将异常的处理隐藏起来。仍然是以上面的代码为例，我们将I/O 这个一定会抛出异常的代码写在 operate 里1234567891011121314class Resource(): def __enter__(self): print('===connect to resource===') return self def __exit__(self, exc_type, exc_val, exc_tb): print('===close resource connection===') return True def operate(self): I/Owith Resource() as res: res.operate()运行一下，惊奇地发现，居然不会报错。这就是上下文管理协议的一个强大之处，异常可以在__exit__ 进行捕获并由你自己决定如何处理，是抛出呢还是在这里就解决了。在__exit__ 里返回 True（没有return 就默认为 return False），就相当于告诉 Python解释器，这个异常我们已经捕获了，不需要再往外抛了。在 写__exit__ 函数时，需要注意的事，它必须要有这三个参数：exc_type：异常类型exc_val：异常值exc_tb：异常的错误栈信息当主逻辑代码没有报异常时，这三个参数将都为None。常见的异常异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。 一般情况下，在Python无法正常处理程序时就会发生一个异常。 异常是Python对象，表示一个错误。 当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。 python的标准异常可以在官网文档中查看,常用的如下:异常名称描述SystemExit解释器请求退出KeyboardInterrupt用户中断执行(通常是输入^C)Exception常规错误的基类StopIteration迭代器没有更多的值GeneratorExit生成器(generator)发生异常来通知退出StandardError所有的内建标准异常的基类ArithmeticError所有数值计算错误的基类FloatingPointError浮点计算错误OverflowError数值运算超出最大限制ZeroDivisionError除(或取模)零 (所有数据类型)AssertionError断言语句失败AttributeError对象没有这个属性EOFError没有内建输入,到达EOF 标记EnvironmentError操作系统错误的基类IOError输入/输出操作失败OSError操作系统错误WindowsError系统调用失败ImportError导入模块/对象失败LookupError无效数据查询的基类IndexError序列中没有此索引(index)KeyError映射中没有这个键MemoryError内存溢出错误(对于Python 解释器不是致命的)NameError未声明/初始化对象 (没有属性)UnboundLocalError访问未初始化的本地变量ReferenceError弱引用(Weak reference)试图访问已经垃圾回收了的对象RuntimeError一般的运行时错误NotImplementedError尚未实现的方法SyntaxErrorPython 语法错误IndentationError缩进错误TabErrorTab 和空格混用SystemError一般的解释器系统错误TypeError对类型无效的操作ValueError传入无效的参数UnicodeErrorUnicode 相关的错误UnicodeDecodeErrorUnicode 解码时的错误UnicodeEncodeErrorUnicode 编码时错误UnicodeTranslateErrorUnicode 转换时错误Warning警告的基类DeprecationWarning关于被弃用警告FutureWarning关于构造将来语义会有改变的警告OverflowWarning旧的关于自动提升为长整型(long)的警告PendingDeprecationWarning关于特性将会被废弃的警告RuntimeWarning可疑的运行时行为(runtime behavior)的警告SyntaxWarning可疑的语法的警告UserWarning用户代码生成的警告]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>上下文管理器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python类补充]]></title>
    <url>%2F2020%2F06%2F02%2FPython%E7%B1%BB%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[item系列__getitem__以字典形式访问属性的时候触发__setitem__以字典形式设置属性的时候触发__delitem__以字典形式删除属性的时候触发12345678910111213141516171819202122232425262728293031class Demo(object): def __getitem__(self, item): print("触发__getitem__") def __setitem__(self, key, value): print("触发__setitem__") self.__dict__[key] = value def __delitem__(self, key): print("触发__delitem__") self.__dict__.pop(key)f = Demo()# 以字典的方式来操作属性print(f.__dict__)f['name'] = 'luenci'print(f.__dict__)print(f['name'])del f['name']print(f.__dict__)out:&#123;&#125;触发__setitem__&#123;'name': 'luenci'&#125;触发__getitem__None触发__delitem__&#123;&#125;__str__和__repr__控制输出__str__会在print()打印时候调用，如果类中没重写则会调用默认的打印值，如果自定义了则会调用自定义的__str__方法__repr__这个实在控制台的时候输出，若一个类中没定义__str__但是定义了__repr__方法，则会调用__repr__的返回值。1234567891011121314151617class bar(object): def __init__(self, name, age): self.name = name self.age = age # def __str__(self): # return '__str__自定义返回值' def __repr__(self): return '__repr__自定义返回值'f = bar('luenci', 18)# print() 函数触发__str__()函数print(f)out:__repr__自定义返回值__slots__属性1.__slots__是什么？是一个类变量，变量值可以是列表，元祖，或者可迭代对象，也可以是一个字符串（意味看所有实例只有一个数据属性）2.引子：使用点来访问属性本质就是在访问类或者对象的dict属性字典（类的字典是共享的，而每个实例的是独立的）3.为何使用__slots__？字典会占用大量内存，如果你有一个属性很少的类，但是有很多实例，为了节省内存可以使用__slots__取代实例的dict当你定义__slots__后，__slots__就会为实例使用一种更加紧凑的内部表示。实例通过一个很小的固定大小的数组来构建，而不是为每个实例定义一字典，这跟元组或列表很类似。在__slots__中列出的属性名在内部被映射到这个数组的指定小标上。使用__slots__一个不好的地方就是我们不能再给实例添加新的属性了，只能使用在slots中定义的那些属性名。注意事项：__slots__的很多特性都依赖于普通的基于字典的实现。另外，定义了__slots__后的类不再支持一些普通类特性了，比如多继承。大多数情况下，你应该只在那些经常被使用到的用作数据结构的类上定义__slots__比如在程序中需要创建某个类的几百万个实例对象。关于__slots__的一个常见误区是它可以作为一个封装工具来防止用户给实例增加新的属性。尽管使用__slots__可以达到这样的目的，但是这个并不是它的初衷。更多的是用来作为一个内存优化工具。12345678910class Demo(object): __slots__ = ['name','age']f1 = Demo()f1.name = 'luenci'# print(f1.__dict__)print(f1.__slots__)# print(Demo.__dict__)['name', 'age']描述符定义一个描述符是一个有“绑定行为”的对象属性(object attribute)，它的访问控制会被描述器协议方法重写。任何定义了 __get__, __set__ 或者 __delete__ 任一方法的类称为描述符类，其实例对象便是一个描述符，这些方法称为描述符协议。当对一个实例属性进行访问时，Python 会按 obj.__dict__ → type(obj).__dict__ → type(obj)的父类.__dict__ 顺序进行查找，如果查找到目标属性并发现是一个描述符，Python 会调用描述符协议来改变默认的控制行为。描述符是 @property``@classmethod``@staticmethod 和 super 的底层实现机制。特性同时定义了 __get__ 和 __set__ 的描述符称为 数据描述符(data descriptor)；仅定义了 __get__的称为 非数据描述符(non-data descriptor) 。两者区别在于：如果 obj.__dict__ 中有与描述符同名的属性，若描述符是数据描述符，则优先调用描述符，若是非数据描述符，则优先使用 obj.__dict__ 中属性。描述符协议必须定义在类的层次上，否则无法被自动调用。描述符协议12345__get__(self, instance, owner):param self: 描述符对象本身:param instance: 使用描述符的对象的实例:param owner: 使用描述符的对象拥有者12__set__(self, instance, value):param value: 对描述符的赋值1__delete__(self, instance)描述符的应用1234567891011121314151617181920212223242526272829303132333435363738class Type(object): """ 属性检查 """ def __init__(self, key, types): self.key = key self.types = types def __get__(self, instance, owner): print("__get__执行") return instance.__dict__[self.key] def __set__(self, instance, value): print("__set__执行") if not isinstance(value, self.types): raise TypeError("%s不是要求的%s类型" % (self.key, self.types)) instance.__dict__[self.key] = value def __delete__(self, instance): print("__delete__执行") instance.__dict__.pop(self.key)class Peopel(object): name = Type('name', str) age = Type('age', int) sex = Type('sex', str) def __init__(self, name, age, sex): self.name = name self.sex = sex self.age = age# p1 = Peopel('luenci', '11', '男')# p2 = Peopel(12, 11, '男')p3 = Peopel('luenci', 11, '男')描述符总结描述符是可以实现大部分python类特性中的底层魔法，包括@classmethod.@staticmethd.@property甚至是__slots__属性描述符是很多高级库和框架的重要工具之一，描述符通常是使用到装饰器或者元类的大型框架中的一个组件。元类元类是类的类，是类的模板元类是用来控制如何创建类的，正如类是创建对象的模板一样元类的实例为类，正如类的实例为对象（f1对象是Foo类的一个实例，Foo类是type类的一个实例）type是python的一个内建元类，用来直接控制生成类，python中任何class定义的类其实都是type类实例化的对象]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>类和模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库函数]]></title>
    <url>%2F2020%2F05%2F29%2FMysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[MySQL数据库函数MySQL函数是数据库提供的内置函数，可以帮助用户更加方便地处理表中的数据。MySQL的内置函数，不但可以在SELECT查询语句中使用，同样可以在INSERT、UPDATE、DELETE等语句中使用。1.数学函数：MySQL中内置的数学函数见下表：函数作用ABS(x)返回x的绝对值CEIL9x),CEILIN(x)返回不小于x的最小整数值FLOOR(x)返回不大于x的最大整数值RAND()返回0~1的随机数RAND(x)返回0~1的随机数，x值相同时返回的随机数相同SIGN(x)返回参数作为-1、0、1的符号，该符号取决于x值的负、零、正PI()返回圆周率的值，默认是7位，内部使用完全双精度值TRUNCATE(x,y)返回数值x保留到小数点y位的值ROUND(x)返回离x最近的整数ROUND(x,y)保留x小数点后y位的值，但截断时要进行四舍五入POW(x,y),POWER(x,y)返回x的y乘方的结果值SQRT(x)返回非负数x的二次方根EXP(x)返回e的x乘方后的值（自然对数的底）MOD(x,y)返回x除以y后的余数LOG(x)返回x的基数为2的对数LOG10(x)返回x的基数为10的对数RADIANS(x)将角度转换为弧度DEGREES(x)将弧度转化为角度SIN(x)返回x的正弦，其中x使用弧度ASIN(x,y)返回x的反正弦，若x不在-1到1范围内则返回NULLCOS(x)返回x的余弦，其中x为弧度ACOS(x,y)返回x的反余弦，若x不在-1到1范围内则返回NULLTAN(x,y)返回x的正切，其中x为弧度ATAN(x),ATAN2(x)返回x的反正切，y确定结果所在象限COT(x,y)返回x的余切2.字符串函数：字符串函数是MySQL中最常用的的一类函数，主要用于处理表中的字符串。见下表：函数作用CHAR_LENGTH(s)返回字符串s的字符数LENGTH(s)返回字符串的字节长度，一个多字节字符算作多字节CONCAT(s)返回结果为连接参数产生的字符串。为了避免将数字参数转化为二进制字符串使用SELECT CONCAT(CAST(int_col AS CHAR),char_col)CONCAT_WS(x,s1,s2,…)同CONCAT()函数，但每个字符串都要加上xINSERT(s1,x,len,s2)将字符串s2替换为s1的x位置开始长度为len的字符串UPPER(s),UCASE(s)将字符串s的所有字母都变成大写字母LOWER(s),LCASE(s)将字符串s的所有字母都变成小写字母LEFT(s,n)返回从字符串s开始的最左边n个字符RIGHT(s,n)返回从字符串s开始的最右边n个字符LPAD(s1,len,s2)返回字符串s1，其左边由字符串s2填补到len字符长度RPAD(s1,len,s2)返回字符串s1，其右边被字符串s2填补至len字符长度LTRIM(s)返回字符串s，其引导空格字符被删除RTRIM(s)返回字符串s，结尾空格字符被删去TRIM(s)去掉字符串s开始和结尾处的空格TRIM(s1 FROM s)去掉字符串s中开始处和结尾处的字符串s1REPEAT(s,n)将字符串s重复n次SPACE(n)返回n个空格REPLACE(s,s1,s2)用字符串s2替代字符串s中的字符串s1STRCMP(s1,s2)比较字符串s1和s2SUBSTRING(s,n,len)获取从字符串s第n个位置开始长度为len的字符串MID(s,n,len)同SUBSTRING()LOCATE(s1,s) POSITION(s1 IN s)从字符串s中获取s1的开始位置INSTR(s,s1)从字符串s中获取s1的开始位置REVERSE(s)将字符串s的顺序反过来ELT(n,s1,s2)返回第n个字符串EXPORT_SET(bits,on,off[, separator[,number_of_bits]])返回一个字符串，生成规则为：针对bits的二进制格式，如果位为1则返回一个on值，如果为0则返回一个off值。每个字符串用separator分隔，默认逗号；number_of_bits指定bits的可用位数，默认64位。示例 selectEXPORT_SET(182,’Y’,’N’,‘@’,6);FIELD(s,s1,s2)返回第一个与字符串s匹配的字符串的位置FIND_IN_SET(s,s2)返回在字符串s2中与s1匹配的字符串的位置MAKE_SET(x,s1,s2,…)按x的二进制数从s1,s2,…,sn中选取字符串3.日期和时间函数：日期和时间函数主要用于对表中的日期和时间数据的处理。见下表：函数作用CURDATE(),CURRENT_DATE()返回当前日期CURTIME(),CURRENT_TIME()返回当前时间NOW(),CURRENT_TIMESTAMP(), LOCALTIME(),SYSDATE(),LOCALTIMESTAMP()返回当前日期时间UNIX_TIMESTAMP()以UNIX时间戳的形式返回当前时间UNIX_TIMESTAMP(d)将时间d以UNIX时间戳的形式返回FROM_UNIXTIME(d)把UNIX时间戳的时间转换为普通格式的时间UTC_DATE()返回UTC（Universal Coordinated Time，国际协调时间）日期UTC_TIME()返回UTC时间MONTH(d)返回日期d中的月份值，范围1~12MONTHNAME(d)返回日期d中的月份名称，如JanuaryDAYNAME(d)返回日期d是星期几，如MondayDAYOFWEEK(d)返回日期d是星期几，范围1~7，1表示星期日WEEKDAY(d)返回日期d是星期几，范围0~6，0表示星期一WEEK(d)计算日期d是本年的第几个星期，范围0~53WEEKOFYEAR(d)计算日期d是本年的第几个星期，范围1~54DAYOFYEAR(d)计算日期d是本年的第几天DAYOFMONTH(d)计算日期d是本月的第几天YEAR(d)返回日期d中的年份值QUARTER(d)返回日期d是第几季度，范围1~4HOUR(t)返回时间t中的小时数MINUTE(t)返回时间t中的分钟数SECOND(t)返回时间t中的秒数EXTRACT(type FROM d)从日期d中获取指定值，type指定返回的值，如YERR HOUR等TIME_TO_SEC(t)将时间t转换为秒SEC_TO_TIME(t)将以秒为单位的时间s转换为时分秒的格式TO_DAYS(d)计算日期d~0000年1月1日的天数FROM_DAYS(d)计算从0000年1月1日开始n天后的日期DATEDIFF(d1,d2)计算日期d1~d2之间间隔的天数ADDDATE(d,n)计算起始日期d加上n天的日期ADDDATE(d,INTERVAL expr type)计算起始日期d加上一个时段后的日期DATE_ADD(d,INTERVAL expr type)同ADDDATE(d,INTERVAL expr type)SUBDATE(d,n)计算起始日期d减去n天后的日期SUBDATE(d,INTERVAL expr type)计算起始日期d减去一个时段后的日期ADDTIME(t,n)计算起始时间t加上n秒的时间SUBTIME(t,n)计算起始时间t减去n秒的时间DATE_FROMAT(d,f)按照表达式f的要求显示日期dTIME_FROMAT(t,f)按照表达式f的要求显示时间tGET_FORMAT(type,s)根据字符串s获取type类型数据的显示格式4.条件判断函数：条件函数用来在SQL语句中进行条件判断，根据不同的条件执行不同的SQL语句。见下表：函数作用IF(expr,v1,v2)如果表达式expr成立，则执行v1；否则执行v2IFNULL(v1,v2)如果v1不为空，则显示v1的值；否则显示v2的值CASE WHEN expr1 THEN v1 [WHEN expr2 THEN v2…][ELSE vn] ENDcase表示函数开始，end表示函数结束。如果表达式expr1成立，则返回v1的值；如果表达式expr2成立，则返回v2的值。依次类推，最后遇到else时，返回vn的值。CASE expr WHEN e1 THEN v1 [WHEN e2 THEN v2…][ELSE vn] ENDcase表示函数开始，end表示函数结束。如果表达式expr取值为e1，则返回v1的值；如果表达式expr取值为e2，则返回v2的值。依次类推，最后遇到else，返回vn的值。示例：select id,grade, CASE WHEN grade&gt;1000000 THEN ‘Very Good’ WHEN grade&lt;1000000 and grade&gt;=100000 THEN ‘Popularly’ ELSE ‘Not Good’ END level from tb_bccd;5.系统信息函数：系统信息函数用来查询MySQL数据库的系统信息。见下表：函数作用示例VERSION()获取数据库的版本号select VERSION();CONNECTION_ID()获取数据库的连接数select CONNECT_ID();DATABASE(),SCHEMA()获取当前数据库名select DATABASE();USER(),SYSTEM_USER(),SESSION_USER()获取当前用户select USER();CURRENT_USER()获取当前用户select CURRENT-USER();CHARSET(str)获取字符串str的字符集select CHARSET(‘mrsoft’);COLLATION(str)获取字符串str的字符排列方式select COLLATION(‘mrsoft’);LAST_INSERT_ID()获取最近生成的AUTO_INCREMENT值select LAST_INSERT_ID();6.加密函数：数据库中有些敏感信息不希望被其他人看到，就可以用加密的方法使这些数据看似乱码。函数作用示例PASSWORD(str)对字符串str加密，不可逆加密select PASSWORD(‘mrsoft’);MD5(str)对字符串str进行加密，用于普通数据select MD5(‘mrsoft’);ENCODE(str,pswd_str)使用字符串pswd_str来加密字符串str，结果是二进制数，用BLOB类型保存select ENCODE(‘mrsoft’,’mr’);DECODE(crypt_str,pswd_str)使用字符串pswd_str来解密字符串crypt_str，对ENCODE()解码select DECODE (ENCODE(‘mrsoft’,’mr’),’mr’);7.统计函数：函数说明Avg(字段名)获取指定列的平均值Count(字段名)如指定一个记录，会统计该字段中非空记录数，如前面使用DISTINCT，则会统计不同值的记录，相同的值当作一条记录。Min(字段名)获取指定字段的最小值Max(字段名)获取指定字段的最大值Std(字段名)指定字段的标准背离值Stdtev(字段名)与Std相同Sum(字段名)指定字段所有记录的总和8.其他函数：函数作用FORMAT(x,n)将数字x进行格式化，保留到小数点后n位，四舍五入ASCII(x)返回字符串s的第一个字符的ASCII码BIN(x)返回x的二进制编码HEX(x)返回x的十六进制编码OCT(x)返回x的八进制编码CONV(x,f1,f2)将x从f1进制数变成f2进制数INET_ATON(IP)将IP地址转换为数字表示INET_NTOA(N)将数字n转换成IP形式GET_LOCT(name,time)定义一个名称为name持续时长为time秒的锁。锁定成功返回1；如此尝试超时返回0；遇到错误返回NULL。RELEASE_LOCK(name)解除名称为name的锁。解锁成功返回1，尝试超时返回0，失败返回NULL。IF_FREE_LOCK(name)判断是否使用名为name的锁，成功返回0，否则返回1。BENCHMARK(count,expr)将表达式expr重复执行count次，然后返回执行时间CONVERT(s USING cs)将字符串s的字符集变成csCAST(x AS type), CONVERT(x,type)将x变成type类型。这两个函数只对BINARY、CHAR、DATE、DATETIME、TIME、SIGNED INTEGER、UNSIGNED INTEGER类型起作用。只是改变了输出值的数据类型，并没有改变表中字段的类型。]]></content>
      <categories>
        <category>SQL知识</category>
      </categories>
      <tags>
        <tag>SQL函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python面向对象]]></title>
    <url>%2F2020%2F05%2F29%2FPython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[类的定义把一类事物的相同的特征和动作整合到一起就是类，类是一个抽象的概念对象的定义基于类而创建一个具体的事物，类的实例化接口继承继承的第二种含义非常重要。它又叫“接口继承”。接口继承实质上是要求“做出一个良好的抽象，这个抽象规定了一个兼容接口，使得外部调用者无需关心具体细节，可一视同仁的处理实现了特定接口的所有对象”——这在程序设计上，叫做归一化。归一化使得高层的外部使用者可以不加区分的处理所有接口兼容的对象集合——就好象linux的泛文件概念一样，所有东西都可以当文件处理，不必关心它是内存、磁盘、网络还是屏幕（当然，对底层设计者，当然也可以区分出“字符设备”和“块设备”，然后做出针对性的设计：细致到什么程度，视需求而定）。123456789101112131415161718192021# 导入抽象基类模块import abc# 定义接口（基类）class File(metaclass=abc.ABCMeta): @abc.abstractmethod def read(self): pass @abc.abstractmethod def write(self): passclass disk(File): def read(self): print("disk read") def write(self): print("disk wirte")ds = disk()ds.read()子类中调用父类的方法12345678910111213141516171819202122232425262728class Grandfather(object): def __init__(self, name, age): self.age = age self.name = name def grandfather(self): print("grandfather method")class Father(Grandfather): def __init__(self, name, age): super().__init__(name,age) def father_method(self): print("father method")class Son(Father): def __init__(self, name, age,sex): # 调用父类的构造方法 super().__init__(name,age) self.sex = sex # 子类中调用父类方法 def son_method(self): Father.father_method(self) def son_method1(self): super().grandfather()son1 = Son('xiaoming',18, 'male')son1.son_method1()组合1、组合指的是，在一个类中以另外一个类的对象作为数据属性，称为类的组合。2、作用是可以将两个本来不相关的类联系起来。一般是两个类之间有显著的不同，很多时候还要附属关系(有相同的属性也有不同的属性)。比如人和头，手机和电池等等。3、无纵向关系时用组合，有纵向关系时用继承。4、组合就是一个类中使用到另一个类，从而把几个类拼到一起。组合的功能也是为了减少重复代码多态由不同的类实例化得到的对象，调用同一个方法，执行的逻辑不同多态的概念指出了对象如何通过他们共同的属性和动作来操作及访问，而不需考虑他们具体类。多态表明了动态（又名，运行时）绑定的存在，允计重载及运行时类型确定和验证。12345678910111213141516171819202122232425262728293031323334353637383940class People(object): def __init__(self, name, age): self.name = name self.age = age def generation(self): if self.age &lt; 18: print("[%s]属于未成年人" % self.name) elif 18 &lt; self.age &lt; 30: print("[%s]属于青年人" % self.name) else: print("[%s]属于中老年人" % self.name)class minor(People): passclass young(People): passclass old(People): passdef func(obj): obj.generation()w1 = young('luenci',20)w2 = minor('xiaoming', 16)w3 = old('jack', 50)func(w1)func(w3)func(w3)out:[luenci]属于青年人[jack]属于中老年人[jack]属于中老年人反射getattr(object, name)得到属性的值hasattr(object, name)说明：判断对象object是否包含名为name的特性（hasattr是通过调用getattr(ojbect, name)是否抛出异常来实现的setattr(object, name, value)这是相对应的getattr()。参数是一个对象,一个字符串和一个任意值。字符串可能会列出一个现有的属性或一个新的属性。这个函数将值赋给属性的。该对象允许它提供。例如,setattr(x,“foobar”,123)相当于x.foobar= 123delattr(object, name)与setattr()相关的一组函数。参数是由一个对象(记住python中一切皆是对象)和一个字符串组成的。string参数必须是对象属性名之一。该函数删除该obj的一个由string指定的属性。delattr(x, &#39;foobar&#39;)=del x.foobar注：getattr,hasattr,setattr,delattr对模块的修改都在内存中进行，并不会影响文件中真实内容。123456789101112131415161718192021222324252627282930313233343536373839404142class Demo(object): def __init__(self,name): self.name = name def method(self): print(&quot;i am method&quot;)d = Demo(&apos;luenci&apos;)# 如果d 对象中有属性name则打印self.name的值，否则打印not findprint(getattr(d,&apos;name&apos;,&apos;not find&apos;))print(getattr(d,&apos;age&apos;,&apos;not find&apos;))#如果有方法method，否则打印其地址，否则打印not findprint(getattr(d, &apos;method&apos;, &apos;not find&apos;))print(getattr(d, &apos;methods&apos;, &apos;not find&apos;))#如果有方法method，运行函数并打印None否则打印not findprint(getattr(d, &apos;method&apos;, &apos;not find&apos;)())# 说明：判断对象object是否包含名为name的特性（hasattr是通过调用getattr(ojbect, name)是否抛出异常来实现的）print(hasattr(d, &apos;name&apos;))# 增加和修改参数# d.age = 18setattr(d,&apos;age&apos;, 18)setattr(d,&apos;name&apos;,&apos;jack&apos;)print(d.__dict__)# 删除 属性 不能删除属性对应的值， 但是可以使用setattr来修改delattr(d,&apos;age&apos;)print(d.__dict__)out:luencinot find&lt;bound method Demo.method of &lt;__main__.Demo object at 0x000001710E9359B0&gt;&gt;not findi am methodNoneTrue&#123;&apos;name&apos;: &apos;jack&apos;, &apos;age&apos;: 18&#125;&#123;&apos;name&apos;: &apos;jack&apos;&#125;动态导入模块问题：我们要导入一个模块,可以使用import.现在有这样的需求,我动态输入一个模块名，可以随时访问到导入模块中的方法或者变量，怎么做呢？123't.py'def test(): print("i am test")1234567891011121314model_name = input("请输入您要导入的模块名称：")imp = __import__(model_name)# 判断是否有test函数，有就执行test函数内容if getattr(imp,'test', 'not find'): imp.test()else: print(imp) imp.test()out: 请输入您要导入的模块名称：t i am test &lt;module 't' from 'E:\\python进阶练习\\面向对象\\t.py'&gt; i am test包装对一个已存在的对象进行包装，可以是对一个已存在的对象，增加，删除，或者修改功能。可以包装任何类型（type）作为一个类（class）的核心成员（如list,dict等），以使新对象的行为模仿你想要的数据类型中已存在的行为，并且去掉你不希望存在的行为。123456789101112131415161718class List(list): # 重写list的append方法,让其只能添加字符类型的数据 def append(self, p_object): if type(p_object) is str: # self.append(self, p_object) super().append(p_object) else: print("只有字符类型才可以允许添加")a = List('hello Luenci')a.append(123)a.append("haha")print(a)out:只有字符类型才可以允许添加['h', 'e', 'l', 'l', 'o', ' ', 'L', 'u', 'e', 'n', 'c', 'i', 'haha']授权123456789101112131415161718192021222324import time# 组合的方式完成授权class FileHandle(object): def __init__(self, filename, mode='r', encoding='utf-8'): self.file = open(filename,mode=mode,encoding=encoding) self.mode = mode self.encoding = encoding # 个性化定制write方法，比如不允许写，去除敏感词汇，给内容加上时间戳 def write(self,content): t = time.strftime('%Y-%m-%d %X') self.file.write('%s %s'%(t,content)) def __getattr__(self, item): return getattr(self.file, item)f = FileHandle('a.txt', 'w')f.write('Hello\n')f.write('luenci\n')a.txt----&gt;2020-05-29 11:23:38 Hello2020-05-29 11:23:38 luenci函数补充123456789101112131415161718192021222324class Foo(object): passclass Too(object): passclass Bar(Foo): passf1 = Foo()# 判断实例化对象是不是属于此类 结果是booleanprint(isinstance(f1, Too))print(isinstance(f1, Foo))# 判断Bar类是不是Foo的子类 结果是booleanprint(issubclass(Bar, Foo))out:FalseTrueTrue]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>类的知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python后端架构演进（转载）]]></title>
    <url>%2F2020%2F05%2F23%2FDjango%E5%90%8E%E7%AB%AF%E6%BC%94%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Python后端架构演进本文转自python社区：https://www.pythontab.com/html/2018/pythonweb_0725/1329.html架构做了3年的后端开发, 经历一款SaaS产品从0到10(还没有到100, 哈哈哈)的过程, 3年间后端的架构逐步演变, 在微服务的实践过程中遇到的问题也越来越多, 在这里总结下.产品是一款服务于人力资源的SaaS在线服务, 面向HR有Web Android/iOS 小程序多个客户端, 后端采用RESTful风格API来提供服务. 主要使用Python语言, 方便快速迭代.架构的演进经历了4个大的阶段: 1. MVC 2. 服务拆分 3. 微服务架构 4. 领域驱动设计.1. MVC项目刚开始的时候, 后端同事不超过5个, 这个阶段主要的工作是实现产品的原型, 没有太多的考虑架构, 使用Django来快速实现功能, DB的表结构设计好之后, 抽象出功能View, 由于产品设计也很不完善, 后端需要很多的预留设计, 避免产品逻辑的变更带来整个表结构的变动, 在这个阶段代码上最重要的是确定适合团队的代码规范, 代码检查规则.整体上架构如上图, Nginx负责负载均衡, 分发流量到多个Django服务, Django处理逻辑, 需要异步任务就交给Celery, 然后数据量比较大的地方使用Redis做缓存. 同时还有实时消息通知的需要使用了Nginx Push Module.问题与优化方式:Django并发性能差 使用uWSGI Master+Worker 配合 gevent 携程支持高并发Redis连接数过多 使用redis-py自带的连接池来实现连接复用MySQL连接数过多 使用djorm-ext-pool连接池复用连接Celery配置gevent支持并发任务随着开发的功能越来越多, Django下的app也越来越多, 这就带了发布上的不方便, 每次发布版本都需要重启所有的Django服务, 如果发布遇到问题, 只能加班解决了. 而且单个Django工程下的代码量也越来越多, 不好维护.2. 服务拆分随着后端团队的壮大, 分给每个同事的需求也越来越细, 如果继续在一个工程里面开发所有的代码, 维护起来的代价太高, 而我们的上一个架构中在Django里面已经按模块划分了一个个app, app内高类聚, app之间低耦合, 这就为服务的拆分带来了便利. 拆分的过程没有遇到太大的问题, 初期的拆分只是代码的分离, 把公用的代码抽离出来实现一个公用的Python库, 数据库, Redis还是共用, 随着负载的增加, 数据库也做了多实例.如上图, 服务之间尽量避免相互调用, 需要交互的地方采用http请求的方式, 内网的调用使用hosts指向内网地址.问题与优化方式:Nginx Push Module由于长时间没有维护, 长连接最大数量不够, 使用Tornado + ZeroMQ实现了tormq服务来支撑消息通知服务之间的调用采用http的方式, 并且要求有依赖的服务主机配置hosts指向被调用的地址, 这样带来的维护上的不方便. 以及在调用链的过程中没有重试, 错误处理, 限流等等的策略, 导致服务可用性差. 随着业务拆分, 继续使用Nginx维护配置非常麻烦, 经常因为修改Nginx的配置引发调用错误. 每一个服务都有一个完整的认证过程, 认证又依赖于用户中心的数据库, 修改认证时需要重新发布多个服务.3. 微服务架构首先是在接入层引入了基于OpenResty的Kong API Gateway, 定制实现了认证, 限流等插件. 在接入层承接并剥离了应用层公共的认证, 限流等功能. 在发布新的服务时, 发布脚本中调用Kong admin api注册服务地址到Kong, 并加载api需要使用插件.为了解决相互调用的问题, 维护了一个基于gevent+msgpack的RPC服务框架doge, 借助于etcd做服务治理, 并在rpc客户端实现了限流, 高可用, 负载均衡这些功能.在这个阶段最难的技术选型, 开源的API网关大多用Golang与OpenResty(lua)实现, 为了应对我们业务的需要还要做定制. 前期花了1个月时间学习OpenResty与Golang, 并使用OpenResty实现了一个短网址服务shorturl用在业务中. 最终选择Kong是基于Lua发布的便利性, Kong的开箱即用以及插件开发比较容易. 性能的考量倒不是最重要的, 为了支撑更多的并发, 还使用了云平台提供的LB服务分发流量到2台Kong服务器组成的集群. 集群之间自动同步配置.饿了么维护一个纯Python实现的thrift协议框架thriftpy, 并提供很多配套的工具, 如果团队足够大, 这一套RPC方案其实是合适的, 但是我们的团队人手不足, 水平参差不齐, 很难推广这一整套学习成本高昂的方案. 最终我们开发了类Duboo的RPC框架doge, 代码主要参考了weibo开源的motan.4. 领域驱动设计在这一架构中我们尝试从应用服务中抽离出数据服务层, 每一个数据服务包含一个或多个界限上下文, 界限上下文类只有一个聚合根来暴露出RPC调用的方法. 数据服务不依赖于应用服务, 应用服务可以依赖多个数据服务. 有了数据服务层, 应用就解耦了相互之间的依赖, 高层服务只依赖于底层服务.在我离职时领域驱动设计还在学习设计阶段, 还没有落地, 但是我相信前公司的后端架构一定会往这个方向继续演进.总结架构的设计, 技术的选型, 不能完全按照流行的技术走, 最终还是服务于产品, 服务于客户的需求. 设计过程中由于团队, 人员的结构问题, 有很多的妥协之处, 如何在妥协中找到最优解才是最大的挑战.]]></content>
      <categories>
        <category>python后端架构</category>
      </categories>
      <tags>
        <tag>架构演进</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些核心模块的介绍]]></title>
    <url>%2F2020%2F05%2F21%2Fpython%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[sys模块模块方法解释说明sys.argv传递到Python脚本的命令行参数列表，第一个元素是程序本身路径sys.executable返回Python解释器在当前系统中的绝对路径sys.exit(arg)程序中间的退出，arg=0为正常退出sys.path返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值sys.platform返回操作系统平台名称，Linux是linux2，Windows是win32sys.stdout.write(str)输出的时候把换行符\n去掉val = sys.stdin.readline()[:-1]拿到的值去掉\n换行符sys.version获取Python解释程序的版本信息os模块方法说明os.mkdir()创建目录os.rmdir()删除目录os.rename()重命名os.remove()删除文件os.getcwd()获取当前工作路径os.walk()遍历目录os.path.join()连接目录与文件名os.path.split()分割文件名与目录os.path.abspath()获取绝对路径os.path.dirname()获取路径os.path.basename()获取文件名或文件夹名os.path.splitext()分离文件名与扩展名os.path.isfile()判断给出的路径是否是一个文件os.path.isdir()判断给出的路径是否是一个目录json模块JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。数据格式可以简单地理解为键值对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。1import jsonPyhton的json模块提供了把内存中的对象序列化的方法。123456789101112131415161718import json# 序列化数据# f = open('JsonDemo.txt', 'a', encoding='utf-8')# dic = &#123;'name': 'luenci'&#125;# tmp = json.dumps(dic)# f.write(tmp)# f.close()# 反序列化数据f = open('JsonDemo.txt', 'r', encoding='utf-8')res = json.loads(f.read())print(res)print(type(res))# out# &#123;'name': 'luenci'&#125;# &lt;class 'dict'&gt;json.dumpsdump的功能就是把Python对象encode为json对象，一个编码过程。注意json模块提供了json.dumps和json.dump方法，区别是dump直接到文件，而dumps到一个字符串，这里的s可以理解为string。12345data = [ &#123; 'a':'A', 'b':(2, 4), 'c':3.0 &#125; ]print 'DATA:', repr(data)data_string = json.dumps(data)print 'JSON:', data_string12DATA: [&#123;'a': 'A', 'c': 3.0, 'b': (2, 4)&#125;]JSON: [&#123;"a": "A", "c": 3.0, "b": [2, 4]&#125;]查看其类型，发现是string对象。12print type(data)print type(data_string)12&lt;type 'list'&gt;&lt;type 'str'&gt;json.dump不仅可以把Python对象编码为string，还可以写入文件。因为我们不能把Python对象直接写入文件，这样会报错TypeError: expected a string or other character buffer object，我们需要将其序列化之后才可以。1data = [ &#123; 'a':'A', 'b':(2, 4), 'c':3.0 &#125; ]12with open('output.json','w') as fp: json.dump(data,fp)1[&#123;"a": "A", "c": 3.0, "b": [2, 4]&#125;]json.loads从Python内置对象dump为json对象我们知道如何操作了，那如何从json对象decode解码为Python可以识别的对象呢？是的用json.loads方法，当然这个是基于string的，如果是文件，我们可以用json.load方法。1decoded_json = json.loads(data_string)12# 和之前一样，还是listprint type(decoded_json)1&lt;type 'list'&gt;12# 像访问 data = [ &#123; 'a':'A', 'b':(2, 4), 'c':3.0 &#125; ]一样print decoded_json[0]['a']1Ajson.load可以直接load文件。123with open('output.json') as fp: print type(fp) loaded_json = json.load(fp)1&lt;type 'file'&gt;12# 和之前一样，还是listprint type(decoded_json)1&lt;type 'list'&gt;12# 像访问 data = [ &#123; 'a':'A', 'b':(2, 4), 'c':3.0 &#125; ]一样print decoded_json[0]['a']1A数据类型对应json和Python对象转换过程中，数据类型不完全一致，有对应。PythonJsondictobjectlist,tuplearraystr, unicodestringint,long,floatnumberTruetrueFalsefalseNonenulljson.dumps常用参数一些参数，可以让我们更好地控制输出。常见的比如sort_keys，indent，separators，skipkeys等。sort_keys名字就很清楚了，输出时字典的是按键值排序的，而不是随机的。123456data = [ &#123; 'a':'A', 'b':(2, 4), 'c':3.0 &#125; ]print 'DATA:', repr(data)unsorted = json.dumps(data)print 'JSON:', json.dumps(data)print 'SORT:', json.dumps(data, sort_keys=True)123DATA: [&#123;&apos;a&apos;: &apos;A&apos;, &apos;c&apos;: 3.0, &apos;b&apos;: (2, 4)&#125;]JSON: [&#123;&quot;a&quot;: &quot;A&quot;, &quot;c&quot;: 3.0, &quot;b&quot;: [2, 4]&#125;]SORT: [&#123;&quot;a&quot;: &quot;A&quot;, &quot;b&quot;: [2, 4], &quot;c&quot;: 3.0&#125;]indent就是更个缩进，让我们更好地看清结构。12345data = [ &#123; 'a':'A', 'b':(2, 4), 'c':3.0 &#125; ]print 'DATA:', repr(data)print 'NORMAL:', json.dumps(data, sort_keys=True)print 'INDENT:', json.dumps(data, sort_keys=True, indent=2)123456789101112DATA: [&#123;'a': 'A', 'c': 3.0, 'b': (2, 4)&#125;]NORMAL: [&#123;"a": "A", "b": [2, 4], "c": 3.0&#125;]INDENT: [ &#123; "a": "A", "b": [ 2, 4 ], "c": 3.0 &#125;]separators是提供分隔符，可以出去白空格，输出更紧凑，数据更小。默认的分隔符是(&#39;, &#39;, &#39;: &#39;)，有白空格的。不同的dumps参数，对应文件大小一目了然。123456data = [ &#123; 'a':'A', 'b':(2, 4), 'c':3.0 &#125; ]print 'DATA:', repr(data)print 'repr(data) :', len(repr(data))print 'dumps(data) :', len(json.dumps(data))print 'dumps(data, indent=2) :', len(json.dumps(data, indent=2))print 'dumps(data, separators):', len(json.dumps(data, separators=(',',':')))12345DATA: [&#123;'a': 'A', 'c': 3.0, 'b': (2, 4)&#125;]repr(data) : 35dumps(data) : 35dumps(data, indent=2) : 76dumps(data, separators): 29json需要字典的的键是字符串，否则会抛出ValueError。1234567891011data = [ &#123; 'a':'A', 'b':(2, 4), 'c':3.0, ('d',):'D tuple' &#125; ]print 'First attempt'try: print json.dumps(data)except (TypeError, ValueError) as err: print 'ERROR:', errprintprint 'Second attempt'print json.dumps(data, skipkeys=True)12345First attemptERROR: keys must be a stringSecond attempt[&#123;"a": "A", "c": 3.0, "b": [2, 4]&#125;]转载自：作者：米乐乐果链接：https://www.jianshu.com/p/e29611244810pickle 模块对于类和函数对象，json不能进行序列化，可以使用 pickle 模块来进行相应的操作pickle 模块只能用于Python中，不同版本的Python可能彼此都不兼容，因此，只能用Pickle保存那些不重要的数据pickle 写入方式：123456789import pickle def foo(): print('Hello World!') data = pickle.dumps(foo)f = open('test1','wb')f.write(data)f.close()pickle 的读取方式与 json 模块一致，同为 dump ，dumps 函数shelve 模块shelve 模块是一个简单的数据存储方案，类似key-value数据库，可以很方便的保存python对象，其内部是通过pickle协议来实现数据序列化。shelve 使用方式：12345678910111213141516import shelve with shelve.open("shelve_test") as f: f["name"] = 'alex' f["age"] = '25' # 这里直接保存到了文件中，生成了3个文件shelve_test.bak,shelve_test.dat,shelve_test.dir with shelve.open('shelve_test') as f: # 只使用shelvefile名字即可 print(f["name"]) for key, value in f.items(): print(key, ': ', value) &gt;&gt;&gt; alex age : 25 name : alexlogging模块logging模块是Python内置的标准模块，主要用于输出运行日志，可以设置输出日志的等级、日志保存路径、日志文件回滚等；相比print，具备如下优点：可以通过设置不同的日志等级，在release版本中只输出重要信息，而不必显示大量的调试信息；print将所有信息都输出到标准输出中，严重影响开发者从标准输出中查看其它数据；logging则可以由开发者决定将信息输出到什么地方，以及怎么输出basicConfig配置了 level 信息和 format 信息level配置为 INFO 信息，即只输出 INFO 级别的信息filename：即日志输出的文件名，如果指定了这个信息之后，实际上会启用 FileHandler，而不再是 StreamHandler，这样日志信息便会输出到文件中了。filemode：这个是指定日志文件的写入方式，有两种形式，一种是 w，一种是 a，分别代表清除后写入和追加写入。format=：指定了 format 格式的字符串，包括 asctime运行时间 name模块名称、levelname（日志级别）message （日志内容）12345678910111213%(levelno)s：打印日志级别的数值。%(levelname)s：打印日志级别的名称。%(pathname)s：打印当前执行程序的路径，其实就是sys.argv[0]。%(filename)s：打印当前执行程序名。%(funcName)s：打印日志的当前函数。%(lineno)d：打印日志的当前行号。%(asctime)s：打印日志的时间。%(thread)d：打印线程ID。%(threadName)s：打印线程名称。%(process)d：打印进程ID。%(processName)s：打印线程名称。%(module)s：打印模块名称。%(message)s：打印日志信息。datefmt：指定时间的输出格式。logging.setLevel :设定日志级别，只有大于或等于这个级别才输出DEBUG 级别0INFO级别1WARNING级别2ERROR级别3CRITICAL级别4style：如果 format 参数指定了，这个参数就可以指定格式化时的占位符风格，如 %、{、$ 等。level：指定日志输出的类别，程序会输出大于等于此级别的信息。stream：在没有指定 filename 的时候会默认使用StreamHandler，这时 stream 可以指定初始化的文件流。指定将日志的输出流，可以指定输出到sys.stderr，sys.stdout或者文件，默认输出到sys.stderr，当stream和filename同时指定时，stream被忽略；handlers：可以指定日志处理时所使用的 Handlers，必须是可迭代的。configparse模块读取和写入类似字典操作read(filename) 直接读取文件内容get(section, option) 获取section 下具体某一配置项的值(返回的是字符串)sections() 得到所有的section，并以列表的形式返回options(section) 得到该section的所有optionitems(section) 键值对的形式 得到该section的所有option写入配置123456789101112131415161718import configparserconfig = configparser.ConfigParser()config['DEFAULT'] = &#123;'serveraliveinterval' : '4', 'compression' : 'yes', 'compressionlevel' : '9'&#125;config['bitbucket'] = &#123;&#125;config['bitbucket']['user'] = 'luenci'config['topsecrect'] = &#123;&#125;topsecrect = config['topsecrect']topsecrect['port'] = '22'with open('example.ini', 'w') as f: config.write(f)读取配置文件12345678910111213141516171819import configparserconfig = configparser.ConfigParser()# 读取配置文件config.read('example.ini')print(config.sections())print(config.options('bitbucket'))for key in config['DEFAULT'].values(): print("%s%s"%(key,type(key)))out：['bitbucket', 'topsecrect']['user', 'serveraliveinterval', 'compression', 'compressionlevel']4&lt;class 'str'&gt;yes&lt;class 'str'&gt;9&lt;class 'str'&gt;操作函数add_section(section) 添加一个新的sectionset(section, option, value) 对section中添加 option 和 valueremove_section(section) 删除某个 sectionremove_option(section, option) 删除某个 section 下的 optionwrite() 将设置的新的 section 和 option 写到文件中configparse支持的数据类型一般情况下，configpaser类是无法识别配置文件中的value的数据类型的，它总是以字符串的形式来存储这些类型，所以当涉及到int float等类型的时候就需要我们自己对它进行转换configparser 为我们提供了getboolean() getint() getfloat()方法用来对读对应类型的配置其中getboolean方法可以识别 &#39;yes&#39;/&#39;no&#39;, &#39;on&#39;/&#39;off&#39;, &#39;true&#39;/&#39;false&#39; and &#39;1&#39;/&#39;0&#39;等数据并转换为布尔值hashlib模块用于加密有关的操作，主要有SHA1，SHA224，SHA256，SHA384，SHA512，MD5算法。替代了在python3中已废弃了md5和sha模块。md5加密12345import hashlibp = hashlib.md5()p.update('12345'.encode('utf-8'))print(p.hexdigest())sha1加密123p = hashlib.sha1()p.update('12345'.encode('utf-8'))print(p.hexdigest())以上加密算法虽然依然非常厉害，但时候存在缺陷，即：通过撞库可以反解。所以，有必要对加密算法中添加自定义key再来做加密。123456import hashlib# 加盐p = hashlib.md5('password'.encode('utf-8'))p.update('12345'.encode('utf-8'))print(p.hexdigest())]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>核心模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块、迭代器，生成器和装饰器]]></title>
    <url>%2F2020%2F05%2F21%2Fpython%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[module模块和包的介绍模块的介绍python给我们提供了十分简单的方法去创建一个模块，我们只需要写一个python文件即可，也就是说写一个.py为后缀的文件。包的介绍简单来说，包就是多个模块的集合。当项目较大，模块较多时，我们就可以把模块放在包中，便于管理。我们在包中一般带有__init__.py文件，随你建包的时候就默认生成。迭代器和生成器迭代器迭代器只不过是一个实现迭代器协议的容器对象。它基于两个方法：next ：返回容器的下一个项目在3.x的版本中为__next__或者next(可迭代对象)__iter__ : 返回迭代器本身迭代器可以通过使用一个iter内建函数和一个序列来创建，示例如下。12345678In [21]: a = ['a','b', 'c']In [22]: a = iter(a)In [23]: next(a)Out[23]: 'a'In [24]: a.__next__()Out[24]: 'b'生成器生成器从Python2.2起，生成器提供了一种出色的方法，使得需要返回一系列元素的函数所需的代码更加简单、高效。基于yield指令，可以暂停一个函数并返回中间结果。该函数将保存执行环境并且可以在必要时恢复。12345678910111213141516171819In [25]: def fibonanci(): ...: a, b = 0, 1 ...: while True: ...: yield b ...: a, b = b, a + b ...:In [26]: fib = fibonanci()In [28]: fib.__next__()Out[28]: 1In [29]: fib.__next__()Out[29]: 1In [30]: fib.__next__()Out[30]: 2In [31]: fib.__next__()yield可以理解为return,每次调用next()就yield值,下次next()从上次的yield处开始运行该函数将返回一个特殊的迭代器，也就是generator对象，它知道如何保存执行环境。对它的调用是不确定的，每次都将产生序列中的下一个元素。这种语法很简洁，算法的不确定特性并没有影响代码的可读性。不必提供使函数可停止的方法。实际上，这看上去像是用伪代码设计的序列一样。高阶函数的定义函数的接收参数是一个函数名函数的返回值是一个函数名1234567891011121314def father(name): print("I am father %s" %name) def son(): print("i am son") # print(locals()) return sonfather("luenci")father("luenci")()out:I am father luenciI am father luencii am son简单的装饰器@语法糖:相当于执行下面timmer(test)()123456789101112131415161718import timedef timmer(func): def wrapper(): start_time = time.time() func() stop_time = time.time() print(&quot;函数运行时间为: %s&quot;%(stop_time - start_time)) return wrapper@timmer# timmer(test)() @ 语法糖def test(): time.sleep(3) print(&quot;test函数运行完毕&quot;)test()# timmer(test)()带参数的装饰器12345678910111213141516171819202122232425import timedef timmer(func): def wrapper(*args, **kwargs): print(*args) # print(**kwargs) start_time = time.time() res = func(*args, **kwargs) stop_time = time.time() print("程序运行时间为：%s" % (stop_time - start_time)) return res return wrapper@timmerdef test(name, age, gender): time.sleep(2) print("我是%s,今年%s,性别%s" % (name, age, gender)) return "sucess"res = test("lusheng", 18, gender="男")# print(res)装饰器应用案例登录验证12345678910111213141516171819202122232425262728293031323334353637383940414243444546user_list = [ &#123;"username": "luenci", "pswd": "123"&#125;, &#123;"username": "lynn", "pswd": "456"&#125;, &#123;"username": "lu", "pswd": "789"&#125;,]current_dic = &#123;"username": None, "login": False&#125;def verify(func): def wrapper(*args, **kwargs): if current_dic['username'] and current_dic['login']: res = func(*args, **kwargs) return res username = input("请输入用户名:").strip() pswd = input("请输入密码:").strip() for user in user_list: if user['username'] == username and user['pswd'] == pswd: current_dic['username'] = username current_dic['login'] = True res = func(*args, **kwargs) return res else: print('用户名或密码错误') return wrapper@verifydef shop(): print('我的购物车')@verifydef user(): print('我的信息')@verifydef things(): print('我的商品')print('登录前的状态:%s'%(current_dic))user()print('登录后的状态:%s'%(current_dic))shop()things()日志记录1234567891011121314151617181920212223242526272829303132333435import loggingimport tracebackdef get_logger(): logger = logging.getLogger("Test") # 设定日志级别，只有大于或等于这个级别才输出 logger.setLevel(level=logging.DEBUG) # 当前路径下创建test_log文件记录错误日志 fh = logging.FileHandler("test_log", encoding='utf-8') ch = logging.StreamHandler() fm = logging.Formatter(fmt='%(asctime)s %(name)s %(pathname)s[%(lineno)d] %(message)s', datefmt='%Y/%m/%d %H:%M:%S') fh.setFormatter(fm) ch.setFormatter(fm) logger.addHandler(fh) logger.addHandler(ch) return loggerdef decoratore(func): def log(*args,**kwargs): try: print("当前运行方法", func.__name__) return func(*args,**kwargs) except Exception as e: get_logger().error(f"&#123;func.__name__&#125; is error,here are details:&#123;traceback.format_exc()&#125;") return log@decoratoredef test(): print(1/0)test()​]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数补充]]></title>
    <url>%2F2020%2F05%2F14%2Fpython%E5%87%BD%E6%95%B0%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[递归函数递归特性1.必须有一个明确的结束条件2.每次进入更深一层递归时，问题规模相比上次递归都应有所减少3.递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出）代码演练123456789101112131415161718def send(student): if len(student) == 0: return 'All student revice messges' one = student.pop() if one == 'luenci': print('luenci get') send(student) elif one == 'jack': print('jack get') send(student) else: print('xiaoming get') send(student)if __name__ == "__main__": student_list = ['luenci', 'jack', 'xiaoming'] send(student_list)函数作用域123456789101112131415161718192021222324def foo(): name = 'luenci' def bar(): name = 'xiaoming' def tt(): print(name) return tt return barprint(foo)print(foo())print(foo()())# bar=foo()# tt=bar()# print(tt)# tt()foo()()()out&gt;&gt;&lt;function foo at 0x0000020655A92E18&gt;&lt;function foo.&lt;locals&gt;.bar at 0x00000206577809D8&gt;&lt;function foo.&lt;locals&gt;.bar.&lt;locals&gt;.tt at 0x0000020657780A60&gt;xiaoming函数式编程匿名函数函数声明：lambda 参数:表达式返回值1234567891011def test(x): return x+1print(test(10))fun = lambda x:x+1print(fun(10))out:1111初始版1234567891011121314151617num_l = [1,2,3,4,5,6]def add(num): return num+1def subtraction(num): return num-1def square(num): return num**2def opertion(func,args): ret = [] for i in args: res = func(i) ret.append(res) return ret进阶版12345678def opertion(func,args): ret = [] for i in args: res = func(i) ret.append(res) return ret print(opertion(lambda x: x + 1, num_l))map函数版1map(lambda x: x + 1, num_l)filter函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。1filter(function, iterable)参数function – 判断函数。iterable – 可迭代对象。reduce()函数1reduce(function, iterable[, initializer])对参数序列中元素进行累积参数function – 函数，两个参数iterable – 可迭代对象initializer – 可选，初始参数12345from functools import reducenum_l = [1,2,3,4,5]print(reduce(lambda x, y: x + y, num_l))一些内置函数abs（）返回绝对值eval（）解除引号的束缚123&gt;&gt;&gt; info = '&#123;"name": "LiHua", "age": 12&#125;'&gt;&gt;&gt; eval(info)&#123;'name': 'LiHua', 'age': 12&#125;dir （）函数返回属性列表id （）函数返回对象地址isinstance（）判断对象的类型type （）返回对象的类型enumerate 函数返回元素的序号与对应值123456789In [3]: for i,elm in enumerate(seq): ...: print(i,elm) ...: 0 P 1 y 2 t 3 h 4 o 5 n]]></content>
      <categories>
        <category>python进阶</category>
      </categories>
      <tags>
        <tag>函数补充</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习（二）]]></title>
    <url>%2F2020%2F05%2F06%2FLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Linux操作系统（二）进程命令ps aux 显示所有进程ps aux | grep &#39;&#39; 筛选出相关进程kill pid 杀死相关的pid进程kill - 9 pid 强制杀死进程jobs查看进程的工作号fg %工作号后台程序调到前台运行硬盘分区fdisk -l /dev/磁盘名查看对应磁盘名的详细信息文件系统磁盘分区完毕后还需要进行格式化（format），之后操作系统才能够使用这个文件系统。 为什么需要进行“格式化”呢？这是因为每种操作系统所设置的文件属性/权限并不相同， 为了存放这些文件所需的数据，因此就需要将分区进行格式化，以成为操作系统能够利用的“文件系统格式（filesystem）”。由此我们也能够知道，每种操作系统能够使用的文件系统并不相同。 举例来说，windows 98 以前的微软操作系统主要利用的文件系统是 FAT （或 FAT16），windows 2000 以后的版本有所谓的 NTFS 文件系统，至于 Linux 的正统文件系统则为 Ext2 （Linux second extended file system, ext2fs）这一个。此外，在默认的情况下，windows 操作系统是不会认识 Linux 的 Ext2 的。传统的磁盘与文件系统之应用中，一个分区就是只能够被格式化成为一个文件系统，所以我们可以说一个 filesystem 就是一个 partition。但是由于新技术的利用，例如我们常听到的LVM与软件磁盘阵列（software raid）， 这些技术可以将一个分区格式化为多个文件系统（例如LVM），也能够将多个分区合成一个文件系统（LVM, RAID）！ 所以说，目前我们在格式化时已经不再说成针对 partition 来格式化了， 通常我们可以称呼一个可被挂载的数据为一个文件系统而不是一个分区喔！那么文件系统是如何运行的呢？这与操作系统的文件数据有关。较新的操作系统的文件数据除了文件实际内容外， 通常含有非常多的属性，例如 Linux 操作系统的文件权限（rwx）与文件属性（拥有者、群组、时间参数等）。 文件系统通常会将这两部份的数据分别存放在不同的区块，权限与属性放置到 inode 中，至于实际数据则放置到 data block 区块中。 另外，还有一个超级区块 （superblock） 会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等。每个 inode 与 block 都有编号，至于这三个数据的意义可以简略说明如下：superblock：记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 block 号码；block：实际记录文件的内容，若文件太大时，会占用多个 block 。由于每个 inode 与 block 都有编号，而每个文件都会占用一个 inode ，inode 内则有文件数据放置的 block 号码。 因此，我们可以知道的是，如果能够找到文件的 inode 的话，那么自然就会知道这个文件所放置数据的 block 号码， 当然也就能够读出该文件的实际数据了。这是个比较有效率的作法，因为如此一来我们的磁盘就能够在短时间内读取出全部的数据， 读写的性能比较好啰。我们将 inode 与 block 区块用图解来说明一下，如下图所示，文件系统先格式化出 inode 与 block 的区块，假设某一个文件的属性与权限数据是放置到 inode 4 号（下图较小方格内），而这个 inode 记录了文件数据的实际放置点为 2, 7, 13, 15 这四个 block 号码，此时我们的操作系统就能够据此来排列磁盘的读取顺序，可以一口气将四个 block 内容读出来！ 那么数据的读取就如同下图中的箭头所指定的模样了。图7.1.1、inode/block 数据存取示意图这种数据存取的方法我们称为索引式文件系统（indexed allocation）。那有没有其他的惯用文件系统可以比较一下啊？ 有的，那就是我们惯用的U盘（闪存），U盘使用的文件系统一般为 FAT 格式。FAT 这种格式的文件系统并没有 inode 存在，所以 FAT 没有办法将这个文件的所有 block 在一开始就读取出来。每个 block 号码都记录在前一个 block 当中， 他的读取方式有点像下面这样：图7.1.2、FAT文件系统数据存取示意图​ 上图中我们假设文件的数据依序写入1-&gt;7-&gt;4-&gt;15号这四个 block 号码中， 但这个文件系统没有办法一口气就知道四个 block 的号码，他得要一个一个的将 block 读出后，才会知道下一个 block 在何处。 如果同一个文件数据写入的 block 分散的太过厉害时，则我们的磁头将无法在磁盘转一圈就读到所有的数据， 因此磁盘就会多转好几圈才能完整的读取到这个文件的内容！常常会听到所谓的“磁盘重组”吧？ 需要磁盘重组的原因就是文件写入的 block 太过于离散了，此时文件读取的性能将会变的很差所致。 这个时候可以通过磁盘重组将同一个文件所属的 blocks 汇整在一起，这样数据的读取会比较容易啊！ 想当然尔，FAT 的文件系统需要三不五时的磁盘重组一下，那么 Ext2 是否需要磁盘重整呢？由于 Ext2 是索引式文件系统，基本上不太需要常常进行磁盘重组的。但是如果文件系统使用太久， 常常删除/编辑/新增文件时，那么还是可能会造成文件数据太过于离散的问题，此时或许会需要进行重整一下的。 不过，老实说，鸟哥倒是没有在 Linux 操作系统上面进行过 Ext2/Ext3 文件系统的磁盘重组.每个 filesystem 都有独立的inode / block / superblock等信息，这个文件系统要能够链接到目录树才能被我们使用。 将文件系统与目录树结合的动作我们称为“挂载”。重点是：挂载点一定是目录，该目录为进入该文件系统的入口。 因此并不是你有任何文件系统都能使用，必须要“挂载”到目录树的某个目录后，才能够使用该文件系统的。关于硬盘空间满1.指硬盘存储空间满2.inode节点数满了查看inode命令ll -i 文件名硬链接和软链接软链接ln -s 源路径 目标路径类似windows操作系统的快捷方式删除链接文件，源文件不影响删除源文件，链接文件失效修改源文件/链接文件，内容都变软链接可以跨分区硬链接ln 源路径 目标路径删除链接文件，源文件无影响删除源文件，链接文件无影响修改源文件/链接文件，内容都变硬链接不可以跨分区软件包管理rpm:readhat package managerpm -ivh 软件包名 安装rpm -qa查看安装的软件包rpm -e 软件包名卸载软件包.tar.gz这种软件包需要编译安装1.解压 tar xvf 压缩包名运行configure指定参数，例如：--prefix:安装路径2.编译（gcc glibc） make make installyum软件包管理（Centos）yum install 软件包名本地的yum仓库路径/etc/yum.repos.d/指定yum仓库的加载顺序安装完yum-priorities插件后需要设置/etc/yum.repos.d/目录下的.repo相关文件（如CentOS-Base.repo），在这些文件中插入顺序指令：priority=N （N为1到99的正整数，数值越小越优先）一般配置[base], [addons], [updates], [extras]的priority=1，[CentOSplus], [contrib] 的priority=2，其他第三的软件源为：priority=N （推荐N&gt;10）以CentOS-Base.repo为例：1234567[base]name=CentOS-$releasever - Base#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=osbaseurl=http://ftp.sjtu.edu.cn/centos/$releasever/os/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5priority=1]]></content>
      <categories>
        <category>Linux</category>
        <category>核心知识</category>
      </categories>
      <tags>
        <tag>Linux知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络学习]]></title>
    <url>%2F2020%2F05%2F02%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[计算机网络概述OSI七层协议物理层传输的数据类型：比特流主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特数据链路层传输的数据类型：帧定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。网络层传输的数据类型：数据报在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。 运输层报文段/用户数据报定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（transmission control protocol –传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据）UDP（user datagram protocol–用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。会话层通过运输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）表示层可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。应用层传输的数据类型：报文五层协议1 第五层——应用层(application layer)应用层(application layer)：是体系结构中的最高。直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。在因特网中的应用层协议很多，如支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议，DNS，POP3，SNMP，Telnet等等。2. 第四层——运输层(transport layer)运输层(transport layer)：负责向两个主机中进程之间的通信提供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能复用，就是多个应用层进程可同时使用下面运输层的服务。分用，就是把收到的信息分别交付给上面应用层中相应的进程。运输层主要使用以下两种协议：(1) 传输控制协议TCP(Transmission Control Protocol)：面向连接的，数据传输的单位是报文段，能够提供可靠的交付。(2) 用户数据包协议UDP(User Datagram Protocol)：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。3. 第三层——网络层(network layer)网络层(network layer)主要包括以下两个任务：(1) 负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报。(2) 选中合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。协议：IP,ICMP,IGMP,ARP,RARP4. 第二层——数据链路层(data link layer)数据链路层(data link layer)：常简称为链路层，我们知道，两个主机之间的数据传输，总是在一段一段的链路上传送的，也就是说，在两个相邻结点之间传送数据是直接传送的(点对点)，这时就需要使用专门的链路层的协议。在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧(framing)，在两个相邻结点之间的链路上“透明”地传送帧中的数据。每一帧包括数据和必要的控制信息(如同步信息、地址信息、差错控制等)。典型的帧长是几百字节到一千多字节。注：”透明”是一个很重要的术语。它表示，某一个实际存在的事物看起来却好像不存在一样。”在数据链路层透明传送数据”表示无力什么样的比特组合的数据都能够通过这个数据链路层。因此，对所传送的数据来说，这些数据就“看不见”数据链路层。或者说，数据链路层对这些数据来说是透明的。(1)在接收数据时，控制信息使接收端能知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层。(2)控制信息还使接收端能检测到所收到的帧中有无差错。如发现有差错，数据链路层就简单地丢弃这个出了差错的帧，以免继续传送下去白白浪费网络资源。如需改正错误，就由运输层的TCP协议来完成。5. 第一层——物理层(physical layer)物理层(physical layer)：在物理层上所传数据的单位是比特。物理层的任务就是透明地传送比特流。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>OSI七层协议</category>
      </categories>
      <tags>
        <tag>计算机网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习（一）]]></title>
    <url>%2F2020%2F05%2F02%2FLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Linux操作系统“一切皆文件”系统启动流程引导图最初始阶段当我们打开计算机电源，计算机会自动从主板的BlOS（Basic Input/output System）读取其中所存储的程序。这一程序通常知道一些直接连接在主板上的硬件（硬盘，网络接口，键盘，串口，并口）。现在大部分的BIOS允许你从软盘、光盘或者硬盘中选择一个来启动计算机。下一步，计算机将从你所选择的存储设备中读取起始的512 bytes（比如光盘一开是的512 bytes，如果我们从光盘启动的话）。这512bytes叫做主引导记录MBR（master boot record）。MBR会告诉电脑从该设备的某一个分区（partition）来装载引导加载程序（boot loader）。Boot loader储存有操作系统（OS）的相关信息，比如操作系统名称，操作系统内核（kernel）所在位置等。常用的boot loader有GRUB和LILO。随后，boot loader会帮助我们加载kernel。kernel实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过kernel传达给硬件。Windows和Linux各自有自己kernel。狭义的操作系统就是指kernel，广义的操作系统包括kernel以及kernel之上的各种应用。（Linus Torvalds与其说是Linux之父，不如说是Linux kernel之父。他依然负责Linux kernel的开发和维护。至于Ubuntu，Red Hat，它们都是基于相同的kernel之上，囊括了不同的应用和界面构成的一个更加完整的操作系统版本。）实际上，我们可以在多个分区安装boot loader，每个boot loader对应不同的操作系统，在读取MBR的时候选择我们想要启动的boot loader。这就是多操作系统的原理。小结：BlOS -&gt; MBR -&gt; boot loader -&gt; kernelkernel如果我们加载的是Linux kernel，Linux kernel开始工作。kernel会首先预留自己运行所需的内存空间，然后通过驱动程序（driver）检测计算机硬件。这样，操作系统就可以知道自己有哪些硬件可用。随后，kernel会启动一个init进程。它是Linux系统中的1号进程（Linux系统没有0号进程）。到此，kernel就完成了在计算机启动阶段的工作，交接给init来管理。小结：kernel -&gt; init processinit process（根据boot loader的选项，Linux此时可以进入单用户模式（single user mode））。在此模式下，初始脚本还没有开始执行，我们可以检测并修复计算机可能存在的错误）随后，init会运行一系列的初始脚本（startup scripts），这些脚本是Linux中常见的shell scripts。这些脚本执行如下功能：设置计算机名称，时区，检测文件系统，挂载硬盘，清空临时文件，设置网络等当这些初始脚本，操作系统已经完全准备好了，只是，还没有人可以登录！！！init会给出登录（login）对话框，或者是图形化的登录界面。输入用户名（比如说luenci）和密码，DONE！在此后的过程中，你将以用户（user）luenci的身份操作电脑。此外，根据你创建用户时的设定，Linux还会将你归到某个组（group）中，比如可以是stupid组，或者是luenci组。所以你将是用户luenci，同时是luenci组的组员。（注意，组luenci和用户luenci只是重名而已，就好想你可以叫Dell，同时还是Dell公司的老板一样。你完全也可以是用户luenci，同时为stupid组的组员）启动级别7种运行级别运行级别（Runlevel）指的是Unix或者Linux等类Unix操作系统的运行模式，不同的运行模式下系统的功能也有所有不同。Linux 系统下通常分为7种运行级别，分别是从0到6。各级别介绍如下：0–停机模式在这种模式下，系统处于停机状态，系统默认运行级别不能设为0，否则将不能正常启动。这个运行级别主要用于关闭任务，在/etc/rc0.d目录下的各个连接命令都是此级别的命令，在关闭系统时，这些命令将被逐个执行。它 们会杀掉所有进程、关闭虚拟内存和交换文件、卸载文件系统和交换分区。1– 单用户模式。在这种运行模下，系统处于单用户工作状态，登录用户具有root权限，文件系统被加载但是网络却没有被加载，因此也无法远程登陆。这个运行级别，只允一个用户从本地计算机上登录，/etc/rc1.d目录下的所有文件与此运行级别相关连，这个运行级别一般用于系统管理与维护。2 - -多用户模式。用户可以通过网络进行登录，但没有NFS（Network File System），即网络文件统。/etc/rc2.d目录下所有文件与此级别相连。3 - -完全多用户模式。用户可以通过网络进行登录，且有NFS，用户登陆后会进入控制台命令行模式。这也是缺省的运行模式，在这种运行级别下所有网络服务程序会一起运行。/etc/rc2.d录下的文件与此级别相连4 - -自定义模式。这是一种系统未使用的保留模式，/etc/rc4.d目录与此级别相连。这一级别是用户自定义的运行级别，用户可以根自己的需要进行一些自定义设置。如果想要运行这一级别的话，必须在rc3.d目录下放入连接文件，就像其他rc*.d目录下的文件，并指明是启动还是终止进程。5 - -图形化模式。在 Linux 下运行X Window就是使用这一运行级别，用户登录后将进入图形化的GUI界面。在这一级别下除了DNS的named与级别3不同，其余的都相同。6 – 重启模式。系统正常关闭并重启，默认运行级别不能设为5，否则系统将不能正常启动。/etc/rc6.d目录与此级别相连。在这一运行级别下，不会关闭电源，/etc/rc6.d目录下的连接与rc0.d目录下的连接基本相同；不同之处在于，虽然它们都执行halt（关闭）命令，但是给halt传递的参数不同，所级别6会重新启动系统而0会关闭系统。GRUB加密GRUB程序和grub.conf文件1）掌握GRUB的定义：GRUB是Grand Unified Boot loader（多重操作系统启动管理器）的缩写。心2）掌握grub的配置文件为：grub.conf设置grub Md5加密命令grub-md5-cryptPassword=明文或password-md5密文（编辑grub配置文件的密码）Title red hat 标题Password=明文或password--md5密文（加载内核系统引导必须的密码）BIOS加密设置BIOS密码来防止更改GRU配置文件但是这种方法可将主板电池扣下，主板自动还原，密码也失效了没有绝对的安全，要不停的学习目录结构在Linux或UNIX操作系统中，所有的文件和目录都被组织成一个以根节点开始的倒置的树状结构。顶层根目录的表示使用&#39;/&#39;来表示根目录文件系统中的特殊目录.表示当前目录，即用户所在的工作目录..表示父目录，即当前目录的上一层目录~代表当前用户的家目录（home）一些重要目录bin目录：用来存放常用的可执行文件sbin目录：用来存放系统的可执行文件home家目录：用来存放用户自己的文件或目录，其中，超级用户root的家目普通用户的家目录被存放在/home目录下，并使用用户名作为最后一级目的名称，如luenci用户的家目录为/home/luencidev目录：设备文件目录etc目录：配置文件目录挂载点（目录）：通常可移除式硬件会被挂载在/media或/mnt目录之下用户，群组，权限管理/etc/passed文件中存放用户的信息分别对应的是：用户名：密码：user_id：group_id：描述名：家目录（home）：登录后执行的命令如果执行的登录命令为：/bin/bash则可以登录如果执行的登录命令为：/sbin/nologin则不可以登录user_id: 500以前id号为系统占用的useradd命令的常用选项-u：指定用户的UID-g：指定用户所属的群组-d：指定用户的家目录-c：指定用户的备注信息-s：指定用户所用的shell-r: 删除用户文件的权限管理权限信息(用户权限(u);组权限(g);其他用户权限(0))；硬链接数；用户；用户组；文件大小；文件创建日期r-&gt;4w-&gt;2x-&gt;1-开头代表一个文件类型d开头代表一个目录类型l开头代表一个软链接b（block）开头代表设备文件p开头有代表管道文件对于可执行文件的运行sh 可执行文件名bash 可执行文件名./可执行文件名. 可执行文件名目录的权限管理ll -d 目录查看目录的权限更改文件的用户和组chown 用户.组别 文件名chown -R递归修改用户和组文件合并wc -l 文件名统计文件行数&gt;以覆盖的方式写入内容&gt;&gt;以追加的方式写入内容解压和压缩命令1、.tar解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）2、.gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName3、.tar.gz 和.tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName4、.bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩：bzip2 -z FileName5、.tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName6、.bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz7、.tar.bz解压：tar jxvf FileName.tar.bz8、.Z解压：uncompress FileName.Z压缩：compress FileName9、.tar.Z解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName10、.zip解压：unzip FileName.zip压缩：zip FileName.zip DirName11、.rar解压：rar x FileName.rar压缩：rar a FileName.rar DirName12、.lha解压：lha -e FileName.lha压缩：lha -a FileName.lha FileName13、.rpm解包：rpm2cpio FileName.rpm | cpio -divvim一些常见指令快速在屏幕中移动光标的位置的命令H光标移动到这个屏幕的最上方那一行的第一个字符M无标移动到这个屏幕的中央那一行的第一个字符L无标移动到这个屏幕的最下那一行的第一个字符G移动到文件的最后一行gg移动到文件的第一行ctrl+ r恢复上一次操作u撤销上一个操作ctrl+a跳到文件的首部ctrl+e跳到文件的尾部yy复制p粘贴到行尾P站贴到行头top命令第一行字符含义top - 10:03:19当前系统时间up 137 days , 10:40系统已运行时间2 user在线用户load average: 0.00, 0.01, 0.05系统负载。三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。2 user，包含系统用户。第二行字符含义Tasks : 92 total总进程数2 running正在运行的进程数90 sleeping正在睡眠的进程数0 stopped停止的进程数0 zombie僵尸进程数僵尸进程:一个子进程在其父进程没有调用wait()或waitpid()的情况下退出。这个子进程就是僵尸进程。如果其父进程还存在而一直不调用wait，则该僵尸进程将无法回收，等到其父进程退出后该进程将被init回收。第三行字符含义%Cpu(s): 0.3 uscpu占用率(%)，用户进程占用cpu百分率0.3 sy系统占用cpu百分率0.0 ni用户进程空间内改变过优先级的进程占用CPU百分比99.3 idcpu空闲率0.0 wa等待IO的CPU时间百分比0.0 hi硬中断（Hardware IRQ）占用CPU的百分比0.0 si软中断（Software Interrupts）占用CPU的百分比cpu的使用情况第四行字符含义KiB Mem : 1016916 total内存总量（我这里是1G）82280 free内存空闲量233848 used内存使用量700788 buff/cache缓存的内存量内存使用率第五行字符含义KiB Swap: 0 total交换区总量0 free交换区空闲量0 used交换区使用量swap分区第六行字符含义PID进程号USER进程创建者PR进程优先级NInice值。越小优先级越高，最小-20，最大20（用户设置最大19）VIRT进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RESRES进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATASHR共享内存大小，单位kbS进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程%CPU进程占用cpu百分比%MEM进程占用内存百分比TIME+进程运行时间COMMAND进程名称PR 越低优先级 越高，PRI(new)=PRI(old)+nicePR中的rt为实时进程优先级即rt_priority，prio=MAX_RT_PRIO - 1- p-&gt;rt_priorityMAX_RT_PRIO = 99，prio大小决定最终优先级。这样意味着rt_priority值越大，优先级越高而内核提供的修改优先级的函数，是修改rt_priority的值，所以越大，优先级越高。例：改变优先级：进入top后按“r”–&gt;输入进程PID–&gt;输入nice值top命令（在进入top后使用）P：以占据CPU百分比排序M：以占据内存百分比排序T：以累积占用CPU时间排序q：退出命令：按q键退出top查看页面s：修改刷新时间间隔。按下s键，然后按下数字，即可修改刷新时间间隔为你输入的数字，单位为秒。例如：按下s键，在按数字1键，即可实现每秒刷新一次k：终止指定的进程。按下k键–&gt;再输入要杀死的进程的pid–&gt;按enter键–&gt;(选择信号类型，以数字标示，默认15为杀死)本步可省略按enter键（常用为-9）free命令freefree -mfree -h]]></content>
      <categories>
        <category>Linux</category>
        <category>核心知识</category>
      </categories>
      <tags>
        <tag>Linux知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查看mysql连接状况]]></title>
    <url>%2F2020%2F04%2F27%2F%E6%9F%A5%E7%9C%8Bmysql%E8%BF%9E%E6%8E%A5%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[使用mysql- uroot -p登录后执行命令: show processlist;查询当前数据库用户连接情况.如果是root帐号,你能看到所有用户的当前连接.如果是其它普通帐号,只能看到自己占用的连接.只列出前100条show processlist;如果想全列出请使用show full processlist;12345mysql&gt; show processlist;命令： show status;命令：show status like ‘%下面变量%’;Aborted_clients 由于客户没有正确关闭连接已经死掉,已经放弃的连接数量.Aborted_connects 尝试已经失败的MySQL服务器的连接的次数.Connections 试图连接MySQL服务器的次数.Created_tmp_tables 当执行语句时,已经被创造了的隐含临时表的数量.Delayed_insert_threads 正在使用的延迟插入处理器线程的数量.Delayed_writes 用INSERT DELAYED写入的行数.Delayed_errors 用INSERT DELAYED写入的发生某些错误(可能重复键值)的行数.Flush_commands 执行FLUSH命令的次数.Handler_delete 请求从一张表中删除行的次数.Handler_read_first 请求读入表中第一行的次数.Handler_read_key 请求数字基于键读行.Handler_read_next 请求读入基于一个键的一行的次数.Handler_read_rnd 请求读入基于一个固定位置的一行的次数.Handler_update 请求更新表中一行的次数.Handler_write 请求向表中插入一行的次数.Key_blocks_used 用于关键字缓存的块的数量.Key_read_requests 请求从缓存读入一个键值的次数.Key_reads 从磁盘物理读入一个键值的次数.Key_write_requests 请求将一个关键字块写入缓存次数.Key_writes 将一个键值块物理写入磁盘的次数.Max_used_connections 同时使用的连接的最大数目.Not_flushed_key_blocks 在键缓存中已经改变但是还没被清空到磁盘上的键块.Not_flushed_delayed_rows 在INSERT DELAY队列中等待写入的行的数量.Open_tables 打开表的数量.Open_files 打开文件的数量.Open_streams 打开流的数量(主要用于日志记载）Opened_tables 已经打开的表的数量.Questions 发往服务器的查询的数量.Slow_queries 要花超过long_query_time时间的查询数量.Threads_connected 当前打开的连接的数量.Threads_running 不在睡眠的线程数量.Uptime 服务器工作了多少秒.]]></content>
      <categories>
        <category>SQL知识</category>
      </categories>
      <tags>
        <tag>SQL命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[list, tuple, dictionary, set的底层细节（python）]]></title>
    <url>%2F2020%2F04%2F05%2Fpython%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[list, tuple, dictionary, set的底层细节列表实现细节python中的列表的英文名是list，因此很容易和其它语言(C++, Java等)标准库中常见的链表混淆。事实上CPython的列表根本不是列表（可能换成英文理解起来容易些：python中的list不是list）。在CPython中，列表被实现为长度可变的数组。​ 可参考《Python高级编程（第2版）》从细节上看，Python中的列表是由对其它对象的引用组成的连续数组。指向这个数组的指针及其长度被保存在一个列表头结构中。这意味着，每次添加或删除一个元素时，由引用组成的数组需要该标大小（重新分配）。幸运的是，Python在创建这些数组时采用了指数分配，所以并不是每次操作都需要改变数组的大小。但是，也因为这个原因添加或取出元素的平摊复杂度较低。不幸的是，在普通链表上“代价很小”的其它一些操作在Python中计算复杂度相对过高。利用 list.insert(i,item) 方法在任意位置插入一个元素——复杂度O(N)利用 list.pop(i) 或 list.remove(value) 删除一个元素——复杂度O(N)操作复杂度复制O(N)添加元素(在尾部添加)O(1)插入元素(在指定位置插入)O(N)获取元素O(1)修改元素O(1)删除元素O(N)遍历O(N)获取长度为k的切片O(k)删除切片O(N)列表扩展O(k)测试是否在列表中O(N)min()/max()O(n)获取列表长度O(1)字典实现细节CPython使用伪随机探测(pseudo-random probing)的散列表(hash table)作为字典的底层数据结构。由于这个实现细节，只有可哈希的对象才能作为字典的键。Python中所有不可变的内置类型都是可哈希的。可变类型（如列表，字典和集合）就是不可哈希的，因此不能作为字典的键。字典的三个基本操作（添加元素，获取元素和删除元素）的平均事件复杂度为O(1)，但是他们的平摊最坏情况复杂度要高得多，为O(N).字典的三个基本操作（添加元素，获取元素和删除元素）的平均事件复杂度为O(1)，但是他们的平摊最坏情况复杂度要高得多，为O(N).操作平均复杂度平摊最坏情况复杂度获取元素O(1)O(n)修改元素O(1)O(n)删除元素O(1)O(n)复制O(n)O(n)遍历O(n)O(n)还有一点很重要，在复制和遍历字典的操作中，最坏的复杂度中的n是字典曾经达到的最大元素数目，而不是当前的元素数目。换句话说，如果一个字典曾经元素个数很多，后来又大大减小了，那么遍历这个字典可能会花费相当长的事件。因此在某些情况下，如果需要频繁的遍历某个词典，那么最好创建一个新的字典对象，而不是仅在旧字典中删除元素。集合实现细节集合是一种鲁棒性很好的数据结构，当元素顺序的重要性不如元素的唯一性和测试元素是否包含在集合中的效率时，大部分情况下这种数据结构极其有用。python的内置集合类型有两种：set(): 一种可变的、无序的、有限的集合，其元素是唯一的、不可变的（可哈希的）对象。frozenset(): 一种不可变的、可哈希的、无序的集合，其元素是唯一的，不可变的哈希对象。CPython中集合和字典非常相似。事实上，集合被实现为带有空值的字典，只有键才是实际的集合元素。此外，集合还利用这种没有值的映射做了其它的优化。由于这一点，可以快速的向集合中添加元素、删除元素、检查元素是否存在。平均时间复杂度为O(1),最坏的事件复杂度是O(n)。哈希函数哈希函数就是一个映射，因此哈希函数的设定很灵活，只要使得任何关键字由此所得的哈希函数值都落在表长允许的范围之内即可；并不是所有的输入都只对应唯一一个输出，也就是哈希函数不可能做成一个一对一的映射关系，其本质是一个多对一的映射，这也就引出了下面一个概念–冲突。只要不是一对一的映射关系，冲突就必然会发生冲突解决方法（python所使用的）开放地址线性探测再散列例如 哈希函数为： H（key） = key %11,key 为关键字，采用开放地址法中的线性探测再散列解决冲突，依次输入9 个关键字，19，01，23，14，55，68，11，82，36，构造哈希表（表长=11）散列地址012345678910关键字550123146811823619探测次数112136251如上表，例如 14%11=3，将14放入3号位置，11%11 = 0，将11放入0号位置，而此时3号位已经有元素。就顺着表往后放，直到5号没有元素，11放入5号。二次探测再散列例如 哈希函数为： H（key） = key %11,key 为关键字，采用开放地址法中的二次探测再散列解决冲突，依次输入9 个关键字，19，01，23，14，55，68，11，82，36，构造哈希表（表长=11）散列地址012345678910关键字550123143682681911探测次数112121413对于01%11=1，将01放入1号位置， 11%11=0，此时0号位置已经有元素，则查找 0 + 1^2 = 1,有元素查找 0 - 1^2 = -1 ,没有则放入，如果还有元素则查找0 + 2^2, 0-2^2…. 0+k^2, 0 - k^2。扩展（哈希冲突解决方法）开放地址开放地址的意思是除了哈希函数得出的地址可用，当出现冲突的时候其他的地址也一样可用，常见的开放地址思想的方法有线性探测再散列，二次探测再散列，这些方法都是在第一选择被占用的情况下的解决方法。再哈希法这个方法是按顺序规定多个哈希函数，每次查询的时候按顺序调用哈希函数，调用到第一个为空的时候返回不存在，调用到此键的时候返回其值。链地址法将所有关键字哈希值相同的记录都存在同一线性链表中，这样不需要占用其他的哈希地址，相同的哈希值在一条链表上，按顺序遍历就可以找到。公共溢出区其基本思想是：所有关键字和基本表中关键字为相同哈希值的记录，不管他们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。装填因子α一般情况下，处理冲突方法相同的哈希表，其平均查找长度依赖于哈希表的装填因子。哈希表的装填因子定义为表中填入的记录数和哈希表长度的壁纸，也就是标志着哈希表的装满程度。直观看来，α越小，发生冲突的可能性就越小，反之越大。一般0.75比较合适，涉及数学推导。]]></content>
      <categories>
        <category>python进阶</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker相关知识学习]]></title>
    <url>%2F2020%2F02%2F28%2Fdocker%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[IaaS、PaaS、SaaS 的区别基础设施(infrastructure)、平台(platform)和软件(software)其实就是云计算的三个分层，基础设施在最下端，平台在中间，软件在顶端，分别是分别是Infrastructure-as-a-Service(IaaS)，Platform-as-a-Service(PaaS)，Software-as-a-Service(SaaS)IaaS: Infrastructure-as-a-Service(基础设施即服务)有了IaaS，你可以将硬件外包到别的地方去。IaaS公司会提供场外服务器，存储和网络硬件，你可以租用。节省了维护成本和办公场地，公司可以在任何时候利用这些硬件来运行其应用。一些大的IaaS公司包括Amazon, Microsoft, VMWare, Rackspace和Red Hat.不过这些公司又都有自己的专长，比如Amazon和微软给你提供的不只是IaaS，他们还会将其计算能力出租给你来host你的网站。PaaS: Platform-as-a-Service(平台即服务)第二层就是所谓的PaaS，某些时候也叫做中间件。你公司所有的开发都可以在这一层进行，节省了时间和资源。PaaS公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统。这节省了你在硬件上的费用，也让分散的工作室之间的合作变得更加容易。网页应用管理，应用设计，应用虚拟主机，存储，安全以及应用开发协作工具等。一些大的PaaS提供者有Google App Engine,Microsoft Azure，Force.com,Heroku，Engine Yard。最近兴起的公司有AppFog,Mendix和Standing Cloud.SaaS: Software-as-a-Service(软件即服务)第三层也就是所谓SaaS。这一层是和你的生活每天接触的一层，大多是通过网页浏览器来接入。任何一个远程服务器上的应用都可以通过网络来运行，就是SaaS了。docker知识Docker 是世界领先的软件容器平台Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核 的cgroup，namespace，以及AUFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。 由于隔离的进程独立于宿主和其它的隔离的进 程，因此也称其为容器。Docker最初实现是基于 LXC.Docker 能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：构建杰出的软件。用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。物理机物理机，对应采购的服务器设备，又叫裸设备，bare metal，比如普通的主机。笔记本电脑，台式电脑都可以叫物理机。虚拟机虚拟机，与现在流行的“云计算”的概念的有着紧密联系，虚拟机的概念在IaaS层，即基础设施即服务部分，可以自行学习一下。为了让全人类能够像使用自来水、电一样使用计算资源，我们需要在几百上千台物理机上部署虚拟化软件，如vmware等等，使得他们的表现就像一台巨大的计算机。同时它还具有灵活性和解耦性，你可以在一台物理机上部署10台虚拟机，使得一台物理机的表现就像10台性能略差的服务器，当你不需要他们时，你又可以随时的回收资源重新分配。容器一句话概括容器：容器就是将软件打包成标准化单元，以用于开发、交付和部署。容器镜像是轻量的、可执行的独立软件包 ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。容器化软件适用于基于Linux和Windows的应用，在任何环境中都能够始终如一地运行。容器赋予了软件独立性 ，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。Docker思想集装箱标准化： ①运输方式 ② 存储方式 ③ API接口隔离Docker容器的特点轻量在一台机器上运行的多个 Docker 容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。标准Docker 容器基于开放式标准，能够在所有主流 Linux 版本、Microsoft Windows 以及包括 VM、裸机服务器和云在内的任何基础设施上运行。安全Docker 赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker 默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。Docker优势一致的运行环境Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题更快速的启动时间可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。隔离性避免公用的服务器，资源会容易受到其他用户的影响。弹性伸缩，快速扩展善于处理集中爆发的服务器使用压力；迁移方便可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。持续交付和部署使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。Docker基本概念Docker 包括三个基本概念镜像（Image）容器（Container）仓库（Repository）镜像（Image）—— 一个特殊的文件系统操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而Docker 镜像（Image），就相当于是一个 root 文件系统。Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。Docker 设计时，就充分利用 Union FS的技术，将其设计为 分层存储的架构 。 镜像实际是由多层文件系统联合组成。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。 比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像容器（Container)——镜像运行时的实体镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。前面讲过镜像使用的是分层存储，容器也是如此。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失。仓库（Repository）——集中存放镜像文件的地方镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。一个 Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：镜像仓库是Docker用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签.。这里补充一下Docker Registry 公开服务和私有 Docker Registry的概念：Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。最常使用的 Registry 公开服务是官方的 Docker Hub ，这也是默认的 Registry，并拥有大量的高质量的官方镜像，网址为：hub.docker.com/ 。在国内访问Docker Hub 可能会比较慢国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 时速云镜像库、网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库等。除了使用公开服务外，用户还可以在 本地搭建私有 Docker Registry 。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。Build, Ship, and RunBuild（构建镜像） ： 镜像就像是集装箱包括文件以及运行环境等等资源。Ship（运输镜像） ：主机和仓库间运输，这里的仓库就像是超级码头一样。Run （运行镜像） ：运行的镜像就是一个容器，容器就是运行程序的地方。​ Docker 运行过程也就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。所以，我们也常常将Docker称为码头工人或码头装卸工，这和Docker的中文翻译搬运工人如出一辙。]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask框架学习]]></title>
    <url>%2F2020%2F02%2F24%2Fflask%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[基本概念1.静态资源​ 一旦准备好资源，不在需要经常变化的资源.由于该资源不需要经常变化，所以可以提前准备.比如png/jpg/css/js等文件2.动态资源​ 和静态资源相反，这种资源会经常变化.比如，我们要编写一个电商网站，我们无法预测用户在浏览商品时选择什么样的条件。根据用户选择条件不同，我们给用户提供可供选择的商品就不同.这种资源无法提前准备。3.模板文件​ 在用户搜索各种商品的时候，大家是否发现虽然大家的条件不同，但是显示商品的网页中除了那些商品信息整个网页的结构/布局几乎是一模一样的.​ 而模板文件就是网页中通用的结构构成的一个页面.这个页面中不含有任何用户需要查看的数据，当用户查询数据的时候会将最终的结果放到模板中形成用户真正需要的页面。​ 这就好比，生活中一个毛坯房可以装饰上不同的风格.我们把模板文件转化为用户真正看到的网页的过程就称为模板替换.通信规范服务器和浏览器之间通信使用HTTP协议同理，框架和web服务器之间进行通信也需要一个协议为了简单明了，一个简单的协议（例子）：1、web服务器在接收到浏览器的动态套源请求的时候会将请求报文请求切割拆分为键值对放到一个字典中2、web服务器调用框架提供的方法执行框架的功能并且传给框架一个字典3、框架通过字典取出用户请求根据请求产生处理状态/响应头信息/响应体4、框架通过返回值将处理状态/响应头信息/响应体给服务器，完成一次动态资源请求的过程Flask程序运行过程1.当客户端想要获取资源时，一般会通过浏览器发起HTTP请求。2.此时，Web服务器会把来自客户端的所有请求都交给Flask程序实例3.程序实例使用Werkzeug来做路由分发（URL请求和视图函数之间的对应关系）。4.根据每个URL请求，找到具体的视图函数并进行调用。在Flask程序中，路由的实现一般是通过程序实例的装饰器实现。5.Flask调用视图函数后，可以返回两种内容：字符串内容：将视图函数的返回值作为响应的内容，返回给客户端（浏览器）HTML模版内容：获取到数据后，把数据传入HTML模板文件中，板引擎负责渲染HTTP响应数据，然后返回响应数据给客户端（浏览器）12345678910111213141516from flask import Flask, render_template# 创建flask应用实例app = Flask(__name__)# 定义路由及是视图函数（装饰器路由）# 路由默认只支持GET请求方式，如需要支持别的请求需要添加@app.route('/', methods=['GET', "POST"])def index(): # return "Hello Flask"z return render_template("index.html")if __name__ == '__main__' app.run()路由传参123456789# 使用一个视图函数 来显示不同用户的订单信息# &lt;&gt;路由定义的参数，&lt;&gt;内需要起个名字# int：限定参数类型为int类型，其他的不解析# -大致原理是将参数强转为int，如果成功，则可以进行路由匹配# -如果参数无法转换成功，就无法匹配该路由@app.route('/orders/&lt;int:order_id&gt;')def get_order_id(order_id): print(type(order_id)) return 'order_id %s' % order_idJinja2模板引擎模板在前面的示例中，视图函数的主要作用是生成请求的响应，这是最简单的请求。实际上，视图函数有两个作用：处理业务逻辑和返回响应内容。在大型应用中，把业务逻辑和表现内容放在一起，会增加代码的复杂度和维护成本。本节学到的模板，它的作用即是承担视图函数的另一个作用，即返回响应内容。模板其实是一个包含响应文本的文件，其中用占位符（变量）表示动态部分，告诉模板引擎其具体的值需要从使用的数据中获取使用真实值替换变量，再返回最终得到的字符串，这个过程称为“渲染”Flask是使用Jinja2这个模板引擎来渲染模板使用模板的好处：视图函数只负责业务逻辑和数据处理（业务逻辑方面）而模板则取到视图函数的数据结果进行展示（视图展示方面）代码结构清晰，耦合度低JinJia2两个概念：Jinja2：是Python下一个被广泛应用的模板引擎，是由Python实现的模板语言，他的设计思想来源于Django的模板引擎，并扩展了其语法和一系列强大的功能，其是Flask内置的模板语言。模板语言：是一种被设计来自动生成文档的简单文本格式，在模板语言中，一般都会把一些变量传给模板，替换模板的特定位置上预先定义好的占位变量名。渲染模版函数Flask提供的render_template函数封装了该模板引擎render_template函数的第一个参数是模板的文件名，后面的参数都是键值对，表示模板中变量对应的真实值。1234@app.route('/', methods=['GET', "POST"])def index(): name = 'Luenci' return render_template("index.html", name=name)使用方法变量代码块用来表示变量名， 这种语法叫做变量代码块)字典和列表的使用控制代码块过滤器Web表单web表单是web应用程序的基本功能。它是HTML页面中负责数据采集的部件。表单有三个部分组成：表单标签、表单域、表单按钮。表单允许用户输入数据，负责HTML页面数据采集，通过表单将用户输入的数据提交给服务器。在Flask中，为了处理web表单，我们一般使用Flask-WTF扩展，它封装了WTForms，并且它有验证表单数据的功能字段对象说明StringField文本字段TextAreaField多行文本字段PasswordField密码文本字段HiddenField隐藏文件字段DateField文本字段，值为 datetime.date 文本格式DateTimeField文本字段，值为 datetime.datetime 文本格式IntegerField文本字段，值为整数DecimalField文本字段，值为decimal.DecimalFloatField文本字段，值为浮点数BooleanField复选框，值为True 和 FalseRadioField一组单选框SelectField下拉列表SelectMutipleField下拉列表，可选择多个值FileField文件上传字段SubmitField表单提交按钮FormField把表单作为字段嵌入另一个表单FieldList一组指定类型的字段WTForms常用验证函数验证函数说明DataRequired确保字段中有数据EqualTo比较两个字段的值，常用于比较两次密码输入Length验证输入的字符串长度NumberRange验证输入的值在数字范围内URL验证URLAnyOf验证输入值在可选列表中NoneOf验证输入值不在可选列表中使用 Flask-WTF需要配置参数 SECRET_KEYCSRF_ENABLED是为了CSRF（跨站请求伪造）保护。 SECRET_KEY用来生成加密令牌，当CSRF激活的时候，该设置会根据设置的密匙生成加密令牌。1234567891011121314151617# 设置密匙app.secret_key = 'luenci'@app.route('/login.html', methods=['GET', 'POST'])def login(): if request.method == "POST": # 获取表单的数据 username = request.form.get('username') password = request.form.get('password') print(username, password) if username == '': flash('请填写邮箱') elif password == '': flash('请设置密码') else: return 'sucess' return render_template("login_demo.html")Flask-WTF实现表单1234567891011121314151617from flask_wtf import FlaskForm# 导入文本字段，密码字段，和提交按钮from wtforms import StringField, PasswordField, SubmitField# 创建表单类class LoginFrom(FlaskForm): username = StringField("用户名") password1 = PasswordField("密码") password2 = PasswordField("确认密码") submit = SubmitField("提交")@app.route('/form', methods=["GET", "POST"])def form_demo(): # 创建表单实例 form_login = LoginFrom() return render_template("login_demo.html", form=form_login)]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12306自动化抢票实现]]></title>
    <url>%2F2020%2F01%2F02%2F12306%E8%87%AA%E5%8A%A8%E6%8A%A2%E7%A5%A8%2F</url>
    <content type="text"><![CDATA[selenium常用APIfind_element_by_xxx 返回第一个符合条件WebElement元素find_elements_by_xxx 返回符合条件所有元素包含了 WebEelemnt列表函数作用find_element_by_class_name通过class查询元素find_element_by_id通过ID查询元素find_element_by_name通过name查询元素find_element_by_tag_name通过标签名称find_element_by_css_selectorcss样式选择find_element_by_link_text通过链接内容查找find_element_by_partial_link_text通过链接内容包含的内容查找，模糊查询find_element_by_xpath通过xpath查找数据获取元素属性和文本内容12345678#获取属性element.get_attribute（'属性名”）#获取文本内容element.text# 输入框输入内容input_element.send_keys（'Luenci'）# 元素点击element.click()三种等待方式当控制浏览器时，浏览器正在加载页面同时又去获取数据导致浏览器寻找不到需要操作的元素引发异常。方式一：强制等待，浪费时间time.sleep（秒数）方式二：隐性等待，无法控制Ajax请求browser.implicit1y_wait（等待时间）方式三：显性等待，每个元素都可以自己定义检查条件。手动编写方式123456789101112131415#显性等待-手动编写t = time.time（）#定义超时时间timeout = 60while True： try： #超时时间间隔 time.sleep（0.1） ur1_element = browser.find_element_by_class_name（"fav ur1"） break except： #超时处理 if time.time（）- t &gt; timeout： break pass系统提供显性等待API123456789101112131415161718# 导入显性等待的API需要的模块# 1等待对象模块from selenium.webdriver.support.wait import WebDriverwait# 2导入等待条件模块from selenium.webdriver.support import expected_conditions as EC# 3导入查询元素模块from selenium.webdriver.common.by import By# 1.创建等待对象# 参数一浏览器对象# 参数二超时时间# 参数三检查元素时间间隔wait = WebDriverwait（browser，5.0，0.5）# 2.通过等待对象获取元素# presence_of_element_located 检查元素是否存在，如果存在就返回如果不存在就继续检查# visibility_of_element_located 检查元素是否可见linkelement = s wait.until（EC.presence_of_element_located（（By.CLASS_NAME，"favurl"）link_element.click（）12306爬虫实现完成代码见：https://github.com/Lucareful/12306_Tickets实现步骤1.访问列表页2.通过时间判定选择点击预订3.点击账号登录4.输入用户名和密码（15523750230）5.截图获取验证码图片6.发送打码平台获取识别数字7.定义8个点击坐标8.模拟点击坐标9.点击登录10.点击选择人物11.点击提交订单12.点击确认订单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# -*- coding: utf-8 -*-import jsonimport timefrom selenium import webdriverfrom selenium.webdriver import ActionChainsfrom selenium.webdriver.support.wait import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.common.by import Byfrom PIL import Imagefrom io import BytesIO# 判断YDMHTTP模块是否在python环境中（我的是不在，所以加上去）import syssys.path.insert(1, r"YDMHTTP.py")from YDMHTTP import decodebrowser = webdriver.Chrome()browser.maximize_window()linktypeid = "dc"fs = "北京"ts = "武汉"date = "2020-01-13"flag = "N,N,Y"base_url = 'https://kyfw.12306.cn/otn/leftTicket/init?linktypeid=&#123;&#125;&amp;fs=&#123;&#125;,BJP&amp;ts=&#123;&#125;,WHN&amp;date=&#123;&#125;&amp;flag=&#123;&#125;'url = base_url.format(linktypeid, fs, ts, date, flag)browser.get(url)wait = WebDriverWait(browser, 10, 0.5)# 通过时间判定选择预定车次# 寻找tr标签中的 属性id 已 ’ticket_‘ 开头的数据tr_list = wait.until(EC.visibility_of_all_elements_located((By.XPATH, '//tr[starts-with(@id, "ticket_")]')))for tr in tr_list: date_string = tr.find_element_by_class_name("start-t").text # 判断时间是否在符合你想要的时间范围中 tr.find_element_by_class_name('no-br').click() # print(date_string) break# 点击账号 异步加载需要显性等待wait.until(EC.visibility_of_element_located((By.LINK_TEXT, "账号登录"))).click()# browser.find_element_by_link_text("账号登录").click()# 输入用户名和密码（我将我的用户名和密码保存在了json文件中，若别人使用需要更改）with open("account.json", "r", encoding="utf-8") as f: account = json.load(f)browser.find_element_by_id("J-userName").send_keys(account["username"])browser.find_element_by_id("J-password").send_keys(account["password"])# 获取全屏截图full_img_data = browser.get_screenshot_as_png()# 截取验证图片login_img_element = wait.until((EC.visibility_of_element_located((By.ID, "J-loginImg"))))# 计算截图位置# 截取验证码的位置scale = 2.0x1 = login_img_element.location["x"]y1 = login_img_element.location["y"]x2 = x1 + login_img_element.size["width"] * scaley2 = y1 + login_img_element.size["height"] * scalecut_info = (x1, y1, x2, y2)# 把全屏图片构建成全屏图片操作对象full_img = Image.open(BytesIO(full_img_data))# 通过截图信息对象截取图片cut_img = full_img.crop(cut_info)# 把图片保存到本地cut_img.save('demo.png')# 将验证图片发送到打码平台result = decode('demo.png', codetype=6701)# 定义八个点击坐标点positions = [ (7.30*25, 140), (10.58*25, 140), (13.83*25, 140), (17.11*25, 140), (7.30*25, 250), (10.58*25, 250), (13.83*25, 250), (17.05*25, 250)]# 模拟点击坐标for num in result: position = positions[int(num) - 1] # 动作对象 ActionChains(browser).move_to_element_with_offset(login_img_element, position[0]/2, position[1]/2).click().perform()# 点击登录browser.find_element_by_id("J-login").click()# 点击选择乘车人wait.until(EC.visibility_of_element_located((By.ID, "normalPassenger_0")))# 点击提交订单browser.find_element_by_id("submitOrder_id").click()time.sleep(5)]]></content>
      <categories>
        <category>selenium知识</category>
      </categories>
      <tags>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js的基本知识]]></title>
    <url>%2F2019%2F12%2F26%2Fvue%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Vue.js概念Vue.js是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App，Vue语法也是可以用于进行手机App开发的，需要借助于Weex）Vue.js 是前端的主流框架之一，和Angularjs、Reactjs一起，并成为前端三大主流框架！·Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）框架和库的区别框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。后端中的MVC与前端中的MVVM之间的区别MVC是后端的分层开发概念；MVVM是前端视图层的概念，主要关注于视图层分离，也就是说：MVVM把前端的视图层，分为了三部分Model，View，VM ,ViewModelvue.js基本架构12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 导入Vue的包 --&gt; &lt;script src="../lib/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 将来new的实例，会控制这个元素中的所有内容 --&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建一个vue的实例 // 当我们导入包之后，在浏览器的内存中，就多了一个vue构造函数 var vm = new Vue(&#123; el: '#app', //表示，当前我们new的这个vue实例，要控制页面上的哪个区域 data: &#123; // data属性中存放的是 el 中要用到的内容 msg: '欢迎学习Vue' //通过vue提供的指令，很方便的就能把数据渲染到页面上，程序员不再手动操作DOM元素了 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;基本事件语法&lt;！--1.如何定义一个基本的vue代码结构--&gt;&lt;！--2.插值表达式和 v-text--&gt;&lt;!--3.v-cloak--&gt;&lt;!--4.v-html--&gt;&lt;！--5.v-bind vue提供的属性绑定机制缩写是 : --&gt;&lt;l--6.v-on vue提供的事件绑定机制缩写是 @ --&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="../lib/vue.min.js"&gt;&lt;/script&gt; &lt;style&gt; [v-cloak]&#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- v-cloak能够解决 插值表达式闪烁的问题 --&gt; &lt;p v-cloak&gt;++++++ &#123;&#123; msg &#125;&#125; ----------&lt;/p&gt; &lt;!-- 默认v-text没有闪烁问题 --&gt; &lt;h1 v-text="msg"&gt;&lt;/h1&gt; &lt;!--v-text会覆盖元素中原本的内容，但是插值表达式只会替换自己的这个占位符，不会把整个元素的内容清空--&gt;I &lt;div&gt; &#123;&#123;msg2&#125;&#125; &lt;/div&gt; &lt;div&gt; &lt;p v-text="msg2"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div v-html="msg2"&gt;&lt;/div&gt; &lt;!-- v-bind: 是vue中，提供用于绑定属性的指令 --&gt; &lt;!-- v-bind 也可以简写为 :要绑定的属性 --&gt; &lt;!-- v-bind 中可以写合法的js表达式 --&gt; &lt;!-- Vue中提供了 v-on: 事件绑定机制 --&gt; &lt;!-- &lt;input type="button" value="按钮" :title="myTitle" v-on:click = "alter('Hello')"&gt; --&gt; &lt;input type="button" value="按钮" @click="show"&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123', msg2: '&lt;h2&gt;Luenci&lt;/h2&gt;', myTitle: '自定义标题' &#125;, methods: &#123; show: function()&#123; alert('Hello') &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;Vue指令之事件修饰符事件修饰符.stop 阻止冒泡.prevent 阻止默认事件.capture 添加事件侦听器时使用事件捕获模式.self只当事件在该元素本身（比如不是子元素）触发时触发回调.once事件只触发一次Vue指令之v-model和双向数据绑定1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="../lib/vue.min.js"&gt;&lt;/script&gt; &lt;style&gt; .btn&#123; width:100%&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;h4&gt;&#123;&#123; msg &#125;&#125;&lt;/h4&gt; &lt;!--v-bind只能实现数据的单向绑定，从M自动绑定到V，无法实现数据的双向绑定--&gt; &lt;!--&lt;input type="text" v-bind:value="msg" style="width：100%；"&gt;--&gt; &lt;!--使用v-mode1指令，可以实现表单元素和 Model 中数据的双向数据绑定--&gt; &lt;!--注意：v-mode1只能运用在表单元素中--&gt; &lt;!--input（radio，text，address，email....）select checkbox textarea--&gt; &lt;input class="btn" type="text" v-model="msg"&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; msg:'hello Vue.js' &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;Vue中使用样式使用class样式1.数组&lt;h1 :class=&quot;[&#39;red&#39;,&#39;thin&#39;]&quot;&gt;这是一个H1&lt;/h1&gt;2.数组中使用三元表达&lt;h1 :class=&quot;[&#39;red&#39;,&#39;thin&#39;,is active?&#39;active&#39;:&#39;&#39;]&quot;&gt;这是一个H1&lt;/h1&gt;3.数组中嵌套对象&lt;h1 :class=&quot;[&#39;red&#39;,&#39;thin&#39;, {&#39;active&#39;:isactive}]&quot;&gt;这是一个H1&lt;/h1&gt;4.直接使用对象&lt;h1 :class=&quot;{red:true, italic:true, active:true，thin:true}&quot;&gt;这是一个H1&lt;/h1&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Luenci&lt;/title&gt; &lt;script src="../lib/vue.min.js"&gt;&lt;/script&gt; &lt;style&gt; .red&#123; color: red; &#125; .thin&#123; font-weight: 200; &#125; .italic&#123; font-style: italic; &#125; .active&#123; letter-spacing: 0.5em; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- &lt;h1 class="red"&gt;这是一个很大很大的H1&lt;/h1&gt; --&gt; &lt;!--第一种使用方式，直接传递一个数组，注意：这里的class需要使用 v-bind 做数据绑定--&gt; &lt;h1 :class="['thin', 'active']"&gt;这是一个很大很大的H1&lt;/h1&gt; &lt;!-- 数组中使用三元表达式 --&gt; &lt;h1 :class="['thin', 'active', falg ? 'red':'italic']"&gt;这是一个很大很大的H1&lt;/h1&gt; &lt;!-- 数组中嵌套对象 --&gt; &lt;h1 :class="['thin', 'active', &#123;'red':falg&#125;]"&gt;这是一个很大很大的H1&lt;/h1&gt; &lt;!-- 直接使用对象 --&gt; &lt;h1 :class="&#123;'thin': true, 'active': true, 'italic': false&#125;"&gt;这是一个很大很大的H1&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data:&#123; falg: true &#125;, methods:&#123;&#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;使用内联样式1.直接在元素上通过style的形式，书写样式对象&lt;h1 :style=&quot;{color:‘red&#39;，&#39;font-size&#39;：&#39;40px&#39;}&quot;&gt;这是一个善良的H1&lt;/hl&gt;2.将样式对象，定义到data中，并直接引用到:style中在data上定义样式：123data:&#123; histyObj:&#123;color:&apos;red&apos;，&apos;font-size&apos;：&apos;40px&apos;，&apos;font-weight&apos;：200&apos; &#125;在元素中，通过属性绑定的形式，将样式对象应用到元素中：&lt;h1 :style=&quot;histyObj&quot;&gt;这是一个h1&lt;/h1&gt;3.在:style中通过数组，引用多个data上的样式对象在data上定义样式：123data:&#123; histy0bj:&#123;color:&apos;red&apos;，&apos;font-size&apos;：‘40px&apos;，‘font-weight&quot;：&apos;200&apos;&#125;, histy0bj2:&#123;fontstyle:&apos;italic&apos;&#125;在元素中，通过属性绑定的形式，将样式对象应用到元素中：&lt;h1 :style=&quot;[histy0bj，histy0bj2]&quot;&gt;这是一个h1&lt;/h1&gt;123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="../lib/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 直接在元素上通过`style`的形式，书写样式对象 --&gt; &lt;h1 :style="&#123;color:'red', 'font-weight':200&#125;"&gt;我是一个标题&lt;/h1&gt; &lt;!-- 2.将样式对象，定义到`data`中，并直接引用到`:style`中 --&gt; &lt;h1 :style="styleObj"&gt;我是一个标题&lt;/h1&gt; &lt;!-- 3.在`:style`中通过数组，引用多个`data`上的样式对象 --&gt; &lt;h1 :style="[styleObj, styleObj2]"&gt;我是一个标题&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; styleObj: &#123; color: 'red', 'font-weight': 200 &#125;, styleObj2: &#123; 'font-style': 'italic' &#125; &#125;, methods: &#123;&#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;Vue指令之v-for和key属性1.迭代数组1&lt;1i v-for="（item，i）in list"&gt;索引：&#123;&#123;i&#125;&#125;---姓名：&#123;&#123;item.name&#125;&#125;---年龄：&#123;&#123;item.age&#125;&#125;&lt;/li&gt;2.迭代对象中的属性12&lt;4--循环遍历对象身上的属性--&gt;&lt;div v-for="（val，key，i）in userInfo"&gt;&#123;&#123;val&#125;&#125;---&#123;&#123;key&#125;&#125;---&#123;&#123;i]&#125;&lt;/div&gt;3.迭代数字&lt;p v-for=&quot;ks in 8&quot;&gt;这是第（{i}}个P标签&lt;/p&gt;22.0+的版本里，当在细件中使用v-for时，key现在是必须的。当Vue.js 用v-for正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定素引下显示已被渲染过的每个元素。为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一key属性。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0,minimal-ui:ios"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="../lib/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 循环普通数组 --&gt; &lt;p v-for="(item,i) in list"&gt;索引值:&#123;&#123;i&#125;&#125;-----数值:&#123;&#123;item&#125;&#125;&lt;/p&gt; &lt;!-- 循环对象数组 --&gt; &lt;p v-for="(user,i) in list2"&gt;&#123;&#123;user.id&#125;&#125;====&#123;&#123;user.name&#125;&#125;------&#123;&#123;i&#125;&#125;&lt;/p&gt; &lt;!-- 循环对象 --&gt; &lt;p v-for="(value, key, i) in list3"&gt;&#123;&#123;i&#125;&#125;-------&#123;&#123;key&#125;&#125;----&#123;&#123;value&#125;&#125;&lt;/p&gt; &lt;!-- 循环数字 --&gt; &lt;p v-for="count in 6"&gt;第&#123;&#123;count&#125;&#125;循环&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; list: [1, 2, 3, 4], list2: [ &#123; id: 1, name: 'Luenci' &#125;, &#123; id: 2, name: 'Lynn' &#125;, &#123; id: 3, name: 'lucy' &#125;, &#123; id: 4, name: 'll' &#125;, ], list3: &#123; user: 'Luenci', age: 20, sex: '男', &#125; &#125;, methods: &#123;&#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;Vue指令之v-if和v-show一般来说，v-if有更高的切换消精而v-show 有更高的初始渲染消耗。如果需要频繁切换v-show较好如果元素可能永远也不会被显示出来被用户看到，则推荐使用v-if12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0,minimal-ui:ios"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="../lib/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" value="点击" @click="flag=!flag"&gt; &lt;!-- v-if的特点：每次都会重新删除或创建元素 --&gt; &lt;!-- v-show的特点：每次不会重新进行DoM的删除和创建操作，只是切换了元素的 display:none 样式 --&gt; &lt;!-- v-if有较高的切换性能消耗 --&gt; &lt;!-- v-show 有较高的初始渲染消耗 --&gt; &lt;!-- 如果元素涉及到频繁的切换，最好不要使用v-if --&gt; &lt;!-- 如果元素可能永远也不会被显示出来被用户看到，则推荐使用v-if --&gt; &lt;h1 v-if="flag"&gt;这是v-if控制的元素&lt;/h1&gt; &lt;h1 v-show="flag"&gt;这是v-show控制的元素&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; flag: true &#125;, methods: &#123;&#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;过滤器概念：Vue.js允许你自定义过滤器，可被用作一些嚣见的文本格式化。过滤器可以用在两个地方：mustache插值和v-bind 表达式。过滤器应该被添加在JavaScript表达式的尾部，由“管道”符指示全局过滤器1234567891011121314151617Vue.filter('time', function (Ctime, pattern = '') &#123;var dt = new Date(Ctime)var y = dt.getFullYear()var m = dt.getMonth() + 1var d = dt.getDate()// return y + '--' + m + '--' + dif (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; var hh = dt.getHours() var mm = dt.getMinutes() var ss = dt.getSeconds() return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125;&#125;);局部过滤器12345678910111213141516171819202122232425262728293031var vm2 = new Vue(&#123; el: '#app2', data: [ dt = new Date(), ], methods: &#123;&#125;, filters: &#123; // 定义私有过滤器过滤器有两个条件【过滤器名称和处理函数】 // 过滤器调用的时候，采用的是`就近原则`， //如果私有过滤器和全局过滤器名称一致了，这时候优先调用私有过滤器 deteFormat: function (dateStr, pattern = '') &#123; var dt = new Date(Ctime) var y = dt.getFullYear() var m = dt.getMonth() + 1 var d = dt.getDate() // return y + '--' + m + '--' + d if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; var hh = dt.getHours() var mm = dt.getMinutes() var ss = dt.getSeconds() return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125; &#125; &#125; &#125;)ES6中的字符串新方法String，prototype，padStart(maxlength，fillString=&#39;&#39;）或 String，prototype，padEnd(maxlength，filString=&#39;&#39;）来填充字符串；Vue指令钩子函数指令提供了几个钩子函数bind：只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。inserted：被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）。update：所在组件的VNode更新时调用，但是可能发生在其孩子的VNode更新之前。指令的值可能发生了改变也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新（详细的钩子函数参数见下）。componentUpdated：所在组件的VNode 及其孩子的VNode全部更新时调用。unbind：只调用一次，指令与元素解绑时调用。接下来我们来看一下钩子函数的参数（包括el，binding，vnode，oldVnode）钩子函数参数指令钩子函数会被传入以下参数：el：指令所绑定的元素，可以用来直接操作 DOM 。binding：一个对象，包含以下属性：name：指令名，不包括 v- 前缀。value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。Vue实例的生命周期仕么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期生命周期钩子 = 生命周期函数 = 生命周期事件：就是生命周期事件的别名而已；主要的生命周期函数分类：创建期间的生命周期函数：beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好data和methods属性created：实例已经在内存中创建OK，此时data和methods已经创建OK，此时还没有开始编译模板beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示运行期间的生命周期函数：beforeUpdate：状态更新之前执行此函数，此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为此时还没有开始重新渲染DOM节点updated：实例更新完毕之后调用此函数，此时data中的状态值和界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！销般期间的生命周期函数：abeforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。destroyed:Vue 实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;h3&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg:'ok' &#125;, methods: &#123; show()&#123; console.log("执行了show方法") &#125; &#125;, beforeCreate() &#123; // 这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会执行它 // console.log（this.msg） // this.show（） // 注意：在beforecreate生命周期函数执行的时候，data和methods中的数据都还没有没初始化 &#125;, created() &#123; //这是遇到的第二个生命周期函数 // console.log（this.msg） // this.show（） // 在created中，data和methdas都已经被初始化好了！ &#125;, beforeMount() &#123; //这是遇到的第3个生命周期函数，表示模板已经在内存中编辑完成了，但是尚未把模板渲染到页面中 //console.1og（document.getElementById（'h31）.innerText） //在beforeMount执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串 &#125;, mounted() &#123; //这是遇到的第4个生命周期函数，表示，内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了 console.log(document.getElementById(("h3").innerText)) //注意：mounted是实例创建期间的最后一个生命周期函数，当执行完mounted就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的躺在我们的内存中，一动不动 &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Vue框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL性能调优]]></title>
    <url>%2F2019%2F12%2F20%2FSQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[原文链接：https://blog.csdn.net/u010520146/article/details/81161762一.创建索引1.要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引2.1在经常需要进行检索的字段上创建索引，比如要按照表字段username进行检索，那么就应该在姓名字段上创建索引，如果经常要按照员工部门和员工岗位级别进行检索，那么就应该在员工部门和员工岗位级别这两个字段上创建索引。2.2创建索引给检索带来的性能提升往往是巨大的，因此在发现检索速度过慢的时候应该首先想到的就是创建索引。2.3一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。二.避免在索引上使用计算在where字句中，如果索引列是计算或者函数的一部分，DBMS的优化器将不会使用索引而使用全表查询,函数属于计算的一种,同时在in和exists中通常情况下使用EXISTS，因为in不走索引。效率低：select * from user where salary*22 &gt; 11000 (salary是索引列)效率高：select * from user where salary &gt; 11000/22 (salary是索引列)三.使用预编译查询程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。四.调整Where字句中的连接顺序DBMS一般采用自下而上的顺序解析where字句，根据这个原理表连接最好写在其他where条件之前，那些可以过滤掉最大数量记录。五.尽量将多条SQL语句压缩到一句SQL中每次执行SQL的时候都要建立网络连接、进行权限校验、进行SQL语句的查询优化、发送执行结果，这个过程是非常耗时的，因此应该尽量避免过多的执行SQL语句，能够压缩到一句SQL执行的语句就不要用多条来执行。六.用where字句替换HAVING字句避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。七.使用表的别名当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减少哪些友列名歧义引起的语法错误。八.用union all替换union当SQL语句需要union两个查询结果集合时，即使检索结果中不会有重复的记录，如果使用union这两个结果集同样会尝试进行合并，然后在输出最终结果前进行排序，因此如果可以判断检索结果中不会有重复的记录时候，应该用union all，这样效率就会因此得到提高。九.考虑使用“临时表”暂存中间结果简化SQL语句的重要方法就是采用临时表暂存中间结果，但是，临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。但是也得避免频繁创建和删除临时表，以减少系统表资源的消耗。十.只在必要的情况下才使用事务begin translationSQL Server中一句SQL语句默认就是一个事务，在该语句执行完成后也是默认commit的。其实，这就是begin tran的一个最小化的形式，好比在每句语句开头隐含了一个begin tran，结束时隐含了一个commit。有些情况下，我们需要显式声明begin tran，比如做“插、删、改”操作需要同时修改几个表，要求要么几个表都修改成功，要么都不成功。begin tran 可以起到这样的作用，它可以把若干SQL语句套在一起执行，最后再一起commit。 好处是保证了数据的一致性，但任何事情都不是完美无缺的。Begin tran付出的代价是在提交之前，所有SQL语句锁住的资源都不能释放，直到commit掉。可见，如果Begin tran套住的SQL语句太多，那数据库的性能就糟糕了。在该大事务提交之前，必然会阻塞别的语句，造成block很多。Begin tran使用的原则是，在保证数据一致性的前提下，begin tran套住的SQL语句越少越好！有些情况下可以采用触发器同步数据，不一定要用begin tran。十一.尽量避免使用游标尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。十二.用varchar/nvarchar代替 char/nchar尽可能的使用 varchar/nvarchar代替char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。不要以为 NULL不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null不占用空间。十三.查询select语句优化1.任何地方都不要使用 select * from T，用具体的字段列表代替“*”，不要返回用不到的任何字段2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：1select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：12select id from t where num=0select id from t where num=10 or num=20可以这样查询：123select id from t where num=10 union allselect id from t where num=204.不能前置百分1select id from t where name like ‘%abc%’若要提高效率，可以考虑全文检索。select id from t where num in(1,2,3)对于连续的数值，能用 between 就不要用 in 了：select id from t where num between 1 and 36.如果查询的两个表大小相当，那么用in和exists差别不大。in：例如：表A（小表），表B（大表）12select * from A where cc in (select cc from B) 效率低，用到了A表上cc列的索引； select * from A where exists(select cc from B where cc=A.cc) 效率高，用到了B表上cc列的索引。相反的12select * from B where cc in (select cc from A) 效率高，用到了B表上cc列的索引；select * from B where exists(select cc from A where cc=B.cc) 效率低，用到了A表上cc列的索引。十四.更新Update语句优化1.如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志十五. 删除Delete语句优化语句1.最高效的删除重复记录方法 ( 因为使用了ROWID)例子：1DELETE FROM EMP E WHERE E.ROWID &gt; (SELECT MIN(X.ROWID) FROM EMP X WHERE X.EMP_NO = E.EMP_NO);十六.插入Insert语句优化在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量log，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。]]></content>
      <categories>
        <category>SQL知识</category>
      </categories>
      <tags>
        <tag>SQL调优</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[积善科技（快代理）Python面试总结]]></title>
    <url>%2F2019%2F12%2F19%2F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[输入密码，查看文章 b217c922d19bd23d3cb0a59d1e5e96f3bdbdfca45580064f07e36cce13375fb374ff956f9941d908fc57914503f16d57c70bec172e543fc25647e1d6b6961c6e04de44fb4a861bbf71248d7cbaa56054b68eb836b000ed675ec8a3a929d9722e99ea486659c46ecf0d895c11b8825b4dd1352766ea02591e2f49883e2819e17d36bd69319f65f6ecf0c275e3fc9a7b00c68f0be802b6fb9c681db0d2abc1c5ded342203c55dff78f767afd0db2b996ee3b7c279ac77717db8f9709a9d0b3bd4e2f97ca3d4515c22d644e464ba0d7e6a5144f09d3b2d03182175b91d6f33e934cda5636d97086dc04ddd6c2cb3a7d09f0a674c3396d15835e9c79712492f2285da1deaa599c66f1911fcb5c390df1a22498c1c1c0804ff195f47f085d0ead1d751aadf82e723a99822535ff5b32fd6b5980ef1239a5de87f25ac27f2be92b6d4d9609b34ad4e1e3090965780db45f1faa2f0b308bd7077a251c9a319e3464cb0d05990c6058e8d018d267871d9c3c307ed31432083d499668067437e46d553ec7a56a78be1977f0b8e5bdf533b8adc648174dfc787b362ed9ba825be6a0055bad21c9d3af5c72e87b2e61892e4b11b8c9c21a22d6003457dd74cabd19b69100f399792e50e66f0af57d0ae72a9daf7505c6005730cd97a394703b2bb8c4e132c201c6ca827c8d91ba86cbfab09a8e3c0e8b115703e06eae1e461b805336fc9d4d404494334da68c99efe36b7c56ad005a693b271bed55198a88d7ca19256f37fd0bba652ec9b73248f27da45dbf953ba93892ed5d5d21818f7f531b209eb8282a5be7ff4bb50a1d69958123a43e82599ba1bceeafefbf7fad8313035c3a67e4721d4f64269598e3cd2b9c1b08fbf425a54054efa6d5b812c70628ea014297f1ec485018c40155248f34d818b2ffe70416faedab372eb643ada4e63911a733a58884be4490ac7ff2b84629beee9ee6b05e814170533c3b8525aacff7eb2145c0b53234fcfde589b6dcce548da417e8ff0699f39923ea9e0dfc3b9c341cd8a91aaaff7f40737cb9bcfa50f22120bef4576bc67aa8fe320b9818fac0175a0b987ad07dbfc52ea03c48e333190bf417f444686e1acfd09f1e14fc35e5adf6f7c19066ca01fc8476faab48584305d043426fca2a3d06e248d87cedb7879ff771afabf03e34114623221683527e97a352646c3cfb5f9de2a6d6a14fcd358825c94f753456db6e4f81262bbbdb23ffa55a4a8d1d2915b29b0e9116a2196f94d84214dfc054eff9d575b95e8960f6300dce10b77a8a5f9d37646b85b7d21cc209d988fc2b3a12519b3be0abe1ac7f3927e375bc8d64e99e81bc0cb4d784e85e3a4663017c2dcfa24d27790c0c50f840860fd0e38f796e5ff1e14e552926ac2be14cc81e7b352bba77ef162a1d72383342c18e6ef87195903c0fe0cc52a355cc5d654973d031784765532e424330d62a2a9f8d584bf7e49357ebba9c7e4d630ee2c17017c351bbf5aa3a35db8f8e90c956e9634e67f63290346fae3a214b5ce4c3080c4bf8334567b072998f7bb88ac3bf3de3bb8a7d5a9844b5d41fb418d7c6da5ef3cc038e4fe9ecccfde647aa156070f95f164f1ec6685b2cf9961aac2f2e0d4398aac7c199f69781c844813c7605549223c4e6e11536b2ab60a7efb9454b242f6b19b741ac499ef3693a6e5d569d69b431314d00ff2d0c14f3dfc0c952c9fa69b836aa6c14470a0b972664ba268f94effbdab14483acb7e0714b8ad169fec16d081d456e4515d62ceef8283f8259d7ef8abb4da740d7a6523f81ed281b77f8abf22b75ec4ed24e1dd3ff5c9e5c66ca6f9cd6298ef2f0adf1df450b31b507d8f431dac7acb09533b715f789ee547515e6a8080fe83f1ffad61edb3e45cde94594f930b2c11cba13716e959743350d4313bd1ae7d336020708d5c2edead6df864255a6f796ba6b30a87777a9bf00a7110a875f36cae6374565823deaf3c9949f785e0c7d0114ebf29cd48cf72d42a42a80a237842946058eda770aba4d60d7fedcbe4981bc16d69cb428a839a681ec4f8a3c746ae21da3bf8356a8990c3f43d48666d869219c428471038ba83ae5d3729a9469b48a34360bdc571fdee8c65fa558541988035865417534761b67a7c81b94aedbbb6030c4621cb62de0df3b14dc2559897a0aa5ad4c591178b8a707f54a41870eac20fd35a92f70f355bcc01677b87bae7c7c43da211a5902d060f2b5b0f292ddc700b05738fdf5f770bb50f9cfdaaaa45201b1ce8ab1244de6c102c93493e7763a8b0f88a27a8c585e46a799930355edfbf1f775f459e8fdfafee323e3e6093268b37ab213e26e9c01a055491079996f29b76e214a6e35cb44df3b695a788a1aceb7622dd2d529adc3e1715c3c2b23cbc9174809a0eb0cd8e3e8d149443eca013e5b815ca640bea9bfa325e01e3f3238bf32aaea7da9e4e72b371b75765aaaee0b35b1a3cbfc0aa2ead421eaef3ed267020a75d01c49b12b5a3bd94f058a59c6ba836fadb726419ebc2fa47979a34110652e8deb935405a8c6f922487226fda0069b8e272e588c1bd9ce935e7dd34ce84ba37a8cf9871b3431f1f5e07eaf075ff96db525f8afa0a9b19d78083a8c6d3e015a462502240bba22dcc4c4ce4bbf596cb2010e14f4f66e86eb97d9b68b6f4a75184886b5050b1ba26d169a0bb2aa9b0f38b9fb0bdf61a533f45fc4d98e13e9a41bb0a1a57f049662213fdc8696eabce0d4be3a241ef2f91da1129d2389473f01ab223d83d1666c35abaac738d1a63d118873a4f33c3d308c7d78cba75e69183b26444e1fca50d32095ddab7d18ace204d124dee5b17c3cc7bdabc20c6cf5e84ab61f90a247c8534662418af6185b840eda834c8f2bdb31e66627371588af4d132f07a4cd0148ac30a94f254b56e2815174cbbdb0a81f33683dac541ca84e20b86966e224ecbebb201e086c6da22a3262357b95612476108b4c6d5686aec5edff6f2b32fa94eb68910965a1581dac72791de6be651f3c9e45d91ac2ce04131208372c0c14743626cd1970e9f536faa98d6605cc3c79916622a5bb7a2dc43dc4c4b6d12ad05c75810b775d293e27025fa468ea7ffacc636369db49628e819c69479c0798c974dda649cc88882b77c1092f917b8bc245f4879ffab0e6a49bf80e61734fc6ad540b3cd40aeca0655ab6f70c0eb5de9d0474796d6de9d1632a98558594fd90c6645f514418bf8a510c8eeea603f7607e2ccbd06ba6e55a87e178d53d7bc12b48340c5bb5adb77432c174e008c786295197de7227b80554253f6982626c3d65ede43dd2e46de937ba4caa5b9abfff99d62246af39ce966752b0b0772dad96f30e3578ecf9a1206fe113d9a7275256bafcb07e22be3606e21a3b3ab42fa2e13180b3cbd7504a47f8815e912bd4f657fd8854d69742b013204b621319b4f64293a2df6a403f0ce42e3482ae132689fe57904b53cd129666fbd6f7bfc6cde0462c0eb8d50244c30d9daf48dc02cb5cbe6595f58e984531a606a52607dccef9275d8fd5a69a5a59a1c1c8a418b9a6a52593395befb40af63fe68dd4f43d8b33fa87854b52d98c4e9b1ffa5274598a29b7ea767f4f6e238ad9e99bd5c0a12b34380b13cefc055de5ea7b90f7aed1c6773bae559f1490906bacd63a6b7eb5d68255a79caa7c87f6abc2ac4fc8d3d71a562849c3ccdc2276960746d353e65916f7426c1cde827962e24af43b5005f1154e2437dd1182ed662b94b8c5f983e720baabbae0e8f58fcac0910f6f19ab289a91c0721af879bc116e5c42f41a052101e40cf1923c26d37108df70de87f73efd61f95f72a1a3b9e60fd36a3afde2e30a4debef7b1b77ccbf7b5f884797c6204e5e764189ede6dc8e50b2ba643d2b28af5d73c98e1d79ba57a1f9b88f04026dbde1a43ee43142a961a85e16113b988a909f8129b3164479539311c970ffbe11c23d3a250b3c502511c092f4fa8cecd09161dd8e537031b1540838f731174bf7c6463b16229645dda93f249b3844967e9e2773d80416e1430a01d88c23f021e3d763fabca3418a839d7914bbd59f985f1b505a4ce71e0f791919313a975aa6a6af260fed23cf014cf6e34bb48da83cb83a190c7eeb218cabad3e66b979f9b671c4ebd151129748459a62f5f175e7b2c0381ec438226a79fb535ed2255bde34de13eaf2b2198a10324ac2b87f49c01a01bb80adcd7c6346d324907f8942c07c4249d788c9345166c6882c837197714b95dbd9eec23e6cfd543f8a6672b8428abdd5910f618d9975f3cc94d5d4020695e6123bcbf8022c0019ce503aa63a5a34e8612b40d190dd73a45f91d9f7c56b418b064111d5582a4f0039942c9b59eef422078e094db6aa19c4176badd637f29abb60a80e41474ba275e04a016a37c44046c3cbbe75a22d6f6d2e29945e1fecb6dc08bafd12cf9db5508aecfe1e740d205f5398723bdaf08dd3ab40561a7023f97dfc03874eb0f353fde3d12398f22970829f767925f98f2810ce538432e485ae9bd33ec065a7f7da225efbf3812a96353a344640710844f2ee216407ed668d3b87ceb1a16150028e503778ea5918114f1c5087d634780c79a872ea75995149c03dc522532d656c1e63208d98df0b6e3da46d88757b7e4692cd1215ea493f32aac4d1c7bffa5b855f877251db888db9aa7e7aa55eacd866c2de9ece7ed9ee0e57e7454d2150b14eabaf92751aef85a98497dfdb766e4b98d31453bb7e1fdcfdc8270d13f6ca4a20b199eb2b6b5aa23c03ba011eb352573502e31467bb86e4fc91ae0c3d2c59e98947f50b8be3548bd57e13133cffc314b5e0abb201a61c529ec3e1fd913e5fdc766581a26a178328466a004a526bde2f227070f0d6471dd11ea7022e8060b63958ec8d3d2eeb61bd4ed8b7b1150aa5c015561766dc0632824a9da8e5e874b4411e430184502e29be102bc6aabad6e6c735af819bae3e05139a5c12cbe533a73cca0c98782da5708d91988525c3e956b825dd6ee49dccadf2266d061566894080833852883ae55dca0d33e585c2f767fdad342758a1d2119237996f64c6314e28ba43fb85232e3129f625fda0cfd154aabca5cdf5ba9b5b965605e7da76f61cdeae1bacb84cc8b110a7d9fe3a97631c85ddc3b0d994418968f1ff69cd31a26031cc9153d06778d359122352a8ace82e810a82a4fc11dd05d2e7da3827f3ed1695020655b8f3b2237abcb9418af4e901f922fb8c539e8f44d5b95d79449f082ebb82f749eef8c56ef99e4bc14f6a343be5d39fd46fd646ae542d5331a8170aec1a18007c5ac8f56ca2498534668f53f67820a69deb5d27750828129c9f54440925ec68ee23668bd7133a77c219a4ec716876f2f6f5c43c1ca40385eb1b2becc3eab5048056a030c784880e0eafac1219e46629573fe88df36c6f3dca23fba6125db778e25bc8df43c3859075df8a2637a35a767b4d45a9141e4f0e8b6f7333efa8b1e97e64732a347fca31d02092f76f136531e6b181e1fe6d78f858a61695d296d71c1522d6ddcc1c012b020bb2d17efcdde62305e1dc54f3d4914a26c0063571549ec256dea4fe03664aebeb9953be5f8e487a5481bd3630c086daed61d416e864b810690c555728469b103e331634b65918adb7286aa9b3f405be68429e114bb312b5e9d42a5f782757af9bb38d70eb94ce9d685f9998c4c96d2d8c9c2f24fa660ffa7fdbc0cc53d3333a7df82761a85c6c955097bfe1ed7e8bee42cfcda4e24d96bc28655577b73482b7ef0b756775b18aa96e3dcc9d6ca130b2d950e74219d3a9915bc6c3bd4afcff03b830f86a8fc4de013a45ca0ad0d2b1e6f1832051789eaeb7bf48cb1c673f565af0913d34abb0fc10becd4b02030c1a83ed8d6af37a3b4f877e48a222ef66bca9e9e33d72a100dbe8fed0419dbdd89d60fd8dfde817fde8752f42b49e64a29ecf37c889757b68e70dce4a5aa93f6bd3a177b7249ceaa9bc2c71a7afb6cb23d0a4a1af7be569d8c3fdcccb75160584457dc3a5ab27d739306f0fe3390ffb3336b92b1f43aa50b805bcd2fdb6b54adb7f2a34e368eb7a29758731355d8ac009d07d609a4bff73ae8d67e17b87b6e77f87394a9e058fe43db0f02781f9cbf45cdd3058779773e5f2e13b0c024173bb1ed78d9d9e0c134862933c25ca9d116c89fd64190e03ba3928321061d896a8c53a403b1a3179a3be408d79b178377ab934ee566e4c28fb48a19241009f3a8a8d826ca67279955408c36ff5a19a94d702c6a44c92e890d9ae330ddb851e2c3f69cdba52acc50ea22e893c8b0db9489c38d6121eb93cdda7f98e0d6da53a87bb68e36c479e99ebeea046b26de00eb155b0ce1c3451d8470374668f5700e1cc00ef45f62b433739859cd69febc7aa7ae7712dc8218a9a3eee94b874e6ec1d6a42b675a9134c6764c4bd776382c3acbe8468dce4a7480e63a122e0ecff4bdf76b6afabfb5a31191bd6fb896e4bf867df9a9f0ecd701d5c8ef705dd8603cf90a6e0eb70608558afa5f0621a45aa535af441a58c5542b50f2d014ac77cda0c7efcea7e37a157bf5d2020f296b3ae8cd3980afe6ef59293b94c3d3813fc1964be2034579164d08ed5a6c108385bfc81fed13fb5b2761add0bb66c79de986f5f2d1ecfd598a100e001f100fa92930a49744851b53daf5279833f01f14f6c1a58c560902a31364908bdbfe6ebaa6f90f0175e0be72336688b138ae8d84729c30db5a4ea12c98f8727b29bc3d8dea6ce52fc422c91d0c5daf79e937c1a9d58fa439b9412d8cde45a389bfcee1fd5630e4941fc243d5eb474649b37095b12379c7d16e98f93aa90c7542895f02db72e6a74f59c796ba3a83988823b74c2753eb5c801f828af4cbfbb1e960cbcc1dd6514e6594f78d9654e2edcf07c12c8476ec9aaa16e2ece7b37d2f0711b6af42313a615ef13ef716bd072e1a44a529b9352f436ac51bada4b230d1dfb4d1de64b848ce84533a1fa43f98c25d7adb70268fa05f3b6230618e390a8b6d822874ba7dd57d8342620a17656bb86b4539302d2c3129d7bc8ceaeb71b8532aa95c3c1b8b4d52541038e77ca24ebc7a0fe20ae3ff26c46e18582da25a86ea9fd60d46dff2b901bd4a2637699433da1dbbf111dbc24e7a8e6026303bb22aef34878f345f42238c73ca3988caee34dd58a119c3b5cff7600d0d6b8374fe646c455083ad6d9b3e95f9613d87b6cdf2cfc74310f81db7bca0a6e912037ef75e3eb1e91a8eba1a6db0d016c78612386b41c64c37e7b43034f9252a037031c88285bde60547beebc0732d5ad272f50aa474abc3d7077c8775eb25b9ca3719540a14c6b2d7181a3fe522583137be9932bc24ca240923ec56df769cede8e955c03340e8a5a07e5c16fc569565f64e460c13855663efa86eb39dc213c22e25ef10efcfa1147743c3923d9b46321a04adf0a146408d6c6cf93a743fd1f6152ee9111e12544da0b2158b88e10aa038c850b0ad366964b239bb3a7efc69579f4d854709ee4f412c4816641042b55fdda1d06a8302a581c4f482427bbfad9e5f849c46459957baa38e23936f260bba3ef3b91cbba3f44b813db70761c1cc0979126f11132df9968ce6288fac1f74b8367d487c6cb1cd23e10f4874a67311fe486de9b90e2e7a5a0243df6565c56be427ff3842904dc2dbab8ddf0175d40538b76fbd9346007c1028bdf9364b3c73b5eac6863a1f14ac3ba53ec6ef81359655b447aafc7249fe04c64a962f3501c94188a0e29eeb26de4ffd1669c92817971a21a00c81e22f38aa9fde057c8d26bca3921fec5351433639dde2a086033f7f376eae25c47cdfe919fea3c3e2b30d8a06dcf35caf3650e53db6b31ef27fc90a03292c2b7a2932ee9616eaa0b2c67f64cc839273e012c00513cdebdb86495e8e0c42ad8cfc1f34e910f5beb08e856f67441a3a3d4f2b91bf5d4dbee3fa3798b6eab1c0428bdc1be8f93d4599aa90ec3319974e7e483ca3c64424dcc0156ab2921fc95efd5bbf10cd3b549fee395c19dbb078f4b25853dcd5531f783a25a8ae63bb702c639b9a29adacfe8880b0d04e111943f09d9ba7badc90bfd84b1dcbd5748c17a3bbdab742968f4b071d854cc685e5514b9aa8f4fea5b2aea3cac05d9854c2a36539b04d7cdea6e021ba9e335b1ba8504262b1e509f3ea6333ea1cda512d07c8710e0fe246e9ed36fb2ae85b1476a6b082780cbb51b0e91531d834d7a8d64827e4136266c3f0dbf34ede982bd6c593a7e7511471cc8b19b40655492b6defe1befdd1fe1f4a94faeb3af809a1054e097ac930d5ecc37b6b170e18c7b33ee1a64b5ff126526e53d8faa59717c37239b8f8e80883650d1733735f21656b633bceceba656851b07bddc91c42a024408465ae49fd2013e11a3f32d769f8e5256753191d38cbdb2fe16ac886f6b7adb907e45d4e5952512ec45b4a2f463825b706010f08f2b48c23728a14c396c60b52d47ae095eedcafb3ab0479990aec73ffa6b0fead0644c9e7a19f30d7b5eb81b11b8fb199b001d94c0979f7575e5a2146a72e49e569c4601ccf0708fd591b256f4d3d0d563312d56a293ae3d73df56545012bf157e4763e5e10e64c1ab764e2da8e3fd15c388cf950c64f8c56ba4ca9bd24b766d5de1a57cca00173f933b50328b7e9835524edfa9bed16e0348bf8f710ae77fdfe291bd1f9b19ca0a4b1ab360691944fbfac4c65298bff5a67a6ecf4821aa1d5e75524f2e92926d53349c43acacdbc9eabf83f8abdf968fb0b4460bbe4da1295e084983084bb0b05bf04820a1701cb79eb90593344bce3ffa4c7930a283c20f964a69cf4e0a3ec375d2542c576459878a74b87e846fe1c8ef838abac61a18ede6d25e44408cddb4f811199cf15058b7dcc02ab5c03e9140a85e2a2435107cb1f4ec6353b42dce90fc618d8d1827e8745ffb9301f66db4e9316edca2d5bf9ce3be4be17b1226e43453be23c729c5ff8f9c379ca33aa576426c8db22ca6a655f5208d137efc107552885f500a1e625e4cb4cf04c340728caeb7b15cdfd43064b0d9fc570d7b24daab713a2ab46117c703f05c3653cf4add473cd4e196103004ee3928d774cf1e248d856034f397a5f1b928a1c3489e8ddbc8fd180dc8f2c2db92dc9498e43faab014060930adf2460c50303eb36864a1085fc4e53c5edbf753083b1a361fde60838081255dcbe33407de496e897bdfefdc490c11973735ddddf0974bcd1f1309d90b0dddb9469245404eca32a117dfb0898adb89ea15ef0eef761a0531db5b3fe8ba1bad6a138ee40f99ddd96f5d117e02c880d6c4328f51f65fd003b3cfeffd9cf283f3e47afe171cc38c388211240b836a0ce321f1a7c38cc1478e74cdd5fc13d6bb23840de36c967833af864666391dd64cb15a1918b59d7bca538017b16a10627eab54cbb3f586d333dc54972b5d0a8ea4e72c168d40c9bb1ecbfa3ae72e9b0a30cd679ebbb29c79609b962cd587df80462ae2615fbbc87e90622d87f4c9cae36431444b7c893509f69dbce228f3c43b64bc604981b37c293f7753fb87f3b4b69b42af76b025b0c626f7142f9f40385cad14f101527c39888f39cc97aead614c455281b78ff2afd2fe24b6a358ba23f2a2b77b51022cf27b601099a4907d85d4537764b0b98f3058c7917e3cbe85687ade1a1703fbd88faf9fe136710aa67636ebf467008c9bb734aaaaf67e475602ee14c6ef15e20dc99efe29506b436ae8ca5f3de8121dbdb9d9f108d974a1ed3dbf39cb50e50e0fd24d762247b2f22d77e4db756307808a8dbed3d96e423f8609e6b498d2e887d0fbd339f2dd0634b77ededb226098c421115d65eaf5680b94730d59f78788fde758bbd4202e78ec477cf4a4e1efa3b5b9d2979034999ebebc70025e49c7884da715d5877a4b65819518ffba7fe4cbff00fd9bef55e5ebd6fd92d9bd2e6886bb2e0fe3e43c8742b3c706b608a4cb777173538dab6fcdac3c67ca404de87c77b9d0e8fd42ce2de1c9938d7d461b38cb9238fb0f9f535e629c38fa3eca74c0353fb7b816764a445964014846877d0418b10182434a83df6b65a7de05710811d0c97e58631cb205bae08629d3a32799469becf16d4bb976fbb7919c32c5f655b4c195aa3c603c81e3af8390a227abadeb3d6841cd131b0e9069dedcb41122ecce077d35a2b83c5ef4b6b77bce880e088ed0e612eed3172ae32e4643f7a1d7832428de10d9325d57c633d98c345e08627539d7983d8c27dcb1e9af6e6da04d3693dca443ab6cd6a2f2190883791b9a179e25fd2eb22e6389e7b175a3ecffc546356547e163b7b4bba255eb023205422a87941190fb822c2db8c69dbf11a00c702237799158fab0a811ff5b90f4fdc7d8cd5d6fef95517b503a3271c6ee6a34a46413d8c5a96f8e940c49445e4ab426c76f5a624a9205ce95c3b023b7d1752f21a3f456e6285c71fd7847fbbd0cd3f491357412a58360d2110c769640e95c12af893a7716805ef19db9c992a6cc52899f1c0f540b0dfdd1e4ceff6cdf523f7a317f7ace2467db5a0c37df381f76ba43d44a90857100d564cb8c11d0f9e6f0558cfca3b668f3a53f0cfa4b96cb737049b6755eeb307c853306f13d82bc82ed892eef12c67da482bb375e69d6e89249b89ff510b85588c13fcbefb9f55fe7c248fb452d4412fe24783258e55a67204da25fd5befe7b1c8949045eff9c2de728526b09af4c6f27af884934eb6fadbdf613f40f4aba323fd25743243505cc3c1577936dac43cfb3f7720714712e09a3b4d047cbecb6df4a348f0c7ca3b33720e74ca86e17c022e66879bdebcf0e50f15faea36279b6c20fd7fcd5b21420e7d5bd05ab00c2e47259fe6f56d6355ae804fd2c5f50a79edce2d4a11972234f548cc50a05728570dbeb16e0cf4083171d9f4b2f6f338934188ed528581ce7ec56bc59d8bcabf67a202c57da1d7fe62814f1164b71a9cb99930690a0cb8afdeef48fa5588920e0a8fda8f56d74705dfcdca3f2c06330f3126059c84600a538f19830bc6ff6b96ed04cffd52c8f773d3b373149f635cf31b9770b06fa7704b2891b54ba60f2fd2a3cdc45e0e564727ca12b89c91608b54ffc87ef9f326f69985c7b3356103b3df15a08eea2b98bc8b03a2c7ae8cb295e3814e5c17afd3e470c15641aaf3f9d8740e77036f144b1f6ea913f0a528ecd8ab7766640647b4c4cc445ecd0865befbee1a26ddc0c91273a3755775ba261d95789abd4597c87a69cc0dea4f073b1e613117c025470534aa78b122f284f5a078c28ed4c11dc5ba763a84342f93ab64771a92e7ae70e7a47833fc6251db92deee9ef16b38d49cb14254a909ef77df3b4b8351f51f368365ca6b5cad8818ba67dab008527597eddc9b28152ba6fe4f0d0ea8b09fb2e4ef104cb42f8f2b8975f82b89f8860724b43bd3ca3fbb12d9957388b0e80711f8ad2f900b51e04cbbe82488e196829cf09e978d5bea8b046d4bd4f7c7b056571179bcc2e47873689e8d3e4b63b9d9b9ba4aa5b7d4ed0cbdf8bb19b4367af2c8aa1552231a0206665e6a605ae1b1b4b489f4685f55604422897bb91ca49b1f49393fa17d65abfe74c3d413ead2b00eef194b33f933025490b5ce71c53af172a2fc9ac255d32ce0b68af4d70899c5c833f0c6118ed74fd88ba27296906f03a8193afa3eea2cce1e0075bc08bf5a6b5820ecd1fba9e10170ebb6483ab03f06a899fbed044bf0c3da9e9512aa8bafd6f9a963f7e3cecaf832c1f65627771b0c2e1606c6d1c170dbaab4fe4c19b65a3169b7fdcba57c9d3d64cacfc1c944b6ae026b381d548af61a172a0ec473ec8c7c0ad124114f8a36f93f1524ddb5624db5236fa656196338cc8e8592afe935b701e1dbd9a201952334de609d716c3a002536d49bddadd1992a3d6ac9ad8e527f960dcf10924f6db6b4b7b91ad9ff19a846b5b890ec9998f09b786649061e7f3eda13a7439fdac6fd5b434ac21eb3b78feb9faef211812307d34e416ca65b523b6cf8e19055d1c0007f52d8d390bfc35832196ad11958f49eb53ea5bb21d5b783e31e3c92e2cad78aa8e31a3823eddb7d9be964be7db47d97504789113319775c488c702262be9b983d19c12c824bdbf6d1e037c6f3f80b773dbf3067f985e33ace5ea50bfb40d84524a317aacfd7a3790bf22862b7a1120a3d1b8140187cfe276104bd15ffcaf00ad5ad3f4fdde42692add082037804354693112cdc5ded5e56c6ed0ee14f2083d14a5084e1c69b797d796e73e63aabfed9d9f5b27ad32816b540f8660e3a35c60d6a5225acd0b7d20123afa32753750ce3124af840214fbab8370e8086b75f097583001cd6a4ad4b3a85ab7463a1b3037dcf15491d72f8c83125332803c18ed221af7cc95f2b2090c90bdbb5bafa6f3b237bdc55ff3b198607f2b5ccb3f7255f2b5e780993819d741d7f27bc24f43208efc0f1a066a0025ef83f99f5cf4538a888812ad5a6183760f85c9ac826bba6b389e98aa60dd24b1c642ace1a1b2d6775c95281c2782c084072bf3644114fbf57b48b0201c8abfa60ced8778ceb1f924c09f4014fd1261358d4d0dbb0f51d4138ec078fe729c400728065e4a128a7ae9e3f1366a44304355df063b747c6f992b6bd7da8e563af84f0206894a39ea15fbd150172aceb51d3377e98cf2196f37023c983d5aac82e6523e6f83a222b985f3550b6dc5f97c67614a192a22801f8dd3c905a1875b83f37f9eba12033887f1b74a243ea58a91bea911e26c19b4f8f2b9284f5a6e6581252d4ff6a26836a7f7fa909a70863e3b3dfcbbba99536604cbac20f01a71c1bd0549c3584f8996194a0e8d3db7ddb7c9b3aebf000f92e588efe6305dc9c38af25c6565383c53625eac7428f54b73a9b169382a200d90352c0aa416eec723af8a40808b2c9efcbb906a55d9ef7b2fcaca091232e37849500e6a0f2292412f3ce1b609da4f0ee2ddd2d6ca2b0ad806e4b015f63c1d56a26f8fcda0f16702f0c23469cf00c62ac717b195f742c97e4a02b4f3b75372ca9d7ac900bacaae8e928f82253da1aa69519ee1b8aaa385623110c533fa08b44d419fa8b1b18d526349805d4a33bc9da32081f8af60668660679aa97c10fdc50420d2e5adcb3a784a82573dd7352d5db3cb4601cac314bae6cb873b61764ece4284574ec98f25cdc18e61c995178b66bcbcedd43ee3b94a0717a0a410a83040966c3870602d2889f19d2e8c385282febc4650a515b78659a84639db5a3805f82b292bb0a5b80e36b832ab573aaf3201110901134f0fec75b910e9ae0e3aa486a013cf098371d876fd0abc608ef9602e848ff697b2ca643aa8e2ff7f088316b20a05bc7175a972db0ad7245acffcdfd36ed1cc0c0fc24ff1a59027c4ab3a704855214e42b2b17864ea3a02d922a921427f19b567dbf51c369c273147b26793cc70dd778ba99f31feb0a2705ac291ada75835386f16ad1c6a1682901e0736afbedbb8e820af5be400beea5aba6647fc4f46d1bef7ea9a16f160b3d20a4638722194b03e675cb4e0a359ec1544981eaf81c46178b2aaa2390824e14cdeaf08105d3e024e51f9fc2374f1cfcec64a5803e2ac34c79f57d4068e9210989acc71b3ac0b8275f84d6e08ea26fc59cef1313236ec9de92fd1be12cfe6f134a2c8a678c59eb21bbc7cbd04139abb4ab246aa1eea4b07a2000b203230417ab5108a36a1b42292549516f91a8b8383e34de8aa460ce3198e220c25e0a19e26b80324bbda2a84984c71ba0f91dbb358189dad01f50415b22e11d806ca136e254613a332d0b8fccb1df83ec02d51e9a3973ad028e14033c0177378dd7505e5ad5838e00f223eca23b7abf3d6486f51d83b59b83e58bc6c31a8769df661c7e71f344d79767523483b3ff278f41409603bcd34425ac887b41f77fb83ea6dc70436e554f243d6ff082c09b939e102d2221ff89def2bdfff862ceda0272db65e20b668ff0bacd15bef510770ddf1f67d2dc1ad4d29cd7ee183559d4cf13c2d664a5d224eacfb0a2b0e9fcef30952f89ae8cdd63002dd586cfa867016cb8075b90785d7d4987131f5ddacdc81cd8f093a2b41515a4931506a91ebb00d74a16fd4ffad1efda406504cd47529c67dc0bc3d05bf0add34e1ffbf978f2a35dc6bcd45a0d42c0bfcd01609d3fbbcd728e5535d6822a3c4d2984800f8036dd488246fead23210c47953dcbd8b4bba5e8c5210a2e38e0b132942d9412c5834cda2853c7c4b8ba378f8b65e85145871e03a342976cc16292cf4aae1d6ad0864368974d64d71ed350b5d33a0fb7fb57ba19df8bb9b376aafe7e40f699315e9cf6f3b571508fab34e1cbcf7b8c5a3a502679cb7fe2adb007925a6a86f2d2efb638da99acca56efea4334bacaf7b350e2cdddbdb118c9801061859ec9805555b1d6267abb09709dc465e5f29fcb7918207eedcc753d279a097d99e09aa7238e9b8f0469cd7686842cd655bfcdd5e81905f5bc94cc932c6e9c4d76259bc14aefddb4746834ff26de92fe1f4dac09a424b180d7c8c71f5770fd7ee497cdfc6620d46963930650bba5287d5cf7a086252b0ed4a369310093e437252582b70a265d3be75be8fe246ef5115d63904a6d5683b123136e6cb742669fa462610d8a85c35092d790b21a01a6ee1e687739ffe91586d91b4aa739b3ddc241a642f80a0f32bafc30028dde0bbf08c0b7e0734d5a3762e9c6780f81384bb545bec39ea8f4bb67f5baa4b9ff4a0adc88358043e3f3f53c78aaf41e26d6d6c8c29077c97d3b33992dd09da16b795a302393c893704671804b417baf7f1be885350f0bd00bd74a3c2dde18965e025d03e324415dfc5e70e84605f02c810854ba257605db34346f52960e7ccb288d8f4fa6f1604f0482d95ccab40582df663cdb2e24b599d1901f55e9a4c8a7963e05ee43b8c5eedca7054ad8f80d7c81c4942e55fae6627789bf74768be9fff27d2dff01ca251d1e8a4639dccb2242b0d7eb8c949c657c24c552a8bb1c88d43098c2a6a32e304a6162c934bdb850998808a8d4bd14ad96abce83a475285bf976450797da19d0c431fb34cf8f415fc47fc5f41f43af4073146a10627201be896bffb53010c8c1a190b9b71f3c855f47fff35dbe971c056b16191b5abb6af27ecc83a91851322e9f99cbd9d9d1d694a16a5b2dffbdcf5cc5947e9dd8e0d39f0f91a2f0e3a2871a7e8f927b909e035630eae9a1346d74861f854c7dfe73d9f15382f9880e9c54a7753425895f0cbe08ac4105104a1d7cd455e9db5ac1b8c0619eae0b0c815c731392e0b3fff7b8d81f3b3072b18a379e1630360f5584dd5fbbc9ab712b316ed7a3fc99f2690ac686e8ad1bb2d2725fe15ebbad6937be3e463dcd08c2a49da2a0c2c89feda434f6fe1b72fc857f1d278145af165d7c90c705e6c90341d3007b6a47ab0ab3a477a77f89c856894cc52e0716e3c92636e116980b547c374c3e9346cc8635832214f761cce47f845275fd190bf19f32f77f114e764549f37d820a8d668515b9fd69762ec36389e8a779e25e291835482f7a6a913807d7a2923a5c7c17cee5fc3c961254bfc5abcbb1d2005be9b01ea7b6a1c508537c8a888d621d5cf0a0e34bb2f44b252485f5204137f4ce21a49a7f3fd595f4867033e58a63f314ef36d76a55bcaf9b2e77a603d42d1c49da8dc14ccb2dd38fe399d5bb1897bf9b338e6d868884b300c408cba10d1eff665a99c0588861d3e90ca9eeeb424ac7f4bc845a3cff89356dc7e10f8539c71d844d5ee4a98d1c0797709baa8bca027a70847118b31eb2019512cafb2cb90f5e953414c9579fcc85e8e5eebf053913de05cf2e9bf33803466fdbd2c2a3decddcbbf478299f750f2ddc6f82d96b112b8ab8bf839d6a02c4f03e168178f9e3630b9841825775f82d5325ef29bc09aed5eb954cc85e775678a06908bb10fa2a1e09fb9379943b17cdc8985f52cdeb30be375aaf7f8e82c3ed09a3c88e2608acb5bd31e117bb5e2fef1785b77e7c354f1e25063a8565d30bb9ba3fcb7a53a867dc995b083cf2e91592763fe76a1e467951a9c0fe1fbd79d603fe40a6eeec49d07ade9e6e42c0f391f552bd8cfb4d1061cc69db599969fdad196e9ed3343e2d1512d6103fc51eff006624253366f034616bed4653be634f239c8479a395cf234d53945529e0709df087b19f0002aec078aa0a29e90f50d56bfb13bf69d4eac4fd5e545b830ee5cae08e4a3a7948b8fcec5049104ee32dc1e4d0bb14f0482ff69fcc00155c9d5049aad663b943573a1559756c25a0e4145baaf0a4b55eaee47ef28faef0a880fb0d9746a3e102c78b38ad92d6b12477788dadd24e0fb7feb7e891eb30ad562d4c5e3574f7b42942b3fcaeef1848aab258d3286b0425d1b8e562c1dbc6ac5fc087c1b78799b736eff146b8be7befa725bc35607d87e01ca0d7d2760e4c3185fdc47b8c63d870f8146859e4bcd9d3742d5c94787216629cfd44a8d050179a021dc91d7b2cccc39877405d1df01efe3c82041c37d2d6b79ca0e24d200a4e1fe3384d8517359cfe523f1ae3dbcb6a518b75cae522062249731883d5992ff1c5413f0b2b4da8e0a2e238ae234fe7b42a90a204992e01f7b2cbc62d7cea14581ba2b329302b58e69e7e58f3ef8b6f72546bc41dc4605468db48d3d2cc301f69183fd9ed3e69eab1753e1616ceb23f897c47a6ad976f9c8bdde8832d0c7147425eb41b565334c3f026d9552accddf95d3b8a2bf3ee1fbc511669a214fb4a5ca47455b356206823cfed872bc149a1811959fb0f07f52f24f541d18a9225d73e5789319742d99a2e9e8c2f33aa465b6724c268d0c1f713588a5ff90b0dbd296d827e4fa823ab47dcfa2b6ca17220d3364a83fa93fbe5fccda762ba3d2122d5d968e2fa5bc3168664cb5635c876005fb6fc7fd4d7bbd121b3430c620757535c740e08358038aa813d1886a372f12f3cb76548744d17af92229bced5d941543eb8333ec25daac1f93fbc6063221c610e4547d49c96c246f68d47d26cf4f3857e0788f4550174b80a06e47f8aece18b927c6d488458ee8a5f2154dc95769377e946fa91c5414c5fb5abed1d3bc46416a3247fda3e5973c7244feeaba8fff3d06fdb629f597b43d760131227d5bea6566a690b5123a4b5b8c4c4d921e061e066f2a519347742ad48a306789013691f888203067dee0b6cb6a83a14cc2acb093a5c5b8b630c0d1c779325b54798426fd39d6b8bb8472739639783957a7b7b71910406e48c5f9459219f1ad5a40412eaded05204e67c375a0f312fc45c7c34e89064a66b7f1c019ecfadc83255a1268412f685a44b3c405ede8f6adaea42db3a7d372b788ea44585183514ec88fdba3bf90ef482ba4637113def04f1fda0824f9e286b934c1d8d9838c53b7b6f9faadf7643afe7950553d089a542b597fb02f3b794fa469c48604b681a13ff8a6d63bbd87301f5ec5b377065c4d6b0a8550803743d8c0edc7880d484bbbd87c697a6ee61a1617c7f8f09095154aa4335b3463595a7118956be3dc37b21c2d4b004291ee014a0fd79a4cd4215fc61d650d82a28ee62933fbdfdc671edfebf541e523ce52b0ec491e6e11adfc73107d6874a6f6a76889f387c006cd6372ba5816d8d53016a9a7de412b24475d63df47436d23ccec96c72873a4b1864ba035efad0a06e5a6630128659deb840c630375f181479cadc231332ca21a6ef4001e5c1daa828fe831b1ccb0985c556d6012be6f2eb407e356bc12bc1031f4d62474a2cd6946d75ceb513d40d885f8f6e41e0fcb129ccd946598ba21c0f30244cdd8a69e44723b5ec882ba9133bd43517b68ab8d9d46b46e7e25d0b83b6de2320087e51fbf3d38798afae98bfc19ec9b4cace08176923e04d1b11bb8d94c51c284e77dbc5365494f0a1630e20ae2a8fa93248a39f4a9d06454206b8093dd87735e9baec0992dedf2f85a20a13dccc703b6b15cdfdb83f14855625d294402dd7fe93dde66bb402ec82374aed47fc60fc0e48f4927122b9056fd8e46b05dc99d001d172c0233e3b13303351af7f47396f8a74169ef655295a9ff7c746131b6f2352a29e9efcb054ef15f074d06e74c3d1321f99765fbf90c9569be185755625c3bbc5cc68b6c51647f28a1730fcfa56fe3d3e4eb31366be2d8eab6377f1c1854a6bcaccf010e9d5eb04cd6db3edc878b796373fa40e9f473fc4b0441966aaa586fb39f54e067fb020d4edb30a55c1ea5eb2dbb3c61fcd81761944bfd06927d79be06141d3c8f0b8d3e530991ca79063da8c2aad4f7559d8f89f75f0a7e0acd3669955ee2ab69798f4c8ba6388f3dc2fc29374442c6c098dc7acb7628ce96298dfae4d9faa2b957229bfc1e6d9012218d70bd2c5ee6f2e39cf22156a2173840db98bd82d41a2aedc7eb8ccd264d7b6b7127fa8d702052461cfce2222191d33a9d8ec548fdaa532bc75320399775c972634c95d054448cd78586a0d2df8a7536ef29b67d3fb4004b724f11ad8373bad276651b41f4e7fcc4aea30e9dcc3e16b390ff2848057f8ae9a847c51b51c0b6ac2418734432adac0be0a37f7228e9ac456a0ee3879706100bffa3156387ef0e9df90468912d976702e2023cc62709ced2824d068ba6b0db4930e05e16b396b61b4b5c99b8dd2b64759a949d572e5fe587dd0c3192b8218bf4eaeaee4d8d51235aee978127f954a1410b5d3e510f0d47854b19dcf0ab99c5c47f959bcbf7ef221e6963d8c4cbfb29a102a3c8ac92d49e0b81f17122c07baec6dacf593bea482947b15e9a7b31d8c15c931537a79339e55cbfcbf2e0662ae19d7944bf1aa3d8df4c1cd5b5c781e53a703ff2f00836461dcb3ac7cee4c22b5f6662753d606fdab68f34a64d79a2a530bef4961f8b3fe8800153448960c8f7608e2cceda31b6223624f3a16bbfe7e029192f2a09420e0a17eb625872ff38e1eb0d2cef2ba46c2cfd2e79760bf795cfbb5040b071743c498f58ee0fc985937d6df95e5550b32e073c4770d9a82c15573d84ef276b9ea11219e6d4b87a7c96e6e537f07c617c3789b5c85a46540ec979914dfdc48fa1eb0c56a64b779483f50c427ff77af218057d79b7076d0369c3a3fa17403585f5dc4f2656675fcad58ba7671af51c0095228f0ac5b00adff4e1e03fc6e81719fe7bdd5112b178a43d937760d7290c08da3fd76afdca1ce6f8a1eb1510a0d7199081f239fa356f5d2a07f0f2a9058d42311e85eee351bab662dbb88422ba0050d1c3096cd5b7d475a0ba74bdc4bd564b47dde99953531ae3458241d3b334f67b6c4c81a3afd02b887c7c764679a140b33ee9cdcecb54917548c27896014d680ffb69b89bbaac30decae7a4d3708c8cd95c08b3e232e232778d0f880edb4f71580a2cd0f2dea06e6adb0bb085213091b0554963dfed91f4328191197fb47cd10a3435607c7b02540f1306bd65d627199f7bc56c5881448d3ef0df93c762a4cf1512b7293a1230ed5d6323ea69493571914054fa01c2c2970036160ecacef9dcee2d562f6253069a1325cd5f38cdfef8f567bc2a8325ab4ea066188e995b3021a38f0d58bf22dfbd9a8181d36cc8686620fc4d5b6ecb378f299cb48febc1ce395b62836a362a1e480ebb6c496778fafdc18e4ff4cefb98ceff0952a525600fa6215b3224462d1a4a7d61836ce2ac5635f997a3a46648b592e3e3f1e236a21ef2b4229bc33827960ea337454e71a285ffb2ddab2fc0a6d1f40a045768721e6b86ab2e59f896799f41bdf8f0a15ec8fca8a3c79fb0f167e767162ba0d6b31578215f53eeeb59032fbccb2674a8773cead7cdc45b4a38c12eafd2bc493490b74b064e968246e43d3a53ebbd96528996582ba1599134d5c4ae0cc69d685f0e45bdbbb32e3e413cb2e12f6fab887a4d42bbfb6dec1708c8e27e5c9ff924de8889905102ae9f3191e46a38d276d6e45e2ada4d8617a1e246cebdd5e513a543d9a0c4fcb1b3c49959350a4c59fd69d6807a6fe7d587f11861bb944006478de632fdc878c872750f58864904522fe4e824f0c995ee407b8ab553fbb55c5421f744ea2a8267ec49627ba2237d3601eed32a2ecbbc0e62f10d49f86e86cdb9b2297f8af3901a30214c9f11775303cc45634359b1b8bbcf49482f3c1a9971c6007a0903488daecef4b7a3133ca77a6cecc39da8e841d7c4e22eea19890bda9c3220f87d979d041e003cd72e2ca78a88f6f75748db976eec5b707ea5e9f5e60f4628f1a8575fd05b723119089b6978680c3b30f63384a8747809abbbf548ab3ecbfd94fa2df3c061653ecce05db9f41bb526bf7bb229ebf6f4505afe9690e1f9c8600bebab6a04fb17eec387f5a1fcdefbbec8f0c150ff006b3f4a299daceb5835da0f2dedf19297ee090378baebed61a2a31ba6c0061cb7ca519c8c2623dfb40f8ac7da13a2580ef6625158f33effe2fafd66d9692e88f0c317f36d2808e6858ac2fa33420ad89a31a3d5ff5a34d341e1422f56b34ed6d2d919c49a1a0bff1b47ae39d1a726f765634e68ececd93ea9da4f8276593245aff8927bd002baaeea0849a21f154a01428a54a5b9801c6903076b85b04d9b39ce4bc184d88cd7d40d840d01774ec544510881bdb4d4dcd2895ac3e647dae57fc30386876322728bdc33fd1bd81c50888275a1675a63f0ca0cc5801ff4df2e0c1ee8312ab9f9d38e2918e7c8b49f28eaa6c85d3d2927458302a412cf4762be1bf8bc28106c9e6bbfd03d43d5deaab28de628bc44107e339146cc01e4a0ac8fd8cfd692640e9f2f8f952c4d3963d422f8fd3c62cac71c157ed9bdb3d7db077578f1d95fefb585e45eb972ef152c28313d04056594fd25722bc0c4a65c05ef78fc00b7d018f4a808b35c33f7a0904cb43d534ca91cce03b2c345d0a6251cbe8e547a379103d42f395028a0e93ac86207da1cb73e1678fa3ed55b252fa18db09277ee921dfb2128a645812c1221aa8aa1d0636503c5300dad9fe10063a52c7ddde533ef8448c5e2bcbc74ac382bcef469b3de54a1fe822bccbf28e2228dbd10036986e241a43e1754a594266c4558e141345fb9b0db492dde04fe7b60254d6e44fb9f71401a4a3a9b4a51f0007ab07ef7475660dbbe75f3be7cccf5569c9e5bb465e1dab588d9d82b4e1bb81aefcf12239f24628b1685689424f9fcddc14721f77e6cc8a45c8dd2b3939aa2f49595dbac2a6e214a7600ee590ebf539328a06d34e400dcb0adcd55a8facc04ccdceac08febcea27e3a3aa8d00117c8a9a36f5804b7ebadbf50d8631d32f46af61b892568e010b7407d5a41d3f25734f417f32be9d08597fbb8fc0c054ba32e2ae3a30f3e57ee85f371e8b4d8a750e45d4a1bf821012adbb65b2f0e63723bf5f7d5fa2c613ade5ae7699b96d14492735aa7afbc54e32288bfdcb19d57f7cdf1048534ab6c0789ab71710176bd7a5f16391d91c921d1763e9f3fd638de77c91a813281a4d4c3c49b4f5a786717c15ab92d43c982ead30529b35d964b76da9cbbc9d36c57009a4e22af44ec16797560818aeb4d017491901725fa10fb6106c86cd9081956dd6e84acf7a572fd389a0735f31f108f585c49732c9e800052ca1443740daf8fdff34d44201629da720817ed3aecbca07d92f6a9158b13ba4a9cdc5037066a2ff93036b8a04657b023f0ec28de1ee07d8922ecfe8613a2c9a6fd028c4168dc926bd03e8c27f16e18bd9b8afd2dba7af503a3d086c22d24e679678863e1ff468bf2eb6851561182f059b9bcb10485b83e4d65ecd584ba59acc51499bfe494ee89c582b70f67274aca429b7ae8c7d67c6dd3097d199578ede0d34d33dfe924d390f444a2042b7178b7d18efb699b432faa6df655f3bca9b916ea861601222cdefdb27fa5f7a142e38ef4b574c6046858797b3bc10aee160a9014b685f8bfa52e487268e7cd6138dc61c2f0d7d213c576b6cbfadc8b4570811256ddbe2cb44675ec9d6abfdd14ea8dd9245ca9ddafa07042a3a36bc57a6e60ef2e70cbcb025c5e2924da684c4519fcaeaf816b17af3d2c94db1589c5fce6823555c0b723c19022dcf413c116ccb6e8f63cff7a0c8dbd47313e7e014dba07d529b9ecb5a9affe3836e096f8d397b085a2c97dd3bdca09047db065b52e172cff917367ffa366e33e41eac087fb262ad1b969a6bab498697f2c24d195319af8489db3beb244a31acfae29e0c9adb9e610232b6b0ae8fbd28adcb58ea9b01243148431a553a2a742c04b59a8d8ab75d5ca138f54ca8a32fdf8fd1b26ac19aa2c927ac5caa4ae548c240123e91ac4a745098825c5f063d67b30d907aaf9c3d0817c61c500a70fece0db2a50db020dcfd79cf70a86f4f0966eaf71cdea01c47c11c7efb09da09d0c7ae463b35dabe67f5aab038783ddbcd9e3616c4656af6b5ad8c17d8efe2a682f2d0f85f5d50e7045006aacbaa1f771630b01bfeebe148df02b55332ad7fb6f560136d04a21fbacbd4a78a36729e476e8f17d3e4ef870e80d32c3dc6872219d567e63e338bf919ff68ee49bb52fc33149a6f705acd1cca6dea8aa9483df28b6841263351e9a4f1f9a82c9c7f886900b3c90e239b1367a9123070c1ed50c48446bbb3dd71c694262fc8ab0984be7ad9355bb6c62bd663a1f098555f3bca546327c0d4e1b5056ec628ec19895ca93e862ef0dd9f579b7a2bf7ae91b21682bab469254703e3d02f02097e54e9e04e4bd1189be4efa5a2eef7372bed171d8e63f16025a47206ff50a21eb058e69b304e4c9e2f3c33ade177484a10bb8e91cd2e273748199c1b6cb030c6c2192d4e832b81133ea22ac023811589f22025e8076a522fcc07a46ff7e40a1383f4498063c1d91cccb46b2416e69c90d86d740e09cba8f7b3f538869964d35ab38d262a8a1490d66d75fd7e461573b7b9160342de8dd5547b2b2c23cba6304769c9e86f5293631e4d25250c6e261c530171542bcb20b48467c65e5b005463daf3a52c1e70f5b882d2d6adc1f325a62f5b5c00e291bf5eb87ab29479d66d68ec95f76cbe1e7049762c3c4861a8cf8e4c3f8b6dfe4e17cf3703087c5025bb852e50d84f3804a981cf6090accf0ede583f9d4b18568f34f2937ff35ddff2c68683ef056f7b8ac733c0df8c5419e2b44bc756e93d7215230d0fa58b039eb2f036c4099c3f2ef81e529ee7f090f737be18cda9b72f84b5fa09e41dec4b1c557b4a799182c713c3c23aa4e3cba6f794bd62688ef1fa4ac5a6da3f9db2672a1b74df98aeed451679fae3309bacfd148c984431ae9bf570d1776f6d371de2fd0b40e0c51c7d727522b934f566fba49edfef23121c3b6c57440dbbc41b407d42c66e370ee3a1f3aa9a3c02fda32061fa6cda06a9607ef5eb6581556d475bcc4de2ed4c576c2d57f19dbfd2066078b085de266499293978e0bbba1f7d1bdd829d74776d90a84cc4d26ccf2ca925939aa2e30c5ffdff813597186827c41d9d352912a25e2ae434c5f7f5305be546a325c7ce3ce533619699f9b62fd9b866e5c432d2f14febccef37bb4f17cc1061d9703ed8db9a6bc5687d9dee8cb7a1c5a3da568b8a5172d51ae82bad183190f9cb129f9083b031e3f1888f3b41d1b010d29f52aa3828ecd2efab4219b77ba4a0ed764c760e130a0e0c2fc11eff5f67651e4a2e75cd263a103785b6dae65180ccdafe3a23c591f277ef1c6f89989945017cd4fc23be3b185762661b80bf77a737497fae4cc62f75d862c51dd38b4d4418976edf68e41d3fd7cb45eda8613028e15e9145818ac8ebc5ae6ca475371ce2cff995340f9d3715053f5dd292c18c7eefebd38347f6cefa266504061fb21785ea29bd77396cd67c55ffec515ac9d3dd445f9aa9ed45f646f5e8ea81d14bf488d1d3aa64f1ad3d8c5ac9d53c1aad62a5b7c3ab2eee3d8525faa5ed73f75bbaf8253f34d317c54f0da8057a91ccd0a6f4e10da82996501b0b69164fa1166440e0543f16ac426200023c0e8105559d76fb53ad2d1dcd46409043a5a704974c8feb993811566ad854127bd656f1ddf65cf69cb3fb1b4d3320849a92164a8920e600b2589749f98d402e15bc3b3c73e5bcf55c024514e57751bc8aeca43786af279e569fa2f335499e785135d5d7df256f1004a8c8c854570c0ff8dc154f1cb773a5357078d9f2253720430fd3eff1776a8194920ec006ca68e56ab73c0d6b87cae5fc32f40f7063d9df86115e0d904ec8334853e3df7941f6fd1f5338191f913fdf38b78a070e9f0fd4e9bddd867de628c97e0f85df9823dca24ef12cc77362ccf869cc9f3199fe7398b8945a91ee61a47e90b965616a5ded0916a7715874b8a2897dab80ed07e243febef7158ffbb7058d3dfd8057138dea402fa7ee35c7abe8a31ad83319a9a898b047609f96421896e319d3aa15321b74db1ed7fc779df0e924f37081121e261ccaa33b74c9eaacba2319507c15c17e8bcec92d25c889cf92a93b32f36c62f75085159b6315f0fe3d2bb4cc61e6260df2a412a9e5334ff9b78639429a0e577c931fa7f37fb2160bfab19bb2561f73d1164a6b9548cf1174d4beceda05deb961779da15287668df8241cd0af5c071f98668671f2a6869de7f4b76f235440408eaecafb0b8d8d1b6706491c02b33b614d024cfc97922a8be1c5823f5a39bea263e0d3fc25f39ef84aa63e42d7512a883ad714a094aad81e8e700df64f75c0f8a3a5313ba12f10d5f52b2f0d84714cd73568858b9117330a0a478590dabde8d1617ab77f93d7061221492ce8500661bf8202c539099389479e03a0783cc37dcff4f685c0926be218b0572a0749e5f0fa7c66026efcb43ee071d937328b3de160f31675b2d6ca59760ef6e3102f57dd88d83bf5da4baf7f5477a0608523bd09abaf83d6c5212bab87a3a42c840a76211e21736c07e7538a7635785939f53791a4e5de28a8307bb1330edd1d743f91d0bbe2c25f12ff57ee6d60e59bd724cc164d9e6cb7257321f9fd3af92b7d874f79d29f4ead8bd36975fa004a833b547ee6ded76f14bccfca89d273c7a0a01b5a82411a3b9bacd9fa279a99d8b34695837178dc697e4b615d85b131510968ce66458aa16f7de6be8dd6f345a69b961efa5810fcd3181eadd472fd0198d46192673bd813ecdfcefe5fe56fe34d395ee33637096ba7c1699a2b468a7f29df6d52a4134a956ec4fc5ee570315e6386302e2a61fdaae2ebe8c48c2210cd2d79894f2d1f28e3603da68e17b44c0e3a89497a158aba50a5fe2544f3daba8903d557d80b551c5dee467e27ada182d4c968e047560f7bf0afa5b7fe5c81fe892cf2b64425e043041a11d6a9f4023d2243cbc016d27be25944ec3c742a19cc5514492aa1f94ad7cdf58bb83f54578f268f332404a8ae0ea6885d9698aa229a0e66adec894fd34ff11658d66b9c6838615ba6490e21d06e8f9cc287d0fb038ad9558e5a991a838d1d1d1cc8b72418e33806542d5646527dad71f6be93a925815cc774e3a75be1e1ec77d7b489873cf8f368fff74e3fd9e6ca4ac6e44b6be3ef63cf7b6a3a821252f91f9e7c79e1400e0525328b5081571cf0c83a070d0d3091d3bc4f71b04424af0e643fbcd2ae67f67a5c9efeb937e355365db872512453ed885a8b05febfb836701131c5fb2813b6f028a27fae9730689d66b809088cea8a875939e71761828e3aee35ec49b42c06f3fc4b595548ac10d599e9acdd5879abe8e3098b993106c4f1ed500ee1496db9a65304bc9944c96bf1d80ddef4652054545b9c9f1ab09161365ab3cec9b277fe87d036dde0db3369bbc2f77761ce2cf9b5f2360a8d98c7335e325f4a518c25d5a0cdb3dbe14b9af57243c71829fda97bcb1dd79d5d16d8e712b9586242855c62cbd23d3989073c0697872d4e9c439678f4acf4292ac3595b57fb31a18fd6f42b21ed7f94c8a91601cc83bc28dac04c2a5cf6ce554afc2cdb8852510bcb521d0031230c7658cd52777f35be013085098654f6d1582af8ed18a98e300a96ae59d6e59880a5cb4668428d9b7afacb72368cd250a68489cad1c800fe3d80a7cec4944d8fc65f4d737c6d77c8dc91c4bb08dc4fa3880480aa0e7c55c334bd98de7db0d4aabe2ff18a37479b935ba5d6d17c34cf34560e260509b7297e2cbcc10e8bec85ed6bb4e095846cc851fafccc8a8caf9008e58ac1738c2333308b51cc89fb9a38f5ff40fcd8cd79cc32c8bc6f2294df48c886709011b7e92a4807f94a2ed4ba51a15830998e5e429081948de19144c812c5b972181320bbb6a8e7a11b667adf6bad0975600e65f451036640d11b3abbd6b22f31be4e7ea3b413370be19734df5d861f26e0cbc7294c5ce17b6f3d4d5d51bcf20f8f4f3bed9edc51331af375d683c3498cab9357d3a1019a243f9803908c2937d7d658d4c93ac24ae087850be92670bd1d02a3a5e52646666c5925aad857ea66770e3bebb27e2758eac77be0dd1d5e903923813a8157eb9fb1ea1eec30ca9d9387ee5c5fa49cfc3f4e626dc92cabbdf1867e18e749ec4ccdf3503f922cac7fc09f11ea6008eb6d91120e01957b76610287ddf9f367ccce94730cfd72ff39b6dc3280ce071c64d65a2829be8d3b5be60e22ed87b7a739a6b465ae4f4d4010f7f2c4004666ce8a0197575ea0caf890f2bdc19b2346d3f5170b0ff0a4204b2b2c21987c8d97ecb7aa9b8865f28385de89f0be0733d77df690a98765944523fd4abfc149e69acdba0c2c1be989e386b8d00f4054a9ab0cbf1be0f7e4025e2e9d3dde8e0dc72ac056bce20301ef697677ecccbc2c168383a54b9c1175a3a66459f07fa89abbe852d42944974c615af0b49b1b44a0b58258930120036a1abb61a4538f4b6d5a820c418fe0d0699bdda445f4464551e6e1c91beea2fbe9b50287e2f230751832a183041f5557e01a353ece6d8ef1e61e0a21cdf6f20a035e37f7d83bbb4d1e1c57842884865081c052b314203c9023c96f139b7895c491606ac34cb997e17bd039cde0e4dee89e5fccf8f2b922b2d1bd522cc1ed3d6db0dc95e0ee6f798810682136f8c510e04e73325cd31038e9a9d7623054052f66d248eff8e388345712a076b711902f516592566f24bfa19b5a32afca7acffb054f38f60cfe12fb4521094300f5d0699611b8b6b6e03b34f79e971ab2d382136a5dc9a68ea60391a072f8dc7eea34c8b3f474c052ce11ccc56dfd1a069bf6836ab7ec12dd11757d0f8457f0be4d65dd0c230004590cae8c3233a56c3a54f2a09631e3f937644464132a00bf5427493a40753f39fd9bd4ed8e56460d09ead1bd8d755cf91d484d00386b0149d71200cbc04a933698b5f625b10c05b13ab9246be5079451906d4ddf0443b9f5dac1938a387e0c8a61b09f92a4ec1afe61290e2803c8d99ef5d2e6e4494e6b05829fbfd852bd535c5c084ca3da65f67c5325af73c9b1e7a180b288cabd7fc22069a16cea9765bba4e111f43561cab3b7dbca2a2c2e43e1b28c7c6336f1a6889b4ca04ace448367fe748c8e08c1363ffd42a60229264cfa1c29fe7d2a47eda2102a9566983aacc607ec3ff903e36b5fa4aa6ef2319b7ad5e1fe1b9bf34d5ffabf69ae5e2f5b0c275f0ad067b8611b1c3dc9b59f6b30f038a46c1f81f94d65b1a1d06345dbfb5202fef722837662cce43f83b37669a0dccf95a4d58bb3b7d40a5e811eeb1ae533d9b93d038658cce19478aefc39fc1283a1cab58e7c922826c0d9b9a5b0adc0f4ffe9619b2a3899c896b71a1ee0440bafb42042524ee5fcbd31367fda49a25f63a742155381b9775cabe22c0ab6f5a55a5cff33b573793f0a18212f8482c69f6c9c1d2222d90d152317d7df29a394a34300f0082c00ed9a2b19f1ca3fdefea413ec5114abed1875de3c85f69c514f0a101021baf6d11b8a941ae5662504cfbef0c0feb2b3c59c93d76f43a8c82a9d8a3eed945c2620e05ba2334cd4c954959d91a6c450d296266ef34a9af69f22dcb081297c34446bd4667c0010e6309ba2d7a9a6d5a4e7fa62920ce5dc3b33bae3bb6b49f07f3d5587fa4121df12347a23c386d22f623f6f09bbd5cb331d6ec5965616251f89d492d18fe0ee809ffd1ffe37fe5b084ff303a9882a65b520b48db69f473ede7f03b90207aa1331bfc9de5b6218d3cbf82c5d54267128732acd0351530bb47c499c38ee0d714d83637920e5e09a1530bcab70a0b5457d81b1024a00ccf879de911acff34a4ab248ec1d71904f1b9464d62000edcfd0c5a65d761f239137298c0b297a0b871d46c4ff7169859255eeba86035a3d5559b7f8ed3265b9249b9d5c3f8f47d3d753d9aebb45d45ba3e0e331a6dfd65194d01c417e2f6e0fb2a448fb2f0c11ee6bde9c9d88f9596d196278ea47843f78f28ecf0f3ded97e67adafec425b2b191a9ff6024d10f3c46c3e82be9054cbfc25892c019526dbca45af28d958eab7034f4f388e8540e1c27fbc4f4b9d1911477fbb5a5af1bff6122a7d431cbb6d715b7e60fc40ddec4db132ddcd694f5a66327d90d042eb78a83343116a3fcbe21c3edd48fa1de7aa8cce404dfab80bfa352e4eefc1522d14a3f530c5ad27b029d82af32fd2149470592e7df872b846a78cefa1e0affe96244b0146bbced083bbcd796cf8bebece197ecff124a18ab69bef6ecc9ea09a1b32c2894a96159e23a3e38b057bd2e2736ebdb8434a2b4214ee45ef0920decd177546b4dac27cfe50a7455abb12d16eb6314007e283be0fad2cd6badd66369ad1cb0a06423e096482670dd7344f1dea6cfe0458c1855b21516ce39b434223c1ee8670ea5f24e6f6377fefcf93f5caf15ca75ade91da7b3426effa94594f58e4580ee8378ee2b228d4f47edec6964c0532943ec2a9fe487038f7a16e97038864c2272afea393888f68e2262116afe872b3f69720119ed0a31b78f30c1d3d580e52881f3265239f83b0dbd6d41c3d02d6e78ab8090b41d0ee8a7ae14025c96fe4e81597e449caf8644983d3324ffe946b05209a48c28b2a68ffdb91290ff6b0e3117ee20ff5a933c7169277f34e776d5552fffbb2ca9a48dc9a81aece6598988b0f70f974f1be5f2aecef59689f15a10e8974841a988c6e64937b55e717f53a290ddcf66ed72ff1f76b4f9fea2082e11305b575fec0c31e37c299ecaa1209443ae0475c630a90076d5e016ed4426ec11fb72231c16a29d19117d882e6477639c68ce333af99f44bbef8874ff65e237982152921694d49c87df56b93fe4ac76c293484cf34d355b9ad0125a2796b98cfbc9eac9faf00d520cf5c4f27ced0f0c66bcebfd8dd57ebee6b9025fe10d472862af1879d5fec6d167158d722f00f4a80f1e1b21cfa854642182bf07c7b9827ba72d6d6aaacda3f8e5c68af916c904aac33a39c29f6339b8851d1502d9a33a0ebd69a31aaec1e625f96b583bd1b26e0fa222174f27ddc8b5322119e45dff131cfacc28c1f3ab1d1fb076c53a2c57a1e2f524d1c307a83725e47f8a54ebb0a121e92035df89745ff9fa27b2130c3cf5b3129ece41dbc2b6a763729493b85e3c61865fb8c09e1bcdf53d141d3e18789a307d61135d902a619b5b2a975aceb2bd0fdb908ad065bfa51929f079d0a44f4cc02463e68fafb746ac3d50edf67a7e7494bdfbd782dcd40935c2bb4ef936fc81f1615fcda5fdabdbabb0b63271b2fb0c8b6923e8c72eccf9d9ca850d452261b3b9c1c17460b6b198f6b3692fdb95ce5a2d0576a410071095c556c5a4d38fc2391919da001fb9782065b258f4bb99380a4b72761931bc0df39a49150a0d01f7d7723d1830ad179f023b94ec205e43b638d1d7ac6719b244ecdaee3105c7ab3c8455fe8f0811f33e5da60184fb01bc2e2ffa72092fc9d0af9033a48b160c7ea118b2452ed5b3c8759e02aed16c72b44a05b018559b88697432cc6f5395c34798faff8c048ff4d0f337e5f3463c128cc60c3512880e95bb67f02ba5814bae0fb410ef3395b8c04ed2ff863d7b4d2f51e9d6c68cfed64c47eb1484532144e21bbadaaf1f29c8c92e756a4e58f5f1e46f1b1968e42e9b10b7c7d9b9e7a842e2fd4792cf0496953529418ff8bf4941112b0a1270fbec81bc16377b4ff9e10c05a67f471ecefdb59c4880a13866f509f277a331772e10888206151b82c2485dce5a4396de792c522248b9eac6e87bdb2ea5d2899e0524ae3774d30dcfa82852d8841fe05ddb2f09b52599fab23fa7b616763005b22a33bfe3966a685926e33980875661bcc8fa898cecea95e8330c02c21a0aac34f93a743beb08a395fd046bd4209dd85b2f250e332dedbcad15924e460984c9431abe4e76b648c81f4fd7fca484768a1fb7f28686175312b0732eecca418c01e0a36334e784626f2404a1c60b94918bd2e75f69116551eae5edd8369e6f3dfaa0b44923e409c897a2e2454b9fbb164592fde98ca83d3d0ca553018f216c3407141928ebee6aaa2485f4fdb7efee8a9ee4503938d8cb94ce7dacd2000068c5e5d2fe5e2dceb2980a4ea78a8767286bda1b12516036bd2ff99ace8a843f7a8ec5dab2f0e0e02ec02dec59ad125d4bb126798e70c6ea0a54df9110dce01dc55f57c98e5c48bc4e9edfecc830fb173d84797cf85efdca03d8cad47ca9bb993b02bd9d3e6ffa8300941068bb82ac6649471c7a730fa430596ba25ce7ea54183bf3e835c2189f6ca925a063b4759ba30c31f13cb34140f15df25f8db4eb0141297fc634e09b52dba3d9f64ec33b1f3facd8924388edc9cc69a380b0542745413933644d837578a36f51802903f1a66c79eb6049114ee8f588469a924f58d4e5829b1b5ce573da39b4aad878905249c664a1c6fbfc8ed9e3f346108ae3767c1fbff5c059663ef3d77fff7855daf59686163be7263c6efea70d09a411bb526b6fd12b3900a6cbee0bbf8cce73313cf02931a7c60552c094232b110784e1abf74ba26de168f02ab188904d6837abd822bc88d9616d71df44d3ebd2bd2bf983d8ab99cb994aee707e26771869ca70bdb17d913cdca784b3d4cd5067a46656643ba722b7626cef09d4b64e01f0f83e467717ba64dff87a4d6d2c1c6da69846c8d539225648469d1f29d1069061be07afecbfdec1ecdc52ff7b14b37a9e070ea3b227396750f556084c8dbacd7cfe65a62af69b90a97c900cefe248cf67a809a9b425568943ab588ba2e1504598bba2c64473e19f37f00e88b2114bfea1cf02eb23c8e2881ae14d0718224a858c570c5093133f55e8903866214b2b675912b5c5f8c64be1c5e812a6c123c674233bea191d25246d7918dbced6c1bb4b760af642d0b8f8c3662d85e51de7ca5cc95ebc2c6966b6b576d9e878419e0a3f5ad309f4a68156cb310064db4fae232705177e12e5f6a051409adb35ea45fe81e426799a6c13f37661ab35ba25b6bfc277d0bd2fcd3697947007ac6946ec3b2a7db6c8d1c980d73d579b2605959ba9d20f33975ebebf647a2d9586f46af1beb60675454ec6280255b92755be0b91265b5942db188280ddb24db893a241daa5b7f686759e3e21665c42a974e36ff2c987de5d298ec0733d6cb9db45e9dd4f33431d3f87b43329db833666764aca26587bc73654089140da91303e55495dccda8b3b6b6b4cf227511bb4f3880046d3185866e5dce83f7ee29d492a6bb56c6ffc3f6f39179034cfd2f532ecb4358ef0afe586e1264f0a414489290edd11a595c4f94efa7fc4a3aec74169ee77c4bb28dc5e634310920288498c005acd58c658bed48b41ab25f85d767cb644e36d88a5b7ffb37f28363e1395c38c68234c7fbcce47f1adb5076ebb9d7acaede7f013e428a17cfdb2623779bbf0700726711f63d40942f349940ee8becaf9b7208399f5ea6b07ca3a41a8eeb5bc1f0a75df79110fcc999e79cef2460a3dbd3d4c83d9df582aa9078187ca319b8614a4c7cd484b45ebcd0006f1638e2f73c1f0a9178aa94cfce08c7731bd11d2dca138efe5bae38fa34af34110c80093c51d7f8b14eb30e4b7fcd96fd165f5f4f9e6411deb41f1c9ec2c6ac884a70ffe420a6dc0c3b42ef743bf7c83f21d65802614a40c8f73c351a7c7b22382a61e60b9d69d16123f5902b665a4fa881a59c609fdac08d912358e43e17136f377b1f7061e09d144b2c46575940dcc65b74285814863ad802e19f55edbb9e0575ace0a0acf13a049ce1c7a425c4486b3ec913dcbd8a39d59c9caa5fea7dc0413032f3ffd7da838082b8927bbf6fd4c5ee6c319d2f79286c64104b00402a3c83a8d96e4c1c2fa8719fb9fa199df4ff4cd14ca70427b4622b136cd107ca382f13dc9b3bbe39a4a4869905ab079ef0f23cfca435569aea870fe47bce35bfe65694d3239144ee5630df8b80e9607efbba2ee1a3de27ad3d9cb7a93b48b65e85e091e7112c2e761f040f1cea29b39ba7f0b9ced50ff6340ae87b2576c23be109ebffa20352b96beb2b193e02da8c33bdcbfa2eb81053f33cd2e2b759c6cc6ffd7e0a101c6d34a786fa4e4c356cb7388039892428f3c1966c6203e8d767e249c0e3407ced192e172265af5ccecb220b886400d282c23d8d8431532aecfbbeb03399586182f0a217df555a7aac8691aa05138b0f10f6802edf17346262f8a6e0a2f05d900dceb808321b8605b5d093ea311332a4b86aa40fa74fcffcbc1d33a86dd61917907af4ecf4efca034a33af49c6df1deb83d6697fa025d06512eb6b7345365ce688cee0cc92ecbb794dd0c49ab13a43d495c1320642f1b7ca16da0064ddb7d017d8cdcd4f464dec77e03d341c20f468c0269f092546d7b467c4042eae676bdc3da264d363aa7159e7545a20d26abb2b65b25627705dc8bedb216361ea84106c3c52102ab867a4a7b13ac5c9613fbb30992f2ace5ee4eaaec18932908ca418d4a20c15794ea682915202f50b28e47066c5ecfcd2f76a358d370d80b9f7435a42ae01765e2862e43d7f7fc805bbe2c81ec09c918b3b18637beead5883e301cd3618c92577335120f75d45a4393672f3f7b75dbc6e6a61722736fe757a9eb7c1a016e95a98555256237328f7ef905999c80f97337079761aafdfac4d6a5aff002bdc3f1797879ed2b2e9c24ddc3ed44ae05d813b9717adbf7ecd6ab3177da2f69e527ef30ebcf5d433a11649ff4e66e1f17245ff755c06db96be36eb534789eb1b64dc06c21f55c1471ba0b97793c4ee93bd1232ee5ef5c2fd71f81dd996438a97ac7659ca6c9afbd83ca994da09da9973b3beec55532e89f1abe2f4c73b502245e386e762466b8ccba4c7b2e03d33c37c1351c078059939b0e246dcc6a2e296984043b8542a8ba75119745fd78fd948e9c11de8588640ca832da750159f63a123221184ebc9de417d901c3663c3108963331c641cc3f637a80f74d7e948b96a0f651244e35089e0e72d3e881e1e0dc08206cd6db5cd6faa829c1b4c46f724123f79c32f5d50e9247fda70ef202116244fc6d7b613804e0c3a48ffd6b592ecff8bb7632b2b658e2b1453e79db07ba45e1e16683d90fc0742a81a4812fd7489ad91b4aabda63692783cef410717c8b72f3665316bebe01764265f06649eaa1b1ac43ab2ba0074ec73ea9fd029e97fbea77c3fb0ac31355cea978aa973902ca087e1ce031022828948ff037c3c0aa5e432c9428d964afa1fcd02c306f94b2006228a4f82bf1fbd72f6e7fa4ce95bffeff380365085ef809b5f4c93b32595bf56729273ac87bf8ea36d142d6917f93fdc8431944a7ccf41a6c28c564efd5c68f189718d7203b5d782ac8ee93754d51235315a2f0ec2c909fd624c6a4a46df2c814f63615cbe35f6da24b20da40105bc9ad4b25332ef52b4f0178b896bee2ee835274ceecd846c4e248245da1b4bc0198e2c1caaa71d4bc7827db4c4ce5b20a77d93464d97c5d076461640baca9c0b4b971e57d07dec7f16ebba38693ad15126b421134acf8f93220457280f5651fa95c243880923da411059029ab1cd3446a1a5ba59cd27f98078ceccd0692e1dd0880203df68e0d597c0782736fe43ac653b40217276a5bd795009b1a8bc00d6b5854b6281ce33ebbf6003b31c5c48c544c3e539e1dc9da51735cc0962542905dc7c640b476590e02c16533c3751eee553e19a7073ebbce116fac4ad9f45dc52854543c7095a616d66ce81d031b6192d0c283f798be60139413bc6fe2e084e4c115e49c2a6bb6272b9c4c0b214b19429f5aeb16178f5607a5d88a3300c4fc99576f6cd97af11fbb2a2fe64390b90f7bf44dafd4e6e28fd737bfa0f9edea79545665701cf7e4a5a747383d17ba1df912b3e477e8c63f9f0336eb84cbba77b51c4157c2381b0c9d4320bfb01af8d9c67d0fd3584787dd1bac1a7ebf91423cbf3c8a69842b2ad51b340031ccb5ae28cc369aa4aa951eb4aa278b961c686a87168e4d324e5b76cb78fed504d0e7b7364e512ce455995ca6f534cc6428340950b05b0f31d31e798cd3edebbe48d63ec8cb78622eaefcb04fd9700c464959d933127a6a44b341573692dec95f5f9a7991bb61f2f20dc425063d53f72c891548ae2156ffd5e78a0097c729590bd24a88dd0869985c2f2e9930bb08a496198bfadd6e6849bf9410459eccd99a353a21bc70f23c3181308a4fb7e040d97459e21210cbaa1af289db10ecf599027a84fef23d5f54065237fa8d3a42aea65ea2dbc4b49b980f8f4d60cb1f13b831e04cc94caedfb46a894acae8e9b07026120301d3d59cdb69a0fe96edbdf80d47c8e6359b4cba275f4f7ba1b5340d33d294cac4005ff2ca6986313b40ac357b1d12137da48202a89821899c9c128cef8dcfec6a8a0c4d521c5bdd16ed24567f88a7efbe6233768624ff9bddbc9ab286ae4294678d2f4cf75a485034245fd81205e40660695769017548452e710e04fee322f338cb344053f01bd11f56ba1ebfb21fbba16c3534817c68986a79a0deb9e82efbbebb192d1f8ea33ee8a1a3c9cae9e3b3ff6c871401502b5d19c2526307ceccd8ce49565e2bbe6a37ec571c50cfc48d0ad19d376662d56e49b630805c6a28a8c827c5f0163ed7ae3ab741b2276f6a860539b6a91788cbfd40336aaafe2b6838deab825dd18f642d6319356399616e08de15e3ef147cb1aec04e336c3867a16366651b92af166e000709dc0a95c76f8e3a6355d59f982034a48cce028c6da5ce5155018413664deff3c40ef99151c29c77a1e44da68280b3956b4ded98d331ccde819395fafd670270f706b186105d558061a3943d2118e68bc712588733c9a3cf40510f50e440c6384edfe9443bd0a1b75228edcaee4eae1a28d830f681b18cd52af2133928ea1c7c6ca4ceb90dbebd9b8b7ce3bce47990b5b27596385bae188b001dbe9f6834390547cf45d76cbb157770a0e35fbebf40519201b29f12aff7f10e73698bbfe90529896ce0740e6213b74019dfa4673500b041112a02a669da36927f72d60d271b32451f669004663f9ba8a5517a30d96f10421b11bb3c292147a520a2dfcca3e8a490f02f7710e17ff6860d4dbc077275cf206d183288c140e2fd37d2ac14754e98eb1b35d321849ddbc6fa70862217c711ca0bfded972b6cb50a325b11d81327c86028456fd4d809d81358f841bc42105f7af38a16c7b72b8324979484a6bda71ebc41b535271c60178d2fcb0a9711a12942e1ca677382cfcd99301bdbe9b72921331a7dfc79f8bda2bc6402f7f2da08e2bdffbfecac3b26e28215e53fa11c30fa2c395afb6ad312775ab0c8068e6c00ec53f900d2821f8f05149aa05b4f594d45ee3945c4128cbc841fd27a53e1ee4467fa3846579dbe8efc44e65a39682a321afbd806bc15570ffe13c3ae342f48010c08f37b19da95c7cf00e9c30db908b2c072f34e602cc27214962c33e2181a872137c11dd2d1142a0ade5d2a3d035e05008dc94a09e5d06405640545c947996f1861278ce87bed4305cb0fb0c94d579ccc11283c1543a9cb7c072e7d9ee4158db1c6db7ee74d1eec742bda1929bc1c42abb067cddb418226d07b1ed7fdfee4aac1cd143aed73bb7e31d02a1eeec9c310bb39492ad20edc4d01bd680a98b987b8d66a6e4bd664c8870ffedd6b523767deb948090118f3da6aa0948fbc8f9c7334d37a21864f76b4fec551ddd147e48d3268773045e7d421a0e506223220a24a2dfc9f9ddeecb7d65a29420a43369f4f542a3f00c6bcee51aa8d64612fafd1c76df39b4376e927d9b6f498ad917881a024a75439235fc1f7ebca26cf97fef6ddca691bfce10e101d43d2a19c61c0309dbaa6c8fdde9a41db7ddc26142669a808cca242a8a732c8c0adfa7a466d19ea63f89a9fabdd8d842c9456736b834f5a68e3c6bf8561e80d168ab92c66aa8de07547d49212fe8bbfced2b2715746c417503b27122d0dcacaf6a7be5c236a43132d19487a9f4e4eb1f9ee86e612d3eeec7cc3a9832edaafdc0aaaa724a137b4ed839abacd402d391d6d6a7ebf57ea464b7932f350b5b67636b3aea9d7ccab7f6fc5d5ee2916401203e5593a2f9a178ffddbb6626aac0b36d23db3b9cd4eff71e2ca9a6fa26e63214e49f1eb5c5525594562606bbdbd597acc4b58205e7ea1eb78a683865fcb4e598ef39db5a17ea678dba914031db9a093145998c5ec515259600c23ce763011980d68b967cf96e9730d65edcc5308dd02c8f9f14cbadd8a058a14a5b337f5c0eacbb080e754d01933e9aff83725904fcb795044b9da84baf3706da3c12425502e6e5bcfcef26ad198944c045ed3fa8200b481959540e3939594e0354b2e807e1758232a038de6900e62a1c3762c251ba8896acbbe8cadb28330df849af255ee3b843254790f4f94c694fa73ffa906c24c247c87509a9e58fce9d7d6453957377cd71dfeb9dfc12c28b18151cf63bbdd71f9a264baf127fef24f912f17758c4fdc8c09ca9062bd64eb53fd5bf82cfe131adaac1d29f083b678a57be30939ecde802b9232d975a17988c3cfeab2812587fc92141dfb0572439c383dabccc9343e91c9f0e146206baed7f8eac23273e141f7d7f9b44817c88d6b5ea2735c6594cca5eaaeebbab8ca5d967c62d18fb9c6b5b20624d23efd26e9d135dfe387d3a7802517447b6cce117866b1d362c255b20af0efc5beb872f43d12bb9ada4a4688f4827005eaa45a704775c1da793a130b7e420bced87a41531336631d8b69d6cefc5580ab48d7fb877c339750ad442fd8a955754e52b99ba9e01f6ea5132dfca6da0d52a69663138bb4b280d7f15824fed33e9961dd3fe926dac3b1077767f4f2ea48a8de5f50af065064f06647beaaae35f04a8806d71045d234c7efcb3fd6937af76c80aa26336a767e3313b8f3448ebe3640a6d8dc38bddab1434f064ed81f97c5d883a7889f7aad5ccac24e368c201663a818963c84e69d28fe0360d3528185f97e6d2198b38320023eab3b617bb4addc268a3ee21bd9229d709f6012692219fa390d33922fd187c624f366b82a2f3291685fe44b7ca45cb8d15fd637fee4c98a15d5f6f5a189e8a8d9ba5daa0a0403b6f928a4014e8de917331c6f18cf40f2b0a01f85bef615e9dc8d13a8ac0dea7c01d53fe13bb9d0e75cd187d7b4c5bf6a1cc3470e8fe171e3a972ce1c07058cfd60332f5e2da8adaa7e39e1ec2453520ac24954080147648d283bb8f9b4a4f8f07ab795bb3b4726d8315684eff6a9c8b10c13e9bc4e73e1bcd3bde77b6ac0af763449d426cc3db82be966c27d0e5292427e0949a050a0b9c77748a23a666397d4e65d8179aa6f9f9b817c5be9cfcd3a93a3e661d9bff81ae3e5a159288ddb767df4a5319d6d2b97ecb21ed0025c813b9cd882daab3eafa88925a80655f4590171084b132ccb6e5a91a7e5cad13d9a03ea3928c3fe6bf49cef10ea44995b62c34780590699adb8fe5abd0f55d353c90e68e20a86e8d999ccdadcfd068b860a73c92a3c1159dc97351fb30021ba18de578888a6bce9763d0174dac67414921863ec9e4b624794b1983a3a9889b7b112f907c26d33cda8d3a27f1d54f9700c39294f74241744134b639d4a1b37497cb7386a4b83ecd78ffc54074e0c20d0add2b8c004a54add1b14fc3c808ed2f4555651b81795847309f4547a001d100b608341a7a2ca871b00723f009549e85510c59f01dd9ffca7615bdf8a34f8e115bc3ad1b46bace462441a9547eb0d82c76efd146fccc8dd652a385be35123662f7673657aca5b63f92c18b323117d06c3d81b8661fb225432352a4eaa9b21c2f181166e7a952904fefe67a7b84b1b6d8e90c241fbe3d19b7750a6e41df838bcf11864c6cdad1489b1dec8cf49bfd3524cfe283fcef97e2d43353b7295a8c2fa1b453703455eb360af807336b6d7fb5ecef1e412dcf961d956dcfc78f1dcd2b71571e865075baabc23d2b01c44ce75ced2630ab7f0a979bbb10779004b61ee5a80c701a6cbfe72f9f8b9504f7a85c266bafde6620cc420e89b2923d0ac5f67622622c1af5010f7265ecaddcd6ad386e39669214880c0111f0196b4e02494a43274b85170540f5ae4d1b5a7f796bc9271e1c392e6b76f0db8309050c04919f9cf0a3633cb69416bdb9668e415d30406ba4a0f18be875ab20ff7ee656fce0ae15a5ad0d433a6ec3a71825a8f628f4362fc4a6c79ca771f1dead59a377fb7219c6c29446a7fb1cb90d5bd4b9599f71a5427d3c12bd4a81ee105a59e10dbe232c444a1498f51b2d62fe606465a6d9e0f0fd3706591fe1bdf774601000ea0c6d0b6f69b1693861e2409cd5c1531a7ebdf4841d01606a8bd6b23e989f8d4fb2f34a577b6d5a3d2a41578c5946d52f907b2892b5ab7e1a7f456848ae3e1560b53c6c725775bcad538535a99d70e3745982693a1a31c02df6952684f41958596777301c1a4127121c627608fb5b8167e371840b5d55fd8cde748884443d530ed3e9a6a26aa3e40b382e4b612f0ee44e18e2657885ae5c5fe3bcb62d0127ef6b72c2f68bbe1e35612312e566417acbf7f79708483cf30de739dab95733775c2064e4faf8699e711d4bd3d2ebc691f5ae348f3ab1c5364ab4e67f9b26894e49ee17454bee711c7a606f6889ca91b71fba530541512530340629641695cfa92cf9f6c11f21d60a6f8bb3f4aec9a52039eb0378d660d77a021629f3cb4683a22640f15b94899ebabbed5d9d6fc3c10ae61d3a30f25b24ef25aa575ee2ca600c5579b1d5be]]></content>
      <categories>
        <category>面试经历</category>
      </categories>
      <tags>
        <tag>面试总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象]]></title>
    <url>%2F2019%2F12%2F17%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象三大特征：封装性，继承性，多态性。继承是多态的前提，如果没有继承，就没有多态继承主要解决的问题是：共性抽取继承父类也可以叫基类，超类子类也可以叫派生类子类可以访问父类的属性和方法，反之父类不能访问子类的属性和方法直接通过子类对象访问成员变量：等号左边是谁，就优先用谁，没有则向上找。间接通过成员方法访问成员变量：该方法属于谁，就优先用谁，没有则向上找。成员变量方法局部变量：直接写成员变量名本类的成员变量：this.成员变量名父类的成员变量：super.成员变量名成员方法的访问在父子类的继承关系当中，创建子类对象，访问成员方法的规则：创建的对象是谁，就优先用谁，如果没有则向上找。注意事项：无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类。方法的重载和重写重写（Override）概念：在继承关系当中，方法的名称一样，参数列表也一样。对比重写（Override）：方法的名称一样，参数列表【也一样】。也称覆盖、覆写。重载（Overload）：方法的名称一样，参数列表【不一样】。方法的覆盖重写特点：创建的是子类对象，则优先用子类方法。方法覆盖重写的注意事项：1.必须保证父子类之间方法的名称相同，参数列表也相同。@Override：写在方法前面，用来检测是不是有效的正确覆盖重写。这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。2.子类方法的返回值必须【小于等于】父类方法的返回值范围。提示：java.Lang.Object类是所有类的公共最高父类（祖宗类），java.Lang.String就是object的子类。3.子类方法的权限必须【大于等于】父类方法的权限修饰符。提示：public &gt; protected &gt;（default）&gt; private备注：（default）不是关键字default，而是什么都不写，留空例子图继承关系中，父子类构造方法的访问特点1.子类构造方法当中有一个默认隐含的“super（）”调用，所以一定是先调用的父类构造，后执行的子类构造。2.子类构造可以通过super关键字来调用父类重载构造。3.super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。总结：子类必须调用父类构造方法，不写则系统会自动分配一个super（）；写了则用写的指定的super调用，super只能有一个，还必须是第一个。super关键字的用法1.在子类的成员方法中，访问父类的成员变量。2.在子类的成员方法中，访问父类的成员方法。3.在子类的构造方法中，访问父类的构造方法。This关键字的用法1.在本类的成员方法中，访问本类的成员变量。2.在本类的成员方法中，访问本类的另一个成员方法。3.在本类的构造方法中，访问本类的另一个构造方法。在第三种用法当中要注意：A.this（…）调用也必须是构造方法的第一个语句，唯一一个。B.super和this两种构造调用，不能同时使用。关键字图解Java继承的特点单继承：一个类的直接父类只能有唯一个多级继承抽象方法抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。使用抽象类和抽象方法：1.不能直接创建new抽象类对象。2.必须用一个子类来继承抽象父类。3.子类必须覆盖重写抽象父类当中所有的抽象方法。覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上厉法体大括号了4.创建子类对象进行使用。注意事项1.抽象类不能创建对象，如果创建，偏译无法通过而报错。只能创建其非抽象子类的对象。理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。2.抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。理解：子类的构造方法中，有默认的super（），需要访问父类构造方法。3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。4.抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。接口接口就是一种公共的规范标准基本定义格式接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。public interface 接口名称{ //接口内容 }备注：换成了关键字interface之后，编译生成的字节码文件仍然是：Java--&gt;.class。如果是Java 7，那么接口中可以包含的内容有：1.常量2.抽象方法如果是Java 8，还可以额外包含有：3.默认方法4.静态方法如果是Java 9，还可以额外包含有：5.私有方法接口使用步骤1.接口不能直接使用，必须有一个”实现类”来实现该接口。格式：public class 实现类名称 implements 接口名称{//…}2.接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。实现：去掉abstract关键字，加上方法体大括号.3.创建实现类的对象，进行使用。注意事项：如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。接口的默认方法从Java 8开始，接口里允许定义默认方法。格式：public default 返回值类型 方法名称（参数列表）{方法体....}备注：接口当中的默认方法，可以解决接口升级的问题。1.接口的默认方法，可以通过接口实现类对象，直接调用。2.接口的默认方法，也可以被接口实现类进行覆盖重写。接口的私有方法从Java 9开始，接口当中允许定义私有方法。1.普通私有方法，解决多个默认方法之间重复代码问题格式：private 返回值类型 方法名称（参数列表）{方法体....}2.静态私有方法，解决多个静态方法之间重复代码问题格式：private static 返回值类型 方法名称（参数列表）{方法体}接口的常量定义和使用接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。从效果上看，这其实就是接口的【常量】。格式：public static final 数据类型 常量名称 = 数据值；备注：一旦使用final关键字进行修饰，说明不可改变。注意事项：1.接口当中的常量，可以省略public static final，注意：不写也照样是这样。2.接口当中的常量，必须进行赋值；不能不赋值。3.接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则则注意事项使用接囗的时候，需要注意：1.接口是没有静态代码块或者构造方法的。2.一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。格式：public class MyInterfaceImpl implements MyInterfaceA，MyInterfaceBf{//覆盖重写所有抽象方法}3.如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。4.如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。5.如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。6.一个类如果父类当中的方法和接口当中的默认方法产生了冲突，优先用父类当中的方法。接口间的多继承1.类与类之间是单继承的。直接父类只有一个。2.类与接口之间是多实现的。一个类可以实现多个接口。3.接口与接口之间是多继承的。注意事项：1.多个父接口当中的抽象方法如果重复，没关系。2.多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】多态多态格式代码当中体现多态性，其实就是一句话：父类引用指向子类对象。格式：父类名称 对象名 = new 子类名称();接口名称 对象名 = new 实现类名称();多态中的成员变量1.直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。2.间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。多态中的成员方法在多态的代码当中，成员方法的访问规则是：看new的是谁，就优先用谁，没有则向上找。口诀：编译看左边，运行看右边。成员变量：编译看左边，运行还看左边。成员方法：编译看左边，运行看右边。对象的向上和向下转型说明：如何才能知道一个父类引用的对象，本来是什么子类格式：对象 instanceof 类名称这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基本知识]]></title>
    <url>%2F2019%2F12%2F11%2Fjava%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[方法12345// 定义方法的格式修饰符 返回值类型 方法名称(参数类型 参数名称，....)&#123; 方法体; return 返回值;&#125;修饰符：现阶段的固定方法，public static返回值类型：也就是方法最终产生的数据结果是什么类型方法名称：方法的名字，规则和变量一样，小驼峰参数类型：进入方法的数据对应的变量名称方法体：方法需要做的事情，若干行代码return：两个作用。停止当前方法将后面的结果数据返回值返还给调用处返回值：也就是方法执行后最终产生的数据结果return后面的“返回值”，必须和方法名称前面的“返回值类型”，保持对应注意事项方法应该定义在类中，但是不能在方法 在定义方法。不能嵌套方法定义的前后顺序无所谓方法定义之后不会执行，若要执行，必须调用：单独调用，打印调用，赋值调用如果方法有返回值，那么必须写上“return 返回值”，不能缺失return后面的返回值类型必须和方法的返回值类型相同，对应。对于一个void没有返回值的方法，没有返回值。一个方法中可以含有多个return语句，但是必须保证同时只有一个会被执行到。方法重载多个方法的名称一样，但是参数列表不一样优点：只需要记住唯一一个方法名称，就可以实现类似的多个功能相关因素参数个数不同参数类型不同参数的多类型顺序不同无关因素与参数的名称无关与方法的返回值类型无关数组数组的概念：是一种容器，可以同时存放多个数据值。数组的特点：1.数组是一种引用数据类型2.数组当中的多个数据，类型必须统一3.数组的长度在程序运行期间不可改变数组声明数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。两种常见的初始化方式：1.动态初始化（指定长度）2.静态初始化（指定内容）动态初始化数组的格式：声明格式：数据类型[]数组名称=new数据类型[数组长度]；静态初始化数组的格式：声明格式(标准)：数据类型[] 数组名称 = new 数据类型[] {元素1，元素2，...}省略格式：数据类型[] 数组名称 = {元素1，元素2，...}注意事项：1.静态初始化没有直接指定长度，但是仍然会自动推算得到长度。2.静态初始化标准格式可以拆分成为两个步骤。3.动态初始化也可以拆分成为两个步骤。4.静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值。规则如下：如果是整数类型，那么默认为0如果是浮点类型，那么默认为0.0如果是字符类型，那么默认为&#39;\u0000&#39;如果是布尔类型，那么默认为false如果是引用类型，那么默认为null静态初始化其实也有默认值的过程，只不过系统自动马上将默认值替换成为了大括号当中的具体数值。数组的长度一旦创建，程序运行期间，长度不可变Java中的内存划分1.栈（Stack）：存放的都是方法中的局部变量。方法的运行一定要在栈当中运行。局部变量：方法的参数，或者是方法内部的变量作用域：一旦超出作用域，立刻从栈内存当中消失。2.堆（Heap）：凡是new出来的东西，都在堆当中。堆内存里面的东西都有一个地址值：16进制堆内存里面的数据，都有默认值。规则：如果是整数默认为0如果是浮点数默认为0.0如果是字符默认为&#39;\u0000&#39;如果是布尔默认为false如果是引用类型默认为null3.方法区（Method Area）：存储.class相关信息，包含方法的信息。4.本地方法栈（Native Method Stack）：与操作系统相关。5.寄存器（PC Register）：与CPU相关。一个数组的内存图所有的引用类型变量，都可以赋值为一个null值。代表其中什么都没有。面向对象类是对一类事物的描述，是抽象的对象是对一类事物的实例，是具体的类是对象的模板，对象是类的实体类的定义类：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物属性：就是该事物的状态信息行为：就是该事物能做什么一个类的对象的内存图使用对象类型作为方法的参数成员变量和局部变量的区别1.定义的位置不一样【重点】局部变量：在方法的内部成员变量：在方法的外部，直接写在类当中2.作用范围不一样【重点】局部变量：只有方法当中才可以使用，出了方法就不能再用成员变量：整个类全都可以通用。3.默认值不一样【重点】局部变量：没有默认值，如果要想使用，必须手动进行赋值成员变量：如果没有赋值，会有默认值，规则和数组一样4.内存的位置不一样（了解）局部变量：位于栈内存成员变量：位于堆内存5.生命周期不一样（了解）局部变量：随着方法进栈而诞生，随着方法出栈而消失成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失面向对象三大特征：封装，继承，多态封装性在Java当中的体现：1.方法就是一种封装2.关键字private也是一种封装封装就是将一些细节信息隐藏起来，对于外界不可见。private关键字的作用一旦使用了private关键字修饰，在同一个类中可以访问。但是其他类别不能直接访问间接访问定义一对Getter/Setter方法必须叫setXxx或者是getxxx[如果是布尔值（那么用isXXX的命名会泽）]命名规则。对于Getter来说，不能有参数，返回值类型和成员变量对应；对于setter来说，不能有返回值，参数类型和成员变量对应。This关键字的作用当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，优先使用局部变量如果要访问类的成员变量需要用关键字：This格式This.成员变量名构造方法构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。格式：123public 类名称（参数类型参数名称）&#123; 方法体&#125;注意事项：1.构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样2.构造方法不要写返回值类型，连void都不写3.构造方法不能return一个具体的返回值4.如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，没有参数、方法体什么事情都不做。5.一旦编写了至少一个构造方法，那么编译器将不再赠送。6.构造方法也是可以进行重载的。重载：方法名称相同，参数列表不同。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// java标准类package object.oriented;/** * @author Luenci * @version 1.0 * @date 2019/12/6 10:50 */public class BaseStudent &#123; private String name; private int age; private char sex; // 无参数的构造方法 public BaseStudent() &#123; System.out.println("我是一个无参数的构造方法"); &#125; // 全参数的构造方法 public BaseStudent(String name, int age, char sex) &#123; this.name = name; this.age = age; this.sex = sex; System.out.println("我是一个全参数的构造方法"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public char getSex() &#123; return sex; &#125; public void setSex(char sex) &#123; this.sex = sex; &#125;&#125;API笔记引用类型的一般使用步骤：1.导包import 包路径.类名称；如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。只有java.lang包下的内容不需要导包，其他的包都需要import语句。2.创建类名称 对象名 = new 类名称（）；3.使用对象名.成员方法名()匿名对象只有右边的对象，没有左边的名字和赋值运算符。new 类名称().属性名12345678910111213141516171819202122232425262728293031323334package object.oriented;import java.util.Scanner;/** * @author Luenci * @version 1.0 * @date 2019/12/7 17:34 */public class AnonymousDemo &#123; public static void main(String[] args) &#123; // 匿名对象 new Student().eat(); // 匿名对象作为参数// methiordParam(new Scanner(System.in)); // 匿名对象作为返回值 Scanner sc = methodReturn(); int num = sc.nextInt(); System.out.println("您输入的是：" + num); &#125; public static void methiordParam(Scanner sc) &#123; int num = sc.nextInt(); System.out.println("输入的是：" + num); &#125; public static Scanner methodReturn() &#123; return new Scanner(System.in); &#125;&#125;对象数组任何数据类型都可以作为数组里面的存储元素。数组有一个缺点：一旦创建，程序运行期间长度不可以发生改变ArrayList集合概述和使用ArrayList集合的长度是可以随意变化的。对于ArrayList来说，有一个尖括号&lt;E&gt;代表泛型。泛型：也就是装在集合当中的所有元素，全都是统一的什么类型。注意：泛型只能是引用类型，不能是基本类型常用的ArrayList方法：public boolean add（E e）：向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。备注：对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用。但是对于其他集合（今后学习）来说，add添加动作不一定成功。public E get（int index）：从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。public E remove（int index）：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。public int size（）：获取集合的尺寸长度，返回值是集合中包含的元素个数。如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的“包装类”。基本类型包装类（引用类型，包装类都位于java.lang包下）shortShortintInteger【特殊】longLongcharCharacter【特殊】floatFloatdoubleDoublebooleanBoolean从 JDK 1.5+ 开始，支持自动装箱、自动拆箱。自动装箱：基本类型–&gt;包装类型自动拆箱：包装类型–&gt;基本类型字符串的概述和特点字符串的特点：1.字符串的内容永不可变（字符串是常量）。【重点】2.正是因为字符串不可改变，所以字符串是可以共享使用的。3.字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组。创建字符串的常见3+1种方式。三种构造方法：public String（）：创建一个空白字符串，不含有任何内容。public String（char[] array）：根据字符数组的内容，来创建对应的字符串。public String（byte[] array）：根据字节数组的内容，来创建对应的字符串。一种直接创建：string str=&quot;Hello&quot;； 右边直接用双引号字符串常量池字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中对于基本类型来说，==是进行数值的比较。对于引用类型来说，==是进行[地址值]的比较。内存划分：常用的API方法==是进行对象的地址值比较，如果需要字符串的内容比较，可以使用两个方法：public boolean equals（Object obj）：参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给true；否则返回false。注意事项：1.任何对象都能用Object进行接收。2.equals方法具有对称性，也就是a.equals（b）和b.equals（a）效果一样。3.如果比较双方一个常量一个变量，推荐把常量字符串写在前面。推荐：&quot;abc&quot;.equals（str不推荐：str.equals（&quot;abc&quot;）public boolean equalsIgnoreCase（String str）：忽略大小写，进行内容比较。static关键字的介绍如果一个成员变量使用了static关键字，那么这个变量不再属于对象自己，而是属于所在的类。多个对象共享同一份数据。static关键字修饰成员变量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package luenci.staticclass;/** * @author Luenci * @version 1.0 * @date 2019/12/12 16:18 * @info 学生类 */public class Student &#123; private int id; private String name; private int age; static String room = "Java一班"; private static int idCount = 0; public Student() &#123; this.id = ++idCount; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; this.id = ++idCount; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public static String getRoom() &#123; return room; &#125; public static void setRoom(String room) &#123; Student.room = room; &#125;&#125;12345678910111213141516171819package luenci.staticclass;/** * @author Luenci * @version 1.0 * @date 2019/12/12 16:22 * @info 实例化例子 */public class Demo1 &#123; public static void main(String[] args) &#123; Student stu1 = new Student("Luenci", 22); Student stu2 = new Student("Lynn", 22); System.out.println("学号：" + stu1.getId() + "姓名：" + stu1.getName() + "年龄：" + stu1.getAge() + "班级：" + Student.room); System.out.println("学号：" + stu2.getId() + "姓名：" + stu2.getName() + "年龄：" + stu2.getAge() + "班级：" + Student.room); &#125;&#125;static关键字修饰成员方法一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。静态变量：类名称.静态变量静态方法：类名称.静态方法（）12345678910111213141516171819202122232425package luenci.staticclass;/** * @author Luenci * @version 1.0 * @date 2019/12/12 16:49 * @info 自定义方法类 */public class myClass &#123; int num; static int age; public void method() &#123; System.out.println("普通的成员方法"); System.out.println(num); System.out.println(age); &#125; public static void methodStatic() &#123; System.out.println("静态方法"); // 错误访问 /*System.out.println(num);*/ System.out.println(age); &#125;&#125;1234567891011121314151617181920212223242526package luenci.staticclass;/** * @author Luenci * @version 1.0 * @date 2019/12/12 16:50 * @info static关键字修饰方法 */public class Demo2 &#123; public static void main(String[] args) &#123; myClass obj = new myClass(); // 普通成员方法 对象名.成员方法（） obj.method(); // 静态方法 推荐用：类名称.静态方法（）调用 myClass.methodStatic(); // 在本类中调用自己的静态方法，可以省略类名称 myMethod(); &#125; public static void myMethod()&#123; System.out.println("自己的方法"); &#125;&#125;注意事项：1.静态不能直接访问非静态。原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容。“先人不知道后人，但是后人知道先人。”2.静态方法当中不能用this关键字。原因：this代表当前对象，通过谁调用的方法，谁就是当前对象。static内存图静态代码块特点：当第一次用到本类时，静态代码块执行唯一的一次。静态内容总是优先于非静态，所以静态代码块比构造方法先执行。静态代码块的典型用途：用来一次性地对静态成员变量进行赋值。Arrays类常用方法java.util.Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。public static String tostring（数组）：将参数数组变成字符串（按照默认格式：[元素1，元素2，元素3…]）public static void sort（数组）：按照默认升序（从小到大）对数组的元素进行排序。1234567891011121314151617181920212223242526272829package luenci.array;import java.util.Arrays;/** * @author Luenci * @version 1.0 * @date 2019/12/12 17:25 * @info Arrays类的常见的使用方法 */public class ArraysDemo &#123; public static void main(String[] args) &#123; int[] array = &#123;1,2,3,4&#125;; String str = Arrays.toString(array); System.out.println(str); int[] array1 = &#123;1,4,5,9,2,5,7,0&#125;; Arrays.sort(array1); System.out.println(Arrays.toString(array1)); String[] array2 = &#123;"aaa","ccc","bbb"&#125;; Arrays.sort(array2); System.out.println(Arrays.toString(array2)); &#125;&#125;out [1, 2, 3, 4] [0, 1, 2, 4, 5, 5, 7, 9] [aaa, bbb, ccc]备注：1.如果是数值，sort默认按照升序从小到大排序2.如果是字符串，sort默认按照字母升序3.如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。Math相关的类方法java.util.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作。public static double abs（double num）：获取绝对值。有多种重载。public static double ceil（double num）：向上取整。public static double floor（double num）：向下取整。public static long round（double num）：四舍五入。final关键字final关键字代表最终、不可改变的。常见四种用法修饰类当final关键字用来修饰一个类的时候，格式：public final class 类名称（//…}含义：当前这个类不能有任何的子类。（太监类）注意事项：一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写。（没法继承，没有儿子）修饰方法当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。格式：修饰符final 返回值类型方法名称（参数列表）（//方法体}注意事项：对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。修饰局部变量一旦使用final用来修饰局部变量，那么这个变量就不能进行更改。“一次赋值，终生不变”对于基本类型来说，不可变说的是变量当中的【数据】不可改变对于引用类型来说，不可变说的是变量当中的【地址值】不可改变修饰成员变量由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。四种权限修饰符类别 \ 关键字publicprotected（default）默认private同一个类YESYESYESYES同一个类YESYESYESNO不同包子类YESYESNONO不同包非子类YESNONONO注意事项：（default）并不是关键字“default”，而是根本不写。内部类如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。例如：身体和心脏的关系。又如：汽车和发动机的关系。分类：成员内部类局部内部类（包含匿名内部类）成员内部类成员内部类的定义格式：1234567修饰符 class 外部类名称&#123; 修饰符 class 内部类名称&#123; // … &#125; // ...&#125;注意：内用外，随意访问外用内，需要内部类对象如何使用成员内部类：1.间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。2.直接方式，公式：类名称 对象名=new 类名称（）；【外部类名称.内部类名称对象名=new外部类名称（）.new内部类名称（）；】内部类同名变量的访问如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名局部内部类如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。“局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。定义格式：1234567修饰符 class 外部类名称&#123; 修饰符 返回值 类型外部类方法名称（参数列表）&#123; class 局部内部类名称&#123; //… &#125; &#125;&#125;局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】备注：从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。原因：1.new出来的对象在堆内存当中。2.局部变量是跟着方法走的，在栈内存当中。3.方法运行结束之后，立刻出栈，局部变量就会立刻消失。4.但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。匿名内部类如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】。匿名内部类的定义格式：123接口名称 对象名 = new 接口名称（）&#123; //覆盖重写所有抽象方法&#125;；对格式“new 接口名称（）{..}”进行解析：1.new表示创建对象的动作2.接口名称就是匿名内部类需要实现哪个接口3.{.…}这才是匿含内部类的内容注意几点问题：1.匿名内部类，在【创建对象】的时候，只能使用唯一一次。如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了。2.匿名对象，在【调用方法】的时候，只能调用唯一一次。如果希望同一个对象，调用多次方法，那么必须给对象起个名字。3.匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】强调：匿名内部类和匿名对象不是一回事注意事项小节一下类的权限修饰符：public &gt; protected &gt;（default）&gt; private定义一个类的时候，权限修饰符规则：1.外部类：public/（default）2.成员内部类：public/protected/（deffult）/private3.局部内部类：什么都不能加]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java语言概述]]></title>
    <url>%2F2019%2F12%2F04%2Fjava%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Java语言简史Java语言是美国Sun公司（Stanford University Network），在1995年推出的高级编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。Java语言发展历史1995年Sun公司发布Java1.0版本1997年发布Java1.1版本1998年发布Java1.2版本2000年发布Java1.3版本2002年发布Java1.4版本2004年发布Java5版本（更新频率较大）2006年发布Java6版本2009年Oracle甲骨文公司收购Sun公司，并于2011发布Java7版本2014年发布Java8版本（更新频率较大，市场占有率最大）2017年9月发布Java9版本2018年3月发布Java10版本Java 平台的三个版本作用：这使软件开发人员、服务提供商和设备生产商可以针对特定的市场进行开发：Java SE（Java Platform，Standard Edition）Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为 Java Platform，Enterprise Edition（Java EE）提供基础。Java EE（Java Platform，Enterprise Edition）这个版本以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 2.0 应用程序。Java ME（Java Platform，Micro Edition）这个版本以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。开发环境，推荐Eclipse,NetBeans,这两个IDE可以挂接对应的插件，进行开发。还有一点，那就是这三个应用，se,标准应用，以学习为主，由于界面，开发成本，速度等问题，很少用来做程序，但不是说，他不能做程序，Eclipse,NetBeans,都是javase写起来的。Me,移动设备应用，对于一些中高端应用还好了！以前用他做过手机游戏，呵呵呵！EE,企业级解决方案，开发套件全部免费，可控性好，安全性高，乃是当前B2B的规范。再者，这三个应用，都需要虚拟机的支持。字节位（bit）：一个数字0或者一个数字1，代表一位。字节（Byte）：每逢8位是一个字节，这是数据存储的最小单位。123456781 Byte = 8 bit1 KB = 1024 Byte1 MB = 1024 KB1 GB = 1024 MB1 TB = 1024 GB1 PB = 1024 TB1 EB = 1024 PB1 ZB = 1024 EBJava虚拟机——JVMJVM（Java Virtual Machine）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java最具吸引力的特性之一。我们编写的Java代码，都运行在JVM之上。跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上。Java的虚拟机本身不具备跨平台功能的，每个操作系统下都有不同版本的虚拟机。JRE和JDKJRE（Java Runtime Environment）：是Java程序的运行时环境，包含Jvm和运行时所需要的核心类。JDK（Java Development Kit）：是Java程序开发工具包，包含JRE]和开发人员使用的工具。我们想要运行一个已有的Java程序，那么只需安装JRE即可。我们想要开发一个全新java程序，那么必须安装JDK。Java程序运行步骤编写源程序， 后缀名为.java的文件编译源程序， 用javac命令将后缀名为.java的源程序编译成.class的字节码文件运行源程序， 用java命令 将.class文件在计算机上解释出来（JVM上运行）。Java标识符标识符：是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。命名规则：硬性要求标识符可以包含英文字母26个（区分大小写）、0-9数字、$（美元符号）和_（下划线）。标识符不能以数字开头。标识符不能是关键字。命名规范：软性建议(代码命名规范建议)类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。方法名规范：同变量名。123456789101112131415161718192021222324252627282930package Luenci.demo;/** * @author Luenci * @version 1.0 * @date 2019/11/30 18:18 */public class DemoCode1 &#123; public static void main(String[] args)&#123; // 字符串常量 和 字符常量（里面有且仅有一个字符） System.out.println("我是字符串常量"); System.out.println('h'); // 整数常量 System.out.println(200); System.out.println(-500); // 浮点数常量 System.out.println(0.22); System.out.println(0.8989); // 布尔常量 System.out.println(true); System.out.println(false); // 空常量:不能用来打印输出 // System.out.println(null); &#125;&#125;Java数据类型Java的数据类型分为两大类：基本数据类型：整数、浮点数、字符、布尔。引用数据类型：类、数组、接口。基本数据类型整数型 byte short int log浮点型 float double字符型 char布尔型 boolean数据类型关键字内存占用取值范围字节型byte1个字节-128 - 127短整型short2个字节-32768 - 32767整型int（默认）4个字节-2^31 - 2^31-1长整型long8个字节-2^63 - 2^63.1单精度浮点数float4个字节1.4013E - 45-3.4028E+38双精度浮点数double（默认）8个字节4.9E-324 ~ 1.7977E+308字符型char2个字节0-65535布尔类型honlean1个字节true false注意事项：字符串不是基本类型，而是引用类型。浮点型可能只是一个近似值，并非精确的值。数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节。浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F。如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L。推荐使用大写字母后缀。【作用域】：从定义变量的行开始，一直到直接所属的大括号结束为止。数据类型转换自动类型转换（隐式）特点：代码不需要进行特殊处理，自动完成规则：数据范围从小到大强制类型转换（显示）特点：代码需要进行特殊的格式处理，不能自动完成格式：范围小的类型 范围小的变量名 = （范围小的类型） 原本范围大的数据;强制类型转换 （注意）使用时注意精度损失和数据溢出等情况byte/short/char这三种类型都可以发生数学运算，例如加法“+”.byte/short/char这三种类型在运算的时候，都会被首先提升成为int类型，然后再计算。boolean类型不能发生数据类型变换ASCII码字符表0 对应的ascill码值为 32A 对应的ascill码值为 65a 对应的ascill码值为 97其余的向后推理即可运算符算数运算符包括解释+加法运算，字符串连接运算-减法运算*乘法运算\除法运算%取模运算，两个数字相除1取余数++, --自增自减运算1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package Luenci.demo;/** * @author Luenci * @version 1.0 * @date 2019/12/2 20:45 */public class OperatorDemo &#123; public static void main(String[] args)&#123; // 四则运算符 int a = 10,b = 25; System.out.println(a + b); System.out.println(a - b); System.out.println(a * b); System.out.println(a / b); // 用字符串进行连接的时候结果都会变成字符串 String str = "Luenci"; System.out.println(str + 404); // 单独使用的时候++在前和++在后没什么区别 // 和变量等在一起使用的时候是++在前的时候【先加后用】 // 和变量等在一起使用的时候是++在后的时候【先用后加】 int num=0; num++; System.out.println(num); System.out.println("-------------- 分割线 -----------------"); int num1 = 20; System.out.println(num1++); // 20 System.out.println(num1); // 21 int num2 = 30; System.out.println(++num2); // 31 &#125;&#125;out: 35 -15 250 0 Luenci404 1 -------------- 分割线 ----------------- 20 21 31常量不可使用 ++，–赋值运算符其中 隐含了一个强制类型转换比较运算符比较运算符类别解释==比较两边的数据是否相等，相等结果为True&lt;比较左边的数据是否小于右边的数据，小于结果为True&gt;比较左边的数据是否大于右边的数据，大于结果为True&lt;=比较左边的数据是否小于或等于右边的数据，小于或等于结果为True&gt;=比较左边的数据是否大于或等于右边的数据，大于或等于结果为True!=比较两边的数据是否相等，不相等结果为True逻辑运算符与（并且）&amp;&amp;全都是true，才是true；否则就是false或（或者）||至少一个是true，就是true；全都是false， 才是false非（取反）！本来是true，变成false；本来是false，变成true编译器的两点优化对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐含地为我们补上一个（byte）（short）（char）。1.如果没有超过左侧的范围，编译器补上强转。2.如果右侧超过了左侧范围，那么直接编译器报错。编译器的常量优化在给变量进行赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。如:short result=5+8；//等号右边全都是常量，没有任何变量参与运算编译之后，得到的.class字节码文件当中相当于【直接就是】：short result=13；程序流程控制判断语句1234567891011121314151617181920212223242526272829303132package Luenci.method;import java.util.Scanner;/** * @author Luenci * @version 1.0 * @date 2019/12/3 17:39 */public class ProcessControl &#123; public static void main(String[] args)&#123; // 从键盘处获得成绩值 Scanner sc = new Scanner(System.in); System.out.println("请输入您的成绩"); String score = sc.nextLine(); // 判断成绩优秀否 if ( Integer.parseInt(score) &gt;= 90)&#123; System.out.println("您的成绩优秀"); &#125; else if (Integer.parseInt(score) &gt; 80 &amp;&amp; Integer.parseInt(score) &lt; 90)&#123; System.out.println("你的成绩良好"); &#125; else if (Integer.parseInt(score) &gt; 60 &amp;&amp; Integer.parseInt(score) &lt;80)&#123; System.out.println("您的成绩合格"); &#125; else &#123; System.out.println("您的成绩不合格"); &#125; &#125; public static String getType(Object o)&#123; return o.getClass().toString(); &#125;&#125;选择结构switch语句使用的注意事项：​ 1.多个case后面的数值不可以重复。​ 2.switch后面小括号当中只能是下列数据类型：​ 基本数据类型：byte/short/char/int​ 引用数据类型：String字符串、enum枚举12345678910111213141516171819202122232425262728293031323334353637package Luenci.method;import java.util.Date;import java.text.SimpleDateFormat;/** * @author Luenci * @version 1.0 * @date 2019/12/4 11:30 */public class SwitchDemo &#123; public static void main(String[] args)&#123; // 设置日期格式 // SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); // new Date()为获取当前系统时间 Date date = new Date(); // 使用SimpleDateFormat格式化日期 SimpleDateFormat df = new SimpleDateFormat("EEEE"); String currSun = df.format(date); switch (currSun)&#123; case "星期一": System.out.println(currSun + "开始上班"); break; case "星期六": System.out.println(currSun + "休息第一天"); break; case "星期五": System.out.println(currSun + "放假前夕"); break; default: System.out.println(currSun + "上班中"); break; &#125; &#125;&#125;循环语句1234567891011121314151617package Luenci.method;/** * @author Luenci * @version 1.0 * @date 2019/12/4 15:00 */public class ForDemo &#123; public static void main(String[] args)&#123; int i,a; a = 0; for ( i = 1; i &lt;= 100; i++)&#123; a += i; &#125; System.out.println(a); &#125;&#125;whlie循环12345678910111213141516171819package Luenci.method;import com.sun.jmx.snmp.internal.SnmpSubSystem;/** * @author Luenci * @version 1.0 * @date 2019/12/4 15:10 */public class WhileDemo &#123; public static void main(String[] args)&#123; // 初始化语句 int a = 1; while (a &lt; 10)&#123; System.out.println("打印" + a + "遍"); a++; &#125; &#125;&#125;do …while 循环123456789101112131415161718package Luenci.method;/** * @author Luenci * @version 1.0 * @date 2019/12/4 15:13 */public class DowhlieDemo &#123; public static void main(String[] args)&#123; // do ..... while 循环的第一次是 无条件执行 int i = 1; do &#123; System.out.println("打印" + i + "遍"); i++; &#125; while (i &lt; 10); &#125;&#125;三种循环的区别1.如果条件判断从来没有满足过，那么for循环和while循环将会执行0次，但是do-while循环会执行至少一次。2.for循环的变量在小括号当中定义，只有循环内部才可以使用。while循环和do-while循环初始化语句本来就在外面，所以出来循环之后还可以继续使用。break关键字的用法有常见的两种1.可以用在switch语句当中，一旦执行，整个switch语句立刻结束。2.还可以用在循环语句当中，一旦执行，整个循环语句立刻结束。打断循环。关于循环的选择，有一个小建议：凡是次数确定的场景多用for循环；否则多用while循环。另一种循环控制语句是continue关键字。一旦执行，立刻跳过当前次循环剩余内容，马上开始下一次循环]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在前面]]></title>
    <url>%2F2019%2F12%2F04%2FREADME%2F</url>
    <content type="text"><![CDATA[写在前面About ME此博客记录了我的一些学习过程和一些项目的源码和学习笔记。有兴趣的朋友可在菜单的分类中找寻自己感兴趣的内容。有些内容可能过于浅显或者有误，欢迎大家指教和斧正。​ 学无止境，希望大家都能学有所成。​ 每一种编程语言都是一种艺术，希望大家选择编程语言不要纠结不前，还不如先出发。一直在路上。​ 2018/12/4]]></content>
      <categories>
        <category>个人随感</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基本知识]]></title>
    <url>%2F2019%2F11%2F23%2FJavaScript%E7%9A%84%E7%AE%80%E4%BB%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[JavaScript作用表单动态检验（密码强度检测）网页特效服务端开发（Node.js）桌面程序（Electron）APP（Cordova）控制硬件 - 物联网（Ruff）游戏小程序（cocos2d-js）HTML/CSS/JS的关系HTML/CSS标记语言–描述类语言HTML决定网页结构和内容（决定看到什么），相当于人的身体CSS决定网页呈现给用户的模样（决定好不好看），相当于给人穿衣服、化妆JS脚本语言-编程类语言实现业务逻辑和页面控制（决定功能），相当于人的各种动作浏览器执行js浏览器分成两部分：渲染引擎和JS引擎渲染引擎：用来解析HTML与CSS，俗称内核，比如chrome浏览器的blink，老版本的webkitJS引擎：也称为JS解释器。用来读取网页中的JavaScript代码，对其处理后运行，比如chrome浏览器的V8浏览器本身并不会执行JS代码，而是通过内置JavaScript引擎（解释器）来执行JS代码。JS引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以JavaScript语言归为脚本语言，会逐行解释执行。JS组成1.ECMAScriptECMAScript是由ECMA国际（原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMAScript语言的实现和扩展。ECMAScript:ECMAScript规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。2.DOM——文档对象模型文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过DOM提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）。3.BOM——浏览器对象模型BOM（Browser Object Model，简称BOM）是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。JS有3种书写1.行内式JS可以将单行或少量JS代码写在HTML标签的事件属性中（以on开头的属性），如：onclick注意单双引号的使用：在HTML中我们推荐使用双引号，JS中我们推荐使用单引号可读性差，在html中编写JS大量代码时，不方便阅读；引号易错，引号多层嵌套匹配时，非常容易弄混；特殊情况下使用2.内嵌JS123&lt;script&gt; alert（'Hello World~！'）；&lt;/script&gt;可以将多行JS代码写到&lt;script&gt;标签中内嵌JS是学习时常用的方式3.外部JS文件利于HTML页面代码结构化，把大段JS代码独立到HTML页面之外，既美观，也方便文件级别的复用引用外部JS文件的script标签中间不可以写代码适合于JS代码量比较大的情况12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 2. 内嵌式的js --&gt; &lt;script&gt; //alert('Hello') &lt;/script&gt; &lt;script src="my.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 1. 行内式的JS 直接写到元素内部 --&gt; &lt;!-- &lt;input type="button" value="Luenci" onclick="alert('hello world')"&gt; --&gt; &lt;/body&gt;&lt;/html&gt;JavaScript注释123//1.单行注释 ctrl + //*2.多行注释默认的快捷键 shift + alt + a */2.多行注释vscode中修改多行注释的快捷键：ctrl + shift + /JavaScript输入输出语句12345678&lt;script&gt; // 这是一个输入框 prompt('请输入您的年龄'); //alert 弹出警示框 alert('计算的结果是：'); // console 控制台输出 给程序员测试用 console.log('我是程序员')&lt;/script&gt;变量声明变量//声明变量var age；//声明一个名称为age的变量var是一个JS关键字，用来声明变量（variable变量的意思）。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序最管age是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间变量命名规范由字母（A-Za-z）、数字（0-9）、下划线（）、美元符号（$）组如：usrAge，num01，_name严格区分大小写。var app；和var App；是两个变量不能以数字开头。18age是错误的不能是关键字、保留字。例如：var、for、while变量名必须有意义。MMDBBD nl → age遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName数据类型JavaScript是一种弱类型或者说动态语言。JS把数据类型分为两类简单数据类型（Number，string，Boolean，Undefined，Null）复杂数据类型（object）### 数字型Infinity，代表无穷大，大于任何数值Infinity，代表无穷小，小于任何数值NaN，Not a number，代表一个非数值isNaN（）这个方法用来判断非数字并且返回一个值如果是数字返回的是false如果不是数字返Turn1234567891011121314151617181920212223242526&lt;script&gt; var num=1e；//num 数字型 var PI=3.14//PI数字型 //1.八进制0~7我们程序里面数字前面加0表示八进制 var numl=010； console.1og（num1）；// 010八进制转换为10进制就是8 var num2=012； console.1og（num2）； //2.十六进制e～9a~f#ffffff数字的前面加0x表示十六进制 var num3=0x9； console.1og（num3）； var num4=0xa； console.1og（num4）； // 数字型的最大值 console.log(Number.MAX_VALUE); // 数字型的最小值 console.log(Number.MIN_VALUE); &lt;/script&gt;out: 8 10 9 10 1.7976931348623157e+308 5e-324字符串型String1.字符串引号嵌套JS可以用单引号嵌套双引号，或者用双引号嵌套单引号（外双内单，外单内双)2.字符串转义符类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。转义符都是\头的，常用的转义符及其说明如下：转义符解释说明\n换行符，n是newline的意思\斜杠 \\&#39;单引号\&quot;双引号\ttab缩进\b空格，b是blank的意思布尔型布尔类型有两个值：true和false，其中true表示真（对），而false表示假（错）。布尔型和数字型相加的时候，true的值为1，false的值为0。Undefined 和Null一个声明后没有被赋值的变量会有一个默认值undefined（如果进行相连或者相加时，注意结果）数据类型的转换转换为字符串类型方式说明案例toString()转成字符串var num=1; alert(num.toString()）String()强制转换转成字符串var num=1；alert(String(num))；加号拼接字符串和字符串拼接的结果都是字符串var num=1；alert(num+”我是字符串”)；toString()和String()使用方式不一样。三种转换方式，我们更喜欢用第三种加号拼接字符串转换方式，这一种方式也称之为隐式转换。转换为数字型方式方式案例parselnt(string)函数将string类型转成整数数值型parselnt(‘78’)parseFloat（string）函数将string类型转成浮点数数值型parseFloat（”78.21”）Number（）强制转换函数将string类型转换为数值型Number(‘12’)js隐式转换（- * / ）利用算术运算隐式转换为数值型‘12’ - 0转换为布尔型方式说明案例Boolean()函数其他类型转成布尔值Boolean(‘var’);代表空、否定的值会被转换为false如”、0、NaN、null、undefined其余值都会被转换为true编译型语言和解释型语言编译器在代码执行之前进行编译，生成中间代码文件解释器在运行时进行及时解释，并立即执行（当编译器以解释方式运行的时候，也称之为解释器）]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[京东全网爬虫]]></title>
    <url>%2F2019%2F11%2F22%2F%E4%BA%AC%E4%B8%9C%E5%85%A8%E7%BD%91%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[完整代码见： https://github.com/Lucareful/JingDongSpider写在前面：折腾了很久的用python做爬虫项目到现在也该告一段落了，看视频学，遇到bug自己查找，代码思路不对重新写，环境不对自己配置….一路上跌跌撞撞，过程很艰苦，所幸结果为好。代码就像一面明镜，照见我自身的不足。继续加油需求抓取首页的分类信息大分类的url中分类的url小分类的url抓取商品信息商品名称价格评论信息店铺促销选项图片开发环境和技术技术选择：由于全网爬虫，抓取页面非常多，为了提高抓的速度，选择使用scrapy框架+scrapy_redis分布式组件由于京东全网的数据量达到了亿级，存储又是结构化数据，数据库，选择使用MongoDB；京东全网爬虫的实现步骤采取广度优先策略，我们把类别和商品信息的抓取分开来做优点，提高程序的稳定性总体设计实现步骤创建爬虫项目根据需求，定义数据数据模型实现分类起虫保存分类信息实现商品爬虫保存商品信息实现随机User-Agent和代理IP下载器中间件，解决IP反爬。创建爬虫项目scrapy startproject jingDong定义数据模型（要抓取的数据）类别数据模型类用于存储类别信息（Category）-字段：b.category_name：大类别名称。b_category_url：大类别URL。m_category_name：中分类名称。m_category_url：中分类URL。s_category_name：小分类名称s_category_url：小分类URL商品数据模型商品数据模型类：用于存储商品信息（Product）字段：oproduct_category：商品类别product_sku_id：商品IDproduct_name：商品名称product_img_url：商品图片URLproduct_book_info：图书信息，作者，出版社product_option：商品选项product_shop：商品店铺product_comments：商品评论数量product_ad：商品促销product_price：商品价格商品的分类爬虫创建爬虫进入项目目录：cd mall_spider创建爬虫：scrapy genslider category_spider jd.com指定起始URL修改起始URL: https://dc.3.cn/category/get实现保存分类的pipeline类open_spider 方法中，链接MongoDB数据库，获取要操作的集合process_item 方法中，向MongoDB中插入类别数据close_spider 方法中，关闭MongoDB的链接实现商品爬虫步骤分析，确定数据所在的URL代码实现（核心）商品爬虫实现分布式分析，确定数据所在的URL解析列表页，提取商品sku_id，实现翻页，确定翻页的URL获取商品的基本信息，通过手机抓包（APP），确定URLPC详情页面，确定商品的促销信息的URLPC详情页面，确定评论信息的URLPC详情页面，确定商品价格信息的URL代码实现1.重写start_requests方法，根据分类信息构建列表页的请求2.解析列表页，提取商品的skuid，构建商品基本的信息请求；实现列表翻页1.确定商品基本的信息请求1.URL:https://cdnware.m.jd.com/c1/skuDetail/apple/7.3.0/32962088964.json2.请求方法：GET3.参数/数据：32962088964商品的skuid2.解析列表页，提取商品的skuid3.构建商品基本的信息请求4.实现列表翻页解析促销信息，构建商品评价信息的请求1.解析促销信息1.produft_ad：商品促销2.构建商品评价信息的请求1.准备评价信息的请求解析商品评价信息，构建价格信息的请求解析商品评价信息1.product_comments：商品评论数量2.评价数量，好评数量，差拜数量，好评率2.构建价格信息的请求准备价格请求：1.URL:https://p.3.cn/prices/mgets?skulds=J_69334292.2.请求方法：GET3.参数：skulds=J_6933429，j后跟这个商品的sku_id解析价格信息1.product_price：商品价格2.把商品数据交给引擎商品爬虫实现分布式修改爬虫类修改继承关系指定redis_key把重写start_requests改为重写make_request from data I在settings文件中配置scrapy_redis直接拷贝scrapy_redis配置信息，到settings.py中.写一个程序用于把MongoDB中分类信息，放入到爬虫redis_key指定的列表中保存商品数据实现存储商品Pipeline类在open_spider方法，建立MongoDB数据库连接，获取要操作的集合在process_item方法，把数据插入到MongoDB中在close_spider方法，关闭数据库连接在settings.py中开启这个管道实现下载器中间件实现随机User-Agent的中间件在settings.py中开启上面的下载器中间件]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>scrapy框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的模块和类]]></title>
    <url>%2F2019%2F11%2F19%2FPython%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[import导入模块路径问题存在的问题：当我们把模块文件放到工程文件夹的外部的文件，发现无法正常引入模块原因：外部的文件夹的路径，没有放到环境变量中。查看环境变量1.导入sys模块2.sys.path查看环境变量返回值是列表把自己写的模块的路径加入到环境变量中1234# 将模块路径追加到末尾 sys.path.append(r"模块的路径")# 将模块路径追加到开头sys.path.insert(0,r"模块的路径")12345678910111213141516171819# import module# # module -- 模块名# # name 模块 modele 中的变量# print(module.name)import sys# 查看python解释器搜索的环境变量# 将模块路径追加到末尾# sys.path.append(r"C:\Users\Luenci\Desktop")# 将模块路径追加到开头有sys.path.insert(0, r"C:\Users\Luenci\Desktop")for i in sys.path: print(i) import appprint(app.name)import导入模块import会防止重复导入在同一个程序中多次import同一个模块，只会执行一次重新导入模块为什么需要重新导入模块?模块被导入后，import module不能重新导入模块，重新导入需用reload重新加载模块代码创建模块对象准备一个模块 reload_test 并定义一个函数 test 代码如下：12def demo(): print(&quot;---------- 111 -----------&quot;)1234567891011121314151617181920# 在 ipython 的交互模式下In [5]: import reload_testIn [6]: reload_test.demo()---------- 111 -----------In [7]: reload_test.demo()---------- 111 -----------# 重新加载之后，改变的内容就可以显示In [14]: from imp import reloadIn [15]: reload(reload_test)Out[15]: &lt;module 'reload_test' from 'D:\\pythonStudy\\import笔记\\reload_test.py'&gt;In [16]: reload_test.demo()---------- 222 -----------from XX import XX的私有化问题123456789# modele.py内容name = "Luenci"# 类中定义私有属性# self._name = XXX# 私有化处理# 如果模块中的变量不希望以 from .. import .. 导入_age = 121234567891011# import module## print(module.name)# 私有化有效from module import *# 私有化无效from module import _ageprint(_age)import 和from..…import的区别import XXX此种方式是直接引用from XXX import xxx此种方式是把XXX的内容复制一份到程序中，若修改不应用到原来的模块可变参数的拆包12345678910111213141516171819202122232425262728def func1(*args, **kwargs): print("---- func1 ----") print("args:", args) print("kwargs:", kwargs)def func2(*args, **kwargs): print("args:", args) print("kwargs:", kwargs) # 调用func1 # 此处没有进行拆包，导致参数传递不过去不符合要求 # func1(args, kwargs) # 此处进行了拆包，阐述传递正确 func1(*args, **kwargs)if __name__ == '__main__': func2(10, 20, 30, a=10, b=20)out: args: (10, 20, 30) kwargs: &#123;'a': 10, 'b': 20&#125; ---- func1 ---- args: (10, 20, 30) kwargs: &#123;'a': 10, 'b': 20&#125;新式类的属性和一些概念12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class People(object): """ 我是一个新式类 """ def __init__(self,name,sex,eat): self.name = name self.sex = sex self.eat = eat self.__date = [] def __test(self): print("我是个私有方法") def sleep(self): print("%s正在睡觉"%self.name)p1 = People('luenci','man','rice')print(People.__doc__)print(People.__bases__)print(People.__mro__)# 打印类的数据属性字典print(People.__dict__)# &#123;'__module__': '__main__', '__doc__': '\n 我是一个新式类\n ',# '__init__': &lt;function People.__init__ at 0x0000017408AC1D90&gt;,# '_People__test': &lt;function People.__test at 0x0000017408AC1A60&gt;,# 'sleep': &lt;function People.sleep at 0x0000017408AC1E18&gt;,# '__dict__': &lt;attribute '__dict__' of 'People' objects&gt;,# '__weakref__': &lt;attribute '__weakref__' of 'People' objects&gt;&#125;# 打印对象的数据属性字典print(p1.__dict__)# &#123;'name': 'luenci', 'sex': 'man', 'eat': 'rice', '_People__date': []&#125;print(p1.__dir__())'''['name', 'sex', 'eat', '_People__date', '__module__', '__doc__', '__init__', '_People__test', '__dict__', '__weakref__', '__repr__', '__hash__', '__str__', '__getattribute__', '__setattr__', '__delattr__', '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__', '__new__', '__reduce_ex__', '__reduce__', '__subclasshook__', '__init_subclass__', '__format__', '__sizeof__', '__dir__', '__class__']'''# 私有方法的访问p1._People__test()# 私有变量的访问print(p1._People__date)p1.sleep()类属性的增加和修改12345678910111213141516171819202122232425262728293031323334class Dog(object): """ 我是一个Dog类 """ master = "luenci" def __init__(self,name): self.name = name def action(self): print("汪汪汪.")dog = Dog('小白')# 增加类的属性Dog.sex = '公'# 实例可以访问到print(dog.sex)# 增加类方法def run(self,name): print("%s在奔跑"%self.name)Dog.run = run# 实例中可以访问dog.run('小白')# 增加私有属性Dog.__age = 2print(Dog.__dict__)print(Dog.__age)out公小白在奔跑&#123;'__module__': '__main__', '__doc__': '\n 我是一个Dog类\n ', 'master': 'luenci', '__init__': &lt;function Dog.__init__ at 0x000001E16328D048&gt;, 'action': &lt;function Dog.action at 0x000001E16328D0D0&gt;, '__dict__': &lt;attribute '__dict__' of 'Dog' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Dog' objects&gt;, 'sex': '公', 'run': &lt;function run at 0x000001E163271F28&gt;, '__age': 2&#125;2单继承的supersuper（）使用的时候，传递参数的时候，self不用传递super（）调用顺序，按照__mro__顺序来完成Grandson.mro是一个元组当在类中使用super在__mro__列表中找到当前类的下一个元素，调用该元素的方法。1234567891011121314151617181920212223242526272829303132333435363738class Parent(object): def __init__(self, name): self.name = name print('parent的init结束被调用')class Son1(Parent): def __init__(self, name, age): self.age = age super().__init__(name) print('Son1的init结束被调用')class Grandson(Son1): def __init__(self, name, age, gender): self.gender = "男" # 单继承不能提供全部参数 super().__init__(name, age) print('Grandson的init结束被调用')gs=Grandson('grandson', 12, "男")print(Grandson.__mro__)print('姓名:', gs.name)print('年龄:', gs.age)print('性别:', gs.gender)out: parent的init结束被调用 Son1的init结束被调用 Grandson的init结束被调用 (&lt;class '__main__.Grandson'&gt;, &lt;class '__main__.Son1'&gt;, &lt;class '__main__.Parent'&gt;, &lt;class 'object'&gt;) 姓名: grandson 年龄: 12 性别: 男多继承和MRO顺序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 定义父类class Parent(object): def __init__(self, name): self.name = name print('parent的init结束被调用')# 定义子类--》继承父类的 name属性class Son1(Parent): def __init__(self, name, age): # 定义age属性 self.age = age Parent.__init__(self, name) print('Son1的init结束被调用')# 定义子类--》继承父类的 name属性class Son2(Parent): def __init__(self, name, gender): # 定义 gender 属性 self.gender = gender Parent.__init__(self, name) print('Son2的init结束被调用')class Grandson(Son1, Son2): def __init__(self, name, age, gender): # 调用父类的初始化方法 Son1.__init__(self, name, age) Son2.__init__(self, name, gender) print('Grandson的init结束被调用')gs = Grandson('grandson', 12, "男")print(Grandson.__mro__)print('姓名:', gs.name)print('年龄:', gs.age)print('性别:', gs.gender)out: parent的init结束被调用 Son1的init结束被调用 parent的init结束被调用 Son2的init结束被调用 Grandson的init结束被调用 (&lt;class '__main__.Grandson'&gt;, &lt;class '__main__.Son1'&gt;, &lt;class '__main__.Son2'&gt;, &lt;class '__main__.Parent'&gt;, &lt;class 'object'&gt;) 姓名: grandson 年龄: 12 性别: 男使用super()调用父类MRO顺序通过上述代码，我们发现由于多继承情况，parent类被的属性被构造了两次，如果在更加复杂的结构下可能更加严重。为了解决这个问题，Python官方采用了一个算法将复杂结构上所有的类全部都映射到一个线性顺序上，而搜索的顺序就是所谓的「方法解析顺序」（Method Resolution Order，或MRO),根据这个顺序就能够保证所有的类都会被构造一次。MRO查看类名.mro()类名.__mro__1234567891011121314151617181920212223242526272829303132333435363738394041424344# 定义父类class Parent(object): def __init__(self, name, *args, **kwargs): self.name = name print('parent的init结束被调用')# 定义子类--》继承父类的 name属性class Son1(Parent): def __init__(self, name, age, *args, **kwargs): # 定义age属性 self.age = age super().__init__(name, *args, **kwargs) print('Son1的init结束被调用')# 定义子类--》继承父类的 name属性class Son2(Parent): def __init__(self, name, gender, *args, **kwargs): # 定义 gender 属性 self.gender = gender super().__init__(name, *args, **kwargs) print('Son2的init结束被调用')class Grandson(Son1, Son2): def __init__(self, name, age, gender): # 调用父类的初始化方法 super().__init__(name, age, gender) # Son1.__init__(self, name, age) # Son2.__init__(self, name, gender) print('Grandson的init结束被调用')gs = Grandson('grandson', 12, "男")print(Grandson.__mro__)out: parent的init结束被调用 Son2的init结束被调用 Son1的init结束被调用 Grandson的init结束被调用 (&lt;class '__main__.Grandson'&gt;, &lt;class '__main__.Son1'&gt;, &lt;class '__main__.Son2'&gt;, &lt;class '__main__.Parent'&gt;, &lt;class 'object'&gt;)注意当在类中使用super（）在 mro列表中找到当前类的下一个元素，调用该元素的方法多继承中，不建议使用类名直接调用父类的方法类的@classmethod、@staticmethod装饰方法@classmethod 用来修饰方法。使用在实例化前与类进行交互，但不和其实例进行交互的函数方法上。@staticmethod 用来修饰类的静态方法。使用在有些与类相关函数，但不使用该类或该类的实例。如更改环境变量、修改其他类的属性等。两者最明显的区别，classmethod 必须使用类的对象作为第一个参数，而staticmethod则可以不传递任何参数1、@classmethod 类方法类方法，我们不用通过实例化类就能访问的方法。而且@classmethod 装饰的方法不能使用实例属性，只能是类属性。它主要使用在和类进行交互，但不和其实例进行交互的函数方法上。下面，我们要写一个只在类中运行而不在实例中运行的方法。简单示例，读取私有化类属性数据，如下：12345678910111213141516171819class Circle(object): __pi = 3.14 def __init__(self, r): self.r = r @classmethod def pi(cls): return cls.__pi def area(self): """圆的面积 """ return self.r ** 2 * self.__piprint(Circle.pi()) # 没有实例化 能直接访问pi() 方法circle1 = Circle(2)print(circle1.pi()) # 也可以通过实例访问pi()方法Circle类下的pi()方法被 @classmethod 装饰后，我们能通过Circle.pi() 直接运行方法，不用实例化类。示例：重构构造__init__()方法应用, 格式化创建时间实例123456789101112131415161718class Date(object): day = 0 month = 0 year = 0 def __init__(self, year=0, month=0, day=0): self.day = day self.month = month self.year = year @classmethod def from_string(cls, date_as_string): year, month, day = date_as_string.split('-') date = cls(year, month, day) return datedate1 = Date.from_string('2017-10-17') # 直接使用固定格式的字符串就能创建Date的实例print(date1.year, date1.month, date1.day)from_string 返回的是Date类的实例，所以我们可以通过from_string 实例化类。注意：from_string(cls, date_as_string)中cls表示的是类，它和self类实例有一定的差别。类方法中都是使用cls，实例方法中使用self。2、@staticmethod静态方法@staticmethod 和@classmethod非常的相似，但是@staticmethod不强制要求传递参数（它做的事与类方法或实例方法一样）。@staticmethod使用在有些和类相关函数，但不使用该类或者该类的实例。如更改环境变量、修改其他类的属性等。一句话@staticmethod 修饰的方法是放在类外的函数，我们为了方便将他移动到了类里面，它对类的运行无影响。示例：123456789101112131415161718192021222324252627class Date(object): day = 0 month = 0 year = 0 def __init__(self, year=0, month=0, day=0): self.day = day self.month = month self.year = year @classmethod def from_string(cls, date_as_string): year, month, day = date_as_string.split('-') date = cls(year, month, day) return date @staticmethod def is_date_valid(date_as_string): """ 用来校验日期的格式是否正确 """ year, month, day = date_as_string.split('-') return int(year) &lt;= 3999 and int(month) &lt;= 12 and int(day) &lt;= 31date1 = Date.from_string('2012-05-10')print(date1.year, date1.month, date1.day)is_date = Date.is_date_valid('2012-09-18') # 格式正确 返回Trueis_date_valid(date_as_string) 只有一个参数，它的运行不会影响类的属性，注意：@staticmethod修饰方法 is_date_valid(date_as_string)中无实例化参数self或者cls；而@classmethod修饰的方法中有from_string(cls, date_as_string)类参数cls。@property装饰方法定义时，在实例方法的基础上添加@property 装饰器；并且仅有一个self参数调用时，无需括号方法：foo_obj.func()property属性：foo_obj.prop12345678910111213141516171819class Foo(object): # 初始化方法 def __init__(self, num): self.num = num # 获取值得方法 @property def prop(self): return self.numfoo = Foo(100)# print(foo.prop())# @property 像使用属性一样获取值print(foo.prop)out: 100property的其它功能1234567891011121314151617181920212223242526272829303132333435363738class Goods(object): def __init__(self): # 初始化原价 self.org_price = 1000 # 初始化折扣 self.discount = 0.7 # 获取价格的方法 @property def price(self): return self.org_price * self.discount # 设置价格的方法 @price.setter def price(self, val): if val &gt; 0: self.org_price = val # 删除价格的方法 @price.deleter def price(self): print("执行了 deleter 方法")# 创建对象goods = Goods()print(goods.price)goods.price = 500print(goods.price)del goods.priceout: 700.0 350.0 执行了 deleter 方法property的另一种使用方法1BAR = property（get_price, set_price, del_price, &quot;BAR是一个property对象&quot;）property（第一个参数，第二个参数，第三个参数，第四个参数）第一个参数，当我们foo.BAR自动调用第一个参数的方法第二个参教，当我们foo.BAR=100，自动调用第二个参数的方法第三个参数，当我们del foo.BAR，自动调用第三个参数的方法第四个参数，当我们Foo.BAR.doc，自动获取第四个参数的内容property实现延迟计算123456789101112131415161718192021222324252627282930313233343536373839# -- coding=utf-8 --"""@author:luenci@time:2020/6/2 12:12"""class Delay(object): def __init__(self, func): self.func = func def __get__(self, instance, owner): print("触发__get__方法") res = self.func(instance) setattr(instance, self.func.__name__, res) return resclass Room(object): def __init__(self, name, length, width): self.name = name self.length = length self.width = width @Delay def area(self): return self.length * self.widthr1 = Room(502, 10, 10)print(r1.area)print(r1.area)print(r1.area)out:触发__get__方法100100100类的魔法属性和方法魔术属性__doc__ 描述类的信息和类方法的信息获取类名 类名.__doc__获取对象 对象.方法名.__doc____model__ 获取所属的模块（对象名.__module__）直接运行该文件 获取main__class__ 获取对象所属的类 对象名.__class____dict__ 获取对象或类的信息通过__dict__获取对象信息，对象.__dict__ 返回字典通过__dict__获取类信息 类名.__dict__返回值是一个字典魔术方法__init__初始化方法 类名（）自动调用__del__删除对象的时候， 会调用__del__方法__call__() 使用对象名()会调用该方法__str__() 打印对象的会调用print(obj) __str__方法一定要return，而且必须return字符串内容用字典的书写格式操作对象的方法__getitem__ 对象[‘XX’]__setitem__ 对象[‘XX’] = xx__delitem__ del 对象[‘xx’]1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Goods(object): """这是一个商品的类""" # 类属性 sell = True def __init__(self): self.price = 100 self.category = "吃的" def set_price(self): """设置价格方法""" pass def __call__(self, *args, **kwargs): print("__call__ 方法被调用") def __str__(self): return "我是一个对象" def __getitem__(self, item): print("key:", item) def __setitem__(self, key, value): print("key:%s, value:%s" % (key, value)) def __delitem__(self, key): print("要删除key：", key) def __del__(self): print("__del__ 正在执行")goods = Goods()# 对象名（） 会去调用对象的 __call__() 方法goods()# print 打印对象的时候，默认输出 &lt;__main__.Goods object at 0x000002356857E080&gt;print(goods)# 通过dict获取对象信息，对象.__dict__ 返回字典print(goods.__dict__)# 通过dict 获取类信息 类名.__dict__返回值是一个字典print(Goods.__dict__)# dict1=&#123;&#125;# dictI['a']=10# goods['a']调用 __getitem__ 方法goods['a']# goods['a']=10用 __setitem__ key，valuegoods['a'] = 10# del goods['a'] 调用 __delitem__ keydel goods['a']out： &#123;'price': 100, 'category': '吃的'&#125; &#123;'__module__': '__main__', '__doc__': '这是一个商品的类', 'sell': True, '__init__': &lt;function Goods.__init__ at 0x00000238CE0F5598&gt;, 'set_price': &lt;function Goods.set_price at 0x00000238CE0F5620&gt;, '__call__': &lt;function Goods.__call__ at 0x00000238CE0F56A8&gt;, '__str__': &lt;function Goods.__str__ at 0x00000238CE0F5730&gt;, '__getitem__': &lt;function Goods.__getitem__ at 0x00000238CE0F57B8&gt;, '__setitem__': &lt;function Goods.__setitem__ at 0x00000238CE0F5840&gt;, '__delitem__': &lt;function Goods.__delitem__ at 0x00000238CE0F58C8&gt;, '__del__': &lt;function Goods.__del__ at 0x00000238CE0F5950&gt;, '__dict__': &lt;attribute '__dict__' of 'Goods' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Goods' objects&gt;&#125; key: a key:a, value:10 要删除key： a __del__ 正在执行]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>类和模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解释器的GIL锁]]></title>
    <url>%2F2019%2F11%2F17%2FGIL%E9%94%81%2F</url>
    <content type="text"><![CDATA[GlL锁定义Gll锁：Global Interpreter Lock，又称：全局解释器锁任何Python线程执行前，必须先获得GlL锁，然后，每执行100条字节码，解释器就自动释放GL锁，让别的线程有机会执行。这个GlL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。GlL不是Python特性GlL是Pythn解释器（Cpython）时引入的概念，在JPython、PyPy中没有GlL。GIL并不是Python的语言缺陷。是解释器层级的锁，跟Python语言特性无关言外之意，就是全局解释器就是为了锁定整个解释器内部的全局资源，每个线程想要运行首先获取GlL，而GlL本身又是一把互斥锁，造成所有线程只能一个一个one-by-one-并发-交替的执行。GlL存在的原因早期计算机都是单核设计CPython在执行多线程的时候并不是线程安全的，所以为了程序的稳定性，加一把全局解释锁，能够确保任何时候都只有一个Python线程执行GlL产生的背景在CPython解释内部运行多个线程的时候，每个线程都需要解释器内部申请相应的全局资源，由于C语言本身比较底层造成CPython在管理所有全局资源的时候并不能应对所有线程同时的资源请求，因此为了防止资源竞争而发生错误，对所有线程申请全局资源增加了限制-全局解释器锁。GlL锁什么时候释放？在当前线程执行超时后会自动释放在当前线程执行阻塞操作时会自动释放当前执行完成时Guido对GIL锁的看法：https://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235关于GIL面试题描述Python GL的概意，以及它对python多线程的影响？编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否可比单线程性能有提升，并解释原因。Python语言和GlL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机（解释器），难以移除GlL。GlIL：全局解释器锁。每个线程在执行的过程都需要先获取GlL，保证同一时刻只有一个线程可以执行代码。线程释放GL锁的情况：在IO操作等可能会引起阻塞的system call之前，可以暂时释放GIL，但在执行完毕后，必须重新获取GlLPython 3.x使用计时器（执行时间达到阔值后，当前线程释放GlL）或Python 2.x，tickets计数达到100Python使用多进程是可以利用多核的CPU资源的。多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁严重问题：既然CPython解释存在GL是否意味每个线程在全局变量就不用加Lock互斥锁了呢？这是一个严重错误的想法，为什么用户操作全局数据还需要加Lock，因为GlL的释放时机我们无法控制-操作非常可能并没有完成，而不像Lock那样我们用完才释放（操作完整）举例线程1取出全局变量g_number==0一直加到20000，但是还没有来得及将20000写入g_number中，就超时了自动释放GIL 而线程2取出g_number==19999加到39999由于超时自动释放GlL此时线程2获取到GIL继续着未完成的事业将20000写入g_number….这就是之前的多线程案例没有加互斥锁的情况晨终结果是140w东右的盾因GIL锁解决方案解决方案一（不推荐）：我们换一个解释器执行程序就行了（jython：用JAVA写的python解释器）解决方案二（推荐）使用多进程替换多线程multiprocessing是一个多进程模块，开多个进程，每个进程都带一个GlL，就相当于多线程来用了。解决方案三（推荐）使用python语言的特性：胶水.我们让子线程部分用c来写，就ok。（实质上也相当于那部分代码绕过了cython解释器）第一步，编写C语言文件：测试代码，C语言写的死循环，文件名为test2.c：123456void Loop()&#123; while(1) &#123; ; &#125;&#125;然后我们把将其编译成.so文件（share object）需要执行如下命令(Linux下)：1gcc test.c -shared -o libtets.so-shared：将其编译成so文件-o：表示output，用来输出的文件名库文件是以lib开头编译过后，在当前的文件夹下就会生成一个.so文件第二步，编写python文件04-04_GIL锁解决方案.py：12345678import ctypes import threading#加载动态库my_lib=ctypes，cdll.LoadLibrary（"./libtest2.so"）#创建子线程t=threading.Thread（target=my_lib.Loop）t.start（）#主线程while True：pass第三步，执行pvthon文件就可避开Cpython解释器的GIL锁总结GIL锁称为：“全局解释器锁“，是CPytrton解释器中的锁机制，也是历史遗留问题要提升多线程执行效率，解决方案：更换解释器改为进程替换多线程子线程使用C语言实现（绕过GL锁）必须要知道的是：CPU密集型不太适合多线程I/O密集型适合多线程（Gil锁会释放）]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>GIL锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的闭包和装饰器]]></title>
    <url>%2F2019%2F11%2F17%2F%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[闭包引入函数名是一个特殊的变量，保存了函教的地址和自定义一个变量可以获取函数地址自定义变量调用函数 “函数名（）”12345678910111213141516171819def work(): print("我是一个测试函数")ret = workprint(ret)print("地址：%X" % id(ret))print("地址：%X" % id(work))ret()work()out: &lt;function work at 0x00000161E3091E18&gt; 地址：161E3091E18 地址：161E3091E18 我是一个测试函数 我是一个测试函数当我们定义函数test1后，函数名test1保存的是函数在内存的首地址函数名就是一个特殊的变量，函数名（）调用函数，执行函数体test1()和ret()都会调用函数，并执行函数体和变量名一样的，函数名数名只是函数代码空间的引用，当函数名赋值给一个对象的时候就是引用传递。闭包概念在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包维基百科中关于闭包的概念：在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。闭包构成条件必须有一个内嵌函数（函数里定义的函数）–这对应函数之间的嵌套内嵌函数必须引用一个定义在闭合范围内（外部函数里）的变量–内部函数引用外部变量外部函数必须返回内嵌函数–必须返回那个内部函数123456789101112131415161718192021def function_out(num): print("1.function_out num = ", num) def function_in(num_in): print("2.---------- function_in -----------------num", num) print("3.---------- function_in -----------------num_in", num_in) return function_in# function_out(10)# 调用function_out获取内层函数的地址，保存到retret = function_out(100)# 调用内层函数ret(88)out: 1.function_out num = 100 2.---------- function_in -----------------num 100 3.---------- function_in -----------------num_in 88通俗理解：存在函数的嵌套关系内层函数引用了外层函数的临时变量外层函数返回内层函数的引用闭包中的变量123456789101112131415161718192021def function_out(num): def function_in(): # 如果在内层定义了和外层变量同名的变量，但是要使用外层变量 # nonlocal 不使用内层函数的，而是使用外层的变量 nonlocal num print("function_in num", num) # 内部自定义的变量 num = 88 return function_in# 调用外部函数ret = function_out(99)ret()out: function_in num 99装饰器入门装饰器作用：在不改变函数的代码前提下，给函数添加新的功能装饰器的使用：存在闭包需要装饰的函数写代码要道循开放封闭原则，虽然在这个原则是用的面向对象开发，但是也适用于函数式编程，简单来说它规定已经实现的功能代码不允许被修改，但可以被扩展，即：封闭：已实现的勤能代码块开放：对扩展开放12345678910111213141516171819202122def function_out(func): def function_in(): print("开始验证") func() return function_in@function_out# @function_out装饰了 login() 函数# 底层实现# login = function_out(login)def login(): print("开始登陆！")# 通过闭包调用外层函数# login = function_out(login)login()out: 开始验证 开始登陆！通用版装饰器1234567891011121314151617181920212223242526272829def function_out(func): def function_in(*args, **kwargs): print("开始验证") print("function_in user=", args) print("function_in password=", kwargs) return func(*args, **kwargs) return function_in@function_outdef login(*args, **kwargs): print("开始登陆 user=", args) print("开始登陆 password=", kwargs) return 10# 装饰完 login == function_inresult = login(20, a=18)print(result)out: 开始验证 function_in user= (20,) function_in password= &#123;'a': 18&#125; 开始登陆 user= (20,) 开始登陆 password= &#123;'a': 18&#125; 10在原装饰器增加外部变量1234567891011121314151617181920212223242526272829303132333435363738def test(path): print(path) def function_out(func): def function_in(): print("开始验证") func() return function_in # 返回装饰器的引用（装饰器工厂） return function_out@test("login.py")# @test（"login.py"）分解为2步# 1）test（"login.py"）--&gt;function out 引用(地址)# 2）@ 第一步的结果--&gt;@function outdef login(): print("开始登陆")@test("register.py")def register(): print("开始注册")login()register()out: login.py register.py 开始验证 开始登陆 开始验证 开始注册多重装饰器给一个函数进行多次装饰装饰原则：就近原则（靠近待装饰函数的先装饰，随后一层一层装饰）123456789101112131415161718192021222324252627282930313233343536373839404142# &lt;b&gt;helloWord&lt;/b&gt;# 定义一个让文字加粗的装饰器def makeBlod(func): def function_in(): return '&lt;b&gt;' + func() + '&lt;/b&gt;' return function_in# 定义一个让文字倾斜的装饰器def makeItalic(func): def function_in(): return '&lt;i&gt;' + func() + '&lt;/i&gt;' return function_in@makeBloddef demo(): return "helloWord"@makeItalicdef demo2(): return "Luenci"@makeBlod@makeItalicdef demo3(): return "LYnn"print(demo())print(demo2())print(demo3())out: &lt;b&gt;helloWord&lt;/b&gt; &lt;i&gt;Luenci&lt;/i&gt; &lt;b&gt;&lt;i&gt;LYnn&lt;/i&gt;&lt;/b&gt;类装饰器装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象在Python中一般callable对象都是函数，但也有例外。只要某个对象重写了__call__（）方法，那么这个对象就是callable的。类的书写：必须有两个方法1）__init__方法，必须接收装饰器传递的参数func2）__call__方法格式：@类名待装饰的函数对象名()调用对象的__call__（）方法123456789101112131415161718192021222324252627282930# 装饰器类class Demo(object): def __init__(self, func): print("__init__方法") print("-- func --", func) self.func = func def run(self): print("正在奔跑") def __call__(self, *args, **kwargs): print("-- 开始验证 --") # 调用原来login内容 self.func()@Demo# login = demo(login)def login(): print("正在登陆")login()out: __init__方法 -- func -- &lt;function login at 0x0000024E64D857B8&gt; -- 开始验证 -- 正在登陆]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的协程]]></title>
    <url>%2F2019%2F11%2F16%2F%E5%8D%8F%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[可迭代对象可遍历对象就是可迭代对象列表、元组、字典、字符串都是可迭代对象100和自定义myclass 默认都是不可以迷代的myclass对象所属的类MyClass如果包含了__iter__（）方法，此时myclass就是一个可送代对象可送代对象的本质：对象所属的类中包含了__iter__（）方法检测一个对象是否可以送代，用isinstance（）函数检测。迭代器我们发现选代器最核心的功能就是可以通过next0函数的调用来返回下一个数据值。如果每次返回的数据值不是在一个已有的数据集合中读取的，而是通过程序按照一定的规律计算生成的，那么也就意味着可以不用再依赖一个已有的数据集合，也就是说不用再将所有要迭代的数据都一次性缓存下来供后续依次读取，这样可以节省大量的存储（内存）空间。举个例子，比如，数学中有个著名的斐波拉契数列（Fibonacci），数列中第一个数为0，第二个数为1，其后的每一个数都可由前两个数相加得到：特点记录遍历的位置提供下一个元素的值（配合next（）函数）迭代器生成斐波那契数列12345678910111213141516171819202122232425262728293031323334353637class Fibanacci(object): def __init__(self, num): # 实例化生成列属性 self.num = num self.a = 1 self.b = 1 self.current_index = 0 def __iter__(self): # 返回自己 return self def __next__(self): if self.current_index &lt; self.num: # 生成斐波那契数列 # 定义变量保存a的值 data = self.a self.a, self.b = self.b, self.a + self.b self.current_index += 1 return data else: raise StopIterationif __name__ == '__main__': fib = Fibanacci(8) value = next(fib) for i in fib: print(i)out: 1 2 3 5 8 13 21生成器生成器是一类特殊的迭代器。利用选代器，我们可以在每次迭代获取数据（通过next()方法）时按照特定的规律进行生成。但是我们在实现一个迭代器时，关于当前迭代到的状态需要我们自己记录，进而才能根据当前状态生成下一个数据。为了达到记录当前状态，并配合next()函数进行迭代使用，我们可以采用更简便的语法，即生成器（generator)。创建生成器方法1要创建一个生成器，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成（）12345678910111213141516171819202122232425262728# 列表推导式data_list = [x*2 for x in range(5)]for i in data_list: print(i)# 生成器的创建data_list1 = (x*2 for x in range(5))# 通过next()获取下一个值value = next(data_list1)print("--------&gt;", value)for j in data_list1: print(j) out: 0 2 4 6 8 --------&gt; 0 2 4 6 8函数中使用yield关键字生成生成器1234567891011121314151617181920def test(): return 10def test2(): yield 10if __name__ == '__main__': m = test() print("m:", m) n = test2() print("n", n) value = next(n) print(value) out： m: 10 n &lt;generator object test2 at 0x000002A2C4C6D0F8&gt; 10生成器生成斐波那契数列123456789101112131415161718192021222324252627282930313233def fibnacci(n): # 初始化a, b的值 a = 1 b = 1 # 纪录迭代位置 current_index = 0 print("-----1------") while current_index &lt; n: # 保存a的值 data = a a, b = b, a+b current_index += 1 print("-----2------") yield data print("-----3------")if __name__ == '__main__': fib = fibnacci(6) print(next(fib)) print(next(fib)) print(next(fib)) out: -----1------ -----2------ 1 -----3------ -----2------ 1 -----3------ -----2------ 2yield作用充当return作用保存程序的运行状态并且暂停程序执行当next的时候，可以继续唤醒程序从yield位置继续向下执行生成器中使用return问题生成器客户以使用return关键字，语法上没有问题，但是如果执行到return语句以后，生成器会停止迭代，抛出停止迭代的异常send作用生成器.send(传递给生成器的值)传递1a = fib.send(1)接收1xxx = yield data协程协程，又称微线程，纤程。英文名Coroutine。从技术的角度来说，“协程就是你可以暂停执行的函数”。如果你把它理解成“就像生成器一样”，那么你就想对了。线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作则是程序员。协程存在的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程（单线程），在一个线程中规定某个代码块执行顺序。协程应用场景协程的适用场景：当程序中存在大量不需要CPU的操作时（IO），适用于协程；通俗的理解：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定协程和线程差异不开辟新的线程的基础上，实现多个任务在实现多任务时，线程切换从系统层面远不止保存和恢复CPU上下文这么简单。操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。1234567891011121314151617181920212223242526# ------------------ 携程的原始实现 --------------------import timedef work1(): while True: print("work1正在工作....") yield time.sleep(0.5)def work2(): while True: print("work2正在工作.............") yield time.sleep(0.5)if __name__ == '__main__': t1 =work1() t2 = work2() print(t1) while True: next(t1) next(t2)greenlet库greenlet 可以实现协程Greenlet是python的一个C扩展，来源于Stackless python，旨在提供可自行调度的“微线程’，即协程。generator实现的协程在yield value时只能将value返回给调用者（caller）。而在greenlet中，target.switch（value）可以切换到指定的协程（target），然后yield value。greenlet用switch来表示协程的切换，从一个协程切换到另一个协程需要显式指定。GNI GREENLE T为了更好使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变的更加简单1234567891011121314151617181920212223242526272829import timefrom greenlet import greenlet# work1生成器def work1(): while True: print("work1正在工作....") time.sleep(2) # 切换到第二个任务 g2.switch()# work1生成器def work2(): while True: print("work2正在工作.............") time.sleep(2) # 切换到第一个任务 g1.switch()if __name__ == '__main__': g1 = greenlet(work1) g2 = greenlet(work2) #执行work1 g1.switch()gevent 库自动调度协程，自动识别程序中的耗时操作greenlet已经实现了协程，但是这个还的人工切换python还有一个比greenlet更强大的并且能够自动切换任务的第三方库 gevent其原理是当一个greenlet遇到IO（指的是input/ output 输入输出，比如网络、文件操作等）操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待使用步骤导入模块Iimport gevent指派任务g1= gevent.spawn（函数名，参数1，参数2，…）join（）让主线程等待协程执行完毕后再退出g1.join()打猴子补丁补丁给程序打补丁（猴子补丁）关于猴子补丁为啥叫猴子补丁，据说是这样子的：这个叫法起源于Zope框架，大家在修正Zope的Bug的时候经常在程序后面追加更新部分，这些被称作是“杂牌军补丁（guerilla patch）”，后来guerilla就渐渐的写成了gorlia（塑猩），再后来就写了monkey（猴子）：所以猴子补丁的叫法是这么莫名其妙的得来的。猴子补丁主要有以下几个用处：1.在运行时替换方法、属性等2.在不修改第三方代码的情况下增加原来不支持的功能3.在运行时为内存中的对象增加patch而不是在盏盘的源代码中增加12345678910111213141516171819202122232425262728293031# 打补丁from gevent import monkey# 破解所有monkey.patch_all()import timeimport geventdef work1(): while True: print(&quot;work1正在工作....&quot;) time.sleep(0.5)def work2(): while True: print(&quot;work2正在工作.............&quot;) # gevent.sleep(0.5) time.sleep(0.5)if __name__ == &apos;__main__&apos;: # 指派任务 g1 = gevent.spawn(work1) g2 = gevent.spawn(work2) # 让主线程等待协程执行完毕再运行 g1.join() g2.join()小福利1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# 妹子图爬虫多协程版# coding=utf-8from gevent import monkeymonkey.patch_all()import geventimport requestsfrom bs4 import BeautifulSoupimport osimport reall_url = 'http://www.mzitu.com'# http请求头Hostreferer = &#123; 'User-Agent': 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)', 'Referer': 'http://www.mzitu.com'&#125;Picreferer = &#123; 'User-Agent': 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)', 'Referer': 'http://i.meizitu.net'&#125;# 此请求头破解盗链start_html = requests.get(all_url, headers=Hostreferer)# 保存地址path = "E:\\mzitu\\"# 找寻最大页数soup = BeautifulSoup(start_html.text, "html.parser")page = soup.find_all('a', class_='page-numbers')max_page = page[-2].textsame_url = 'http://www.mzitu.com/all/'def download_img(pic_url): html = requests.get(pic_url, headers=Picreferer) file_name = pic_url.split(r'/')[-1].replace('"', "") print(file_name) f = open(file_name, 'wb') f.write(html.content) f.close()for n in range(1, int(max_page) + 1): ul = same_url + str(n) start_html = requests.get(ul, headers=Hostreferer) soup = BeautifulSoup(start_html.text, "html.parser") all_a = soup.find('div', class_='all').find_all('a', target='_blank') for a in all_a: # 提取文本 title = a.get_text() if title != '': print("准备扒取：" + title) # win不能创建带？的目录 if os.path.exists(path + title.strip().replace('?', '')): # print('目录已存在') flag = 1 else: os.makedirs(path + title.strip().replace('?', '')) flag = 0 os.chdir(path + title.strip().replace('?', '')) href = a['href'] html = requests.get(href, headers=Hostreferer) mess = BeautifulSoup(html.text, "html.parser") pic_max = mess.find_all('span') try: # 最大页数 pic_max = pic_max[9].text if flag == 1 and len(os.listdir(path + title.strip().replace('?', ''))) &gt;= int(pic_max): print('已经保存完毕，跳过') continue except Exception: pass pic_url = [] for num in range(1, int(pic_max) + 1): pic = href + '/' + str(num) html = requests.get(pic, headers=Hostreferer) mess = BeautifulSoup(html.text, "html.parser") pic_url.append(mess.find('img', alt=title)) # print("图片路径：", pic_url['src']) pic_url = re.findall(r"[a-zA-z]+://[^\s]*", str(pic_url)) print(pic_url) # 将列表编程迭代器 a = pic_url.__iter__() # 开启多个协程 Coroutine = [] for i in range(len(pic_url)): Coroutine.append(gevent.spawn(download_img(next(a)))) gevent.joinall(Coroutine) print('完成') print('第', n, '页完成')]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>协程知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的进程，线程和协程对比]]></title>
    <url>%2F2019%2F11%2F16%2F%E8%BF%9B%E7%A8%8B%2C%E7%BA%BF%E7%A8%8B%2C%E5%8D%8F%E7%A8%8B%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[概念进程​ 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。线程​ 线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。协程​ 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。三者关系应用场景多进程：密集CPU任务，需要充分使用多核CPU资源（服务器，太量的并行计算）的时候，用多进程。缺陷：多个进程之间通信成本高，切换开销大。多线程：密集I/O任务（网络I/O，磁盘以I/O，数据库I/O）使用多线程合适。缺陷：同一个时间切片只能运行一个线程，不能做到高并行，但是可以做到高并发。协程：当程中存在太量不需要CPU的操作时（IO），适用于协程；多线程请求返回是无序的，那个线程有数据返回就处理那个线程，而协程返回的数据是有序的。缺陷：单线程执行，处理密集CPU和本地磁盘IO的时候，性能较低。处理网络I/O性能还是比较高。]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>进程,线程,协程总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python类中的 私有变量 和 私有方法]]></title>
    <url>%2F2019%2F11%2F15%2Fpython%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Python中的类原文转自：https://blog.csdn.net/sxingming/article/details/52875125默认情况下，Python中的成员函数和成员变量都是公开的(public),在python中没有类似public,private等关键词来修饰成员函数和成员变量。在python中定义私有变量只需要在变量名或函数名前加上 __两个下划线，那么这个函数或变量就是私有的了。在内部，python使用一种 name mangling 技术，将 __membername替换成_classname__membername，也就是说，类的内部定义中,所有以双下划线开始的名字都被”翻译”成前面加上单下划线和类名的形式。例如：为了保证不能在class之外访问私有变量，Python会在类的内部自动的把我们定义的__spam私有变量的名字替换成为_classname__spam(注意，classname前面是一个下划线，spam前是两个下划线)，因此，用户在外部访问__spam的时候就会提示找不到相应的变量。python中的私有变量和私有方法仍然是可以访问的访问方法如下：私有变量:实例._类名__变量名私有方法:实例._类名__方法名()其实，Python并没有真正的私有化支持，但可用下划线得到伪私有。尽量避免定义以下划线开头的变量！（1）_xxx “单下划线 “ 开始的成员变量叫做保护变量，意思是只有类实例和子类实例能访问到这些变量，需通过类提供的接口进行访问；不能用’from module import *’导入（2）__xxx 类中的私有变量/方法名 （Python的函数也是对象，所以成员方法称为成员变量也行得通。）,“ 双下划线 “ 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。（3）__xxx__系统定义名字，前后均有一个“双下划线” 代表python里特殊方法专用的标识，如 __init__（）代表类的构造函数。下面我们看几个例子：123456789101112131415161718192021222324252627282930313233class A(object): def __init__(self): #翻译成 self._A__data=[] self.__data=[] def add(self,item): #翻译成 self._A__data.append(item) self.__data.append(item) def printData(self): #翻译成 self._A__data print(self.__data) a=A()a.add('hello')a.add('python')a.printData()#外界不能访问私有变量 AttributeError: 'A' object has no attribute '__data'#print a.__data #通过这种方式，在外面也能够访问“私有”变量；这一点在调试中是比较有用的！print a._A__data out: ['hello', 'python'] ['hello', 'python']12345678910111213141516171819202122232425262728293031323334353637383940# 获取实例的所有属性 print a.__dict__# 获取实例的所有属性和方法 print dir(a) class A(): def __init__(self): #私有变量，翻译成 self._A__name='python' self.__name='python' #私有方法,翻译成 def _A__say(self) def __say(self): #翻译成 self._A__name print(self.__name) a=A()#访问私有属性,报错!AttributeError: A instance has no attribute '__name'#print a.__name#查询出实例a的属性的集合print(a.__dict__)#这样，就可以访问私有变量了print(a._A__name)#调用私有方法，报错。AttributeError: A instance has no attribute '__say'#a.__say()#获取实例的所有属性和方法print(dir(a))#这样，就可以调用私有方法了a._A__say() out: &#123;'_A__name': 'python'&#125; python ['_A__name', '_A__say', '__doc__', '__init__', '__module__'] python从上面看来,python还是非常的灵活，它的oop没有做到真正的不能访问，只是一种约定让大家去遵守，比如大家都用self来代表类里的当前对象，其实，我们也可以用其它的，只是大家习惯了用self 。小漏洞：派生类和基类取相同的名字就可以使用基类的私有变量12345678910111213141516171819202122232425262728class A(): def __init__(self): self.__name='python' #翻译成self._A__name='python' class B(A): def func(self): #翻译成print self._B__name print(self.__name ) instance=B()#报错：AttributeError: B instance has no attribute '_B__name'#instance.func()print(instance.__dict__)print(instance._A__name)out: &#123;'_A__name': 'python'&#125; python1234567891011121314151617181920212223class A(): def __init__(self): #翻译成self._A__name='python' self.__name='python' class A(A): #派生类和基类取相同的名字就可以使用基类的私有变量。 def func(self): #翻译成print self._A__name print(self.__name) instance=A()instance.func()out: python]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>面向对象编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的进程概念]]></title>
    <url>%2F2019%2F11%2F14%2F%E5%A4%9A%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程进程概念进程（Process）是资源分配的最小单位，是线程的容器。程序是固定不变的，而进程会根据运行需要，让操作系统动态分配各种资源的CPU的时间片轮转，在不同的时间段切换执行不同的进程，但是切换进程是比较耗时的；就引来了轻量级进程，也就是所谓的线程，一个进程中包括多个线程（代码流，其实也就是进程中同时跑的多个方法体）程序：例xxx.py这是程序，是一个静态的进程：一个程序运行起来后，代码+用到的资源称之为进程，它是操作系统分配资源的基本单元。进程状态工作中，任务数往往大于cpu的核数，即一定有一些任务正在执行，而另外一些任务在等待cpu进行执行，因此导致了有了不同的状态进程状态就绪态：运行的条件都已经满足，正在等在cpu执行执行态：cpu正在执行其功能等待态：等待某些条件满足，例如一个程序sleep了，此时就处于等待态进程的创建 - multiprocessingmultiprocessing模块就是跨平台版本的多进程模块，提供了一个Process类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情。·创建子进程跟创建线程十分类似，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start0方法后动Process语法结构如下：Process([group [，target[，name，[args[，kwargs]]]）target：如果传递了函数的引用，这个子进程就执行这里（函数）的代码args：给target指定的函数传递的参数，以元组的方式传递kwargs：给target指定的函数传递命名参数name：给进程设定一个名字，可以不设定group：指定进程组，大多数情况下用不到Process创建的实例对象的常用方法：start()：后动子进程实例（创建子进程）is_alive：判断进程子进程是否还在活着join([timeout]）：是否等待子进程执行结束，或等待多少秒oterminate：不管任务是否完成，立即终止子进程Process创建的实例对象的常用属性：name：当前进程的别名，默认为Process-N，N为从1开始递增的整数pid：当前进程的pid（进程号）linux系统可使用kill命令结束进程123456789101112131415161718192021222324252627282930313233343536373839404142import multiprocessingimport osimport timedef work1(): for i in range(10): # 获取进程的父id print("正在运行work1 第&#123;&#125;次..进程id&#123;&#125;，父进程id&#123;&#125;".format(i, os.getpid(), os.getppid())) time.sleep(2)if __name__ == '__main__': # 获取主进程名称 print("主进程名称", multiprocessing.current_process()) # 获取进程的编号 # 1.获取进程id multiprocessing.current_process().pid print("主进程编号", multiprocessing.current_process().pid) # 2. 模块os # print(os.getpid()) process_obj = multiprocessing.Process(target=work1, name="进程一") process_obj.start() print("XXXX") out: 主进程名称 &lt;_MainProcess(MainProcess, started)&gt; 主进程编号 31776 XXXX 正在运行work1 第0次..进程id43088，父进程id31776 正在运行work1 第1次..进程id43088，父进程id31776 正在运行work1 第2次..进程id43088，父进程id31776 正在运行work1 第3次..进程id43088，父进程id31776 正在运行work1 第4次..进程id43088，父进程id31776 正在运行work1 第5次..进程id43088，父进程id31776 正在运行work1 第6次..进程id43088，父进程id31776 正在运行work1 第7次..进程id43088，父进程id31776 正在运行work1 第8次..进程id43088，父进程id31776 正在运行work1 第9次..进程id43088，父进程id31776进程参数，全局变量进程间不能共享全局变量子进程在运行时候，会将主进程的内容复制到自己进程中，修改只限自己进程有效。不影响其他进程和主进程12345678910111213141516171819202122232425262728293031import multiprocessing# 定义全局变量import timeg_num = 10def work1(): global g_num for i in range(10): g_num += 1 print("work1---------", g_num)def work2(): print("work1---------", g_num)if __name__ == '__main__': p1 = multiprocessing.Process(target=work1) p2 = multiprocessing.Process(target=work2) p1.start() p2.start() time.sleep(3) print("---------main-----------", g_num)out: work1--------- 20 work1--------- 10 ---------main----------- 10守护进程p1.daemon=True设置子进程p1守护主进程，当主进程结束的时候，子进程也随之结束p1.terminate（）终止进程执行，并非是守护进程123456789101112131415161718192021222324252627import multiprocessingimport timedef work1(): for i in range(10): print("正在运行work1...&#123;&#125;".format(time.ctime())) time.sleep(0.5)if __name__ == '__main__': process_obj = multiprocessing.Process(target=work1) # 开启守护 # process_obj.daemon = True process_obj.start() print("我睡两秒就结束", time.ctime()) time.sleep(2) # 终止进程 process_obj.terminate() exit()out: 我睡两秒就结束 Thu Nov 14 16:04:29 2019 正在运行work1...Thu Nov 14 16:04:29 2019 正在运行work1...Thu Nov 14 16:04:30 2019 正在运行work1...Thu Nov 14 16:04:30 2019 正在运行work1...Thu Nov 14 16:04:31 2019进程线程对比功能进程，能够完成多任务，比如在一台电脑上能够同时运行多个QQ线程，能够完成多任务，比如一个QQ中的多个聊天窗口使用区别进程是系统进行资源分配和调度的一个独立单位。线程是进程的一介实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.一个程序至少有一个进程，一个进程至少有一个线程.线程的划分尺度小于进程（资源比进程少），使得多线程程序的并发性高。进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率线程不能独立运行，必须依赖于线程对比维度多进程多线程总结数据共享，同步数据共享复杂，需要用IPC；数据是分开因为共享进程数据，数据共享简单因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂各有千秋内存、CPU占用内存多，切换复杂，CPU利用率低占用内存少，切换简单，PU利用率高CPU线程占优创建销毁、切换创建销毁、切换复杂，速度慢创建销毁、切换简单，速度很快线程占优编程，调试编程简单，调试简单编程复杂，调试复杂进程占优可靠性进程间不会互相影响一个线程挂掉将导致整个进程挂掉进程占优分布式适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单应用于多核分布式进程占优进程线程取舍需要频繁创建销毁的先使用线程；（如：Web服务器）线程的切换速度快，所以在需要大量计算，切换频繁时用线程（如图像处理、算法处理）因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。都满足需求的情况下，用你最熟悉、最拿手的方式需要提醒的是：虽然有这么多的选择原则，但实际应用中基本上都是“进程+线程”的结合方式在Python的原始解释器CPython中存在着GlL（Global Interpreter Lock，全局解释器锁），因此在解释执行python代码时，会产生互斥锁来限制线程对共享资源的访问，直到解释器遇到I/O操作或者操作次数达到一定数目时才会释放GlL。造成了即使在多核CPU中，多线程也只是做着分时切换而已消息队列可以使用multiprocessing模块的Queue实现多进程之间的数据传递Queue本身是一个消息列队程序1234567891011121314151617181920212223242526272829303132333435363738import multiprocessing# 创建队列(指定长度)queue = multiprocessing.Queue(5)# 向队列中放值queue.put("Luenci")queue.put(1)queue.put([5, 2])queue.put((9, 8, 7))queue.put(&#123;"a": 6, "b": 8&#125;)# 判断队列是否全满isfull = queue.full()print("队列为全满：", isfull)# 长度为5，放入第6个数据后，队列就进行入了阻塞状态，默认会等待以列先取出值再放入新的值# queue.put(22)# 不等待的放入# queue.put_nowait(11)# 向队列中取值# 当队列为空的时候，再取值的时候，程序会进行阻塞状态，等待队列中有值再取value = queue.get()print(value)# 当队列为空的时候，再取值的时候，程序会直接报错# value = queue.get_nowait()# 队列元素个数num = queue.qsize()print(num)# 判断队列是否为空empty = queue.empty()print("队列为空？：", empty)进程池进程池概述当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务。进程池实现方式同步方式：pool.apply()异步方式pool.apply_async（copy_work）核心方法multiprocessing.Pool常用函数解析：apply（）：–进程池中进程以同步方式执行任务apply_async（func[，args[，kwds]]）：–使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表进程池中的进程通信12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import multiprocessingimport timedef write_queue(queue): for i in range(10): if queue.full(): print("队列已满") break else: queue.put(i) print("成功添加：", i) time.sleep(0.5)def read_queue(queue): while True: if queue.qsize() == 0: print("队列已空") break value = queue.get() print("已经读取", value)if __name__ == '__main__': # 创建进程池 pool = multiprocessing.Pool(3) # 创建进程池中的队列 queue = multiprocessing.Manager().Queue(10) # 同步的方式执行 # pool.apply(write_queue, args=(queue,)) # pool.apply(read_queue, args=(queue,)) # 异步的方式执行 # apply_async（）返回值ApplyResult对象，该对象有一个wait（）的方法 result = pool.apply_async(write_queue, args=(queue,)) result.wait() pool.apply_async(read_queue, args=(queue,)) # 不再接收新的任务 pool.close() pool.join()out: 成功添加： 0 成功添加： 1 成功添加： 2 成功添加： 3 成功添加： 4 成功添加： 5 成功添加： 6 成功添加： 7 成功添加： 8 成功添加： 9 已经读取 0 已经读取 1 已经读取 2 已经读取 3 已经读取 4 已经读取 5 已经读取 6 已经读取 7 已经读取 8 已经读取 9 队列已空]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>进程概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python多线程，并发和锁]]></title>
    <url>%2F2019%2F11%2F13%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多任务同一个时间有多个任务在执行python程序默认是单任务线程线程概念线程，可简单理解为是程序执行的一条分支，也是程序执行流的最小单元。线程是被系统独立调度和分底的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程为其它线程共享进程所拥有的全部资源。主线程当一个程序后动时，就有一个进程被操作系统（OS）创建，与此同时一个线程也立刻运行，该线程通常叫做程序的主线程，简而言之；程序后动就会创建一个主线程。Copy主线程的重要性有两方面：1）是产生其他子线程的线程；2）通常它必须最后完成执行比如执行各种关闭动作·子线程可以看做是程序执行的一条分支，当子线程后动后会和主线程一起同时执行主线程会等待所以子线程结束之后再结束123456789101112131415161718192021222324252627282930313233343536import threadingfrom time import *def loop0(): print('start loop0 at:', ctime()) sleep(4) print('loop0 done at:', ctime())def loop1(): print('start loop1 at:', ctime()) print('loop1 done at:', ctime())def main(): print('starting at :', ctime()) # 使用threading.Thread创建对象（子进程对象） # threading.Thread（target=函数名） thread_1 = threading.Thread(target=loop0) thread_2 = threading.Thread(target=loop1) thread_1.start() thread_2.start() print('all done at:', ctime())if __name__ == '__main__': main() out： starting at : Wed Nov 13 14:21:27 2019 start loop0 at: Wed Nov 13 14:21:27 2019 start loop1 at: Wed Nov 13 14:21:27 2019 loop1 done at: Wed Nov 13 14:21:27 2019 all done at: Wed Nov 13 14:21:27 2019 loop0 done at: Wed Nov 13 14:21:31 2019线程数量目标能够如何查看正在活动的线程数量1.查看线程数量threading.enumerate（）获取当前所有活跃的线程对象列表。使用len()对列表求长度可以看到当前活跃的线程的个数12345678910111213141516171819202122232425262728293031323334353637383940import threadingfrom time import *def loop0(): print('&#123;&#125;start loop0 at&#123;&#125;:'.format(threading.current_thread(), ctime())) sleep(4) print('loop0 done at:', ctime())def loop1(): print('&#123;&#125;start loop1 at&#123;&#125;:'.format(threading.current_thread(), ctime())) print('loop1 done at:', ctime())def main(): print('starting at :', ctime()) # 使用threading.Thread创建对象（子进程对象） # threading.Thread（target=函数名） thread_1 = threading.Thread(target=loop0) thread_2 = threading.Thread(target=loop1) thread_1.start() thread_2.start() print('all done at:', ctime())if __name__ == '__main__': main() thread_list = threading.enumerate() print("当前线程数量：%d" % len(thread_list))out: starting at : Wed Nov 13 14:41:20 2019 &lt;Thread(Thread-1, started 9916)&gt;start loop0 atWed Nov 13 14:41:20 2019: &lt;Thread(Thread-2, started 2868)&gt;start loop1 atWed Nov 13 14:41:20 2019: loop1 done at: Wed Nov 13 14:41:20 2019 all done at: Wed Nov 13 14:41:20 2019 当前线程数量：2 loop0 done at: Wed Nov 13 14:41:24 2019线程参数及顺序线程中传递参数有三种方法1.使用元组传递threading.Thread(target=fun_name,args=(参数。。。))thread_1 = threading.Thread(target=loop0, args=(10, 21, 22))2.使用字典传递 threading.Thread(target=fun_name,kwargs={&quot;参数名&quot;: &quot;参数值&quot;....})thread_1 = threading.Thread(target=loop0, kwargs={&quot;a&quot;: 10, &quot;b&quot;: 21, &quot;c&quot;: 22})3.混合使用元组和字典传递 threading.Thread(target=fun_name,args=(10, 21, 22), kwargs={&quot;参数名&quot;: &quot;参数值&quot;....})thread_1 = threading.Thread(target=loop0, args=(10, 21), kwargs={&quot;c&quot;: 22})123456789101112131415161718192021222324252627282930313233343536373839404142434445import threadingfrom time import *def loop0(a, b, c): print("参数：", a, b, c) print("start loop0 at:", ctime()) sleep(4) print("loop0 done at:", ctime())def loop1(): print("start loop1 at:", ctime()) print("loop1 done at:", ctime())def main(): print("starting at :", ctime()) # 线程中传递参数有三种方法 # 1.使用元组传递 threading.Thread(target=fun_name,args=(参数。。。)) # thread_1 = threading.Thread(target=loop0, args=(10, 21, 22)) # 2.使用字典传递 threading.Thread(target=fun_name,kwargs=&#123;"参数名": "参数值"....&#125;) # thread_1 = threading.Thread(target=loop0, kwargs=&#123;"a": 10, "b": 21, "c": 22&#125;) # 3.混合使用元组和字典传递 threading.Thread(target=fun_name,args=(10, 21, 22), kwargs=&#123;"参数名": "参数值"....&#125;) thread_1 = threading.Thread(target=loop0, args=(10, 21), kwargs=&#123;"c": 22&#125;) thread_2 = threading.Thread(target=loop1) thread_1.start() thread_2.start() print("all done at:", ctime())if __name__ == "__main__": main()out: starting at : Wed Nov 13 15:00:00 2019 参数： 10 21 22 start loop0 at: Wed Nov 13 15:00:00 2019 start loop1 at: Wed Nov 13 15:00:00 2019 loop1 done at: Wed Nov 13 15:00:00 2019 all done at: Wed Nov 13 15:00:00 2019 loop0 done at: Wed Nov 13 15:00:04 2019守护线程守护线程：如果在程序中将子线程设置为守护线程，则该子线程会在主线程结束时自动退出，设置方式为threaj.setDaemon（True），要在thread.start0之前设置，默认是false的，也就是主线程结束时，子线程依然在执行。对于python应用我们都知道main方法是入口，它的运行代表着主线程开始工作了，我们都知道Python虚拟机里面有垃圾回收器的存在使得我们放心让main运行，然而这背后是垃圾回收线程作为守护着主线程的守护线程。1234567891011121314151617181920212223242526272829import threadingimport timedef work1(): for i in range(10): print("正在执行work1...", i) time.sleep(0.5)if __name__ == '__main__': # 创建子线程 thread_woek1 = threading.Thread(target=work1) # 将子线程设置为守护线程 thread_woek1.setDaemon(True) thread_woek1.start() # 睡眠 time.sleep(2) print("game over") # 让程序退出，主线程主动结束 exit() out: 正在执行work1... 0 正在执行work1... 1 正在执行work1... 2 正在执行work1... 3 game over并行和并发多任务的原理剖析操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒…….这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。并发：指的是任务数多于cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一超执行而已）真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。并发：任务数量大于CPU的核心数并行：指的是任务数小于等于cpu核数，即任务真的是一起执行的并行：任务数量小于或等于CPU的核心数多线程——共享全局变量当多个线程修改同一个资源的时候，会出现资源竞争，导致计算结果有误调用join方法优先让某个线程先执行缺点：将多线程变成了单线程，影响执行效率12345678910111213141516171819202122232425262728293031323334import threadingimport timeg_num = 0def work1(): # 声明g_num是一个全局变量 global g_num for i in range(10000000): g_num += 1 print("work1-----------------", g_num)def work2(): global g_num for i in range(10000000): g_num += 1 print("work2-----------------", g_num)if __name__ == '__main__': work_1 = threading.Thread(target=work1) work_2 = threading.Thread(target=work2) work_1.start() # 优先让t1线程先执行， t1执行完毕后，t2才能执行 work_1.join() work_2.start() while len(threading.enumerate()) != 1: time.sleep(1) print("main-----------", g_num)同步和异步同步：多任务，多个任务之间执行的时候要求有先后顺序，必须一个先执行完成之后，另一个才能继续执行，只有一个主线。如：你说完，我再说（同一时间只能做一件事情）异步，指的是：多个任务之间执行没有先后顺序，可以同时运行，执行的先后顺序不会有什么影响，存在的多条运行主线。如：发微信（可以不用等对方回复，继续发）、点外卖（点了外卖后，可以继续忙其他的事情，而不是坐等外卖，啥也不做）线程锁互斥锁当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制线程同步能够保证多个线程安全访问竞争源，最简单的同步机制是引入互斥锁。互斥锁为资源引入一个状态：锁定/非锁定某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import threadingimport timeg_num = 0def work1(): # 声明g_num是一个全局变量 global g_num for i in range(10000000): # 上锁 lock1.acquire() g_num += 1 # 释放锁 lock1.release() print("work1-----------------", g_num)def work2(): global g_num for i in range(10000000): # 上锁 lock1.acquire() g_num += 1 # 解锁 lock1.release() print("work2-----------------", g_num)if __name__ == '__main__': print(time.ctime()) # 创建一把互斥锁 lock1 = threading.Lock() work_1 = threading.Thread(target=work1) work_2 = threading.Thread(target=work2) work_1.start() work_2.start() while len(threading.enumerate()) != 1: time.sleep(1) print("main-----------", g_num) print("总时间:", time.ctime())死锁在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。注意：使用完毕及时释放1234567891011121314151617181920212223import threadingdef get_value(index): data_list = [1, 3, 5, 7, 9] lock1.acquire() if index &gt;= len(data_list): print("下标越界", index) # 若不释放就产生死锁 lock1.release() return print(data_list[index]) lock1.release()if __name__ == '__main__': # 创建一把锁 lock1 = threading.Lock() for i in range(10): t1 = threading.Thread(target=get_value, args=(i, )) t1.start()]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>线程概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket网络编程实战-斗鱼弹幕获取]]></title>
    <url>%2F2019%2F10%2F31%2F%E6%96%97%E9%B1%BC%E5%BC%B9%E5%B9%95%E6%8A%93%E5%8F%96%2F</url>
    <content type="text"><![CDATA[asyncore模块介绍这个模块为异步socket的服务器客户端通信提供简单的接口。该模块提供了异步socket服务客户端和服务器的基础架构。相比python原生的socket api，asyncore具备有很大的优势，asyncore对原生的socket进行封装，提供非常简洁优秀的接口，利用asyncore覆写相关需要处理的接口方法，就可以完成一个socket的网络编程，从而需要处理复杂的socket网络状况以及多线程处理等等。实现流程客户端 Socket 开发基本使用1.定义类继承自asyncore.dispatcher2.实现类中的回调代码实现构造函数调用父类方法创建 Socket对象连接服务器实现handle_connect回调函数当socket连接服务器成功时回调该函数实现writable回调函数描述是否有数据需要被发送到服务器。返回值为True表示可写，False表示不可写，如果不实现默认返回为True，当返回True时，回调函数handle_write将被触发实现handle_write 回调函数当有数据需要发送时（writable回调函数返回True时），该函数被触发，通常情况下在该函数中编写send方法发送数据实现readable回调函数描述是否有数据从服务端读取。返回True 表示有数据需要读取，False表示没有数据需要被读取，当不实现默认返回为True，当返回True 时，回调函数handle_read将被触发实现handle_read回调函数当有数据需要读取时触发（readable回调函数返回True时），该函数被触发，通常情况下在该函数中编写recv方法接收数据实现handle_error回调函数当程序运行过程发生异常时回调实现handle_close回调函数当连接被关闭时触发3.创建对象并且执行asyncore.loop进入运行循环timeout表示一次循环所需要的时长12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import asyncoreimport sys# 定义类继承自 asyncore.dispatherclass scoket_client(asyncore.dispatcher): # 实现类中的回调代码 def __init__(self, host, port): # 调用父类的方法 asyncore.dispatcher.__init__(self) # 创建 Scoket 服务器 self.create_socket() # 连接地址 address = (host, port) self.connect(address) pass # 实现handle_connect回调函数 def handle_connect(self): print("连接成功") # 实现writable函数 def writable(self): return False # 实现handle_write回调函数 def handle_write(self): # 内部实现对服务器发送数据代码 # 调用 send 方法发送数据，参数是字节数据 self.send("hello world".encode('utf-8')) # self.send("hello world") # 实现readable回调函数 def readable(self): return True # 实现handle_read回调函数 def handle_read(self): # 主动接收数据 result = self.recv(1024) print(result) # 实现handle_error回调函数 def handle_error(self): # 编写处理错误方法 t, e, trace = sys.exc_info() # 实现handle_close回调函数 def handle_close(self): print("连接关闭") self.close()# 创建对象并且执行asyncore.loop 进入循环if __name__ == '__main__': client = scoket_client('127.0.0.1', 9000) # 开始启动运行循环 asyncore.loop(timeout=5)斗鱼弹幕实战文档资料斗鱼弹幕服务器第三方接入协议V1.6.2.pdf 官方提供协议文档弹幕客户端开发流程连接初始化使用TCP连接服务器IP地址：openbarrage.douyutv.com端口：8601客户端向弹幕服务器发送登录请弧，登录弹幕服务器弹幕服务器收到客户端登录请求并完成登录后，返回登录成功消息给客户端客户端收到登录成功消息后发送进入弹幕分组请求给弹幕服务器弹幕服务器接受到客户端弹幕分组请求后将客户端添加到请求指定的弹幕分组中服务过程客户端每隔45秒发送心跳给弹幕服务器，弹幕服务器回复心跳信息给客户端弹幕服务器如有广播信息，则推送给客户端，服务器消息协议断开连接客户端发送登出消息客户端关闭TCP连接数据发送和接收流程数据包讲解消息长度：4 字节小端整数，表示整条消息（包括自身）长度（字节数）消息长度出现两遍，二者相同消息类型：2 字节小端整数，表示消息类型。取值如下：689 客户端发送给弹幕服务器的文本格式数据690 弹幕服务器发送给客户端的文本格式数据。加密字段：暂时未用，默认为 0。保留字段：暂时未用，默认为 0。数据部分：斗鱼独创序列化文本数据，结尾必须为‘\0’。详细序列化、反序列化算法见下节。（所有协议内容均为 UTF-8 编码）数据包的封装对数据包进行对象化封装，对数据的封装方便以后使用，实现对象和二进制数据之间的转换通过参数构建数据包对象实现获取数据包长度的方法实现获取二进制数据的方法实现发送数据包构建发送数据包的容器实现回调函数，判断容器中有数据就发送没有数据不发送实现登录函数构建登录数据包把数据包添加到发送数据包容器中实现接收数据构建接收数据包队列读取回调函数中读取数据读取长度读取内容构建数据包对象把数据包放入接收数据包容器中构建处理数据包线程构建线程实现回调函数处理数据实现外部传入回调函散通过外部指定回调函数实现自定义数据处理添加参数callback构造函数中添加参数外部传入自定义回调函数在处理接收数据包的线程中调用回调函数数据内容序列话与反序列化1 键 key 和值 value 直接采用‘@=’分割2 数组采用‘/’分割3 如果 key 或者 value 中含有字符‘/’，则使用‘@S’转义4 如果 key 或者 value 中含有字符‘@’ ，使用‘@A’转义举例：多个键值对数据：key1@=value1/key2@=value2/key3@=value3/数组数据：value1/value2/value3/不同消息有相同的协议头、序列化方式加入弹幕分组​ 第三方平台建议选择-9999（即海量弹幕模式 )心跳机制作用是让服务器解决假死连接问题，客户端必须每隔45秒发送一次请求，否则就会被主动断开。实现发送心跳函数构建心跳数据包把数据包添加到发送数据包容器队列中构建心跳线程构建心跳线程添加触发机制添加暂停机制]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令集合]]></title>
    <url>%2F2019%2F10%2F28%2Fgit%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git config配置 Git 的相关参数。Git 一共有3个配置文件：仓库级的配置文件：在仓库的 .git/.gitconfig，该配置文件只对所在的仓库有效。全局配置文件：Mac 系统在 ~/.gitconfig，Windows 系统在 C:\Users\&lt;用户名&gt;\.gitconfig。系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 /usr/local/git）的 etc 文件夹中的 gitconfig。123456789101112131415161718192021222324252627282930313233343536373839404142# 查看配置信息# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; -l# 查看当前生效的配置信息$ git config -l# 编辑配置文件# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; -e# 添加配置项# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; --add &lt;name&gt; &lt;value&gt;# 获取配置项$ git config &lt;--local | --global | --system&gt; --get &lt;name&gt;# 删除配置项$ git config &lt;--local | --global | --system&gt; --unset &lt;name&gt;# 配置提交记录中的用户信息$ git config --global user.name &lt;用户名&gt;$ git config --global user.email &lt;邮箱地址&gt;# 更改Git缓存区的大小# 如果提交的内容较大，默认缓存较小，提交会失败# 缓存大小单位：B，例如：524288000（500MB）$ git config --global http.postBuffer &lt;缓存大小&gt;# 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态$ git config --global color.ui true# 配置可以缓存密码，默认缓存时间15分钟$ git config --global credential.helper cache# 配置密码的缓存时间# 缓存时间单位：秒$ git config --global credential.helper 'cache --timeout=&lt;缓存时间&gt;'# 配置长期存储密码$ git config --global credential.helper storegit clone从远程仓库克隆一个版本库到本地。12345678# 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下$ git clone &lt;远程仓库的网址&gt;# 指定本地仓库的目录$ git clone &lt;远程仓库的网址&gt; &lt;本地目录&gt;# -b 指定要克隆的分支，默认是master分支$ git clone &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt;git init初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。12# 初始化本地仓库，在当前目录下生成 .git 文件夹$ git initgit status查看本地仓库的状态。1234567# 查看本地仓库的状态$ git status# 以简短模式查看本地仓库的状态# 会显示两列，第一列是文件的状态，第二列是对应的文件# 文件状态：A 新增，M 修改，D 删除，?? 未添加到Git中$ git status -sgit remote操作远程库。123456789101112131415161718# 列出已经存在的远程仓库$ git remote# 列出远程仓库的详细信息，在别名后面列出URL地址$ git remote -v$ git remote --verbose# 添加远程仓库$ git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的URL地址&gt;# 修改远程仓库的别名$ git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;# 删除指定名称的远程仓库$ git remote remove &lt;远程仓库的别名&gt;# 修改远程仓库的 URL 地址$ git remote set-url &lt;远程仓库的别名&gt; &lt;新的远程仓库URL地址&gt;git branch操作 Git 的分支命令。1234567891011121314151617181920# 列出本地的所有分支，当前所在分支以 "*" 标出$ git branch# 列出本地的所有分支并显示最后一次提交，当前所在分支以 "*" 标出$ git branch -v# 创建新分支，新的分支基于上一次提交建立$ git branch &lt;分支名&gt;# 修改分支名称# 如果不指定原分支名称则为当前所在分支$ git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;# 强制修改分支名称$ git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;# 删除指定的本地分支$ git branch -d &lt;分支名称&gt;# 强制删除指定的本地分支$ git branch -D &lt;分支名称&gt;git checkout检出命令，用于创建、切换分支等。123456789101112# 切换到已存在的指定分支$ git checkout &lt;分支名称&gt;# 创建并切换到指定的分支，保留所有的提交记录# 等同于 "git branch" 和 "git checkout" 两个命令合并$ git checkout -b &lt;分支名称&gt;# 创建并切换到指定的分支，删除所有的提交记录$ git checkout --orphan &lt;分支名称&gt;# 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响$ git checkout &lt;文件路径&gt;git cherry-pick把已经提交的记录合并到当前分支。12# 把已经提交的记录合并到当前分支$ git cherry-pick &lt;commit ID&gt;git add把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交。1234567891011121314# 把指定的文件添加到暂存区中$ git add &lt;文件路径&gt;# 添加所有修改、已删除的文件到暂存区中$ git add -u [&lt;文件路径&gt;]$ git add --update [&lt;文件路径&gt;]# 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录$ git add -A [&lt;文件路径&gt;]$ git add --all [&lt;文件路径&gt;]# 查看所有修改、已删除但没有提交的文件，进入一个子命令系统$ git add -i [&lt;文件路径&gt;]$ git add --interactive [&lt;文件路径&gt;]git commit将暂存区中的文件提交到本地仓库中。123456789101112# 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息$ git commit# 把暂存区中的文件提交到本地仓库中并添加描述信息$ git commit -m "&lt;提交的描述信息&gt;"# 把所有修改、已删除的文件提交到本地仓库中# 不包括未被版本库跟踪的文件，等同于先调用了 "git add -u"$ git commit -a -m "&lt;提交的描述信息&gt;"# 修改上次提交的描述信息$ git commit --amendgit fetch从远程仓库获取最新的版本到本地的 tmp 分支上。12345# 将远程仓库所有分支的最新版本全部取回到本地$ git fetch &lt;远程仓库的别名&gt;# 将远程仓库指定分支的最新版本取回到本地$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;git merge合并分支。12# 把指定的分支合并到当前所在的分支下$ git merge &lt;分支名称&gt;git diff比较版本之间的差异。123456789101112131415161718# 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改$ git diff# 比较暂存区中的文件和上次提交时的差异$ git diff --cached$ git diff --staged# 比较当前文件和上次提交时的差异$ git diff HEAD# 查看从指定的版本之后改动的内容$ git diff &lt;commit ID&gt;# 比较两个分支之间的差异$ git diff &lt;分支名称&gt; &lt;分支名称&gt;# 查看两个分支分开后各自的改动内容$ git diff &lt;分支名称&gt;...&lt;分支名称&gt;git pull从远程仓库获取最新版本并合并到本地。首先会执行 git fetch，然后执行 git merge，把获取的分支的 HEAD 合并到当前分支。12# 从远程仓库获取最新版本。$ git pullgit push把本地仓库的提交推送到远程仓库。123456# 把本地仓库的分支推送到远程仓库的指定分支$ git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;# 删除指定的远程仓库的分支$ git push &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;$ git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt;git log显示提交的记录。12345678# 打印所有的提交记录$ git log# 打印从第一次提交到指定的提交的记录$ git log &lt;commit ID&gt;# 打印指定数量的最新提交的记录$ git log -&lt;指定的数量&gt;git reset还原提交记录。12345678910111213141516# 重置暂存区，但文件不受影响# 相当于将用 "git add" 命令更新到暂存区的内容撤出暂存区，可以指定文件# 没有指定 commit ID 则默认为当前 HEAD$ git reset [&lt;文件路径&gt;]$ git reset --mixed [&lt;文件路径&gt;]# 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改$ git reset &lt;commit ID&gt;$ git reset --mixed &lt;commit ID&gt;# 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改# 相当于调用 "git reset --mixed" 命令后又做了一次 "git add"$ git reset --soft &lt;commit ID&gt;# 将 HEAD 的指向改变，撤销到指定的提交记录，文件也修改了$ git reset --hard &lt;commit ID&gt;git revert生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。12# 生成一个新的提交来撤销某次提交$ git revert &lt;commit ID&gt;git tag操作标签的命令。1234567891011121314151617181920212223# 打印所有的标签$ git tag# 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录$ git tag &lt;标签名称&gt; [&lt;commit ID&gt;]# 添加带有描述信息的附注标签，可以指定之前的提交记录$ git tag -a &lt;标签名称&gt; -m &lt;标签描述信息&gt; [&lt;commit ID&gt;]# 切换到指定的标签$ git checkout &lt;标签名称&gt;# 查看标签的信息$ git show &lt;标签名称&gt;# 删除指定的标签$ git tag -d &lt;标签名称&gt;# 将指定的标签提交到远程仓库$ git push &lt;远程仓库的别名&gt; &lt;标签名称&gt;# 将本地所有的标签全部提交到远程仓库$ git push &lt;远程仓库的别名&gt; –tagsgit mv重命名文件或者文件夹。12# 重命名指定的文件或者文件夹$ git mv &lt;源文件/文件夹&gt; &lt;目标文件/文件夹&gt;git rm删除文件或者文件夹。12345678# 移除跟踪指定的文件，并从本地仓库的文件夹中删除$ git rm &lt;文件路径&gt;# 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除$ git rm -r &lt;文件夹路径&gt;# 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件$ git rm --cachedGit操作场景示例1. 删除掉本地不存在的远程分支多人合作开发时，如果远程的分支被其他开发删除掉，在本地执行 git branch --all 依然会显示该远程分支，可使用下列的命令进行删除：123456# 使用 pull 命令，添加 -p 参数$ git pull -p# 等同于下面的命令$ git fetch -p$ git fetch --prune origin来源：https://www.jianshu.com/p/93318220cdce]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Python语言的IP代理池]]></title>
    <url>%2F2019%2F10%2F27%2FIP%E4%BB%A3%E7%90%86%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[环境：python3.6MongoDBflaskrequests等第三方库完整代码见： https://github.com/Lucareful/IPProxyPool代理池概述什么是代理池代理池就是有代理IP组成的池子，它可以提供多个稳定可用的代理IP为什么要实现代理池我们在做爬虫的时候，最常见的一种反爬虫手段就是：IP反爬；也就是当同一个IP访问这个网站的次数过多，频率过高，就会限制这个IP的访问。就是需要经常换IP；使用IP代理池是其中一个比较常用的方案免费代理都是非常不稳定的，有10%是可用就很不错了一些收费代理稳定性也不好目的：从一堆不稳定的代理IP中，抽取高可用代理IP，给爬虫使用代理池开发环境python3开发语言requests：发送请求，获取页面数据lxml：使用XPATH从页面提取我们想要的书籍pymonge：把提取到代理IP存储到MongoDB数据库中和MongoDB数据库中读取代理IP，给爬虫使用Flask：用于提供WEB服务代理池工作流程1.代理池工作渡程描述：代理IP采集模块-&gt;采集代理IP-&gt;检测代理IP-&gt;如果不可用用，直接过滤掉，如果可用，指定默认分数-&gt;存入数据库中代理IP检测模块-&gt;从数据库中获取所有代理IP-&gt;检测代理IP-&gt;如果代理IP不可用用，就把分数-1，如果分数为0从数据库中删除，否则更新数据库，如果代理IP可用，恢复为默认分值，更新数据库代理API模块-&gt;从数据库中高可用的代理IP给爬虫使用；代理池的模块及其作用五大核心模块爬虫模块从代理IP网站上采集代理IP进行校验（获取代理响应速度，协议类型，匿名类型）把可用代理IP存储到数据库中代理IP的校验模块：获取指定代理的响应速度，支持的协议以及匿名程度原因：网站上所标注的响应速度，协议类型和匿名类型是不准确的这里使用httpbin.org进行检测数据库模块：实现对代理IP的增删改查操作这里使用MongoDB来存储代理IP检测模块：定时的对代理池中代理进行检测，保证代理池中代理的可用性.从数据库读取所有的代理IP对代理IP进行逐一检测，可用开启多个协程，以提高检测速度如果该代理不可用，就让这个代理分数-1，当代理的分数到0了，就删除该代理；如果检测到代理可用就恢复为满分.代理IP服务接口：提供高可用的代理IP给爬虫使用根据协议类型和域名获取随机一个高质量代理IP根据协议类型和域名获取多个高质量代理IP根据代理IP不可用域名，告诉代理池这个代理IP在该域名下不可用，下次获取这个域名的代理IP时候，就不会再获取这个代理IP了，从而保证代理IP高可用性.代理池的其它模块数据模型：domain.py代理IP的数据模型，用于封装代理IP相关信息，比如ip，端口号，响应速度，协议类型，匿名类型，分数等程序启动入口：main.py·代理池提供一个统一的启动入口工具模块：、日志模块：用于记录日志信息http模块：用于获取随机User-Agent的请求头配置文件：settings.py用于默认代理的分数，配置日志格式，文件，启动的爬虫，检验的间隔时间等.代理池的项目结构12345678910111213141516171819202122--IPProxyPoo1 --core --db --__init__.py --mongo_pool.py --proxy_validate --__init__.py --httpbin_validator.py --proxy_spider --__init__.py --base_spider.py --proxy_kpiders.py --run_spiders.py --proxy_test.py --proxy_api.py --domain.py --utils --__init__.py --http.py --log.py --main.py --settings.py定义代理IP的数据模型类定义Proxy类，继承object实现_init_方法，负责初始化，包含如下字段：ip：代理的IP地址port：代理IP的端口号protocol：代理IP支持的协议类型，http是0，https是1，https和http都支持是2nick_type：代理IP的匿名程度，高匿：0，匿名：1，透明：2speed：代理IP的响应速度，单位sarea：代理IP所在地区score：代理IP的评分，用于衡量代理的可用性；默认分值可以通过配置文件进行配置.在进行代理可用性检查的时候，每遇到一次请求失败就减1份，减到0的时候从池中删除.如果检查代理可用，就恢复默认分值disable_domains：不可用域名列表，有些代理IP在某些域名下不可用，但是在其他域名下可用在配置文件：settings.py中定义MAX_SCORE=50，表示代理IP的默认最高分数提供_str方法，返回数据字符串代理池的工具模块日志模块http模块日志模块能够方便的对程序进行调试能够方便记录程序的运行状态能够方便记录错误信息日志的实现目标：实现日志模块，用于记录日志把日志相关配置信息放到配置文件中修改日志代码，使用配置文件中的配置信息Http模块我在从代理IP网站上抓取代理IP和检验代理IP时候，为了不容易不服务器识别为是一个爬虫，我们最好提供随机的User-Agent请求头.目标：获取随机User-Agent的请求头步骤：1.准备User-Agent的列表2.实现一个方法，获取随机User-Agent的请求头代理池的检验模块目标：检查代理IP速度，匿名程度以及支持的协议类型.步骤：检查代理IP速度和匿名程度；代理IP速度：就是从发送请求到获取响应的时间间隔匿名程度检查：对http://httpbin.org/get 或https://httpbin.org/get 发送请求如果响应的origin中有 ，分割的两个IP就是透明代理IP如果响应的headers 中包含Proxy-Connection 说明是匿名代理IP否则就是高匿代理IP。检查代理IP协议类型如果http://httpbin.org/get 发送请求可以成功，说明支持http协议如果https://httpbin.org/get 发送请求可以成功，说明支持https协议代理池的数据库模块作用：用于对proxies集合进行数据库的相关操作目标：实现对数据库增删改查相关操作、步骤：1.在init中，建立数据连接，获取要操作的集合，在del方法中关闭数据库连接2.提供基础的增删改查功能实现插入功能实现修改该功能实现删除代理：根据代理的IP删除代理查询所有代理IP的功能3.提供代理API模块使用的功能实现查询功能：根据条件进行查询，可以指定查询数量，先分数降序，速度升序排，保证优质的代理IP在上面.实现根据协议类型和要访问网站的域名，获取代理IP列表实现根据协议类型和要访问完整的域名，随机获取一个代理IP实现把指定域名添加到指定IP的disable_domain列表中.实现代理池的爬虫模块爬虫模块的需求需求：抓取各个代理IP网站上的免费代理IP进行检测，如果可用存储到数据库中需要抓取代理IP的页面如下：西刺代理：https://www.xicidaili.com/nn/1ip3366代理：http://www.ip3366.net/free/?stype=1&amp;page=1快代理：https://www.kuaidaili.com/free/inha/1/oproxylistplus代理:https://list.proxylistplus.com/Fresh-HTTP-Proxy-List-166ip代理：http://www.66ip.cn/1.html爬虫模块的设计通用爬虫：通过指定URL列表，分组XPATH和组内XPATH，来提取不同网站的代理IP原因代理IP网站的页面结构几乎都是Table，页面结构类似具体爬虫：用于抓取具体代理IP网站通过继承通用爬虫实现具体网站的抓取，一般只需要指定爬取的URL列表，分组的XPATH和组内XPATH就可以了.如果该网站有特殊反爬手段，可以通过重写某些方法实现反爬爬虫运行模块：启动爬虫，抓取代理IP进行检测，如果可用，就存储到数据库中；通过配置文件来控制启动哪些爬虫，增加扩展性；如果将来我们遇到返回json格式的代理网站，单独写一个爬虫配置下就好了.实现通用爬虫目标：实现可以指定不同URL列表，分组的XPATH和详情的XPATH，从不同页面上提取代理的IP端口号和区域的通用爬虫；步骤：1.在base_spider.py文件中，定义一个BaseSpider类，继承object2.提供三个类成员变量：urls：代理IP网址的URL的列表group_xpath：分组XPATH，获取包含代理IP信息标签列表的XPATHdetail_xpath：组内XPATH，获取代理IP详情的信息XPATH，格式为：{“ip’:’xx’，’port’：’xx’，‘area’：’xx’}3.提供初始方法，传入爬虫URL列表，分组XPATH，详情（组内）XPATH4.对外提供一个获取代理IP的方法遍历URL列表，获取URL根据发送请求，获取页面数据解析页面，提取数据，封装为Proxy对象返回Proxy对象列表实现具体爬虫目标：通过继承通用爬虫，实现多个具体爬虫，分别从各个免费代理IP网站上抓取代理IP1.实现西刺代理爬虫：http://www.xicidaili.com/nn/1定义一个类，继承通用爬虫类（BasicSpider）提供urls，group_xpath 和detail_xpath2.实现ip3366代理爬虫：http://www.ip3366.net/free/？stype=1&amp;page=1定义一个类，继承通用爬虫类（BasicSpider）提供urls，group_xpath 和detail_xpath3.实现快代理爬虫：https://www.kuaidaili.com/free/inha/1/定义一个类，继承通用爬虫类（BasicSpider）提供urls，group_xpath和detail_xpath4.实现 proxylistplus代理爬虫：https://list.proxylistplus.com/Fresh-HTTP-Proxy-List-1定义一个类，继承通用爬虫类（BasicSpider）提供urls，group_xpath 和detail_xpath5.实现66ip爬虫：http://www.66ip.cn/1.html定义一个类，继承通用爬虫类（BasicSpider）提供urls，group_xpath和detail_xpath由于66ip网页进行js+cookie反爬，需要重写父类的get_page_from_url 方法PS：实现66ip爬虫：http://www.66ip.cn/1.html核心：通过加密的js，生成需要cookie信息1.从响应页面中，提取：​ 1.执行生成真正js语句​ 2.生成真正js的函数.2.网页中，是通过eval执行真正js，加载页面；而我们要获取真正的js；我们就需要把eval语句，替换为return，把真正js返回.3.使用js2py，获取执行js的环境，使用js执行环境加载这个函数4.使用这个执行环境，执行调用调用，生成真正js，赋值给一个变量5.从真正的js代码中，提取我们需要cookie信息.实现爬虫的运行模块目标：根据配置文件信息，加载爬虫，抓取代理IP，进行校验，如果可用，写入到数据库中思路：在run_spider.py中，创建RunSpider类提供一个运行爬虫的run方法，作为运行爬虫的入口，实现核心的处理逻辑根据配置文件信息，获取爬虫对象列表.遍历爬虫对象列表，获取爬虫对象，遍历爬虫对象的get_proxies方法，获取代理IP检测代理IP（代理IP检测模块）如果可用，写入数据库（数据库模块）处理异常，防止一个爬虫内部出错了，影响其他的爬虫.使用异步来执行每一个爬虫任务，以提高抓取代理IP效率在init 方法中创建协程池对象把处理一个代理爬虫的代码抽到一个方法使用异步执行这个方法调用协程的join方法，让当前线程等待队列任务的完成.使用schedule模块，实现每隔一定的时间，执行一次爬取任务定义一个start的类方法创建当前类的对象，调用run方法使用schedule模块，每隔一定的时间，执行当前对象的run方法实现代理池的检测模块目的：检查代理IP可用性，保证代理池中代理IP基本可用思路1.在proxy_test.py中，创建Proxy Tester类2.提供一个run 方法，用于处理检测代理命核心逻辑从数据库中获取所有代理IP遍历代理IP列表检查代理可用性如果代理不可用，让代理分数-1，如果代理分数等于0就从数据库中删除该代理，否则更新该代理IP如果代理可用，就恢复该代理的分数，更新到数据库中3.为了提高检查的速度，使用异步来执行检测任务在init方法中，创建队列和协程池把要检测的代理IP，放到队列中i.把检查一个代理可用性的代码，抽取到一个方法中；从队列中获取代理IP，进行检查；检查完毕，调度队列的task_done方法ii.通过异步回调，使用死循环不断执行这个方法，iv.开启多个一个异步任务，来处理代理IP的检测；可以通过配置文件指定异步数量调用队列的join方法，让当前线程等待队列任务完成4.使用schedule模块，每隔一定的时间，执行一次检测任务定义类方法start，用于启动检测模块在start方法中i.创建本类对象i.调用run方法i.每间隔一定时间，执行一下，run方法实现代理池的API模块目标：为爬虫提供高可用代理IP的服务接口步骤：实现根据协议类型和域名，提供随机的获取高可用代理IP的服务实现根据协议类型和域名，提供获取多个高可用代理IP的服务实现给指定的IP上追加不可用域名的服务实现在proxy_api.py中，创建ProxyApi类实现初始方法s初始一个Flask的Web服务实现根据协议类型和域名，提供随机的获取高可用代理IP的服务可用通过protocol和domain参数对IP进行过滤protocol：当前请求的协议类型domain：当前请求域名实现根据协议类型和域名，提供获取多个高可用代理IP的服务·可用通过protocol和domain参数对IP进行过滤实现给指定的IP上追加不可用域名的服务如果在获取IP的时候，有指定域名参数，将不在获取该IP从而进一步提高代理IP的可用性.实现run方法，用于启动Flask的WEB服务实现start的类方法，用于通过类名，启动服务实现代理池的程序入口目标：把启动爬虫，启动检测代理IP，启动WEB服务统一到一起思路：开启三个进程，分别用于启动爬虫，检测代理IP，WEB服务步骤：定义一个run方法用于启动动代理池定义一个列表，用于存储要启动的进程创建启动爬虫的进程，添加到列表中创建启动检测的进程，添加到列表中创建启动提供API服务的进程，添加到列表中遍历进程列表，启动所有进程遍历进程列表，让主进程等待子进程的完成在if__name__==&#39;__main__&#39;：中调用run方法]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>爬虫实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言笔记（3）]]></title>
    <url>%2F2019%2F10%2F22%2Fc%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[结构体结构体声明1234567struct Book&#123; 结构体成员1; 结构体成员2; 结构体成员3; ......&#125;;定义结构体类型变量struct 结构体名称 结构体变量名访问结构体变量要访问结构体成员，我们需要引入一个新的运算符——点号(.)运算符。比如book.title就是引用book结构体的title成员，它是一个字符数组。初始结构体的指定成员值其语法和数组指定初始化元素类似，不过结构体指定初始化成员使用点号（.）运算符和成员名123456789101112131415161718192021222324252627282930313233343536//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;struct Book&#123; char title[128]; char author[40]; float price; unsigned int data; char publisher[40];&#125;book;int main(void)&#123;// struct Book book1; printf("请输入书名："); scanf("%s", book.title); printf("请输入作者："); scanf("%s", book.author); printf("请输入售价："); scanf("%f", &amp;book.price); printf("请输入出版日期："); scanf("%d", &amp;book.data); printf("请输入出版社："); scanf("%s", book.publisher); printf("\n====数据录入完毕====\n\n"); printf("书名：%s\n", book.title); printf("作者：%s\n", book.author); printf("售价：%.2f\n", book.price); printf("出版日期：%d\n", book.data); printf("出版社：%s\n", book.publisher); return 0;&#125;结构体嵌套123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;struct Data&#123; int year; int month; int day;&#125;;struct Book&#123; char title[128]; char author[40]; float price; struct Data data; char publisher[40];&#125;book = &#123; // 初始化 "c学习", "Luenci", 48.8, &#123;2019,11,13&#125;, "文华出版社"&#125;;int main(void)&#123; printf("\n====数据录入为====\n\n"); printf("书名：%s\n", book.title); printf("作者：%s\n", book.author); printf("售价：%.2f\n", book.price); printf("出版日期：%d%d%d\n", book.data.year, book.data.month, book.data.day); printf("出版社：%s\n", book.publisher); return 0;&#125;out书名：c学习作者：Luenci售价：48.80出版日期：20191113出版社：文华出版社结构体数组第二种方法是先声明一个结构体类型（如上例子中Book），再用此类型定义一个结构体数组：12345678910111213struct 结构体名称&#123; 结构体成员;&#125;;struct 结构体名称 数组名[长度];// 初始化结构体数组struct Book book[3] = &#123; &#123;"《零基础学c》", "Luenci", 49.5, &#123;2016, 11, 22&#125;, "清华大学出版社"&#125;， &#123;"《零基础学c》", "Luenci", 49.5, &#123;2016, 11, 22&#125;, "清华大学出版社"&#125;， &#123;"《零基础学c》", "Luenci", 49.5, &#123;2016, 11, 22&#125;, "清华大学出版社"&#125;， &#125;；结构体指针12struct Book *ptr；ptr = &amp;book；通过结构体指针访问结构体成员(*结构体指针).成员名结构体指针-&gt;成员名1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;struct Data&#123; int year; int month; int day;&#125;;struct Book&#123; char title[128]; char author[40]; float price; struct Data data; char publisher[40];&#125;book = &#123; // 初始化 "c学习", "Luenci", 48.8, &#123;2019,11,13&#125;, "文华出版社"&#125;;int main(void)&#123; struct Book *ptr; ptr = &amp;book; printf("\n====数据录入为====\n\n"); printf("书名：%s\n", (*ptr).title); printf("作者：%s\n", (*ptr).author); printf("售价：%.2f\n", (*ptr).price); printf("出版日期：%d%d%d\n", (*ptr).data.year, (*ptr).data.month, (*ptr).data.day); printf("出版社：%s\n", (*ptr).publisher); printf("书名：%s\n", ptr-&gt;title); printf("作者：%s\n", ptr-&gt;author); printf("售价：%.2f\n", ptr-&gt;price); printf("出版日期：%d%d%d\n", ptr-&gt;data.year, ptr-&gt;data.month, ptr-&gt;data.day); printf("出版社：%s\n", ptr-&gt;publisher); return 0;&#125;out:====数据录入为====书名：c学习作者：Luenci售价：48.80出版日期：20191113出版社：文华出版社链表单链表12345graph LRhead --&gt; AA[信息域- 指针] --&gt; B[信息域- 指针]B[信息域- 指针] --&gt; c[信息域- 指针]c[信息域- 指针] --&gt; NULL头插法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// ------------ 头插法实现链表的插入 ---------------//// Created by Luenci on 2019/10/14.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Book&#123; char title[128]; char author[40]; struct Book *next;&#125;;void getInput(struct Book *book)&#123; printf("请输入书名："); scanf("%s", book-&gt;title); printf("请输入作者："); scanf("%s", book-&gt;author);&#125;void add_book(struct Book **library)&#123; struct Book *book, *temp; book = (struct Book *)malloc(sizeof(struct Book)); if(book == NULL)&#123; printf("分配内存失败"); exit(1); &#125; getInput(book); if (*library != NULL)&#123; temp = *library; *library = book; book-&gt;next = temp; &#125; else&#123; *library = book; book-&gt;next = NULL; &#125;&#125;void printLibrary(struct Book *library)&#123; struct Book *book; int count = 1; book = library; while(book != NULL)&#123; printf("Book%d: ", count); printf("书名：%s", book-&gt;title); printf("作者:%s", book-&gt;author); book = book-&gt;next; count++; &#125;&#125;void releaseLibrary(struct Book *library)&#123; while(library != NULL)&#123; library = library-&gt;next; free(library); &#125;&#125;int main(void)&#123; struct Book *library = NULL; int ch; while (1)&#123; printf("请问你是否需要录入书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; add_book(&amp;library); &#125; else&#123; break; &#125; &#125; printf("请问你是否需要打印书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; printLibrary(library); &#125; releaseLibrary(library); return 0;&#125;尾插法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//// Created by Luenci on 2019/10/14.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Book&#123; char title[128]; char author[40]; struct Book *next;&#125;;void getInput(struct Book *book)&#123; printf("请输入书名："); scanf("%s", book-&gt;title); printf("请输入作者："); scanf("%s", book-&gt;author);&#125;void add_book2(struct Book **library)&#123; /* ------------ 尾插法 ------------- */ struct Book *book,*temp; book = (struct Book *)malloc(sizeof(struct Book)); if(book == NULL)&#123; printf("分配内存失败"); exit(1); &#125; getInput(book); if (*library != NULL)&#123; temp = *library; // 定位单链表的尾部位置 while (temp-&gt;next != NULL)&#123; temp = temp-&gt;next; &#125; // 插入数据 temp-&gt;next = book; book-&gt;next = NULL; &#125; else&#123; *library = book; book-&gt;next = NULL; &#125;&#125;void printLibrary(struct Book *library)&#123; struct Book *book; int count = 1; book = library; while(book != NULL)&#123; printf("Book%d: ", count); printf("书名：%s", book-&gt;title); printf("作者:%s", book-&gt;author); book = book-&gt;next; count++; &#125;&#125;void releaseLibrary(struct Book **library)&#123; struct Book *temp; while(library != NULL)&#123; temp = *library; *library = (*library)-&gt;next; free(temp); &#125;&#125;int main(void)&#123; struct Book *library = NULL; int ch; while (1)&#123; printf("请问你是否需要录入书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; add_book2(&amp;library); &#125; else&#123; break; &#125; &#125; printf("请问你是否需要打印书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; printLibrary(library); &#125; releaseLibrary(&amp;library); return 0;&#125;尾插法改进123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178//// Created by Luenci on 2019/10/14.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct Book&#123; char title[128]; char author[40]; struct Book *next;&#125;;void getInput(struct Book *book);void add_book(struct Book **library);void getInput(struct Book *book);void add_book2(struct Book **library);void printLibrary(struct Book *library);struct Book *searchBook(struct Book *library, char *target);void releaseLibrary(struct Book **library);void printBook(struct Book *book);void getInput(struct Book *book)&#123; printf("请输入书名："); scanf("%s", book-&gt;title); printf("请输入作者："); scanf("%s", book-&gt;author);&#125;void add_book(struct Book **library)&#123; /* ----------- 头插法 ------------- */ struct Book *book, *temp; book = (struct Book *)malloc(sizeof(struct Book)); if(book == NULL)&#123; printf("分配内存失败"); exit(1); &#125; getInput(book); if (*library != NULL)&#123; temp = *library; *library = book; book-&gt;next = temp; &#125; else&#123; *library = book; book-&gt;next = NULL; &#125;&#125;void add_book2(struct Book **library)&#123; /* ------------ 尾插法 ------------- */ struct Book *book; static struct Book *tail; book = (struct Book *)malloc(sizeof(struct Book)); if(book == NULL)&#123; printf("分配内存失败"); exit(1); &#125; getInput(book); if (*library != NULL)&#123; tail-&gt;next = book; book-&gt;next = NULL; &#125; else&#123; *library = book; book-&gt;next = NULL; &#125; tail = book;&#125;void printLibrary(struct Book *library)&#123; struct Book *book; int count = 1; book = library; while(book != NULL)&#123; printf("Book%d: ", count); printf("书名：%s", book-&gt;title); printf("作者:%s", book-&gt;author); book = book-&gt;next; count++; &#125;&#125;void releaseLibrary(struct Book **library)&#123; struct Book *temp; while(library != NULL)&#123; temp = *library; *library = (*library)-&gt;next; free(temp); &#125;&#125;struct Book *searchBook(struct Book *library, char *target)&#123; struct Book *book; book = library; while (book != NULL)&#123; // C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false if (!strcmp(book-&gt;title, target) || !strcmp(book-&gt;author, target))&#123; break; &#125; book = book-&gt;next; &#125; return book;&#125;void printBook(struct Book *book)&#123; printf("书名: %s\n", book-&gt;title); printf("作者: %s\n", book-&gt;author);&#125;int main(void)&#123; struct Book *library = NULL; struct Book *book; char *input[128]; int ch; while (1)&#123; printf("请问你是否需要录入书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; add_book2(&amp;library); &#125; else&#123; break; &#125; &#125; printf("请问你是否需要打印书籍信息（Y/N）:"); do&#123; ch = getchar(); &#125;while (ch != 'Y' &amp;&amp; ch != 'N'); if (ch == 'Y')&#123; printLibrary(library); &#125; printf("\n请输入书名或作者："); scanf("%s", input); book = searchBook(library, input); if(book == NULL)&#123; printf("很抱歉没能找到！\n"); &#125; else&#123; do&#123; printf("已找到符合条件的书籍...\n"); printBook(book); &#125; while ((book = searchBook(book-&gt;next, input)) != NULL); &#125; releaseLibrary(&amp;library); return 0;&#125;链表的插入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//// Created by Luenci on 2019/10/16.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Node&#123; int value; struct Node *next;&#125;;void insertNode(struct Node **head, int value);void printNode(struct Node *head);void insertNode(struct Node **head, int value)&#123; struct Node *previous; struct Node *current; struct Node *new; current = *head; previous = NULL; while (current != NULL &amp;&amp; current-&gt;value &lt; value)&#123; previous = current; current = current-&gt;next; &#125; new = (struct Node *)malloc(sizeof(struct Node)); if (new == NULL)&#123; printf("分配内存失败！\n"); exit(1); &#125; new-&gt;value = value; new-&gt;next = current; if (previous == NULL)&#123; *head = new; &#125; else&#123; previous-&gt;next = new; &#125;&#125;void printNode(struct Node *head)&#123; struct Node *current; current = head; while (current != NULL)&#123; printf("%d ", current-&gt;value); current = current-&gt;next; &#125; putchar('\n');&#125;int main()&#123; struct Node *head = NULL; int input; while (1)&#123; printf("请输入一个整数（-1结束）："); scanf("%d", &amp;input); if(input == -1)&#123; break; &#125; insertNode(&amp;head, input); printNode(head); &#125; return 0;&#125;链表的删除123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//// Created by Luenci on 2019/10/16.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Node&#123; int value; struct Node *next;&#125;;void insertNode(struct Node **head, int value);void printNode(struct Node *head);void delectNode(struct Node **head, int value);void insertNode(struct Node **head, int value)&#123; struct Node *previous; struct Node *current; struct Node *new; current = *head; previous = NULL; while (current != NULL &amp;&amp; current-&gt;value &lt; value)&#123; previous = current; current = current-&gt;next; &#125; new = (struct Node *)malloc(sizeof(struct Node)); if (new == NULL)&#123; printf("分配内存失败！\n"); exit(1); &#125; new-&gt;value = value; new-&gt;next = current; if (previous == NULL)&#123; *head = new; &#125; else&#123; previous-&gt;next = new; &#125;&#125;void delectNode(struct Node **head, int value)&#123; struct Node *previous; struct Node *current; current = *head; previous = NULL; while (current != NULL &amp;&amp; current-&gt;value != value)&#123; previous = current; current = current-&gt;next; &#125; if (current == NULL)&#123; printf("找不到匹配的节点"); return; &#125; else&#123; if(previous == NULL)&#123; *head = current-&gt;next; &#125; else&#123; previous-&gt;next = current-&gt;next; &#125; free(current); &#125;&#125;void printNode(struct Node *head)&#123; struct Node *current; current = head; while (current != NULL)&#123; printf("%d ", current-&gt;value); current = current-&gt;next; &#125; putchar('\n');&#125;int main()&#123; struct Node *head = NULL; int input; printf("开始测试插入整数...\n"); while (1)&#123; printf("请输入一个整数（-1结束）："); scanf("%d", &amp;input); if(input == -1)&#123; break; &#125; insertNode(&amp;head, input); printNode(head); &#125; printf("开始测试删除整数...\n"); while (1)&#123; printf("请输入一个整数（-1结束）："); scanf("%d", &amp;input); if(input == -1)&#123; break; &#125; delectNode(&amp;head, input); printNode(head); &#125; return 0;&#125;内存池优点：设计内存池的目标是为了保证服务器长时间高效的运行，通过对申请空间小而申请频繁的对象进行有效管理，减少内存碎片的产生，合理分配管理用户内存，从而减少系统中出现有效空间足够，而无法分配大块连续内存的情况。结论：内存池基本上满足初期设计目标，但是她并不是完美的，有缺陷，比如,不能申请大于256字节的内存空间，无内存越界检查，无内存自动回缩功能等。只是这些对我们的影响还不是那么重要。typedef基础相比起宏定义的直接替换， typedef是对类型的封装。1234567891011121314151617181920//// Created by Luenci on 2019/10/16.//#include&lt;stdio.h&gt;typedef int integer;int main(void)&#123; integer a; int b; a = 1; b = a; printf("a = %u\n", a); printf("b = %d\n", b); printf("size of a = %d\n", sizeof(a)); return 0;&#125;123456789101112131415161718192021222324252627//// Created by Luenci on 2019/10/16.//#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Data&#123; int year; int mouth; int day;&#125; DATA, *PDATA;int main(void)&#123; struct Data *data; data = (PDATA)malloc(sizeof(DATA)); if (data == NULL)&#123; printf("内存分配失败！\n"); exit(1); &#125; data-&gt;year = 2019; data-&gt;mouth = 10; data-&gt;day = 16; printf("%d-%d-%d\n", data-&gt;year, data-&gt;mouth, data-&gt;day);&#125;进阶Typedef在变成中使用typedef目的一般有两个：一个是给变量起一个容易记住且意义明确的别名另一个是简化一些比较复杂的类型声明共用体共用体的所有成员共享同一个内存地址。123456union 共用体名称&#123; 共用成员1； 共用成员2； 共用成员3；&#125;;123456789101112131415161718192021222324252627282930313233343536373839//// Created by Luenci on 2019/10/19.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;union Test&#123; int i; double pi; char str[6];&#125;;int main(void)&#123; union Test test; test.i = 50; test.pi = 1.2; strcpy(test.str, "Luenci"); printf("addr of test.i:%p\n", &amp;test.i); printf("addr of test.pi:%p\n", &amp;test.pi); printf("addr of test.str:%p\n", &amp;test.str); printf("value of test.i:%d\n", test.i); printf("value of test.i:%.2f\n", test.pi); printf("value of test.i:%s\n", test.str); return 0;&#125;out：addr of test.i:0061FF18addr of test.pi:0061FF18addr of test.str:0061FF18value of test.i:1852142924value of test.i:0.00value of test.i:Luenci​枚举类型如果一个变量只有几种可能的值，那么就可以将其定义为枚举（enumeration）类型。12345// 声明enum 枚举类型名称 &#123;枚举值名称, 枚举值名称...&#125;// 定义enum 枚举类型名称 枚举变量1, 枚举变量;​123456789101112131415161718192021222324252627282930313233343536//// Created by Luenci on 2019/10/19.//#include &lt;stdio.h&gt;#include &lt;time.h&gt;int main(void)&#123; enum Week &#123;sun, mon, tue, wed, thu, fri, sat&#125;; enum Week today; struct tm *p; time_t t; time(&amp;t); p = localtime(&amp;t); today = p-&gt;tm_wday; switch (today)&#123; case mon: case tue: case wed: case thu: case fri: printf("学习！！！\n"); break; case sat: case sun: printf("放假！\n"); break; default: printf("Error!\n"); &#125; return 0;&#125;位域使用位域的做法是在结构体定义时，在结构体成员后面使用冒号（：）和数字来表示该成员所占的位数。无名位域位域成员可以没有名称，只要给出数据类型和位宽即可1234567struct Test&#123; unsigned int x:100; unsigned int y:200; unsigned int z:300; unsigned int :424;&#125;;单片机单片机（Microcontrollers）是一种集成电路芯片，是采用超大规模集成电路技术把具有数据处理能力的中央处理器CPU、随机存储器RAM、只读存储器ROM、多种I/0口和中新系统、定时器/计数器等功能（可能还包括显示驱动电路、脉宽调制电路、模拟多路转换器、A/D转换器等电路）集成到一块硅片上构成的一个小而完善的微型计算机条统，在工业控制领域广泛应用。位操作逻辑位运算符按位取反（~）逻辑位运算符中优先级最高的是按位取反运算符，它的运算符是一个~符号，作用是将1变成0，将0变成1：按位与（&amp;）优先级第二高的是按位与运算符，它的运算符是一个&amp;符号（而逻辑与是两个&amp;符号）按位异或（^）优先级排第三的是按位异或运算符，它的运算符是一个个符号，只有当两个操作数对应的二进制位不同时，它的结果才为1，否则为0：按位或（|）逻辑位运算符中优先级最低的是按位或运算符，它的运算符是一个|符号（而逻辑或是两个I符号）和赋值号结合这四个运算符，除了按位取反只有一个操作数之外，其它三个都可以跟赋值号（=）结合到一块，使得代码更加简洁！1234567891011121314151617181920212223242526//// Created by Luenci on 2019/10/19.//#include &lt;stdio.h&gt;int main(void)&#123; int mask = 0xFF; int v1 = 0xABCDEF; int v2 = 0xABCDEF; int v3 = 0xABCDEF; v1 &amp;= mask; v2 |= mask; v3 ^= mask; printf("v1 = 0x%x\n", v1); printf("v2 = 0x%x\n", v2); printf("v3 = 0x%x\n", v3); return 0;&#125;out:v1 = 0xefv2 = 0xabcdffv3 = 0xabcd10移位运算符A = 0011 1100左移位运算符二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。A &lt;&lt; 2 将得到 240，即为 1111 0000右移位运算符二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。A &gt;&gt; 2 将得到 15，即为 0000 1111一些未定义行为左移、右移运算符右边的操作数如果是为负数，或者右边的操作数火于左边操作数支持的最大宽度，那么表达式的结果均是属于“未定义行为”。左边的操作数是有符号还是无符号数其实也对移位运算符有着不同的影响。无等号数肯定没问题，因为这时候变量里边所有的位都用于表示该数值的大小。但如果是有符号数，那就要区别对待了，因为有符号数的左边第一位是符号位，所以如果恰好这个操作数是个负数，那么移动之后是否覆盖符号位的决定权还是落到了编译器上。文件操作文件概念计算机文件（或称文件、电脑档案、档亲），是存储在基种长期储存设备或临时存储设备中的一段数据流，并且归属于计算机文件系统管理之下。所谓“长期储存设备”一般指磁盘、光盘、磁带等。而“短期存储设备”一般指计算机内存。需要注意的是，存储于长期存储设备的文件不一定是长期存储的，有些也可能是程序或条统运行中产生的临时数据，并于程序或系统退出后删除。打开文件您可以使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：1FILE *fopen( const char * filename, const char * mode );在这里，filename 是字符串，用来命名文件，访问模式 mode 的值可以是下列值中的一个：模式描述r打开一个已有的文本文件，允许读取文件。w打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。a打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。r+打开一个文本文件，允许读写文件。w+打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。a+打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：1"rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b"关闭文件为了关闭文件，请使用 fclose( ) 函数。函数的原型如下：1int fclose( FILE *fp );如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量。C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。写入文件下面是把字符写入到流中的最简单的函数：1int fputc( int c, FILE *fp );函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：1int fputs( const char *s, FILE *fp );函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。您也可以使用 int fprintf(FILE *fp,const char *format, …) 函数来写把一个字符串写入到文件中。读写单个字符fgetc函数描述C 库函数 char *fgets(char *str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。声明下面是 fgets() 函数的声明。1char *fgets(char *str, int n, FILE *stream)参数str – 这是指向一个字符数组的指针，该数组存储了要读取的字符串。n – 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。返回值如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。如果发生错误，返回一个空指针。getc函数描述C 库函数 int getc(FILE *stream) 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。声明下面是 getc() 函数的声明。1int getc(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要在上面执行操作的流。返回值该函数以无符号 char 强制转换为 int 的形式返回读取的字符，如果到达文件末尾或发生读错误，则返回 EOF单个字符写入fputc函数描述C 库函数 int fputc(int char, FILE *stream) 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。声明下面是 fputc() 函数的声明。1int fputc(int char, FILE *stream)参数char – 这是要被写入的字符。该字符以其对应的 int 值进行传递。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符的流。返回值如果没有发生错误，则返回被写入的字符。如果发生错误，则返回 EOF，并设置错误标识符。puts函数描述C 库函数 int putc(int char, FILE *stream) 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。声明下面是 putc() 函数的声明。1int putc(int char, FILE *stream)参数char – 这是要被写入的字符。该字符以其对应的 int 值进行传递。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符的流。返回值该函数以无符号 char 强制转换为 int 的形式返回写入的字符，如果发生错误则返回 EOF。区别fgetc（fputc）函数和getc （putc）函数两个的功和描述基本上是一模一样的，它们的区别主要在于实现上：fgetc（fputc）是一个函数；而getc （putc）则是一个宏的实现一般来说宏产生较大的代码，但是避免了函数调用的堆栈操作，所以速度会比较快。由于getc是由宏实现的，对其参数可能有不止一次的调用，所以不能使用带有副作用（side effects）的参数。123456789101112131415161718192021222324252627282930//// Created by Luenci on 2019/10/20.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; FILE *fp1; FILE *fp2; int ch; if ((fp1 = fopen("D:\\c_study\\test.txt", "r")) == NULL)&#123; printf("打开文件失败！\n"); exit(EXIT_FAILURE); &#125; if ((fp2 = fopen("D:\\c_study\\demo2.txt", "w")) == NULL)&#123; printf("打开文件夹失败！\n"); exit(EXIT_FAILURE); &#125; while ((ch = fgetc((fp1))) != EOF)&#123; fputc(ch, fp2); &#125; fclose(fp1); fclose(fp2); return 0;&#125;读写整个字符串fgets函数描述C 库函数 char *fgets(char *str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。声明下面是 fgets() 函数的声明。1char *fgets(char *str, int n, FILE *stream)参数str – 这是指向一个字符数组的指针，该数组存储了要读取的字符串。n – 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。返回值如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。如果发生错误，返回一个空指针。fputs函数描述C 库函数 int fputs(const char *str, FILE *stream) 把字符串写入到指定的流 stream 中，但不包括空字符。声明下面是 fputs() 函数的声明。1int fputs(const char *str, FILE *stream)参数str – 这是一个数组，包含了要写入的以空字符终止的字符序列。stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符串的流。返回值该函数返回一个非负值，如果发生错误则返回 EOF。feof()函数描述C 库函数 int feof(FILE *stream) 测试给定流 stream 的文件结束标识符。声明下面是 feof() 函数的声明。1int feof(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。返回值当设置了与流关联的文件结束标识符时，该函数返回一个非零值，否则返回零。123456789101112131415161718192021222324252627282930313233343536//// Created by Luenci on 2019/10/20.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX 1024int main(void)&#123; FILE *fp1; char buff[MAX]; if ((fp1 = fopen("D:\\c_study\\demo3.txt", "w")) == NULL)&#123; printf("打开文件失败！\n"); exit(EXIT_FAILURE); &#125; fputs("Luenci 的文件操作1 。\n", fp1); fputs("Luenci 的文件操作2 。\n", fp1); fclose(fp1); if ((fp1 = fopen("D:\\c_study\\demo3.txt", "r")) == NULL)&#123; printf("打开文件失败！\n"); exit(EXIT_FAILURE); &#125; while (!feof(fp1))&#123; fgets(buff, MAX, fp1); printf("%s", buff); &#125; fclose(fp1); return 0;&#125;格式化读写文件fprintf（）函数描述C 库函数 int fprintf(FILE *stream, const char *format, …) 发送格式化输出到流 stream 中。声明下面是 fprintf() 函数的声明。1int fprintf(FILE *stream, const char *format, ...)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。format – 这是 C 字符串，包含了要被写入到流 stream 中的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是1%[flags][width][.precision][length]specifier，具体讲解如下：specifier（说明符）输出c字符d 或 i有符号十进制整数e使用 e 字符的科学科学记数法（尾数和指数）E使用 E 字符的科学科学记数法（尾数和指数）f十进制浮点数g自动选择 %e 或 %f 中合适的表示法G自动选择 %E 或 %f 中合适的表示法o有符号八进制s字符的字符串u无符号十进制整数x无符号十六进制整数X无符号十六进制整数（大写字母）p指针地址n无输出%字符flags（标识）描述-在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。+强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。(space)如果没有写入任何符号，则在该值前面插入一个空格。#与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。 与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。0在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。width（宽度）描述(number)要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。*宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。.precision（精度）描述.number对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。 对于 g 和 G 说明符：要输出的最大有效位数。 对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 对于 c 类型：没有任何影响。 当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。.*精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。length（长度）描述h参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。l参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。L参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。附加参数 – 根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。返回值如果成功，则返回写入的字符总数，否则返回一个负数。fread()函数描述C 库函数 size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 从给定流 stream 读取数据到 ptr 所指向的数组中。声明下面是 fread() 函数的声明。1size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)参数ptr – 这是指向带有最小尺寸 size*nmemb 字节的内存块的指针。size – 这是要读取的每个元素的大小，以字节为单位。nmemb – 这是元素的个数，每个元素的大小为 size 字节。stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。返回值成功读取的元素总数会以 size_t 对象返回，size_t 对象是一个整型数据类型。如果总数与 nmemb 参数不同，则可能发生了一个错误或者到达了文件末尾。fwrite（）函数描述C 库函数 size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) 把 ptr 所指向的数组中的数据写入到给定流 stream 中。声明下面是 fwrite() 函数的声明。1size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)参数ptr – 这是指向要被写入的元素数组的指针。size – 这是要被写入的每个元素的大小，以字节为单位。nmemb – 这是元素的个数，每个元素的大小为 size 字节。stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。返回值如果成功，该函数返回一个 size_t 对象，表示元素的总数，该对象是一个整型数据类型。如果该数字与 nmemb 参数不同，则会显示一个错误。文件随机读写ftell（）函数描述C 库函数 long int ftell(FILE *stream) 返回给定流 stream 的当前文件位置。声明下面是 ftell() 函数的声明。1long int ftell(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。返回值该函数返回位置标识符的当前值。如果发生错误，则返回 -1L，全局变量 errno 被设置为一个正值。rewind() 函数描述C 库函数 void rewind(FILE *stream) 设置文件位置为给定流 stream 的文件的开头。声明下面是 rewind() 函数的声明。1void rewind(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。fseek() 函数描述C 库函数 int fseek(FILE *stream, long int offset, int whence) 设置流 stream 的文件位置为给定的偏移 offset，参数 offset 意味着从给定的 whence 位置查找的字节数。声明下面是 fseek() 函数的声明。1int fseek(FILE *stream, long int offset, int whence)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。offset – 这是相对 whence 的偏移量，以字节为单位。whence – 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一：常量描述SEEK_SET文件的开头SEEK_CUR文件指针的当前位置SEEK_END文件的末尾返回值如果成功，则该函数返回零，否则返回非零值。可移植性问题想要编写可移植的代码，就需要考虑以下问题：对于以二进制模式打开的文件，fseek函数在某些操作系统可能不支持SEEK_END位置。一对于以文本模式打开的文件，fseek函数的whence参数只能取SEEK_SET才是有意义的，并且传递给offset参数的值要么是0，要么是上一次对同个文件调用fte11函数获得的返回值。标准流和错误处理文件流标准输入（stdin）标准输入（stdout）标准错误输出（stderr）重定向由于标准输出和标准错误输出通常都是直接打印到屏幕上，为了区分宅们，我们可以使用Linux shell的重定向功能：重定向标准输入使用 &lt;重定向标准输出使用 〉重定向标准错误输出使用 2〉错误处理错误指示器 - ferror（）描述C 库函数 int ferror(FILE *stream) 测试给定流 stream 的错误标识符。声明下面是 ferror() 函数的声明。1int ferror(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。返回值如果设置了与流关联的错误标识符，该函数返回一个非零值，否则返回一个零值。使用clearerr函数可以人为地清除文件末尾指示器和错误指示器的状态。ferror函数只能检测是否出错，但无法获取错误原因。不过，大多数系统函数在出现错误的时候会将错误原因记录在errno中。perror函数可以直观地打印出错误原因。描述C 库函数 void perror(const char *str) 把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 str，后跟一个冒号，然后是一个空格。声明下面是 perror() 函数的声明。1void perror(const char *str)参数str – 这是 C 字符串，包含了一个自定义消息，将显示在原本的错误消息之前。返回值该函数不返回任何值strerror（）函数直接返回错误码对应的错误信息。描述C 库函数 char *strerror(int errnum) 从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。strerror 生成的错误字符串取决于开发平台和编译器。声明下面是 strerror() 函数的声明。1char *strerror(int errnum)参数errnum – 错误号，通常是 errno。返回值该函数返回一个指向错误字符串的指针，该错误字符串描述了错误 errnum。12345678910111213141516171819202122232425//// Created by Luenci on 2019/10/20.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;int main(void)&#123; FILE *fp; if(fp = fopen("bucunzai.txt", "r") == NULL)&#123; printf("出错啦，原因就是：%d\n", errno); fprintf(stderr, "出错啦，原因就是：%s", strerror(errno) ); perror("出错啦，原因就是：");// fputs("打开文件失败！\n", stderr); exit(EXIT_FAILURE); &#125; fclose(fp); return 0;&#125;I/O 缓冲区标准I/O提供的三种类型的缓冲模式按块执行按块缓存也称为全缓存，即在填满缓冲区后才进行实际的设备读写操作；按行执行按行缓存是指在接收到换行符（’\n’）之前，数据都是先缓存在缓冲区的；不缓存也就是允许你直接读写设备上的数据。setvbuf()函数描述C 库函数 int setvbuf(FILE *stream, char *buffer, int mode, size_t size) 定义流 stream 应如何缓冲。声明下面是 setvbuf() 函数的声明。1int setvbuf(FILE *stream, char *buffer, int mode, size_t size)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流。buffer – 这是分配给用户的缓冲。如果设置为 NULL，该函数会自动分配一个指定大小的缓冲。mode – 这指定了文件缓冲的模式：模式描述_IOFBF全缓冲：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充。_IOLBF行缓冲：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符。_IONBF无缓冲：不使用缓冲。每个 I/O 操作都被即时写入。buffer 和 size 参数被忽略。size –这是缓冲的大小，以字节为单位。返回值如果成功，则该函数返回 0，否则返回非零值。fflush（）函数描述C 库函数 int fflush(FILE *stream) 刷新流 stream 的输出缓冲区。声明下面是 fflush() 函数的声明。1int fflush(FILE *stream)参数stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个缓冲流。返回值如果成功，该函数返回零值。如果发生错误，则返回 EOF，且设置错误标识符（即 feof）]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C结构体打包技艺]]></title>
    <url>%2F2019%2F10%2F19%2FC%E8%AF%AD%E8%A8%80%E6%89%93%E5%8C%85%E6%8A%80%E8%89%BA%2F</url>
    <content type="text"><![CDATA[失传的 C 结构体打包技艺（转）转自： https://fishc.com.cn/forum.php?mod=viewthread&amp;tid=83418&amp;extra=page%3D2%26filter%3Dtypeid%26typeid%3D571作者：Eric S. Raymond原文链接：http://www.catb.org/esr/structure-packing谁应阅读本文如果你在内存容量受限的嵌入式系统中写程序，或者编写操作系统内核代码，就有必要了解这项技术。如果数据集巨大，应用时常逼近内存极限，这项技术会有所帮助。倘若你非常非常关心如何最大限度地减少处理器缓存段（cache-line）未命中情况的发生，这项技术也有所裨益。2013 年底，我大量应用了一项 C 语言优化技术，这项技术是我早在二十余年前就已掌握的，但彼时之后，鲜有使用。通过精心调整结构成体员的顺序，可以在这种情况下大幅减少内存占用。其效果显著——在上述案例中，可以减少 40% 的内存空间。程序应用于更大的软件仓库，也不会因内存耗尽而崩溃。事出有因。计算机科学课程（正确地）引导人们远离微观优化，转而寻求更理想的算法。计算成本一路走低，令压榨内存的必要性变得越来越低。旧日里，黑客们通过在陌生的硬件架构中跌跌撞撞学习 —— 如今已不多见。首先需要了解的是，对于现代处理器，C 编译器在内存中放置基本 C 数据类型的方式受到约束，以令内存的访问速度更快。用行话来说，x86 和 ARM 上的基本 C 类型是“自对齐（self-aligned）”的。关于指针，无论 32 位（4 字节）还是 64 位（8 字节）也都是自对齐的。我提到“现代处理器”，是因为有些老平台强迫 C 程序违反对齐规则（例如，为 int 指针分配一个奇怪的地址并试图使用它），不仅令速度减慢，还会导致非法指令错误。例如 Sun SPARC 芯片就有这种问题。事实上，如果你下定决心，并恰当地在处理器中设置标志位（e18），在 x86 平台上，也能引发这种错误。你还可以通过 pragma 指令（通常为 ）强迫编译器不采用处理器惯用的对齐规则。但请别随意运用这种方式，因为它强制生成开销更大、速度更慢的代码。通常，采用我在下文介绍的方式，可以节省相同或相近的内存。#pragma pack我们来看一个关于变量在内存中分布的简单案例。思考形式如下的一系列变量声明，它们处在一个 C 模块的顶层。然而实际情况（在 x86、ARM 或其他采用自对齐类型的平台上）如下。存储 p 需要自对齐的 4 或 8 字节空间，这取决于机器字的大小。这是指针对齐 —— 极其严格。1234561. char *p; /* 4 or 8 bytes */2. char c; /* 1 byte */3. char pad[3]; /* 3 bytes */4. int x; /* 4 bytes */字符数组 pad[3] 意味着在这个结构体中，有 3 个字节的空间被浪费掉了。老派术语将其称之为“废液（slop）”。1231. char *p;2. char c;3. short x;在这个例子中，实际分布将会是：1231. char *p;2. char c;3. long x;我们将得到：1231. char c;2. char *p;3. int x;假如实际内存分布可以写成下面这样：首先，在此例中，N 将为 0，x 的地址紧随 p 之后，能确保是与指针对齐的，因为指针的对齐要求总比 int 严格。不过更有可能的情况是，c 将被映射为机器字的首字节。于是乎 M 将会用于填充，以使 p 指针对齐——32 位系统中为 3 字节，64 位系统中为 7 字节。倘若你希望这些变量占用的空间更少，那么可以交换 x 与 c 的次序。在讲述这部分内容前，我们先对标量数组做个说明。在具有自对齐类型的平台上，char、short、int、long 和指针数组都没有内部填充，每个成员都与下一个成员自动对齐。通常情况下，结构体实例以其最宽的标量成员为基准进行对齐。编译器之所以如此，是因为此乃确保所有成员自对齐，实现快速访问最简便的方法。假如你对此有疑惑，ANSI C 提供了一个 宏，可用于读取结构体成员位移。123451. struct foo1 &#123;2. char *p;3. char c;4. long x;5. &#125;;假定处在 64 位系统中，任何 struct fool 的实例都采用8字节对齐。不出所料，其内存分布将会像下面这样：12345678910111. struct foo2 &#123;2. char c; /* 1 byte */3. char pad[7]; /* 7 bytes */4. char *p; /* 8 bytes */5. long x; /* 8 bytes */6. &#125;;如果成员是互不关联的变量，c便可能从任意位置起始，pad的大小则不再固定。因为struct foo2的指针需要与其最宽的成员为基准对齐，这变得不再可能。现在 c 需要指针对齐，接下来填充的7个字节被锁定了。结构体尾填充的通用法则是：编译器将会对结构体进行尾填充，直至它的跨步地址。这条法则决定了 sizeof() 的返回值。12345671. struct foo3 &#123;2. char *p; /* 8 bytes */3. char c; /* 1 byte */4. &#125;;5. 6. struct foo3 singleton;7. struct foo3 quad[4];复制代码你以为 的值是 9，但实际是 16。它的跨步地址是 。于是，在 quad 数组中，每个成员都有 7 字节的尾填充，因为下个结构体的首个成员需要在 ８ 字节边界上对齐。内存分布就好像这个结构是这样声明的：12341. struct foo4 &#123;2. short s; /* 2 bytes */3. char c; /* 1 byte */4. &#125;;因为 s 只需要 2 字节对齐，跨步地址仅在 c 的 1 字节之后，整个 struct foo4 也只需要 1 字节的尾填充。形式如下：的返回值将为 4。12345671. struct foo5 &#123;2. short s;3. char c;4. int flip:1;5. int nybble:4;6. int septet:7;7. &#125;;关于位域需要了解的是，它们是由字（或字节）层面的掩码和移位指令实现的。从编译器的角度来看，struct foo5 中的位域就像 ２ 字节、16 位的字符数组，只用到了其中 12 位。为了使结构体的长度是其最宽成员长度 的整数倍，接下来进行了填充。1234567891. struct foo6 &#123;2. char c;3. struct foo5 &#123;4. ​ char *p;5. ​ short x;6. &#125; inner;7. &#125;;内层结构体成员 char *p 强迫外层结构体与内层结构体指针对齐一致。在 64 位系统中，实际的内存分布将类似这样：理解了编译器在结构体中间和尾部插入填充的原因与方式后，我们来看看如何榨出这些废液。此即结构体打包的技艺。消除废液最简单的方式，是按对齐值递减重新对结构体成员排序。即让所有指针对齐成员排在最前面，因为在 64 位系统中它们占用 8 字节；然后是 4 字节的 int；再然后是 2 字节的 short，最后是字符。123451. struct foo7 &#123;2. char c;3. struct foo7 *p;4. short x;5. &#125;;将隐含的废液写明，形式如下：12345671. struct foo8 &#123;2. struct foo8 *p;3. short x;4. char c;5. &#125;;考虑到自对齐，我们看到所有数据域之间都不需填充。因为有较严对齐要求（更长）成员的跨步地址对不太严对齐要求的（更短）成员来说，总是合法的对齐地址。重打包过的结构体只需要尾填充：注意，重新打包不能确保在所有情况下都能节省空间。将这项技术应用于更靠前 struct foo6 的那个例子，我们得到：123456789101. struct foo9 &#123;2. struct foo9_inner &#123;3. char *p; /* 8 bytes */4. int x; /* 4 bytes */5. char pad[4]; /* 4 bytes */6. &#125; inner;7. char c; /* 1 byte */8. char pad[7]; /* 7 bytes */9. &#125;;结果还是 24 字节，因为 c 无法作为内层结构体的尾填充。要想节省空间，你需要得新设计数据结构。棘手的标量案例#define请当心，重打包结构体时，枚举型变量通常是 int，这与编译器相关；但也可能是 short、long、甚至默认为 char。编译器可能会有 预处理指令或命令行选项指定枚举的尺寸。以上两种情况，最好用 来检查存储尺寸。尽管按尺寸重排是最简单的消除废液的方式，却不一定是正确的方式。还有两个问题需要考量：可读性与缓存局部性。笨拙地、机械地重排结构体可能有损可读性。倘若有可能，最好这样重排成员：将语义相关的数据放在一起，形成连贯的组。最理想的情况是，结构体的设计应与程序的设计相通。为保持可读性所做的工作（将相关和同时访问的数据放在临近位置）也会提高缓存段的局部性。这些都是需要明智地重排，并对数据的存取模式了然于心的原因。是的，某些时候，这种做法与前文将相关数据放入与缓存段长度相同块的做法矛盾。多线程的确是个难题。缓存段弹跳和其他多线程优化问题是很高级的话题，值得单独为它们写份指导。这里我所能做的，只是让你了解有这些问题存在。其他打包技术你可能会有一点儿存取时间的损失，但只要将工作集合压缩得足够小，那点损失可以靠避免缓存未命中补偿。这不仅减小了结构体的可见尺寸，还可以消除废液和/或创造额外的机会来进行重新排序。这种良性串连的效果不难被触发。clang 编译器有个 Wpadded 选项，可以生成有关对齐和填充的信息。读者可以下载一段程序源代码 ，验证上文有关标量和结构体尺寸的结论。理解这些规则的第二个层次是，知其何时及如何会被打破。在我学习它们的日子里（1980 年代早期），我们把不理解这些规则的人称为“所有机器都是 VAX 综合症”的牺牲品。记住，世上所有电脑并非都是 PC。]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>扩展知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言笔记（2）]]></title>
    <url>%2F2019%2F10%2F13%2FC%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[先举三反一，再举一反三，学习就应该是这样，先模仿，再改进，最后实现自己的创意！ –小甲鱼论坛递归调用函数本身设置递归结束条件12345678910111213141516171819202122232425262728293031323334353637383940//// Created by Luenci on 2019/10/11.//#include &lt;stdio.h&gt;void fun(void);long fact(int num);void fun(void)&#123; static int count = 10; printf("Hi\n"); if (count--)&#123; fun(); &#125;&#125;long fact(int num)&#123; long result; if(num &gt; 0)&#123; result = num * fact(num-1); &#125; else&#123; result = 1; &#125; return result;&#125;int main(void)&#123;// fun(); int num; long re; printf("请输入您要求阶乘的数："); scanf("%d", &amp;num); re = fact(num); printf("%d", re); return 0;&#125;汉罗塔123456789101112131415161718192021222324#include&lt;stdio.h&gt;void hanoi(int n, char x, char y, char z);void hanoi(int n, char x, char y, char z)&#123; if(n==1)&#123; printf("%c --&gt; %c \n", x,z); &#125; else&#123; // 将前n-1个圆盘借助z移动到y hanoi(n-1, x, z, y); printf("%c --&gt; %c \n", x,z); // 将前n-1个圆盘借助x移动到z hanoi(n-1, y, x, z); &#125;&#125;int main(void)&#123; int n; printf("请输入您的层数："); scanf("%d", &amp;n); hanoi(n, 'X', 'Y', 'Z'); return 0;&#125;快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//// Created by Luenci on 2019/10/11.//#include &lt;stdio.h&gt;void quick_sort(int array[], int left, int right);void quick_sort(int array[], int left, int right) &#123; int i = left, j = right; int temp; // 交换的中间变量 int pivot; // 基准点 pivot = array[(left + right) / 2]; while (i &lt;= j) &#123; // 从右往左找到大于等于基准点的元素 while (array[i] &lt; pivot) &#123; i++; &#125; // 从右到左找到小于等于基准点的元素 while (array[j] &gt; pivot) &#123; j--; &#125; // 如果 i &lt;= j,则互换 if (i &lt;= j) &#123; temp = array[i]; array[i] = array[j]; array[j] = temp; i++; j++; &#125; &#125; if (left &lt; j) &#123; quick_sort(array, left, j); &#125; if (i &lt; right) &#123; quick_sort(array, i, right); &#125;&#125;int main(void)&#123; int array[] = &#123;73, 108, 111, 101, 78, 109, 66, 48, 88, 135&#125;; int i, length; // 计算数组的长度 length = sizeof(array) / sizeof(array[0]); quick_sort(array, 0, length-1); printf("排序后的结果是："); for (i = 0; i &lt; length; i++)&#123; printf("%d ,", array[i]); &#125; putchar('\n'); return 0;&#125;动态内存管理malloc申请动态内存空间free释放动态内存空间calloc申请并初始化一系列内存空间realloc重新分配内训空间malloc函数函数原型void *malloc（size_t size）malloc函数向系统申请分配size个字节的内存空间，并返回一个指向这块空间的地址。如果函数调用成功，返回一个指向申请的内存空间的指针，由于返回类型是void 指针（void * ）， 所以它是可以被转换成任何类型的数据；如果函数调用失败，返回值是NULL。另外，如果size的参数设置为0，返回值也可能是NULL，但这并不意味着函数调用失败。free函数函数原型void free（void *ptr）free函数释放ptr参数指向的内存空间。该内存空间必须是有malloc，calloc或realloc函数申请的。否则，该函数将导致未定义行为。如果ptr参数是NULL，则不执行任何操作。注意：该函数并不会修改ptr参数的值，所以调用后仍然指向原来的地方（变为非法空间）。123456789101112131415161718192021222324252627//// Created by Luenci on 2019/10/12.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int *ptr; ptr = (int *)malloc(sizeof(int)); if(ptr == NULL)&#123; printf("分配内存失败"); exit(1); &#125; printf("请输入一个整数："); scanf("%d", ptr); printf("您输入的整数是:%d\n", *ptr); free(ptr); printf("您输入的整数是:%d\n", *ptr); return 0;&#125;内存泄漏隐式内存泄漏用完内存块没有及时使用free函数释放丢失内存块的地址初始化内存空间mem开头的函数被编入字符串标准库，函数的声明包含在string.h这个头文件中：memset – 使用一个常量字节填充空间memcpy – 拷贝内存空间memmove – 拷贝内存空间memcmp – 比较内存空间memchr – 在内存空间中搜索一个字符123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by Luenci on 2019/10/12.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define N 10int main(void)&#123; int *ptr = NULL; int i; ptr = (int *)malloc(N * sizeof(int)); if(ptr == NULL)&#123; exit(1); &#125; memset(ptr, 0, N * sizeof(int)); for (i= 0; i &lt; N; i++) &#123; printf("%d ", ptr[i]); &#125;// putchar("\n"); putchar('\n'); free(ptr); return 0;&#125;/*1、含义不同。用单引号引起的一个字符实际上代表一个整数，整数值对应于该字符在编译器采用的字符集中的序列值。而一般我们的编译器采用的都是ASCII字符集。因此's'的含义其实和十进制数115的含义是一致的。而用双引号引起的字符串，代表的是一个指向无名数组起始字符的指针。2、大小不同。用单引号引起的一个字符大小就是一个字节。而用双引号引起的字符串大小是字符的总大小+1，因为用双引号引起的字符串会在字符串末尾添加一个二进制为0的字符'\0'。*/calloc函数函数原型void *calloc(size_t nmemb, sizet_t size);calloc函数在内存中动态地申请nmemb个长度为size的连续内存空间（即申请的总空间尺寸为nmemb * size），这些内存空间全部被初始化为 0.calloc函数与malloc函数的一个重要区别是：calloc函数在申请完内存后，自动初始化该内存空间为零malloc函数不进行初始化操作，里面数据是随机的12345678// 两者等价// calloc() 分配内存空间并初始化int *ptr = （int *）calloc（8， sizeof（int））；//malloc()分配内存空间并用memset（）初始化int *ptr = (int *)malloc(8 * sizeof(int))；memset(prt, 0, 8 * sizeof(int));realloc函数如果ptr参数为NULL，那么调用该函数就相当于调用malloc（size）如果size参数为0，并且ptr参数不为NULL，那么调用该函数就相当于调用free（ptr）除非ptr参数为NULL，否则ptr的值必须由先前调用malloc，calloc或realloc函数返回。1234567891011121314151617181920212223242526272829303132//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int i, num; int count = 0; int *ptr = NULL;// 注意这里必须初始化为NULL do &#123; printf("请输入一个整数：（输入-1表示结束）"); scanf("%d", &amp;num); count++; ptr = (int *)realloc(ptr, count * sizeof(int)); if(ptr == NULL)&#123; exit(1); &#125; ptr[count-1] = num; &#125;while(num != -1); printf("输入的整数分别是："); for (int i = 0; i &lt;count ; i++) &#123; printf("%d ", ptr[i]); &#125; free(ptr); return 0;&#125;c语言的内存布局代码段代码段（Text segment）通常是指用来存放在程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读。在代码段中，也有可能包含一些只读的常熟变量，例如字符串常量等。BSS段BSS段（BSS segment/Uninitialized data segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BBS是英文Block Started Symbol的简称，这个区段中的数据在程序运行前将被自动初始化为数字0。堆堆是用于存放进程中被动态分配的内存段，它的大小并不固定，可动态扩展或缩小。当进程调用malloc等函数分配内存时，新分配的内存就被动态调价到对上；当利用free等函数释放内存时，被释放的内存从堆中被剔除。栈栈是函数执行的内存区域，通常和堆共享同一片区域。堆和栈的区别申请方式堆是由程序员手动申请栈时系统自动分配释放方式堆是由程序员手动释放栈由系统自动释放生存周期堆的生存周期由动态申请到程序员主动释放位置，不同函数之间均可自由访问。栈的生存周期由函数调用开始到函数返回时结束，函数之间的局部变量不能互相访问。高级宏定义本质就是替换内联函数在程序函数调用时，直接展开，而不是去查找调用。内联函数嵌入调用者代码中的操作是一种优化操作，因此只有进行优化编译时才会执行代码嵌入处理。若编译过程中没有使用优化选项‘-o’，那么内联函数的代码就不会真正地嵌入到函数调用者代码中，而是只作为普通函数调用来处理。内联函数虽然节省了函数调用的时间消耗，但由于每一个函数出现的地方都要进行替换，因此增加了代码的编译时间。另外，并不是所有的函数都能变成内联函数现在的编译器也很智能，就算你不写inline，它也会自动将一些函数优化成内联函数不带参数的宏定义为了和普通的变量进行区分，宏的名字通常我们约定是由大写字母组成宏定义只是简单地进行替换，并且由于预处理是在编译之前进行，而编译工作的任务之一就是语法检查，所以编译器不会对宏定义进行语法检查宏定义不是说明或语句，在末尾不必加分号宏定义的作用是从定义的位置开始到整个程序的结束可以用 #undef 来终止宏定义的作用域宏定义允许嵌套12345678910111213141516171819//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define PI 3.14int main()&#123; int r; float s; printf("请输入圆的半径："); scanf("%d", &amp;r);// #undef PI 终止宏定义 s = PI * r * r; printf("圆的面积是：%.2f\n", s);&#125;123456789101112131415//// Created by Luenci on 2019/10/13.//// 宏定义的嵌套#include &lt;stdio.h&gt;#define R 6371#define PI 3.14#define V PI * R * R * R * 4 / 3int main()&#123; printf("地球的体积是：%.2f\n", V);&#125;带参数的宏定义12345678910111213141516//// Created by Luenci on 2019/10/13.////带参数的宏定义#include &lt;stdio.h&gt;#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))int main()&#123; int x,y; printf("请输入两个数："); scanf("%d%d", &amp;x, &amp;y); printf("%d是最大的那个数！\n", MAX(x, y));&#125;‘#’ 和 ‘##’‘#’ 和 ‘##’是两个预处理运算符在带参数的宏定义中， #运算符后面应该跟着一个参数，预处理器会把这个参数转换为一个字符串。1234567891011121314//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define STR(s) # sint main(void)&#123; printf(STR(Hlloc %s num = %d), STR(Luenci), 520); return 0;&#125;out :Hlloc Luenci num = 520‘##’运算符被称为记号连接运算符，我们可以使用’##’运算符连接两个参数。123456789101112131415161718192021222324252627 //// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define TOGETHER(x,y) x ## yint main(void)&#123; printf("%d\n", TOGETHER(2,50)); return 0;&#125;//// Created by Luenci on 2019/10/13.//#include &lt;stdio.h&gt;#define TOGETHER(x,y) x ## yint main(void)&#123; printf("%d\n", TOGETHER(2,50)); return 0;&#125;out:250可变参数之前学习了如何让函数支持可变参数，带参数的宏定义是使用可变参数的：1#define SHOWLIST（...） printf（#__VA_ARGS__）其中…表示可变参数，1#__VA_ARGS__在预处理中被实际的参数集所替代。123456789101112#include &lt;stdio.h&gt;#define SHOWLIST(...) printf(#__VA_ARGS__)int main(void)&#123; SHOWLIST(Luenci,5 20, 3.14 \n); return 0;&#125;out:Luenci,5 20, 3.1412345678910111213#include &lt;stdio.h&gt;#define SHOWLIST(format, ...) printf(#format, ##__VA_ARGS__)int main(void)&#123; SHOWLIST(num = %d\n,520); SHOWLIST(hello Luenci\n); return 0;&#125;out:num = 520hello Luenci]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言笔记（1）]]></title>
    <url>%2F2019%2F10%2F13%2FC%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[ps:先举三反一，再举一反三，学习就应该是这样，先模仿，再改进，最后实现自己的创意！ –小甲鱼论坛C语言中各种数据类型所占用的存储空间的大小int—32位 四个字节float —32位 四个字节char—8位 一个字节double—-64位 8个字节bool—-16位 2个字节long—-32位 四个字节整数类型下表列出了关于标准整数类型的存储大小和值范围的细节：类型存储大小值范围char1 字节-128 到 127 或 0 到 255unsigned char1 字节0 到 255signed char1 字节-128 到 127int2 或 4 字节-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647unsigned int2 或 4 字节0 到 65,535 或 0 到 4,294,967,295short2 字节-32,768 到 32,767unsigned short2 字节0 到 65,535long4 字节-2,147,483,648 到 2,147,483,647unsigned long4 字节0 到 4,294,967,295浮点类型下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：类型存储大小值范围精度float4 字节1.2E-38 到 3.4E+386 位小数double8 字节2.3E-308 到 1.7E+30815 位小数long double16 字节3.4E-4932 到 1.1E+493219 位小数void 类型void 类型指定没有可用的值。它通常用于以下三种情况下：序号类型与描述1函数返回为空 C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);2函数参数为空 C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);3指针指向 void 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。C语言运算符优先级优先级运算符名称或含义使用形式结合方向说明1[]数组下标数组名[常量表达式]左到右()圆括号（表达式）/函数名(形参表).成员选择（对象）对象.成员名-&gt;成员选择（指针）对象指针-&gt;成员名2-负号运算符-表达式右到左单目运算符(类型)强制类型转换(数据类型)表达式++自增运算符++变量名/变量名++单目运算符–自减运算符–变量名/变量名–单目运算符*取值运算符*指针变量单目运算符&amp;取地址运算符&amp;变量名单目运算符!逻辑非运算符!表达式单目运算符~按位取反运算符~表达式单目运算符sizeof长度运算符sizeof(表达式)3/除表达式/表达式左到右双目运算符*乘表达式*表达式双目运算符%余数（取模）整型表达式/整型表达式双目运算符4+加表达式+表达式左到右双目运算符-减表达式-表达式双目运算符5&lt;&lt;左移变量&lt;&lt;表达式左到右双目运算符&gt;&gt;右移变量&gt;&gt;表达式双目运算符6&gt;大于表达式&gt;表达式左到右双目运算符&gt;=大于等于表达式&gt;=表达式双目运算符&lt;小于表达式&lt;表达式双目运算符&lt;=小于等于表达式&lt;=表达式双目运算符7==等于表达式==表达式左到右双目运算符!=不等于表达式!= 表达式双目运算符8&amp;按位与表达式&amp;表达式左到右双目运算符9^按位异或表达式^表达式左到右双目运算符10|按位或表达式|表达式左到右双目运算符11&amp;&amp;逻辑与表达式&amp;&amp;表达式左到右双目运算符12||逻辑或表达式||表达式左到右双目运算符13?:条件运算符表达式1? 表达式2: 表达式3右到左三目运算符14=赋值运算符变量=表达式右到左/=除后赋值变量/=表达式*=乘后赋值变量*=表达式%=取模后赋值变量%=表达式+=加后赋值变量+=表达式-=减后赋值变量-=表达式&lt;&lt;=左移后赋值变量&lt;&lt;=表达式&gt;&gt;=右移后赋值变量&gt;&gt;=表达式&amp;=按位与后赋值变量&amp;=表达式^=按位异或后赋值变量^=表达式|=按位或后赋值变量|=表达式15,逗号运算符表达式,表达式,…左到右从左向右顺序运算注：同一优先级的运算符，运算次序由结合方向所决定。break和continue语句区别break语句结束当前循环continue语句跳过本次循环二维下标直接索引和指针间接索引的相互转化1234*（array + i） = array[i]*(*(array + i) + j) = array[i][j]*(*(*(array + i) + j) + K) = array[i][j][k] ...二维数组和数组指针的关系12345678910111213141516171819202122//// Created by Luenci on 2019/10/5.//#include &lt;stdio.h&gt;int main()&#123; int array[2][3] = &#123;&#123;0, 1, 2&#125;, &#123;4, 5, 6&#125;&#125;; int (*p)[3] = array; printf("**(p+1): %d\n", **(p+1)); printf("**(array+1): %d\n", **(array+1)); printf("array[1][0]: %d\n", array[1][0]); printf("*(*(p+1)+2): %d\n", *(*(p+1)+2)); printf("*(*(array+1)+2): %d\n", *(*(array+1)+2)); printf("array[1][2]: %d\n", array[1][2]); return 0;&#125;void指针和NULL指针Void指针void指针我们把它称之为通用指针，就是可以指向任意类型的数据。也就是说，任何类型的指针都可以赋值给void指针。123456789101112131415161718192021//// Created by Luenci on 2019/10/5.//#include &lt;stdio.h&gt;int main()&#123; int num = 1024; int *pi = &amp;num; char *ps = "Luenci"; void *pv; pv = pi; printf("pi:%p, pv:%p\n", pi,pv); printf("*pv:%d\n", *(int *)pv); pv = (char *)ps; printf("ps:%p, pv:%p\n", ps, pv); printf("*pv:%s\n", (char *)pv); return 0;&#125;NULL指针当你还不清楚要将指针初始值为什么地址时，请先将它初始化为NULL；在对指针进行解引用时，先检查该指针是否为NULL。这种策略可以为今后编写大型程序 节省大量的 调试时间。1#define NULL ((void *)0)1234567891011121314//// Created by Luenci on 2019/10/5.//#include &lt;stdio.h&gt;int null_pointer()&#123; int *p1; int *p2 = NULL; printf("%d\n", *p1); printf("%d\n", *p2); return 0;&#125;指向指针的指针123456789101112131415161718192021int main()&#123; int num = 520; int *p = &amp;num; int **pp = &amp;p; printf("num: %d\n", num); printf("*p: %d\n", *p); printf("**PP: %d\n", **pp); printf("&amp;p: %p, pp:%p\n", &amp;p, pp); printf("&amp;num:%p, p:%p, *pp:%p\n", &amp;num,p,*pp); return 0;&#125; out: num: 520 *p: 520 **PP: 520 &amp;p: 0061FF14, pp:0061FF14 &amp;num:0061FF18, p:0061FF18, *pp:0061FF18指针数组和指向指针的指针123456789101112131415161718192021222324252627282930313233343536373839int pointer_array()&#123; char *cBooks[] = &#123; &quot;&lt;c程序设计语言&gt;&quot;, &quot;&lt;c专家编程&gt;&quot;, &quot;&lt;c和指针&gt;&quot;, &quot;&lt;c prime plus&gt;&quot;, &quot;&lt;C study&gt;&quot; &#125;; char **byLuenci; char **byGood[4]; byLuenci = &amp;cBooks[4]; byGood[0] = &amp;cBooks[0]; byGood[1] = &amp;cBooks[1]; byGood[2] = &amp;cBooks[2]; byGood[3] = &amp;cBooks[3]; printf(&quot;Luenci拥有的书: %s\n&quot;, *byLuenci); printf(&quot;Luenci喜欢的图书有：\n&quot;); int i; for (int i = 0; i &lt; 4; ++i) &#123; printf(&quot;%s\n&quot;,*byGood[i]); &#125; return 0;&#125;out: Luenci拥有的书: &lt;C study&gt;Luenci喜欢的图书有：&lt;c程序设计语言&gt;&lt;c专家编程&gt;&lt;c和指针&gt;&lt;c prime plus&gt;常量定义1234567891011520，‘a’, 3.14#define price 520#define A 'a'#define PI 3.14 // 使用const关键字修饰 const int price = 520;const char A = 'a';const float pi = 3.14;指向常量的指针指针可以修改为指向不同的常量指针可以修改为指向不同的变量可以通过解引用来读取指针指向的数据不可以通过解引用修改指针指向的数据123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int num =520; const int cnum = 880; const int *pc = &amp;cnum; printf("cnum:%d, &amp;cum:%p \n", cnum, &amp;cnum); printf("*pc:%d, pc:%p\n", *pc, pc); pc = &amp;num; printf("num:%d, &amp;num:%p \n", num, &amp;num); printf("*pc:%d, pc:%p\n", *pc, pc); return 0;&#125;函数结构1234类型名 函数名（参数列表）&#123; 函数体&#125;函数的声明所谓的声明（Declaration），就是告诉编译器我要是用这个函数，你现在没有找到它的定义不要紧，请不要报错，稍后我将会把它补上。函数的参数和返回值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;void print_c();int sum(int n);int max(int x, int y);int max(int x, int y)&#123; // a？b:c 当a的值为真时，返回b的值；否则返回c的值 return x &gt; y ? x:y;&#125;int sum(int n)&#123; int result = 0; do &#123; result += n; &#125;while (n-- &gt; 0); return result;&#125;void print_c()&#123; printf(" ###### \n"); printf("## ##\n"); printf("## \n"); printf("## \n"); printf("## ##\n"); printf(" ###### \n");&#125;int main()&#123; print_c(); int n,x,y;// printf("请输入n的值："); printf("请输入x,y的值：");// scanf("%d", &amp;n); scanf("%d%d", &amp;x, &amp;y);// printf("1+2+3+...+(n-1)+n的结果是：%d\n",sum(n)); printf("x,y中最大值的值为：%d\n", max(x,y)); return 0;&#125;形参和实参用于数据传输，形参就相当与一个占位符，只在函数内部有效。传值和传址1234567891011121314151617181920212223242526//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;void swap(int *x, int *y);void swap(int *x, int *y)&#123; int *temp; printf("In swap 互换前：x %d, y %d\n", *x,*y); temp = *x; *x = *y; *y = temp; printf("In swap 互换后：x %d, y %d\n", *x,*y);&#125;int main()&#123; int x = 3, y = 5; printf("In main 互换前：x %d, y %d\n", x,y); swap(&amp;x,&amp;y); printf("In main 互换后：x %d, y %d\n", x,y); return 0;&#125;传数组实际上传过去的是数组的地址123456789101112131415void get_array(int b[10])&#123; printf("sizeof b: %d\n", sizeof(b));&#125;int main()&#123; int a[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; printf("sizeof a:%d\n", sizeof(a)); get_array(a); out:sizeof a:40sizeof b: 4可变参数引入 头文件#include&lt;stdarg.h&gt;123456789101112131415161718192021222324252627282930313233343536373839//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;int sum(int n, ...);int sum(int n, ...)&#123; int i; int sum = 0; va_list vap; va_start(vap, n); for(i = 0; i &lt; n; i++)&#123; sum += va_arg(vap, int); &#125; va_end(vap); return sum;&#125;int main()&#123; int result,result2,result3; result = sum(3,1,2,-3); printf("result:%d\n", result); result2 = sum(4,2,2,4,2); printf("result2:%d\n", result2); result3 = sum(4,2,8,4,-2); printf("result3:%d\n", result3); return 0;&#125;指针函数使用指针变量作为函数的返回值，就是指针函数123456789101112131415161718192021222324252627282930313233343536373839//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;char *getchartchar();char *getchart(char c)&#123; switch (c) &#123; case &apos;A&apos;: return &quot;Apple&quot;; case &apos;B&apos;: return &quot;Banana&quot;; case &apos;C&apos;: return &quot;Cat&quot;; case &apos;D&apos;: return &quot;Dog&quot;; default: return &quot;None&quot;; &#125;&#125;int main()&#123; char input; printf(&quot;请输入一个字母：&quot;); scanf(&quot;%c&quot;, &amp;input); printf(&quot;%s\n&quot;, getchart(input)); return 0;&#125;in:Aout:ApplePS:不要返回局部变量的指针函数指针指针函数 - - &gt; int *p();函数指针 - - &gt; int (*p)();函数指针作为参数12345678910111213141516171819202122232425262728//// Created by Luenci on 2019/10/8.//#include &lt;stdio.h&gt;int add(int, int);int sub(int, int);int clac(int (*fp)(int, int), int, int);int add(int num1, int num2)&#123; return num1 + num2;&#125;int sub(int num1, int num2)&#123; return num1 - num2;&#125;int clac(int (*fp)(int, int), int num1, int num2)&#123; return (*fp)(num1, num2);&#125;int main()&#123; printf("3 + 5 = %d\n", clac(add, 3,5)); printf("3 - 5 = %d\n", clac(sub, 3,5)); return 0;&#125;函数指针作为返回值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//// Created by Luenci on 2019/10/10.//#include &lt;stdio.h&gt;int add(int, int);int sub(int, int);int calc(int (*)(int, int), int, int);int (*slect(char))(int,int);int add(int num1, int num2)&#123; return num1 + num2;&#125;int sub(int num1, int num2)&#123; return num1 - num2;&#125;int calc(int (*fp)(int, int),int num1, int num2)&#123; return (*fp)(num1, num2);&#125;int (*slect(char op))(int, int)&#123; switch(op)&#123; case '+': return add; case '-': return sub; &#125;&#125;int main()&#123; int num1, num2; char op; int (*fp)(int, int); printf("请输入一个式子 (如 1+3) :"); scanf("%d%c%d", &amp;num1, &amp;op, &amp;num2); fp = slect(op); printf("%d %c %d = %d\n", num1, op, num2, calc(fp, num1, num2)); return 0;&#125;局部变量和全局变量局部变量不同函数的变量无法相互访问全局变量如果不对全局变量进行初始化，那么它会自动初始化为0.如果函数在内部存在一个与全局变量同名的局部变量，编译器不会报错，而是在函数中屏蔽全局变量。exsten关键字告诉编译器我等下会定义变量，不要报错不要大量的使用全局变量使用全局变量会使你的程序占用更多的内存，因为全局变量从定义时候开始，知道程序退出才释放。污染命名空间提高了程序耦合性作用域和链接属性当变量被定义在不同的位置时，它的作用域的范围是不一样的，这个作用范围就是我们所说的作用域C语言编译器可以确认四种不同类型的作用域：代码块的作用域文件作用域原型作用域函数作用域代码块作用域（Block scope）在代码块中定义的变量，具有代码块作用域。作用范围是从变量定义的位置开始，到标志代码块结束的大括号（}）处。文件作用域（file scope）任何在代码块之外声明的标识符都具有文件作用域，作用域的范围是从他们的声明位置开始，到文件的结尾处都是可以访问的。原型作用域（prototype scope）原型作用域只适用于那些在函数原型中声明的参数名。函数作用域（function scope）函数作用域只适合于goto语句的标签，作用将goto语句得标签限制在同一个函数内部，以防止出现重名的标签。定义和声明当一个变量被定义的时候，编译器为变量申请内存空间并填充值当一个变量被声明的时候，编译器就知道该变量被定义在其他地方声明是通知编译器该变量名及相关的类型已经存在，不需要再为此申请内存空间。局部变量即是定义又是声明定义只能来一次，否则就叫做重复定义某个同名的变量；而声明可以由你很多次。链接属性external（外部的）多个文件中声明的同名标识符表示一个实体internal（内部的）单个文件中声明的同名标识符表示同一个实体none（无）声明的同名标识符被当做独立的不同实体只有具备文件作用域的标识符才能拥有external或internal的链接属性，其他作用域的标识符都是none属性。默认情况下，具备文件的作用域的标识符拥有external属性。也就是说该标识符允许跨文件访问。对于external属性的标识符，无论在不同文件中声明多少次，表示的都是一个实体。使用static关键字可以使得原先拥有的external属性的标识符变为internal属性。这里有两点需要注意：使用static关键字修改链接属性，只对具有文件作用域的标识符生效（对于拥有其他作用域的标志符是另一种功能）链接属性只能修改一次，也就是说一旦将标识符的链接属性改为internal，就无法变回external。生存期和存储类型C语言变量拥有两种生存周期静态存储器自动存储器具有文件作用域的变量属于静态存储器，函数也属于静态存储器。属于静态存储器的变量在程序执行期间将一直占据存储空间，直到程序关闭才释放具有代码块作用域的变量一般情况下属于自动存储器。属于自动存储期的变量在代码块结束时将自动释放。存储类型存储类型其实是指存储变量值的内存类型，C语言提供了五种类型。autoregisterstaticexterntypedef]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>基本知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django之编写URL]]></title>
    <url>%2F2019%2F10%2F07%2Fdjango%E4%B9%8Burl%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[编写URL编写规则​ 为了使其规范性，在每个新创建的App中设置独立的静态资源和模板文件夹并添加一个空白的.py文件，命为urls.py。如下是创建app中的文件结构：1234567891011121314frist/ migrations/ # 数据库前后是否有变化，生成出迁移文件 static/ # 创建App后存放App中的静态资源文件，自己手动添加 templates/ # 创建App后存放App中的模板文件，自己手动添加 __init__.py admin.py apps.py models.py tests.py urls.py # 创建App后由系统总路由映射到App的路由文件，自己手动添加 view.py系统总路由和app的路由分发配置12345678# 根目录的urls.pyfrom django.contrib import adminfrom django.urls import path,adminurlpatterns = [ path('admin/', admin.site.urls), path('',include('frist.urls')) # 引入app中的urls.py]代码详解:from django.contrib import admin:导入Admin功能模块.from django.urls import path,admin:导入URL编写模块.urlpatterns:整个项目的URL集合,每个元素代表一条URL信息.path(&#39;admin/&#39;, admin.site.urls):设定Admin的URL.&#39;admin/&#39;代表127.0.0.1/admin地址信息,admin后面的斜杠是路径分隔符;admin.site.urls是URL的处理函数,也称为视图函数.path(&#39;&#39;,include(&#39;frist.urls&#39;)):URL为空,代表网站的域名,即127.0.0.1,通常是网站的首页;include将该URL分发给app的urls.py处理.1234567# app下的urls.pyfrom django.urls import pathfrom . import viewsurlpatterns = [ path('',views.index) # 调用和url匹配的视图函数]当根目录的URL分发给app中的URL处理后,下一步就是根据所匹配的URL进行视图的调用.在Views中编写相应的视图函数。如下：12345# index的views.pyfrom django.http import HttpResponse# creat you views here.def index(request): return HttpResponse("hello world")视图函数的参数必须设置为request，该参数代表当前用户的请求对象，该对象包含用户名，请求内容和请求方式等信息，执行完成后必须使用return将处理结果返回。带变量的URL​ 在日常开发中，有时候一个URL可以代表多个不同的页面，如编写带有日期的URL，若根据前面的编写方式，按一年计算，则需要开发者编写365个不同的URL才能实现。这种做法是不可取的，因此，Django在编写URL时，可以对URL设置变量值，使URL具有多样性。​ URL的变量类型有字符类型，整型，slug和uuid，常用的是字符类型和整型。说明如下：字符类型：匹配任何非空字符串，但不含斜杠。如果没有指定类型，默认使用该类型。整形：匹配0和正整数slug：可理解为注释，后缀或附属等概念，常作为URL的解释性字符。可匹配任何ASCII字符以及连接符和下画线，能使URL更加清晰易懂。比如网页的标题是“13岁的孩子”，其URL地址可以设置为“13-sui-de-hai-zi“。uuid：匹配一个uuid格式的对象。为了防止冲突，规定必须使用破折号并且所有字母必须小写，例如0201203-3213-31e-321c34d435（未待完续）]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django简介]]></title>
    <url>%2F2019%2F10%2F07%2Fdjango%E9%85%8D%E7%BD%AE%E5%88%9D%E5%90%AF%2F</url>
    <content type="text"><![CDATA[Django简介背景2003诞生 它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的MVT（框架）Models 模型 数据库Views 视图 放和拿Template 模板 前端From 表单 django 会根据你后台数据库字段及表单层的设计对应的给你创建HTML关于表单的代码Django优点对象关系映射（Object Relational Mapping ORM）：通过定义映射类来构建数据模型，将模型与关系型数据库连接起来，使用ORM框架内置的数据库接口可实现复杂的数据操作。（简单来说就是把数据库的语句换成了python可识别的语言）URL设计：开发者可以设计任意的URL（网站地址）， 而且支持使用正则表达式设计。模板系统：提供可扩展的模板语言，模板之间具有可继承性。表单处理：可以生成各种表单模型，而且表单具有有效性检验功能。Cache系统：完善的缓存系统，可支持多种缓存方式用户管理系统：提供用户认证，权限设置和用户组功能，功能扩展性强。国际化：内置国际化系统，方便开发出多语言的网站。admin管理系统：内置admin管理系统，系统的扩展性强。Django项目目录1234567891011121314用django-admin startproject demo 创建一个demo项目文件结构如下：demo/ # 最外层 这个是整个项目的容器文件夹，可以随意改名字 demo/ # 内层的demo 是这个项目中关于配置文件的一个管理文件夹，这个不允许改名字 __init__.py #初始化文件，代表这个文件夹是一个包，一个模块，demo文件夹就是一个模块了 settings.py # 这个是整个项目的配置文件，配置中间，配置邮件等 urls.py # django项目的总路由配置文件。网站的地址信息 wsgi.py # 全称为Python Web Server Gateway Interface，即为python服务器网关接口， 是python应用与Web服务器之间的接口，用于Django项目在服务器上的部署和上线，一 般不需要修改 manage.py # 命令行工具，允许以多种方式与项目交互。 可输入 python manage.py help 查看 该工具的具体用法Django的创建的App目录使用命令创建app： python manage.py startapp frist创建了App必须把App名称添加到INSTALL_APPS里面。1234567891011121314frist/ migrations/ # 数据库前后是否有变化，生成出迁移文件 static/ # 创建App后存放App中的静态资源文件，自己手动添加 templates/ # 创建App后存放App中的模板文件，自己手动添加 __init__.py admin.py apps.py models.py tests.py urls.py # 创建App后由系统总路由映射到App的路由文件，自己手动添加 view.pyDjango（settings）配置全览123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122"""Django settings for mysite project.Generated by 'django-admin startproject' using Django 2.1.2.For more information on this file, seehttps://docs.djangoproject.com/en/2.1/topics/settings/For the full list of settings and their values, seehttps://docs.djangoproject.com/en/2.1/ref/settings/"""import os# 项目路径# Build paths inside the project like this: os.path.join(BASE_DIR, ...)BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))# Quick-start development settings - unsuitable for production# See https://docs.djangoproject.com/en/2.1/howto/deployment/checklist/# 密匙配置# SECURITY WARNING: keep the secret key used in production secret!SECRET_KEY = '#g$qgqkee8csvp67l$(8ugkx%+i_9k%mbykw-%9zpbnyn!bb!='# 调试模式# SECURITY WARNING: don't run with debug turned on in production!DEBUG = True# 域名访问权限ALLOWED_HOSTS = ['*']# App列表# Application definitionINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'myblog', 'article',]MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]ROOT_URLCONF = 'mysite.urls'TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [BASE_DIR, 'templates'], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', # 自定义模版全局变量(默认变量) 'article.views.global_settings', ], &#125;, &#125;,]WSGI_APPLICATION = 'mysite.wsgi.application'# Database# https://docs.djangoproject.com/en/2.1/ref/settings/#databasesDATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125;# Password validation# https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validatorsAUTH_PASSWORD_VALIDATORS = [ &#123; 'NAME':'django.contrib.auth.password_validation.UserAttributeSimilarityValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator', &#125;,]# Internationalization# https://docs.djangoproject.com/en/2.1/topics/i18n/LANGUAGE_CODE = 'zh-Hans'TIME_ZONE = 'Asia/Shanghai'USE_I18N = TrueUSE_L10N = TrueUSE_TZ = True# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/2.1/howto/static-files/STATIC_URL = '/static/'STATIC_ROOT = os.path.join(BASE_DIR, "static/")项目路径 BASE_DIR：主要通过os模块读取当前项目在系统的具体路径，该代码在创建项目时自动生成，一般情况无需修改密匙配置SECRET_KEY：是一个随机值，在项目创建的时候自动生成，一般情况下无需修改。主要用于重要的数据 加密处理，提高系统的安全性，避免遭到攻击者的恶意破坏。密匙主要用于用户密码，CSRF机制和会话Session等数据加密。12345* 用户密码：Django内置一套用户管理系统，该系统具有用户认证和存储用户信息等功能，在创建用户的时候，将用户的密码通过密匙进行加密处理，保证用户的安全性。* CSRF机制：该机制主要用于表单提交，防止窃取网站的用户信息来制造恶意请求* 会话Session：Session的信息存放在Cookies，以一串随机的字符串表示，用于标识当前访问网站的用户身份，记录相关用户信息。调试模式DEBUG：该值为布尔类型。如果在开发调试阶段应设置为True，在开发调试过程中会自动检测代码是否 发生更改，根据检测结果执行是否刷新重启系统。如果项目部署上线，将其改为False，否则会泄露系统的相关信息。域名访问权限ALLOWED_HOSTS:设置可访问的域名，默认值为空。当DEBUG为True并且ALLOWED_HOSTS为空时，项目只允许以localhost或127.0.0.1在浏览器上访问启动。当DEBUG为False时，ALLOWED_HOSTS为必填项，否则程序无法启动，如果想允许所有域名访问，可设置ALLOW_HOSTS=[‘*’]。App列表INSTALLED_APPS：告诉Django有哪些App。在创建项目时已有admin，auth，和session等配置等信息，这些都是Django内置的应用功能，各个功能说明如下。123456* admin:内置的后台管理系统。* auth：内置的用户认证系统。* contenttypes：记录项目中所有的model元数据（Django的ORM框架）。* session：Session会话功能，用于标识当前访问网站的 用户身份，记录相关用户信息。* message：消息提示功能。* staticfiles：查找静态资源路径。静态资源（static）123456789101112# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/2.1/howto/static-files/STATIC_URL = '/static/' STATIC_ROOT = os.path.join(BASE_DIR, "static/")# 设置根目录的静态资源文件夹staticSTATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'),# 设置App的静态资源文件夹 os.path.join(BASE_DIR, '/static')， ]​​ CSS也称层叠样式表（Cascading Style Sheets），是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。​ JavaScript是一种直译式脚本语言，也是一种动态类型，弱类型，基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。STATIC_URL是必须配置的属性而且属性值不能为空。如果没有配置STATICFILES_DIRS，则STATIC_URL只能识别App里的static静态资源文件夹。STATICFILES_DIRS是可选配置属性，属性值为列表或元组格式，每个列表（元组）元素代表一个静态资源文件夹，这些文件夹可行命名。在浏览器上访问项目的静态资源时，无论项目的静态资源文件夹是如何命名的，在浏览器上，静态资源的上级目录必须为static，而static而STATIC_URL的属性值,因为STATIC_URL也是静态资源的起始URL。​ 除此之外，静态资源配置还有STATIC_ROOT，其作用是方便在服务器上部署项目，实现服务器和项目之间的映射。STATIC_URL和STATICFILES_DIRS区别STATIC_URL是必须配置的属性而且属性的值不能为空。如果没有配置STATICFILES_DIRS,则STATIC_URL只能识别App里面的static静态资源文件夹。STATICFILES_DIRS是可选配置属性，属性值为列表或元组格式，每个列表（元组）元素代表一个静态资源文件夹，这些文件夹可自行命名。在浏览器上访问项目的静态资源时，无论项目的静态资源文件夹是如何命名的，在浏览器上，静态资源的上级目录必须为static，而static是STATIC_URL的属性值，因为STATIC_URL也是静态资源的起始URL。模板路径（template）在web开发中，模板是一种较为特殊的HTML文档。这个HTML文档嵌入了一些能够让Python识别的变量和指令，然后程序解析这些变量和指令，生成完整的HTML网页并返回给用户浏览。模板是Django里面的MTV框架模式的T部分，配置模板路径是Django在解析模板时，如何找到模板所在的位置。创建项目时，Django以有初始的模板配置信息。如下：123456789101112131415161718TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [BASE_DIR, 'templates'], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', # 自定义模版全局变量(默认变量) 'article.views.global_settings', ], &#125;, &#125;,]模板信息是以列表格式呈现的，每个元素具有不同的含义，说明如下：BACKEND：定义模板引擎，用于识别模板里面的变量和指令。内置的模板引擎有DjangoTemplate和jinjia2.Jinjia2，每个模板引擎都有自己的变量和指令语法。DIRS：设置模板所在的路径，告诉Django在那个地方查找模板的位置，默认为空列表APP_DIRS:是否在App里面查找模板文件OPTIONS：用于填充在RequestContext中上下文调用函数，一般情况下不做任何修改。数据库设置（Databases）在settings文件下 有一个DATABASES属性123456789101112131415DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', # 数据库引擎 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), # 本地sqllite3数据库位置 'USER': # 用户名 'PASSWORD': # 数据库密码 'HOST': # 数据库主机地址 &#125; &#125;# 默认的django使用sqllite3作为数据库 # django提供四种 ENGINE 数据库引擎 # django.db.backends.mysql # django.db.backends.oracle # django.db.backends.splite3# 如果你使用的是 PostgreSQL 或者Mysql的话，已经是先创建了数据库，但是默认的SQLlite不需要sqlite3 轻量级数据库（数据存放在文件里面）在Django连接MYSQL数据库时候如果提示django.db.utils.OperationalError的错误信息，这是因为MYSQL8.0版本的密码加密方式发生了变化，8.0版本的用户密码采用的是cha2加密方法。解决方法，把SQL语句将8.0版本加密方法改回原来的加密方式。123# newpassword 是我们设置的用户密码ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'newpassword';FLUSH PRIVILEGES;中间件（Middlewere）中间件（Middleware）是处理Django的request和response对象的钩子。当用户在网站中进行单击某个按钮等操作时，这个动作是用户向网站发送请求（request）；而网页会根据用户的操作返回相关的网页内容，这个过程称为响应处理（response）。从请求到响应的过程中，当Django接收到用户的请求时，Django首先经过中间件处理请求消息，执行相关的处理，然后将处理结果返回给用户，中间件的执行流程如图：如上图，中间件的作用主要是处理用户的请求信息。开发者也可以根据自己的开发需求自定义中间件，只要将自定义的中间件添加到配置属性MIDDLEWARE中即可激活。一般情况下，Django默认的中间件配置均可满足大部分的开发需求。1234567'django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware','django.middleware.csrf.CsrfViewMiddleware','django.contrib.auth.middleware.AuthenticationMiddleware','django.contrib.messages.middleware.MessageMiddleware','django.middleware.clickjacking.XFrameOptionsMiddleware',配置属性MIDDLEWARE的数据格式为列表类型，每个中间件的设置顺序是固定的，如果随意变更中间件很容易导致程序异常，每个中间件的说明如下：SecurityMiddleware：内置的安全机制，保护用户与网站的通信安全。SessionMiddleware：会话Session。LocaleModdleware：支持中文语言。CommonMiddleware：处理请求信息，规范化请求内容。CsrViewMiddleware：开启CSRF防护功能。AuthenticationMiddleware：开启内置的用户认证系统。MessageMiddleware：开启内置的信息提示功能。XFrameOptionsMiddleware：防止恶意程序点击劫持。修改时区及语言LANGUAGE_CODE = ‘en-us’ #语言TIME_ZONE = ‘UTC’ #时区12LANGUAGE_CODE = 'zh-Hans'TIME_ZONE = 'Asia/Shanghai'开启测试服务器用来展示你创建出来的空项目/home/Publc_Class/5-17-django框架/python3 manage.py runserver 0.0.0.0:9090开启了一个测试服务器runserver 可以让你在浏览器看到效果，但是这个是测试服务器，压力不过百创建默认数据库因为django自带的admin界面，首先需要数据库来支持我们来先创建出一个数据库1234makemigrations 数据库前后是否有变化，生成出迁移文件migrate 根据迁移文件 来对应的执行SQL语句 python3 manage.py makemigrationspython3 manage.py migrate如果数据库创建完成，那么目录结构下和manage.py同级的就会有一个db.splite3文件有了这个数据库，就可以创建超级用户来管理admin界面啦！为admin界面创建超级用户数据库有了，要创建超级用户python3 manage.py createsuperuser12345Username (leave blank to use 'root'): rootEmail address: 2573799357@qq.com Password: Password (again): Superuser created successfully.]]></content>
      <categories>
        <category>python的web框架</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高德无人机科技研发岗（测试工程师）面试总结]]></title>
    <url>%2F2019%2F09%2F30%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[输入密码，查看文章 60c6c1d4790a27c1edcecd39c72c8547f5bfe12547a1127d26411c766abe2f8f5b6dc11a6ddad0eb0193536a2f014b95a48a9e5c4d7dbbc84b2e34119aeb66ef5e7342e37014bc70cbe091c1c3500be36129770ec7d13d2c6d4e581b70fd882ef443923c5967fa89412bc42673545b14ae2ed113dd92ebd1ac616c16b4ae05161d9ebc4162d93bcbf7e17d5352b01a1e155f1d1985eabbeec222147e7c38d643f47a0f5e5c7782e1237cd0db906db51271ef6928caa23efaf76b30fa6dbd4618cb58fcda7ababc0ef29920f824d054592fac59b2a8df6d454fa4ae33aa00f8d4a1d84d0c71d68dab1345a2366e7f3013bbe598eca314ea88fc3a54590c122160e370f01b80a86809c302288b53f571571d564ae15d79bf9d6238920921bf8c002f4b15a78dd5ff2976f7950b18687c9997910bd2024f108af94a530911ada02d8b02b41708a93a44120c73bef92aa5f559deac9f7d4937cb96d3b85e0039c5548b481b8c2d671aa5b379d5be5bb4da809fd06990863e12d0fbcab2b1c2508eda6e5c84cf251d5a552bc4331101df043010a837da52e4082f00c514f6b204bc1856f0e3c55ae0e076cbb345bbf0998a879f997ddebede71e9f2c3b8c1e6e99fdd74737e1442caaa5085b83f4ad33ca73f7c6174f06047b0f64cbc2fa6a6ce69ccfa6fc7b3cc8ec41021602b8bdf21b87ba21d5f2278064af82e0d57e7a9610d1cb0d2b09adfe40657b5d528c1566eccdac2c7014e1064a933c17892d06db15ba462eb10da372a5f8d734d8ccda21c283eade61d8b3434135b9b4ebfed0183dc3e723bc7440db7e398d36aa43de15f5fb22710f8ec8b7589f565d7942daf7362e7bededcdc8b2a498dc4f29d699f78a34a8137ebd27afe77624cbfb6b9e952b211604ebfb9a0ae7d0dcac07ef3f69466883e62e92e7f36c93a345820aeb29e62d07358bc111990c2c93aa9d1b26cd69df3427ac0a27464ef740c20937b3fdc12b3bcb14a7a3e72730637cb6fd945e33256749e232f8d1c4eb002c2e7a2cecd524fad0130e9afcff7494a56d3ca854e98dd2d64d6fc8afdd3e06918cde349406d2cad1e2d5f6cc5ca7baa453e06ffe1cc05e8b9e896b91e3c9b3caacc4a0f41cec0b69fc45a1b83fc6cb0c7fa9864861ab30f475d54bb98c30769bc4a9d9fdc23647030fe4e5e1b21d485fa208b9dce2553ed3c360b9db75599962df6b4c9e8aba2e01e6f52d89eaded7ba1bd3140ef80b11c6b57af8579ece6a693990c318364b7d56a12c2263d7c43e3dbcb83275ff9b568b61f98007f7b341de7513ff30a1248e78b511f97f70dfbc408b1687a212e0fdddc723e71a7c660d93a012ab7151a37b87a6e25d63df141cbadf07021c29f205ac2da9e523bf3c44f517c6f2d8b13c7e852a73419e2ccd411615c00fbba00283313198c34687cf8c40b5d6cfc6a6ee31eb1e87ecf26a75fc96e409deb15b1aa69be63b318eecd3071e9c96c1ba7dee0eefed13fee5506accbf9ec346778a0d611ae85ecda5f08a4c82a93507114f2eaaac77778638ce3abcb8d0064b4f958c2ca3e304e8ec46ee3e8f51c88f689ab7d2b557e5672dd4b226b7655a658ad16e268895bf3adb02466a59a4ed65d6666b15bb855216efef3d2e8781e7b3c8d346d1c07e0c9dbe37a227080e50b98db62b2d90cf1d36a795d78846ee7f184a3ac7543740dcfaf4162354bad397846ec128b3f3eed20c4ea18f3258342524f83596cf47470abf7c8ea6fe0e4f98287d6121c96c33707aef2589ba0709f30c2fb2848bdf5c8e9c1c40c03c7adccb61fad3dab0da654b3f65e6c7b4431bc5af60cee9cacb79518fce2fadf10f9e92cdf85582e763b2a12daccd5227e59412805169f052277a176eaa27034eab365a038ad3ebbb31f6f17d4f7d0ad044777b87242bfbde74648a264896c5fca0665d614255cedf2755d8b4310e511fc74a2262be294e9d8377fa18446c63c675bb89590c0a23bdda8569c3094868af8240be38d9b3198466448136c7fe4209aff5f6f317248ebf7fe1cf799d032b6857514442a408afdca79450b17a4adf679c17a30efd3a9fbebcd2b440f183a61ec2459248fe98607d59a31b1d1cf28b2f4c09a949408bd7df312cc1e30caaf9c7817026f32ab2ac18b4446eee25389abaaee2f2599f7f389efbb7ea8018f1ff0bb30d5b1a86fbcbf5404d0a6cad1755a6867ff65a7b5c3f44347a54b13d6344b33f3a2b2f50f29a11faf7294f9746c150c2e67b70b7738555ed5bcb3f922a2c6c10e5964501e7e23bd16d86ce8379f783ae82e56a325e35df5c157781aff13896b1114bf0b3bd7a2ec2cd9fc3dca6dfba6379220aaf3f35ad7ba324eda6d260800fe613dfe85d675897aa33e7e5aaf69ad808681aa8eabbbe408203906da4be967cdde2c8cad814b3fed67be71c744235720c11e3d9f8ed0143f433b3a4f3d1a3f4403e61e47263809ec79787e8d04970756c0ba3fa91927cc72ec3e7b3de446e90eb5995a52c2c83a08bdbf1d6acc22e1778e6689584744ac82105e7fa96acca673050a1148f15648be8b11fc33276baf50085a695b3180090031fc04c94165a02c719964fef75949ad6f6175e5381dcd03a7b0baaaee36c5b5d2878e066c60e1de0fb115c2e77d5d800dbae5d497535006a50aa821bca7cf36c90f5c32ce746ae92167ab0bff8048c67458dfd14579269f19d9395654d8669ca342febf8d81fce9044122ba777344b8d53886b10076f55274f135166a969a84506c82118f482dd828b674a9e8dde0ad84ad28185c03dffa1ee2e35544686dc956a9ad247e03bf525428aa5a8db4749618f23341e1067350c00aa4ef81a68c6b7f5c6edc0dafc767a1463ab0c423620f87641d674adab4673deb0ed55cffd2e503451d537533186d6013004b96d5270fd4460c6cb3e6a7228589596257ed3a1b7b65e20a96fa62e5359611f0f51bd565763922e1a80574617ff08d23a2c0e203ee1e5ec1f4921aac27d07a4024f3ef03a9e429d416af06ab2a6f81f1864ae2a6585af7eae51dc8a99d465415eb04ea6fa8c307f53abefe37aa3ec55300f3b29bc26208ecc64970f16b6275c53ae376f2e01bc93f947c543513e7a2d652b8fc7044dc8549890f8a024ba4f6f690697e37fd70eab99427fdd6c7e17c7a08ca2702572cb1bfa55be0ca93866a81152a]]></content>
      <categories>
        <category>面试经历</category>
      </categories>
      <tags>
        <tag>面试总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 语言中 void* 详解及应用]]></title>
    <url>%2F2019%2F09%2F30%2FC%20%E8%AF%AD%E8%A8%80%E4%B8%AD%20void%20%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[C 语言中 void* 详解及应用void 在英文中作为名词的解释为 “空虚、空间、空隙”，而在 C 语言中，void 被翻译为“无类型”，相应的void * 为“无类型指针”。void 似乎只有”注释”和限制程序的作用，当然，这里的”注释”不是为我们人提供注释，而是为编译器提供一种所谓的注释。void 的作用1.对函数返回的限定，这种情况我们比较常见。2.对函数参数的限定，这种情况也是比较常见的。一般我们常见的就是这两种情况：当函数不需要返回值值时，必须使用void限定，这就是我们所说的第一种情况。例如：void func（int a,char *b）。当函数不允许接受参数时，必须使用void限定，这就是我们所说的第二种情况。例如：int func(void)。void 指针的使用规则\1. void 指针可以指向任意类型的数据，就是说可以用任意类型的指针对 void 指针对 void 指针赋值。例如：123int *a；void *p；p=a；如果要将 void 指针 p 赋给其他类型的指针，则需要强制类型转换，就本例而言：a=（int *）p。在内存的分配中我们可以见到 void 指针使用：内存分配函数 malloc 函数返回的指针就是 void * 型，用户在使用这个指针的时候，要进行强制类型转换，也就是显式说明该指针指向的内存中是存放的什么类型的数据 (int *)malloc(1024) 表示强制规定 malloc 返回的 void* 指针指向的内存中存放的是一个个的 int 型数据。\2. 在 ANSI C 标准中，不允许对 void 指针进行一些算术运算如 p++ 或 p+=1 等，因为既然 void 是无类型，那么每次算术运算我们就不知道该操作几个字节，例如 char 型操作 sizeof(char) 字节，而 int 则要操作 sizeof(int) 字节。而在 GNU 中则允许，因为在默认情况下，GNU 认为 void * 和 char * 一样，既然是确定的，当然可以进行一些算术操作，在这里sizeof(*p)==sizeof(char)。void 几乎只有”注释”和限制程序的作用，因为从来没有人会定义一个 void 变量，让我们试着来定义：1void a;这行语句编译时会出错，提示“illegal use of type ‘void’”。即使 void a 的编译不会出错，它也没有任何实际意义。众所周知，如果指针 p1 和 p2 的类型相同，那么我们可以直接在 p1 和 p2 间互相赋值；如果 p1 和 p2 指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的指针类型转换为左边指针的类型。123456float *p1;int *p2;p1 = p2;//其中p1 = p2语句会编译出错，//提示“&apos;=&apos; : cannot convert from &apos;int *&apos; to &apos;float *&apos;”，必须改为：p1 = (float *)p2;而 void * 则不同，任何类型的指针都可以直接赋值给它，无需进行强制类型转换。123void *p1;int *p2;p1 = p2;但这并不意味着，void * 也可以无需强制类型转换地赋给其它类型的指针。因为”无类型”可以包容”有类型”，而”有类型”则不能包容”无类型”。小心使用 void 指针类型:按照 ANSI(American National Standards Institute) 标准，不能对 void 指针进行算法操作，即下列操作都是不合法的：1234567void * pvoid;pvoid++; //ANSI：错误pvoid += 1; //ANSI：错误//ANSI标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指向数据类型大小的。//例如：int *pint;pint++; //ANSI：正确pint++ 的结果是使其增大 sizeof(int)。但是 GNU 则不这么认定，它指定 void * 的算法操作与 char * 一致。因此下列语句在 GNU 编译器中皆正确：12pvoid++; //GNU：正确pvoid += 1; //GNU：正确pvoid++ 的执行结果是其增大了 1。在实际的程序设计中，为迎合 ANSI 标准，并提高程序的可移植性，我们可以这样编写实现同样功能的代码：123void * pvoid;((char *)pvoid)++; //ANSI：错误；GNU：正确(char *)pvoid += 1; //ANSI：错误；GNU：正确GNU 和 ANSI 还有一些区别，总体而言，GNU 较 ANSI 更”开放”，提供了对更多语法的支持。但是我们在真实设计时，还是应该尽可能地迎合 ANSI 标准。 如果函数的参数可以是任意类型指针，那么应声明其参数为void *。注：void 指针可以任意类型的数据，可以在程序中给我们带来一些好处，函数中形为指针类型时，我们可以将其定义为 void 指针，这样函数就可以接受任意类型的指针。如：典型的如内存操作函数 memcpy 和 memset 的函数原型分别为：12void * memcpy(void *dest, const void *src, size_t len);void * memset ( void * buffer, int c, size_t num );这样，任何类型的指针都可以传入 memcpy 和 memset 中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型（参见 C 语言实现泛型编程）。如果 memcpy 和 memset 的参数类型不是 void *，而是 char *，那才叫真的奇怪了！这样的 memcpy 和 memset 明显不是一个”纯粹的，脱离低级趣味的”函数！void 的出现只是为了一种抽象的需要，如果你正确地理解了面向对象中”抽象基类”的概念，也很容易理解 void 数据类型。正如不能给抽象基类定义一个实例，我们也不能定义一个 void（让我们类比的称 void 为”抽象数据类型”）变量。原文地址：https://www.cnblogs.com/wuyudong/p/c-void-point.html]]></content>
      <categories>
        <category>C语言编程知识</category>
      </categories>
      <tags>
        <tag>Void* 知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机系统组成及工作原理简介]]></title>
    <url>%2F2019%2F09%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[计算机系统组成及工作原理简介硬件系统中央控制器 CPU运算器 ALU又称算数逻辑部件，是计算机用来进行数据运算的部件算数运算加、减、乘、除四则运算逻辑运算与、或、非、异或等逻辑操作，以及移位、比较和传送等操作，亦称算术逻辑部件（ALU）控制器 Controller通过地址访问存储器，逐条取出选中单元的指令，分析指令，根据指令产生相应的控制信号，用于其他各个部件，控制其他部件完成指令要求的操作。存储器 Memory：计算机中具有记忆能力的部件，用来存放程序或数据内存储器内存，又称主存，是CPU能根据地址线直接寻址的存储空间，是计算机内部存放数据的硬件设备，是程序和数据存储的基本要素。外存储器外存，又称辅存，作为一种辅助存储设备，主要用来存放一些暂时不用而又需长期保存的程序或数据。输入设备 Input Device用来输入程序和数据的部件：常用的输入设备有键盘，鼠标，传声器（麦克风），扫描仪，手写板，数码相机，摄像头等。输出设备 Output Device显示输出结果的部件 显示器，音响，打印机，绘图仪。软件系统系统软件管理，监控，维护计算机正常工作和供用户操作使用的计算机软件。应用软件在某种具体应用，供最终用户使用的软件。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas函数]]></title>
    <url>%2F2019%2F08%2F25%2Fpandas%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[【python】Pandas中DataFrame基本函数整理构造函数DataFrame([data, index, columns, dtype, copy]) #构造数据框1属性和数据DataFrame.axes #index: 行标签；columns: 列标签DataFrame.as_matrix([columns]) #转换为矩阵DataFrame.dtypes #返回数据的类型DataFrame.ftypes #返回每一列的 数据类型float64:denseDataFrame.get_dtype_counts() #返回数据框数据类型的个数DataFrame.get_ftype_counts() #返回数据框数据类型float64:dense的个数DataFrame.select_dtypes([include, include]) #根据数据类型选取子数据框DataFrame.values #Numpy的展示方式DataFrame.axes #返回横纵坐标的标签名DataFrame.ndim #返回数据框的纬度DataFrame.size #返回数据框元素的个数DataFrame.shape #返回数据框的形状DataFrame.memory_usage() #每一列的存储12345678910111213类型转换1234DataFrame.astype(dtype[, copy, errors]) #转换数据类型DataFrame.copy([deep]) #deep深度复制数据DataFrame.isnull() #以布尔的方式返回空值DataFrame.notnull() #以布尔的方式返回非空值1234索引和迭代123456789101112131415161718DataFrame.head([n]) #返回前n行数据DataFrame.at #快速标签常量访问器DataFrame.iat #快速整型常量访问器DataFrame.loc #标签定位，使用名称DataFrame.iloc #整型定位，使用数字DataFrame.insert(loc, column, value) #在特殊地点loc[数字]插入column[列名]某列数据DataFrame.iter() #Iterate over infor axisDataFrame.iteritems() #返回列名和序列的迭代器DataFrame.iterrows() #返回索引和序列的迭代器DataFrame.itertuples([index, name]) #Iterate over DataFrame rows as namedtuples, with index value as first element of the tuple.DataFrame.lookup(row_labels, col_labels) #Label-based “fancy indexing” function for DataFrame.DataFrame.pop(item) #返回删除的项目DataFrame.tail([n]) #返回最后n行DataFrame.xs(key[, axis, level, drop_level]) #Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.DataFrame.isin(values) #是否包含数据框中的元素DataFrame.where(cond[, other, inplace, …]) #条件筛选DataFrame.mask(cond[, other, inplace, …]) #Return an object of same shape as self and whose corresponding entries are from self where cond is False and otherwise are from other.DataFrame.query(expr[, inplace]) #Query the columns of a frame with a boolean expression.123456789101112131415161718二元运算123456789101112131415161718192021222324DataFrame.add(other[,axis,fill_value]) #加法，元素指向DataFrame.sub(other[,axis,fill_value]) #减法，元素指向DataFrame.mul(other[, axis,fill_value]) #乘法，元素指向DataFrame.div(other[, axis,fill_value]) #小数除法，元素指向DataFrame.truediv(other[, axis, level, …]) #真除法，元素指向DataFrame.floordiv(other[, axis, level, …]) #向下取整除法，元素指向DataFrame.mod(other[, axis,fill_value]) #模运算，元素指向DataFrame.pow(other[, axis,fill_value]) #幂运算，元素指向DataFrame.radd(other[, axis,fill_value]) #右侧加法，元素指向DataFrame.rsub(other[, axis,fill_value]) #右侧减法，元素指向DataFrame.rmul(other[, axis,fill_value]) #右侧乘法，元素指向DataFrame.rdiv(other[, axis,fill_value]) #右侧小数除法，元素指向DataFrame.rtruediv(other[, axis, …]) #右侧真除法，元素指向DataFrame.rfloordiv(other[, axis, …]) #右侧向下取整除法，元素指向DataFrame.rmod(other[, axis,fill_value]) #右侧模运算，元素指向DataFrame.rpow(other[, axis,fill_value]) #右侧幂运算，元素指向DataFrame.lt(other[, axis, level]) #类似Array.ltDataFrame.gt(other[, axis, level]) #类似Array.gtDataFrame.le(other[, axis, level]) #类似Array.leDataFrame.ge(other[, axis, level]) #类似Array.geDataFrame.ne(other[, axis, level]) #类似Array.neDataFrame.eq(other[, axis, level]) #类似Array.eqDataFrame.combine(other,func[,fill_value, …]) #Add two DataFrame objects and do not propagate NaN values, so if for aDataFrame.combine_first(other) #Combine two DataFrame objects and default to non-null values in frame calling the method.123456789101112131415161718192021222324函数应用&amp;分组&amp;窗口12345678DataFrame.apply(func[, axis, broadcast, …]) #应用函数DataFrame.applymap(func) #Apply a function to a DataFrame that is intended to operate elementwise, i.e.DataFrame.aggregate(func[, axis]) #Aggregate using callable, string, dict, or list of string/callablesDataFrame.transform(func, *args, **kwargs) #Call function producing a like-indexed NDFrameDataFrame.groupby([by, axis, level, …]) #分组DataFrame.rolling(window[, min_periods, …]) #滚动窗口DataFrame.expanding([min_periods, freq, …]) #拓展窗口DataFrame.ewm([com, span, halflife, …]) #指数权重窗口12345678描述统计学12345678910111213141516171819202122232425262728293031323334DataFrame.abs() #返回绝对值DataFrame.all([axis, bool_only, skipna]) #Return whether all elements are True over requested axisDataFrame.any([axis, bool_only, skipna]) #Return whether any element is True over requested axisDataFrame.clip([lower, upper, axis]) #Trim values at input threshold(s).DataFrame.clip_lower(threshold[, axis]) #Return copy of the input with values below given value(s) truncated.DataFrame.clip_upper(threshold[, axis]) #Return copy of input with values above given value(s) truncated.DataFrame.corr([method, min_periods]) #返回本数据框成对列的相关性系数DataFrame.corrwith(other[, axis, drop]) #返回不同数据框的相关性DataFrame.count([axis, level, numeric_only]) #返回非空元素的个数DataFrame.cov([min_periods]) #计算协方差DataFrame.cummax([axis, skipna]) #Return cumulative max over requested axis.DataFrame.cummin([axis, skipna]) #Return cumulative minimum over requested axis.DataFrame.cumprod([axis, skipna]) #返回累积DataFrame.cumsum([axis, skipna]) #返回累和DataFrame.describe([percentiles,include, …]) #整体描述数据框DataFrame.diff([periods, axis]) #1st discrete difference of objectDataFrame.eval(expr[, inplace]) #Evaluate an expression in the context of the calling DataFrame instance.DataFrame.kurt([axis, skipna, level, …]) #返回无偏峰度Fisher’s (kurtosis of normal == 0.0).DataFrame.mad([axis, skipna, level]) #返回偏差DataFrame.max([axis, skipna, level, …]) #返回最大值DataFrame.mean([axis, skipna, level, …]) #返回均值DataFrame.median([axis, skipna, level, …]) #返回中位数DataFrame.min([axis, skipna, level, …]) #返回最小值DataFrame.mode([axis, numeric_only]) #返回众数DataFrame.pct_change([periods, fill_method]) #返回百分比变化DataFrame.prod([axis, skipna, level, …]) #返回连乘积DataFrame.quantile([q, axis, numeric_only]) #返回分位数DataFrame.rank([axis, method, numeric_only]) #返回数字的排序DataFrame.round([decimals]) #Round a DataFrame to a variable number of decimal places.DataFrame.sem([axis, skipna, level, ddof]) #返回无偏标准误DataFrame.skew([axis, skipna, level, …]) #返回无偏偏度DataFrame.sum([axis, skipna, level, …]) #求和DataFrame.std([axis, skipna, level, ddof]) #返回标准误差DataFrame.var([axis, skipna, level, ddof]) #返回无偏误差 12345678910111213141516171819202122232425262728293031323334从新索引&amp;选取&amp;标签操作12345678910111213141516171819202122232425DataFrame.add_prefix(prefix) #添加前缀DataFrame.add_suffix(suffix) #添加后缀DataFrame.align(other[, join, axis, level]) #Align two object on their axes with theDataFrame.drop(labels[, axis, level, …]) #返回删除的列DataFrame.drop_duplicates([subset, keep, …]) #Return DataFrame with duplicate rows removed, optionally onlyDataFrame.duplicated([subset, keep]) #Return boolean Series denoting duplicate rows, optionally onlyDataFrame.equals(other) #两个数据框是否相同DataFrame.filter([items, like, regex, axis]) #过滤特定的子数据框DataFrame.first(offset) #Convenience method for subsetting initial periods of time series data based on a date offset.DataFrame.head([n]) #返回前n行DataFrame.idxmax([axis, skipna]) #Return index of first occurrence of maximum over requested axis.DataFrame.idxmin([axis, skipna]) #Return index of first occurrence of minimum over requested axis.DataFrame.last(offset) #Convenience method for subsetting final periods of time series data based on a date offset.DataFrame.reindex([index, columns]) #Conform DataFrame to new index with optional filling logic, placing NA/NaN in locations having no value in the previous index.DataFrame.reindex_axis(labels[, axis, …]) #Conform input object to new index with optional filling logic, placing NA/NaN in locations having no value in the previous index.DataFrame.reindex_like(other[, method, …]) #Return an object with matching indices to myself.DataFrame.rename([index, columns]) #Alter axes input function or functions.DataFrame.rename_axis(mapper[, axis, copy]) #Alter index and / or columns using input function or functions.DataFrame.reset_index([level, drop, …]) #For DataFrame with multi-level index, return new DataFrame with labeling information in the columns under the index names, defaulting to ‘level_0’, ‘level_1’, etc.DataFrame.sample([n, frac, replace, …]) #返回随机抽样DataFrame.select(crit[, axis]) #Return data corresponding to axis labels matching criteriaDataFrame.set_index(keys[, drop, append ]) #Set the DataFrame index (row labels) using one or more existing columns.DataFrame.tail([n]) #返回最后几行DataFrame.take(indices[, axis, convert]) #Analogous to ndarray.takeDataFrame.truncate([before, after, axis ]) #Truncates a sorted NDFrame before and/or after some particular index value.12345678910111213141516171819202122232425处理缺失值123DataFrame.dropna([axis, how, thresh, …]) #Return object with labels on given axis omitted where alternately anyDataFrame.fillna([value, method, axis, …]) #填充空值DataFrame.replace([to_replace, value, …]) #Replace values given in ‘to_replace’ with ‘value’.123从新定型&amp;排序&amp;转变形态1234567891011121314DataFrame.pivot([index, columns, values]) #Reshape data (produce a “pivot” table) based on column values.DataFrame.reorder_levels(order[, axis]) #Rearrange index levels using input order.DataFrame.sort_values(by[, axis, ascending]) #Sort by the values along either axisDataFrame.sort_index([axis, level, …]) #Sort object by labels (along an axis)DataFrame.nlargest(n, columns[, keep]) #Get the rows of a DataFrame sorted by the n largest values of columns.DataFrame.nsmallest(n, columns[, keep]) #Get the rows of a DataFrame sorted by the n smallest values of columns.DataFrame.swaplevel([i, j, axis]) #Swap levels i and j in a MultiIndex on a particular axisDataFrame.stack([level, dropna]) #Pivot a level of the (possibly hierarchical) column labels, returning a DataFrame (or Series in the case of an object with a single level of column labels) having a hierarchical index with a new inner-most level of row labels.DataFrame.unstack([level, fill_value]) #Pivot a level of the (necessarily hierarchical) index labels, returning a DataFrame having a new level of column labels whose inner-most level consists of the pivoted index labels.DataFrame.melt([id_vars, value_vars, …]) #“Unpivots” a DataFrame from wide format to long format, optionallyDataFrame.T #Transpose index and columnsDataFrame.to_panel() #Transform long (stacked) format (DataFrame) into wide (3D, Panel) format.DataFrame.to_xarray() #Return an xarray object from the pandas object.DataFrame.transpose(*args, **kwargs) #Transpose index and columns1234567891011121314Combining&amp; joining&amp;merging12345DataFrame.append(other[, ignore_index, …]) #追加数据DataFrame.assign(**kwargs) #Assign new columns to a DataFrame, returning a new object (a copy) with all the original columns in addition to the new ones.DataFrame.join(other[, on, how, lsuffix, …]) #Join columns with other DataFrame either on index or on a key column.DataFrame.merge(right[, how, on, left_on, …]) #Merge DataFrame objects by performing a database-style join operation by columns or indexes.DataFrame.update(other[, join, overwrite, …]) #Modify DataFrame in place using non-NA values from passed DataFrame.12345时间序列12345678910DataFrame.asfreq(freq[, method, how, …]) #将时间序列转换为特定的频次DataFrame.asof(where[, subset]) #The last row without any NaN is taken (or the last row withoutDataFrame.shift([periods, freq, axis]) #Shift index by desired number of periods with an optional time freqDataFrame.first_valid_index() #Return label for first non-NA/null valueDataFrame.last_valid_index() #Return label for last non-NA/null valueDataFrame.resample(rule[, how, axis, …]) #Convenience method for frequency conversion and resampling of time series.DataFrame.to_period([freq, axis, copy]) #Convert DataFrame from DatetimeIndex to PeriodIndex with desiredDataFrame.to_timestamp([freq, how, axis]) #Cast to DatetimeIndex of timestamps, at beginning of periodDataFrame.tz_convert(tz[, axis, level, copy]) #Convert tz-aware axis to target time zone.DataFrame.tz_localize(tz[, axis, level, …]) #Localize tz-naive TimeSeries to target time zone.12345678910作图1234567891011121314DataFrame.plot([x, y, kind, ax, ….]) #DataFrame plotting accessor and methodDataFrame.plot.area([x, y]) #面积图Area plotDataFrame.plot.bar([x, y]) #垂直条形图Vertical bar plotDataFrame.plot.barh([x, y]) #水平条形图Horizontal bar plotDataFrame.plot.box([by]) #箱图BoxplotDataFrame.plot.density(**kwds) #核密度Kernel Density Estimate plotDataFrame.plot.hexbin(x, y[, C, …]) #Hexbin plotDataFrame.plot.hist([by, bins]) #直方图HistogramDataFrame.plot.kde(**kwds) #核密度Kernel Density Estimate plotDataFrame.plot.line([x, y]) #线图Line plotDataFrame.plot.pie([y]) #饼图Pie chartDataFrame.plot.scatter(x, y[, s, c]) #散点图Scatter plotDataFrame.boxplot([column, by, ax, …]) #Make a box plot from DataFrame column optionally grouped by some columns orDataFrame.hist(data[, column, by, grid, …]) #Draw histogram of the DataFrame’s series using matplotlib / pylab.1234567891011121314转换为其他格式123456789101112131415161718192021DataFrame.from_csv(path[, header, sep, …]) #Read CSV file (DEPRECATED, please use pandas.read_csv() instead).DataFrame.from_dict(data[, orient, dtype]) #Construct DataFrame from dict of array-like or dictsDataFrame.from_items(items[,columns,orient]) #Convert (key, value) pairs to DataFrame.DataFrame.from_records(data[, index, …]) #Convert structured or record ndarray to DataFrameDataFrame.info([verbose, buf, max_cols, …]) #Concise summary of a DataFrame.DataFrame.to_pickle(path[, compression, …]) #Pickle (serialize) object to input file path.DataFrame.to_csv([path_or_buf, sep, na_rep]) #Write DataFrame to a comma-separated values (csv) fileDataFrame.to_hdf(path_or_buf, key, **kwargs) #Write the contained data to an HDF5 file using HDFStore.DataFrame.to_sql(name, con[, flavor, …]) #Write records stored in a DataFrame to a SQL database.DataFrame.to_dict([orient, into]) #Convert DataFrame to dictionary.DataFrame.to_excel(excel_writer[, …]) #Write DataFrame to an excel sheetDataFrame.to_json([path_or_buf, orient, …]) #Convert the object to a JSON string.DataFrame.to_html([buf, columns, col_space]) #Render a DataFrame as an HTML table.DataFrame.to_feather(fname) #write out the binary feather-format for DataFramesDataFrame.to_latex([buf, columns, …]) #Render an object to a tabular environment table.DataFrame.to_stata(fname[, convert_dates, …]) #A class for writing Stata binary dta files from array-like objectsDataFrame.to_msgpack([path_or_buf, encoding]) #msgpack (serialize) object to input file pathDataFrame.to_sparse([fill_value, kind]) #Convert to SparseDataFrameDataFrame.to_dense() #Return dense representation of NDFrame (as opposed to sparse)DataFrame.to_string([buf, columns, …]) #Render a DataFrame to a console-friendly tabular output.DataFrame.to_clipboard([excel, sep]) #Attempt to write text representation of object to the system cli]]></content>
      <categories>
        <category>python数据挖掘</category>
      </categories>
      <tags>
        <tag>pandas函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[妹子图爬虫（爬取妹子图图片）]]></title>
    <url>%2F2019%2F07%2F22%2Fpython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[python实现妹子图爬虫（爬取妹子网图片）一个简单的小爬虫实现爬取妹子图网站上的图片。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#coding=utf-8import requestsfrom bs4 import BeautifulSoupimport osall_url = 'http://www.mzitu.com'#http请求头Hostreferer = &#123; 'User-Agent':'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)', 'Referer':'http://www.mzitu.com' &#125;Picreferer = &#123; 'User-Agent':'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)', 'Referer':'http://i.meizitu.net'&#125;#此请求头破解盗链start_html = requests.get(all_url,headers = Hostreferer)#保存地址path = "D:\\mzitu\\"#找寻最大页数soup = BeautifulSoup(start_html.text,"html.parser")page = soup.find_all('a',class_='page-numbers')max_page = page[-2].textsame_url = 'http://www.mzitu.com/all/'for n in range(1,int(max_page)+1): ul = same_url+str(n) start_html = requests.get(ul, headers = Hostreferer) soup = BeautifulSoup(start_html.text,"html.parser") all_a = soup.find('div',class_='all').find_all('a',target='_blank') for a in all_a: title = a.get_text() #提取文本 if(title != ''): print("准备扒取："+title) #win不能创建带？的目录 if(os.path.exists(path+title.strip().replace('?',''))): #print('目录已存在') flag=1 else: os.makedirs(path+title.strip().replace('?','').replace(':', '')) flag=0 os.chdir(path + title.strip().replace('?','').replace(':', '')) href = a['href'] html = requests.get(href,headers = Hostreferer) mess = BeautifulSoup(html.text,"html.parser") pic_max = mess.find_all('span') try: pic_max = pic_max[9].text #最大页数 if(flag == 1 and len(os.listdir(path+title.strip().replace('?',''))) &gt;= int(pic_max)): print('已经保存完毕，跳过') continue for num in range(1, int(pic_max)+1): pic = href+'/'+str(num) html = requests.get(pic,headers = Hostreferer) mess = BeautifulSoup(html.text,"html.parser") pic_url = mess.find('img',alt = title) print(pic_url['src']) #exit(0) html = requests.get(pic_url['src'],headers = Picreferer) file_name = pic_url['src'].split(r'/')[-1] f = open(file_name,'wb') f.write(html.content) f.close() except Exception: pass print('完成 ') print('第',n,'页完成')原文参考：https://blog.csdn.net/baidu_35085676/article/details/68958267]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>爬虫实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据之Hadoop]]></title>
    <url>%2F2019%2F07%2F14%2Fhadoop%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Hadoop介绍组成部分Hadoop主要由3部分组成：Mapreduce编程模型HDFS分布式文件存储YARN配置信息管理员密码：admin123DNS1=202.103.24.68DNS2=202.103.44.150export HADOOP_HOME=/usr/local/hadoop-2.6.4export PATH=$HADOOP_HOME/bin$PATH:/usr/java/jdk1.8.0_201-amd64/binHadoop HDFS 简介概念：namenode：负责记录 数据块 的分布情况– 数据元数据信息datanode:负责实际存储 数据块block：是Hadoop最小存储数据单位 默认 128Msecondarynamenode: 辅助namenode完成fsimage管理或者优化HDFS简单命令hadoop version //查看版本hadoop fs //文件系统客户端hadoop jar //运行jar包hadoop classpath //查看类路径hadoop checknative //检查本地库并压缩hadoop distcp // 远程递归拷贝文件hadoop credential //认证hadoop trace //跟踪$ hdfs dfs -mkdir-p /user/ubuntu/ //在hdfs上建立文件夹$ hdfs dfs -puthdfs.cmd /user/ubuntu/ //将本地文件上传到HDFS$ hdfs dfs -get/user/ubuntu/hadoop.cmd a.cmd //将文件从HDFS取回本地$ hdfs dfs -rm -r -f /user/ubuntu/ //删除$ hdfs dfs -ls -R/ //递归展示HDFS文件系统一、hadoop所在目录cd usr/local/hadoop1二、启动hadoopbash ./starth.sh% 运行start-dfs.sh% 运行start-yarn.sh123启动dfs，浏览器查看：172.16.31.17:500701启动脚本，浏览器查看：172.16.31.17:80881停止脚本：bash ./stoph.sh1三、常用命令1.显示hadoop目录结构hdfs dfs -ls -R /12.在hadoop指定目录内创建新目录hdfs dfs -mkdir /winnie13.将本地文件夹存储至hadoophdfs dfs -put [本地目录] [hadoop目录]14.将本地文件存储至hadoophdfs dfs -put [本地地址] [hadoop目录]15.查看指定目录下内容hdfs dfs -ls [文件目录]16.打开某个已存在文件hdfs dfs -cat [file_path]17.在hadoop指定目录下新建一个空文件hdfs dfs -touchz /winnie/test03.txt18.将hadoop上某个文件重命名hdfs dfs -mv /winnie/test03.txt /winnie/test.txt19.将hadoop上某个文件down至本地已有目录下hdfs dfs -get [文件目录] [本地目录]110.将hadoop指定目录下所有内容保存为一个文件，同时down至本地hdfs dfs -getmerge /winnie/hadoop-file /home/spark/hadoop-file/test.txt111.删除hadoop上指定文件hdfs dfs -rm [文件地址]112.删除hadoop上指定文件夹（包含子目录等）hdfs dfs -rm -r [目录地址]hdfs dfs -rmr [目录地址]1213.将正在运行的hadoop作业kill掉hadoop job -kill [job-id]114.查看帮助hdfs dfs -help1四、安全模式1.退出安全模式NameNode在启动时会自动进入安全模式，安全模式是NameNode的一种状态，在这个阶段，文件系统不允许有任何修改。系统显示Name node in safe mode，说明系统正处于安全模式，这时只需要等待几十秒即可，也可通过下面的命令退出安全模式：/usr/local/hadoop$bin/hadoop dfsadmin -safemode leave12.进入安全模式在必要情况下，可以通过以下命令吧HDFS置于安全模式：/usr/local/hadoop$bin/hadoop dfsadmin -safemode enter1五、补充1.对hdfs操作的命令格式是hdfs dfs1.1 -ls 表示对hdfs下一级目录的查看1.2 -lsr 表示对hdfs目录的递归查看1.3 -mkdir 创建目录1.4 -put 从Linux上传文件到hdfs1.5 -get 从hdfs下载文件到linux1.6 -text 查看文件内容1.7 -rm 表示删除文件1.7 -rmr 表示递归删除文件2.hdfs在对数据存储进行block划分时，如果文件大小超过block，那么按照block大小进行划分；不如block size的，划分为一个块，是实际数据大小。3.hadoop常用命令：hdfs dfs 查看Hadoop HDFS支持的所有命令hdfs dfs –ls 列出目录及文件信息hdfs dfs –lsr 循环列出目录、子目录及文件信息hdfs dfs –tail /user/sunlightcs/test.txt 查看最后1KB的内容hdfs dfs –copyFromLocal test.txt /user/sunlightcs/test.txt 从本地文件系统复制文件到HDFS文件系统，等同于put命令hdfs dfs –copyToLocal /user/sunlightcs/test.txt test.txt 从HDFS文件系统复制文件到本地文件系统，等同于get命令hdfs dfs –chgrp [-R] /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录所属群组，选项-R递归执行，跟linux命令一样hdfs dfs –chown [-R] /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录拥有者，选项-R递归执行hdfs dfs –chmod [-R] MODE /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录权限，MODE可以为相应权限的3位数或+/-{rwx}，选项-R递归执行hdfs dfs –count [-q] PATH 查看PATH目录下，子目录数、文件数、文件大小、文件名/目录名hdfs dfs –cp SRC [SRC …] DST 将文件从SRC复制到DST，如果指定了多个SRC，则DST必须为一个目录hdfs dfs –du PATH 显示该目录中每个文件或目录的大小hdfs dfs –dus PATH 类似于du，PATH为目录时，会显示该目录的总大小hdfs dfs –expunge 清空回收站，文件被删除时，它首先会移到临时目录.Trash/中，当超过延迟时间之后，文件才会被永久删除hdfs dfs –getmerge SRC [SRC …] LOCALDST [addnl] 获取由SRC指定的所有文件，将它们合并为单个文件，并写入本地文件系统中的LOCALDST，选项addnl将在每个文件的末尾处加上一个换行符hdfs dfs –test –[ezd] PATH 对PATH进行如下类型的检查：-e PATH是否存在，如果PATH存在，返回0，否则返回1；-z 文件是否为空，如果长度为0，返回0，否则返回1； -d 是否为目录，如果PATH为目录，返回0，否则返回1hdfs dfs –text PATH 显示文件的内容，当文件为文本文件时，等同于cat；文件为压缩格式（gzip以及hadoop的二进制序列文件格式）时，会先解压缩hdfs dfs –help ls 查看某个[ls]命令的帮助文档Mapreduce解释mapper的角色:hadoop将用户提交的mapper可执行程序或脚本作为一个单独的进程加载起来，这个进程我们称之为mapper进程，hadoop不断地将文件片段转换为行，传递到我们的mapper进程中，mapper进程通过标准输入的方式一行一行地获取这些数据，然后设法将其转换为键值对，再通过标准输出的形式将这些键值对按照一对儿一行的方式输出出去。虽然在我们的mapper函数中，我们自己能分得清key/value(比方说有可能在我们的代码中使用的是string key,int value)，但是当我们采用标准输出之后，key value是打印到一行作为结果输出的(比如sys.stdout.write(“%s\t%s\n”%(birthyear,gender)))，因此我们为了保证hadoop能从中鉴别出我们的键值对，键值对中一定要以分隔符’\t’即Tab(也可自定义分隔符)字符分隔，这样才能保证hadoop正确地为我们进行partitoner、shuffle等等过程。reducer的角色:hadoop将用户提交的reducer可执行程序或脚本同样作为一个单独的进程加载起来，这个进程我们称之为reducer进程，hadoop不断地将键值对(按键排序)按照一对儿一行的方式传递到reducer进程中，reducer进程同样通过标准输入的方式按行获取这些键值对儿，进行自定义计算后将结果通过标准输出的形式输出出去。在reducer这个过程中需要注意的是：传递进reducer的键值对是按照键排过序的，这点是由MR框架的sort过程保证的，因此如果读到一个键与前一个键不同，我们就可以知道当前key对应的pairs已经结束了，接下来将是新的key对应的pairs。]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop介绍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据科学之统计学习]]></title>
    <url>%2F2019%2F07%2F14%2F%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[统计学中心倾向均值（常用的额）中位数分位数：它表示少于数据中特定百分比的一个值众数离散度极差方差统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数概率论中方差用来度量随机变量)和其数学期望（即均值）之间的偏离程度计算公式$$s^2 = \frac{\sum_{}(x-u)^2}{N}$$标准差中文环境中又常称均方差，是离均差平方的算术平均数的平方根，用σ表示。标准差是方差的算术平方根计算公式$$σ = \sqrt\frac{\sum_{}(x-u)^2}{N}$$相关性协方差协方差（Covariance）在概率论和统计学中用于衡量两个变量的总体误差。而方差是协方差的一种特殊情况，即当两个变量是相同的情况。计算公式概率论不独立和独立如果事件E和事件F独立意味着两个事同时发生的概率等于它们分别发生的概率的乘积。$$P（E, F） = P(E)*P(F)$$条件概率如果事件E与事件F独立，那么定义：$$P（E, F） = P(E)*P(F)$$如果两者不一定独立（并且概率都不为0），那么概率公式为：（已知F发生，在此条件下E发生的概率）$$P（E|F） = P（E, F）/P（F）$$]]></content>
      <categories>
        <category>统计学和概率论</category>
      </categories>
      <tags>
        <tag>数学知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之百度接口语音识别]]></title>
    <url>%2F2019%2F07%2F12%2F%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[python编程之百度接口语音识别首先在百度AI开放平台上创建语音识别应用，创建完毕应用后，得到系统分配给用户的AppID， API Key， secret Key，均为字符串，用于标识用户，为访问做签名验证。得到验证后，开始编程1.记录自己声音2.将记录下来的音频文件上传至云端3.解析返回后的结果python实现相关包 pyaudio，baidu-aip123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from aip import AipSpeechimport wavefrom pyaudio import PyAudio, paInt16def save_wave_file(filename, data): '''save the date to the wavfile''' wf = wave.open(filename, 'wb') wf.setnchannels(channels) wf.setsampwidth(sampwidth) wf.setframerate(framerate) wf.writeframes(b"".join(data)) wf.close()def my_record(): pa = PyAudio() stream = pa.open(format=paInt16, channels=1, rate=framerate, input=True, frames_per_buffer=NUM_SAMPLES) my_buf = [] count = 0 print('录音开始') while count &lt; TIME*10: # 控制录音时间 string_audio_data = stream.read(NUM_SAMPLES) my_buf.append(string_audio_data) count += 1 print('录音结束') save_wave_file('01.pcm', my_buf) stream.close()if __name__ == "__main__": framerate = 16000 NUM_SAMPLES = 2000 channels = 1 sampwidth = 2 TIME = 2 my_record() """ 我的 APPID AK SK """ APP_ID = '16795182 ' API_KEY = '8io5s7uv8pjYPUrQp1i8PcIg' SECRET_KEY = 'gK2MljvbcF3SKS4p0C2ieq1SCBNY48BD' client = AipSpeech(APP_ID, API_KEY, SECRET_KEY) # 读取文件 def get_file_content(filePath): with open(filePath, 'rb') as fp: return fp.read() # 识别本地文件 result = client.asr(get_file_content('01.pcm'), 'pcm', 16000, &#123; 'dev_pid': 1536, &#125;) # print(type(result)) print("语音识别结果：", result['result'])]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>语音识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据科学之数据可视化]]></title>
    <url>%2F2019%2F07%2F11%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数据可视化概述可视化的目的，是对数据进行可视化处理，以更明确地，有效的传递信息。数据可视化意义数据可视化是为了从数据中寻找三个方面的信息。模式。指数据中的规律。关系。指数据间的相关性。数据间的比较数据的构成数据的分布或联系异常。指有问题的数据。数据可视化的作用记录信息。用图形的方式描述各种具体或抽象的事物。分析推理。有效的提升了信息认知的效率，从而有助于人们更快地分析和推理出有效信息。信息传播和协同。数据可视化的分类科学可视化信息可视化可视分析学数据可视化基础数据类型根据数据模型，可将数据分为浮点数，整数，字符等根据概念模型类别型数据，有序型数据，区间型数据和比值型数据类别型数据：用于区分物体有序型数据：用来表示对象间的顺序关系区间型数据：用于得到对象间的定量关系。用于比较数值间的比列关系，可以精确地定义比例数据预处理数据的预处理的目的是提升数据质量数据质量包含以下六方面有效性：数据与实际情况对应时，是否违背约束条件准确性：数据能否精确的反映现实。完整性：采集数据集是否包含了数据源中 的所有数据点：且样本的属性都是完整的。一致性：整个数据集中的数据的衡量标准要一致时效性：数据适合当下时间区间内的分析任务可行性：数据源中的数据是使用者可依赖的。数据预处理步骤如下数据清理：指修正数据中的错误，识别脏数据，更正不一致数据的过程。数据集成：指把来自不同数据的同类数据进行合并，减少数据冲突，降低数据冗余程度等。数据归约：指在保证数据挖掘结果准确性的前提下，最大限度地精简数据量，得到简化的数据集。数据转换：指对数据进行规范化处理数据组织与管理大数据存储利用的是分布式存储与访问计数，它具有高效，容错性强等特点。分布式文件系统分布式文件系统是指文件在物理上可能被分散存储在不同地点的节点上，各节点通过计算机网络进行通信和数据传输，但仍然是一个完整的文件。常用的分布式系统有HDFS（hadoop分布式文件系统），GFS（Google分布式文件系统）等。文档存储文档存储支持对结构化数据的访问，一般以键值对的方式进行存储。文档存储类型也支持数组和列值键列式存储列式存储是指以流的方式在列中存储所有的数据键式存储以Key-Value存储，简称KV存储图形数据库图形数据库是NOSQL数据库的一种，是一种非关系型的数据库，它应用图形理论存储实体间的关系信息。关系型数据库关系模型是最传统的数据存储模型，数据按行存储在有架构界定的表中。用户可使用基于关系代数演算的结构化查询语言提供相应的语法查找符合条件的记录。内存数据库内存数据库就是将数据放在内存中直接操作的数据库。特点速度快，能处理实时型业务数据仓库数据仓库是一种特殊的数据库，一般用于存储海量数据，并直接支持后续的分析和决策操作。数据分析与数据挖掘数据分析统计分析是指对数据进行统计描述和统计推断的过程探索性数据分析是对调查，观测所得到的一些初步的杂乱无章的数据，在尽量少的先验假设下进行处理，通过作图，制表等形式和方程拟合，计算某些特征量等手段，探索数据的结构和规律的一种数据分析方法。验证性数据分析是指在已经有事先假设的关系模型等情况下，通过数据分析来验证已提出的假设在线分析和处理是一种交互式探索大规模多维数据集的方法。数据挖掘数据挖掘一般是指从大量的数据中通过算法搜索隐藏于其中的信息的过程。常见的数据挖掘分析方法有分类与预测，聚类分析，关联性分析和异常分析等。分类与预测聚类分析关联分析异常分析数据挖掘的步骤确定业务对象数据准备数据挖掘结果分析知识的同化]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>数据可视化概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站概念]]></title>
    <url>%2F2019%2F07%2F06%2F%E7%BD%91%E7%AB%99%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[网站的组成目前多数网站由域名，空间服务器，DNS域名解析，网站程序和数据库等组成空间服务器（以下三种类型）虚拟主机：指在网络服务器上划分一定的磁盘空间供用户放置站点和应用组件等，提供必要的站点功能，数据存放和传输功能。所谓虚拟主机，也叫“网站空间”，就是把一台运行在互联网上的服务器划分成多个”虚拟“的服务器独立服务器：指性能更强大，整体硬件完全独立的服务器，其cpu都在8核以上。VPS（虚拟专用服务器）：将一个服务器分区成多个虚拟独立专享服务器的技术。网站的程序:是建设与修改网站所使用的编程语言。网站的分类资讯门户类网站企业品牌网站交易类网站B2C（Business To Consumer）网站：商家——消费者，主要是购物网站，用于商家和消费者之间的买卖，如传统的百货商店和购物广场。B2B（Business To Business）网站：商家——商家，主要是商务网站，用于商家之间的买卖，如传统的原材料市场和大型批发市场C2C（Consumer To Consumer）网站：消费者——消费者，主要以拍卖网站为主，用于个人的物品的买卖，如传统的旧货市场，跳骚市场，废品收购站等。办公及政府机构网站企业办公事物类网站政府办公类事物网站互动游戏网站功能性网站这类网站的主要特征是将一个具有广泛需求的共能扩展开来，开发一套强大的功能体系，将功能的实现推向极致。如：百度，goolge网站开发的常用术语域名：用于标识一个或多个ip地址DNS：域名系统，用于跟踪计算机的域名及其在互联网上的相应的IP地址]]></content>
      <categories>
        <category>网站知识</category>
      </categories>
      <tags>
        <tag>网站的基本概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法时间复杂度和五大经典排序算法]]></title>
    <url>%2F2019%2F06%2F29%2F%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E4%BA%94%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[渐进时间度表O记法所代表的是渐进上界限，Ω记法代表的是渐进下界Θ代表的集合是上述符号的交集，Θ(g) = O(g)常见的渐进运行时间实例时间复杂度相关名称相关实例及说明Θ（1）常数级哈希表的查询和修改Θ（lg n）对数级二分搜索，其对数基数并不重要Θ（n）线性级列表的遍历Θ(nlgn)线性对数级任意值序列的最优化排序，其复杂度等同于Θ(lg n!)Θ(n^2)平方级拿n个对象进行互相比对Θ(n^3)立方级Floyd-Warshall算法O(n^k)多项式级基于n的k层嵌套循环（k为整数），且必须满足K &gt; 0Ω(K^n)指数级每n项产生一个子集（其中k = 2），且必须满足K &gt; 1Θ(n!)阶乘级对n个值执行全排列操作冒泡排序冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 冒泡排序算法的运作如下： 1、比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。 2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 3、针对所有的元素重复以上的步骤，除了最后一个。 4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 ‘’’冒泡排序的时间复杂度为O(n^2)。1234567891011121314151617181920212223def store(x): '''冒泡排序算法实现''' f=0 while f &lt; len(x): i=0 j=1 while j &lt; len(x): if x[i] &lt;= x[j]: i = i + 1 j = j + 1 elif x[i] &gt; x[j]: var1 = x[i] var2 = x[j] x[j] = var1 x[i] = var2 i = i + 1 j = j + 1 f = f + 1 return xif __name__ == "__main__": test = [2,4,6,5,9,7,12,15,13,19,20,1,3] print(store(test))归并排序归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表， 即把待排序序列分为若干个子序列，每个子序列是有序的。 然后再把有序子序列合并为整体有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。123456789101112131415161718192021222324252627282930313233def merge_extend(x): '''归并排序算法''' # 拆分列表 if len(x) &lt;= 1: # 向下取整数 return x mid = len(x)//2 left = merge_extend(x[:mid]) right = merge_extend(x[mid:]) print(left,right) return merge_add(left, right)def merge_add(a, b): '''和并列表''' result = [] i = 0 j = 0 while i &lt; len(a) and j &lt; len(b): if a[i] &lt; b[j]: result.append(a[i]) i += 1 else: result.append(b[j]) j += 1 #print("a",a[i:]) #print("b",b[j:]) result.extend(a[i:]) result.extend(b[j:]) return resultif __name__ == "__main__": test=[11,0,5,7,3,6,8,1,2] print(merge_extend(test))插入排序插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列， 对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。简单插入排序的时间复杂度也是O(n^2)123456789101112def insert_sort(x): # 取列表的第一个元素为单独的一个，已经排好序的列表 for i in range(1, len(x)): # 要排序的的牌 for j in range(0, i): if x[i] &lt; x[j]: x[i], x[j] = x[j], x[i] return xif __name__=="__main__": test = [2,3,5,7,9,1,20,0,4,12,19,11,8,1] print(insert_sort(test))选择排序选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置， 然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。 选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上， 因此对n个元素的表进行排序总共进行至多n-1次交换。 在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。选择排序的时间复杂度为O(n^2)1234567891011def select_sort(x): '''选择排序''' new = [] while x: new.append(min(x)) x.remove(min(x)) return newif __name__=="__main__": test = [2,3,5,7,9,1,20,0,4,12,19,11,8,1] print(select_sort(test))快速排序1.先从待排序的数组中找出一个数作为基准数（取第一个数即可）， 2.然后将原来的数组划分成两部分：小于基准数的左子数组和大于等于基准数的右子数组。 3.然后对这两个子数组再递归重复上述过程，直到两个子数组的所有数都分别有序。 4.最后返回“左子数组” + “基准数” + “右子数组”，即是最终排序好的数组。快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)1234567891011121314151617def quick_sort(x): '''快速排序''' if len(x) &lt;= 1: return x base = x[0] left = [] right = [] for var in x: if var &gt; base: right.append(var) elif var &lt; base: left.append(var) return quick_sort(left) + [base] + quick_sort(right)if __name__ == "__main__": # 存在重复值被覆盖 test = [2,6,7,8,12,56,36,89,45,3]]]></content>
      <categories>
        <category>算法</category>
        <category>五大经典排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的正则表达式]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[匹配小数1[0-9]&#123;1,&#125;[.][0-9]*匹配整数1[0-9]中文的匹配1[\u4e00-\u9fa5]特殊符号和字符：123456789101112131415161718192021[A-Z0-9a-z]: A,1,a[abc]*: aaa,abc,acc,匹配前面的正则0次或多次a？: a,匹配前面的出现正则0次或一次.： 匹配任意字符\n\t1,2.3,4,5.a,c.*: acb,aaa,weaijdiajdw,desd.*?: 非贪婪匹配\d: 匹配任何数字 [0-9]*:002121,5498464\s: 匹配任意空白符 \n\t\v\r\f\w: 匹配任何数字，字母，字符 [A-Za-z0-9][u4e00-u9fa5] ：匹配中文a|b a,b1|2 1,2&#123;int&#125;:指明正则出现的次数+：匹配前面出现的正则一次或多次?：0次或一次*：0次或多次^:匹配开头$:匹配结尾^$:空[^A-Z]: 除了A-Z都匹配匹配双字节字符(包括汉字在内)：1[^\x00-\xff]匹配空白行的正则表达式：1\n\s*\r匹配HTML标记的正则表达式：1&lt;(\s*?)[^&gt;]*&gt;.*?|&lt;.*?&gt;匹配首尾空白字符的正则表达式：1^\s*|\s*$匹配Email地址的正则表达式：1\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*匹配网址URL的正则表达式：1[a-zA-z]+://[^\s]*匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：1^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$匹配国内电话号码：1\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;匹配腾讯QQ号：1[1-9][0-9]&#123;4,&#125;匹配中国邮政编码：12[1-9]\d&#123;5&#125;(?!\d)评注：中国邮政编码为6位数字匹配身份证：12\d&#123;15&#125;|\d&#123;18&#125;评注：中国的身份证为15位或18位匹配ip地址：12\d+\.\d+\.\d+\.\d+评注：提取ip地址时有用匹配特定数字：1234567891011^[1-9]\d*$ //匹配正整数^-[1-9]\d*$ //匹配负整数^-?[1-9]\d*$ //匹配整数^[1-9]\d*|0$ //匹配非负整数（正整数 + 0）^-[1-9]\d*|0$ //匹配非正整数（负整数 + 0）^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ //匹配正浮点数^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ //匹配负浮点数^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ //匹配浮点数^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ //匹配非负浮点数（正浮点数 + 0）^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$ //匹配非正浮点数（负浮点数 + 0）评注：处理大量数据时有用，具体应用时注意修正匹配特定字符串：12345^[A-Za-z]+$ //匹配由26个英文字母组成的字符串^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串^[a-z]+$ //匹配由26个英文字母的小写组成的字符串^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串^\w+$ //匹配由数字、26个英文字母或者下划线组成的字符串]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解释器介绍]]></title>
    <url>%2F2019%2F06%2F26%2Fpython%E8%A7%A3%E9%87%8A%E5%99%A8%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[CPython当我们从Python官方网站下载并安装好Python 3.x后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。IPythonIPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。CPython用&gt;&gt;&gt;作为提示符，而IPython用In [序号]:作为提示符。JpythonJython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。PyPyPyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术（just-in-time compiler 即时编译器，通俗解释就是边编译边执行），对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。、IronPythonIronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>python编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2019%2F06%2F23%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux管理文件和目录的命令命令功能命令功能pwd显示当前目录ls查看目录下的内容cd改变所在目录cat显示文件的内容grep在文件中查找某字符cp复制文件touch创建文件mv移动文件rm删除文件rmdir删除目录pwd命令该命令的英文解释为print working directory(打印工作目录)。输入pwd命令，Linux会输出当前目录。cd命令cd命令用来改变所在目录。1234cd / 转到根目录中 cd ~ 转到/home/user用户目录下 cd /usr 转到根目录下的usr目录中-------------绝对路径 cd test 转到当前目录下的test子目录中-------相对路径ls命令​ ls命令用来查看目录的内容。选项含义-a列举目录中的全部文件，包括隐藏文件-l列举目录中的细节，包括权限、所有者、组群、大小、创建日期、文件是否是链接等-f列举的文件显示文件类型-r逆向，从后向前地列举目录中内容-R递归，该选项递归地列举当前目录下所有子目录内的内容-s大小，按文件大小排序-h以人类可读的方式显示文件的大小，如用K、M、G作单位ls -l examples.doc列举文件examples.doc的所有信息cat命令123cat命令可以用来合并文件，也可以用来在屏幕上显示整个文件的内容。cat snow.txt 该命令显示文件snow.txt的内容，ctrl+D退出cat。grep命令12345grep命令的最大功能是在一堆文件中查找一个特定的字符串。 grep money test.txt 以上命令在test.txt中查找money这个字符串，grep查找是区分大小写的touch命令​123touch命令用来创建新文件，他可以创建一个空白的文件，可以在其中添加文本和数据。 touch newfile 该命令创建一个名为newfile的空白文件。cp命令​ cp命令用来拷贝文件，要复制文件，输入命令：12cp &lt;source filename&gt; &lt;target filename&gt;cp t.txt Document/t 该命令将把文件t.txt复制到Document目录下，并命名为t。选项含义-i互动：如果文件将覆盖目标中的文件，他会提示确认-r递归：这个选项会复制整个目录树、子目录以及其他-v详细：显示文件的复制进度mv命令​ mv命令用来移动文件。选项说明-i互动：如果选择的文件会覆盖目标中的文件，他会提示确认-f强制：它会超越互动模式，不提示地移动文件，属于很危险的选项-v详细：显示文件的移动进度​ mv t.txt Document 把文件t.txt 移动到目录Document中。rm命令​ rm命令用来删除文件。选项说明-i互动：提示确认删除-f强制：代替互动模式，不提示确认删除-v详细：显示文件的删除进度-r递归：将删除某个目录以及其中所有的文件和子目录​ rm t.txt 该命令删除文件t.txtrmdir命令​ rmdir命令用来删除目录。mkdir 命令1234567#单个文件夹创建mkdir 文件夹名称#例如：mkdir wenjianjia#多个文件夹创建mkdirs 文件夹1/文件夹2......\#例如：mkdirs wenjianjia1/wenjianjia2chmod命令详解作用：改变一个或多个文件的存取模式(mode)格式：chmod [options] mode files只能文件属主或特权用户才能使用该功能来改变文件存取模式。mode：可以是数字形式或以who opcode permission形式表示。who是可选的，默认是a(所有用户)。只能选择一个opcode(操作码)。可指定多个mode，以逗号分开。综上，包含options、who、opcode、permission等选项，下面分别进行介绍options：标识含义-c，–changes只输出被改变文件的信息-f，–silent，–quiet当chmod不能改变文件模式时，不通知文件的用户–help输出帮助信息。-R，–recursive可递归遍历子目录，把修改应到目录下所有文件和子目录–reference=filename参照filename的权限来设置权限-v，–verbose无论修改是否成功，输出每个文件的信息–version输出版本信息who标识含义u用户g组o其它a所有用户(默认)opcode标识含义+增加权限-删除权限=重新分配权限permission标识含义r读w写x执行s设置用户(或组)的ID号t设置粘着位(sticky bit)，防止文件或目录被非属主删除作为选择，我们多数用三位八进制数字的形式来表示权限，第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限。如6(4+2)代表有读写权，7(4+2+1)有读、写和执行的权限。还可设置第四位，它位于三位权限序列的前面，第四位数字取值是4，2，1，代表意思如下：4，执行时设置用户ID，用于授权给基于文件属主的进程，而不是给创建此进程的用户。2，执行时设置用户组ID，用于授权给基于文件所在组的进程，而不是基于创建此进程的用户。1，设置粘着位。实例：12345678$ chmod u+x file 给file的属主增加执行权限$ chmod 751 file 给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限$ chmod u=rwx,g=rx,o=x file 上例的另一种形式$ chmod =r file 为所有用户分配读权限$ chmod 444 file 同上例$ chmod a-wx,a+r file 同上例$ chmod -R u+r directory 递归地给directory目录下所有文件和子目录的属主分配读的权限$ chmod 4755 设置用ID，给属主分配读、写和执行权限，给组和其他用户分配读、执行的权限。linux下链接ln –s 源文件 目标文件]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>LinuxLiunx命令</tag>
      </tags>
  </entry>
</search>
