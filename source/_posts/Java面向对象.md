---
title: Java面向对象
categories: 
- Java学习
tags: 
- Java基本知识点
---

# 面向对象

- 三大特征：封装性，继承性，多态性。
- 继承是多态的前提，如果没有继承，就没有多态
- 继承主要解决的问题是：**共性抽取**



## 继承

- 父类也可以叫基类，超类
- 子类也可以叫派生类

- 子类可以访问父类的属性和方法，反之父类不能访问子类的属性和方法

直接通过子类对象访问成员变量：

- 等号左边是谁，就优先用谁，没有则向上找。

间接通过成员方法访问成员变量：

- 该方法属于谁，就优先用谁，没有则向上找。



## 成员变量方法

- 局部变量：直接写成员变量名
- 本类的成员变量：this.成员变量名
- 父类的成员变量：super.成员变量名



## 成员方法的访问

- 在父子类的继承关系当中，创建子类对象，访问成员方法的规则：
- 创建的对象是谁，就优先用谁，如果没有则向上找。



> 注意事项：
> 无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类。



## 方法的重载和重写

- 重写（Override）概念：在继承关系当中，方法的名称一样，参数列表也一样。



### 对比

- 重写（Override）：方法的名称一样，参数列表`【也一样】`。也称覆盖、覆写。

- 重载（Overload）：方法的名称一样，参数列表`【不一样】`。

  

- 方法的覆盖重写特点：创建的是子类对象，则优先用子类方法。

方法覆盖重写的注意事项：

- 1.必须保证父子类之间方法的名称相同，参数列表也相同。

  > @Override：写在方法前面，用来检测是不是有效的正确覆盖重写。
  > 这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。

- 2.子类方法的返回值必须【小于等于】父类方法的返回值范围。

- > 提示：`java.Lang.Object`类是所有类的公共最高父类（祖宗类），`java.Lang.String`就是`object`的子类。

- 3.子类方法的权限必须【大于等于】父类方法的权限修饰符。

  > 提示：`public > protected >（default）> private`备注：`（default）`不是关键字`default`，而是什么都不写，留空

### 例子图

![image-20191214160412148](https://upload.cc/i1/2019/12/14/kIQvGN.png)



## 继承关系中，父子类构造方法的访问特点

- 1.子类构造方法当中有一个默认隐含的“`super（）`”调用，所以一定是先调用的父类构造，后执行的子类构造。
- 2.子类构造可以通过`super`关键字来调用父类重载构造。
- 3.`supe`r的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。
- 总结：
  子类必须调用父类构造方法，不写则系统会自动分配一个`super（）`；写了则用写的指定的`super`调用，`super`只能有一个，还必须是第一个。



## super关键字的用法

- 1.在子类的成员方法中，访问父类的成员变量。
- 2.在子类的成员方法中，访问父类的成员方法。
- 3.在子类的构造方法中，访问父类的构造方法。



## This关键字的用法

- 1.在本类的成员方法中，访问本类的成员变量。

- 2.在本类的成员方法中，访问本类的另一个成员方法。

- 3.在本类的构造方法中，访问本类的另一个构造方法。

> 在第三种用法当中要注意：
> A.`this（…）`调用也必须是构造方法的第一个语句，唯一一个。
> B.`super`和`this`两种构造调用，不能同时使用。



## 关键字图解

![image-20191214175159192](https://upload.cc/i1/2019/12/14/wbWsh2.png)



## Java继承的特点

- 单继承：一个类的直接父类只能有唯一个
- 多级继承

![image-20191215121245751](https://upload.cc/i1/2019/12/15/VDmdbk.png)



# 抽象方法

- 抽象方法：就是加上`abstract`关键字，然后去掉大括号，直接分号结束。
- 抽象类：抽象方法所在的类，必须是抽象类才行。在`class`之前写上`abstract`即可。

使用抽象类和抽象方法：

- 1.不能直接创建`new`抽象类对象。

- 2.必须用一个子类来继承抽象父类。

- 3.子类必须覆盖重写抽象父类当中所有的抽象方法。

  > 覆盖重写（实现）：子类去掉抽象方法的`abstract`关键字，然后补上厉法体大括号了

- 4.创建子类对象进行使用。

## 注意事项

- 1.抽象类不能创建对象，如果创建，偏译无法通过而报错。只能创建其非抽象子类的对象。

 > 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。

- 2.抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。

 > 理解：子类的构造方法中，有默认的super（），需要访问父类构造方法。

- 3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。

> 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。

- 4.抽象类的子类，必须**重写抽象父类中所有的抽象方法**，否则，编译无法通过而报错。除非该子类也是抽象类。

> 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。

# 接口

- **接口就是一种公共的规范标准**

## 基本定义格式

- 接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。
- `public interface 接口名称{  //接口内容    }`
- 备注：换成了关键字`interface`之后，编译生成的字节码文件仍然是：`Java-->.class`。
- 如果是`Java 7`，那么接口中可以包含的内容有：
  - 1.常量
  - 2.抽象方法
- 如果是`Java 8`，还可以额外包含有：
  - 3.默认方法
  - 4.静态方法
- 如果是`Java 9`，还可以额外包含有：
  - 5.私有方法

## 接口使用步骤
- 1.接口不能直接使用，必须有一个"**实现类**”来实现该接口。
  格式：
  `public class 实现类名称 implements 接口名称{//…}`

- 2.接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。
  实现：去掉abstract关键字，加上方法体大括号.

- 3.创建实现类的对象，进行使用。

  

  > 注意事项：
  > 如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。



## 接口的默认方法

- 从`Java 8`开始，接口里允许定义默认方法。
  格式：`public default 返回值类型 方法名称（参数列表）{方法体....}`

  > 备注：接口当中的默认方法，可以解决接口升级的问题。

  

- 1.接口的默认方法，可以通过接口实现类对象，直接调用。
- 2.接口的默认方法，也可以被接口实现类进行覆盖重写。

## 接口的私有方法

- 从`Java 9`开始，接口当中允许定义私有方法。
- 1.普通私有方法，解决多个默认方法之间重复代码问题格式：
  `private 返回值类型 方法名称（参数列表）{方法体....}`
- 2.静态私有方法，解决多个静态方法之间重复代码问题格式：
  `private static 返回值类型 方法名称（参数列表）{方法体}`

## 接口的常量定义和使用

- 接口当中也可以定义**“成员变量**”，但是必须使用`public static final`三个关键字进行修饰。
  从效果上看，这其实就是接口的`【常量】`。
  格式：
  `public static final 数据类型 常量名称 = 数据值；`

- 备注：一旦使用final关键字进行修饰，说明不可改变。

> 注意事项：
> 1.接口当中的常量，可以省略`public static final`，注意：不写也照样是这样。
> 2.接口当中的常量，必须进行赋值；不能不赋值。
> 3.接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则则



## 注意事项

使用接囗的时候，需要注意：

- 1.接口是没有静态代码块或者构造方法的。
- 2.一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。
  格式：
  `public class MyInterfaceImpl implements MyInterfaceA，MyInterfaceBf{//覆盖重写所有抽象方法}`
- 3.如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。
- 4.如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。
- 5.如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。
- 6.一个类如果父类当中的方法和接口当中的默认方法产生了冲突，优先用父类当中的方法。

## 接口间的多继承

- 1.类与类之间是单继承的。直接父类只有一个。

- 2.类与接口之间是多实现的。一个类可以实现多个接口。

- 3.接口与接口之间是多继承的。

> 注意事项：
> 1.多个父接口当中的抽象方法如果重复，没关系。
> 2.多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着`default`关键字】



# 多态 

## 多态格式

- 代码当中体现多态性，其实就是一句话：父类引用指向子类对象。
- 格式：
- `父类名称 对象名 = new 子类名称();`
- `接口名称 对象名 = new 实现类名称();`

## 多态中的成员变量

- 1.直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。
- 2.间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。

## 多态中的成员方法

- 在多态的代码当中，成员方法的访问规则是：看`new`的是谁，就优先用谁，没有则向上找。

  > 口诀：编译看左边，运行看右边。
  > 成员变量：编译看左边，运行还看左边。
  >
  > 成员方法：编译看左边，运行看右边。

## 对象的向上和向下转型

![image-20191217152136035](https://upload.cc/i1/2019/12/17/Dw7Fh3.png)

> 说明：如何才能知道一个父类引用的对象，本来是什么子类
> 格式：
> `对象 instanceof 类名称`
> 这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。

