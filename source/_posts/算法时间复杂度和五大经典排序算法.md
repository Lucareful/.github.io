---
title: 算法时间复杂度和五大经典排序算法
categories: 
- 算法
- 五大经典排序
tags: 
- 排序算法
---

# 渐进时间度表

* `O`记法所代表的是渐进上界限，`Ω`记法代表的是渐进下界
* Θ代表的集合是上述符号的交集，Θ(g) = O(g) 

* 常见的渐进运行时间实例



* | 时间复杂度 | 相关名称   | 相关实例及说明                                  |
  | ---------- | ---------- | ----------------------------------------------- |
  | Θ（1）     | 常数级     | 哈希表的查询和修改                              |
  | Θ（lg n）  | 对数级     | 二分搜索，其对数基数并不重要                    |
  | Θ（n）     | 线性级     | 列表的遍历                                      |
  | Θ(nlgn)    | 线性对数级 | 任意值序列的最优化排序，其复杂度等同于Θ(lg n!)  |
  | Θ(n^2)     | 平方级     | 拿n个对象进行互相比对                           |
  | Θ(n^3)     | 立方级     | Floyd-Warshall算法                              |
  | O(n^k)     | 多项式级   | 基于n的k层嵌套循环（k为整数），且必须满足K > 0  |
  | Ω(K^n)     | 指数级     | 每n项产生一个子集（其中k = 2），且必须满足K > 1 |
  | Θ(n!)      | 阶乘级     | 对n个值执行全排列操作                           |

<!--more-->

# 冒泡排序

- 冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 冒泡排序算法的运作如下： 1、比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。 2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 3、针对所有的元素重复以上的步骤，除了最后一个。 4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 '''
- 冒泡排序的时间复杂度为O(n^2)。

```python
def store(x):
    '''冒泡排序算法实现'''
    f=0
    while f < len(x):
        i=0
        j=1
        while j < len(x):
            if x[i] <= x[j]:
                i = i + 1
                j = j + 1
            elif x[i] > x[j]:
                var1 = x[i]
                var2 = x[j]
                x[j] = var1
                x[i] = var2
                i = i + 1
                j = j + 1
        f = f + 1
    return x

if __name__ == "__main__":
    test = [2,4,6,5,9,7,12,15,13,19,20,1,3]
    print(store(test))
```


# 归并排序

- 归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表， 即把待排序序列分为若干个子序列，每个子序列是有序的。 然后再把有序子序列合并为整体有序序列。 
- 空间复杂度为O(n)，时间复杂度为O(nlogn)。

```python
def merge_extend(x):
    '''归并排序算法'''
    # 拆分列表
    if len(x) <= 1:
         # 向下取整数
        return x
    mid = len(x)//2
    left = merge_extend(x[:mid])
    right = merge_extend(x[mid:])
    print(left,right)
    return merge_add(left, right)

def merge_add(a, b):
    '''和并列表'''
    result = []
    i = 0
    j = 0
    while i < len(a) and j < len(b):
        if a[i] < b[j]:
            result.append(a[i])
            i += 1
        else:
            result.append(b[j])
            j += 1
    #print("a",a[i:])
    #print("b",b[j:])
    result.extend(a[i:])
    result.extend(b[j:])
    return result

if __name__ == "__main__":
    test=[11,0,5,7,3,6,8,1,2]
    print(merge_extend(test))
```



# 插入排序

- 插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列， 对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
- 简单插入排序的时间复杂度也是O(n^2)

```python
def insert_sort(x):
    # 取列表的第一个元素为单独的一个，已经排好序的列表
    for i in range(1, len(x)):
        # 要排序的的牌
        for j in range(0, i):
            if x[i] < x[j]:
                x[i], x[j] = x[j], x[i]
    return x

if __name__=="__main__":
    test = [2,3,5,7,9,1,20,0,4,12,19,11,8,1]
    print(insert_sort(test))
```


# 选择排序

- 选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置， 然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。 选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上， 因此对n个元素的表进行排序总共进行至多n-1次交换。 在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。
- 选择排序的时间复杂度为O(n^2)

```python
def select_sort(x):
    '''选择排序'''
    new = []
    while x:
        new.append(min(x))
        x.remove(min(x))
    return new

if __name__=="__main__":
    test = [2,3,5,7,9,1,20,0,4,12,19,11,8,1]
    print(select_sort(test))
```


#  快速排序

- 1.先从待排序的数组中找出一个数作为基准数（取第一个数即可）， 2.然后将原来的数组划分成两部分：小于基准数的左子数组和大于等于基准数的右子数组。 3.然后对这两个子数组再递归重复上述过程，直到两个子数组的所有数都分别有序。 4.最后返回“左子数组” + “基准数” + “右子数组”，即是最终排序好的数组。
- 快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)

```python
def quick_sort(x):
    '''快速排序'''
    if len(x) <= 1:
        return x
    base = x[0]
    left = []
    right = []
    for var in x:
        if var > base:
            right.append(var)
        elif var < base:
            left.append(var)
    return quick_sort(left) + [base] + quick_sort(right)

if __name__ == "__main__":
    # 存在重复值被覆盖
    test = [2,6,7,8,12,56,36,89,45,3]
```

