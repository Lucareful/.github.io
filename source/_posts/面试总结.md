---
title: 积善科技（快代理）Python面试总结
categories: 
- 面试经历
tags: 
- 面试总结
comments: true
keywords: 博客文章密码
password: nicaicai
abstract: 输入密码，查看文章
message:  输入密码，查看文章
---

# 积善科技（快代理）Python实习生面试总结

第一面是电话面。简单问了几个问题

- 1.生成八位字符串的随机验证码 ？
- 我当时想的是：将字符串存放在字典中，然后用随机函数生成数字，最后通过数字索引来取到对应的字符生成字符串
- 2.Python中的None和NULL类型
- None表示的是空对象，null表示的是空字符串
- 数据库的问题
- 条件查询，连表查询等（很久没有用mysql数据库，基本上忘得干干净净，看来以后关系型数据库不能丢啊！！！）

第二面是做了一套笔试题

- 记录下几个我在意的问题

<!-- more -->

## 列表推导式和字典推导式，以及匿名函数

***原文转自***：https://blog.51cto.com/6226001001/2059536

推导式comprehensions（又称解析式），是Python的一种独有特性。推导式是可以从一个数据序列构建另一个新的数据序列的结构体。共有三种推导式，在Python2和3中都有支持：

- 列表(list)推导式
- 字典(dict)推导式
- 集合(set)推导式

### 1. 列表推导式

#### 1.1 使用[]生成list

基本格式：

```python
variable = [out_exp_res for out_exp in input_list if out_exp == 2]
```

- out_exp_res：列表生成元素表达式，可以是有返回值的函数。
- for out_exp in input_list：迭代input_list将out_exp传入out_exp_res表达式中。
- if out_exp == 2：根据条件过滤哪些值可以。

实例：

- 过滤掉长度小于3的字符串列表，并将剩下的转换成大写字母

```python
names = ['Bob','Tom','alice','Jerry','Wendy','Smith'] 

[name.upper() for name in names if len(name) > 3] 

# ['ALICE', 'JERRY', 'WENDY', 'SMITH']12345
```

- 生成间隔5分钟的时间列表序列

```python
["%02d:%02d"%(h,m) for h in range(0, 24) for m in range(0, 60, 5)]1
```

- 求(x, y)，其中x是0-5之间的偶数，y是0-5之间的奇数组成的元祖列表

```python
[(x,y) for x in range(5) if x%2==0 for y in range(5) if y%2==1] 

# [(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]123
```

- 求M中3, 6, 9组成的列表

```python
M = [[1,2,3], [4,5,6], [7,8,9]] 

[row[2] for row in M]          # [3, 6, 9] 

# 或者用下面的方式 

[M[row][2] for row in (0, 1, 2)] # [3, 6, 9]1234567
```

- 求M中斜线1, 5, 9组成的列表

```python
M = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] 

[M[i][i] for i in range(len(M))]   # 打印M[0][0], M[1][1], M[2][2]

# [1, 5, 9]12345
```

- 求M, N中矩阵和元素的乘积

```python
M = [[1,2,3],[4,5,6],[7,8,9]] 
N = [[2,2,2],[3,3,3],[4,4,4]] 

[M[row][col]*N[row][col] for row in range(3) for col in range(3)] 

# [2, 4, 6, 12, 15, 18, 28, 32, 36] 

[[M[row][col]*N[row][col] for col in range(3)] for row in range(3)] 
# [[2, 4, 6], [12, 15, 18], [28, 32, 36]] 

[[M[row][col]*N[row][col] for row in range(3)] for col in range(3)] 

# [[2, 12, 28], [4, 15, 32], [6, 18, 36]]12345678910111213
```

- 把字典中age键，按照条件赋新值

```python
bob = {'pay': 3000, 'job': 'dev', 'age': 42, 'name': 'Bob Smith'} 

sue = {'pay': 4000, 'job': 'hdw', 'age': 45, 'name': 'Sue Jones'} 

people = [bob, sue] 

[rec['age']+100 if rec['age'] >= 45 else rec['age'] for rec in people] # 注意for位置 

# [42, 145]123456789
```

- 列表推导式

```python
multiples = [i for i in range(30) if i%3 == 0]
print(multiples)

# Output: [0, 3, 6, 9, 12, 15, 18, 21, 24, 27]

def squared(x):
    return x*x

multiples = [squared(i) for i in range(30) if i%3 == 0]
print(multiples)
#  Output: [0, 9, 36, 81, 144, 225, 324, 441, 576, 729]1234567891011
```

#### 1.2 使用()生成generator

将上述两表推导式的[]改成()，即可得到生成器。

```python
multiples = (i for i in range(30) if i%3 == 0)
print(type(multiples))

#  Output: <type 'generator'>1234
```



### 2. 字典推导式

字典推导和列表推导的使用类似，只不过中括号改成大括号。

基本格式：{ key_expr: value_expr for value in collection if condition }

举例说明：

- 用字符串和其长度创建字典

```python
strings = ['import','is','with','if','file','exception']
D = {key: val for val,key in enumerate(strings)}

D

# {'exception': 5, 'file': 4, 'if': 3, 'import': 0, 'is': 1, 'with': 2}123456
```

- 大小写key合并

```python
mcase = {'a': 10, 'b': 34, 'A': 7, 'Z': 3}

mcase_frequency = {
    k.lower(): mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0)
    for k in mcase.keys()
    if k.lower() in ['a','b']
}

print(mcase_frequency)
#  Output: {'a': 17, 'b': 34}12345678910
```

- 快速更换key和value

```python
mcase = {'a': 10, 'b': 34}
mcase_frequency = {v: k for k, v in mcase.items()}
print(mcase_frequency)

#  Output: {10: 'a', 34: 'b'}12345
```



### 3. 集合推导式

集合推导式跟列表推导式也是类似的。 唯一的区别在于它使用大括号{ }。

基本格式：{ expr for value in collection if condition }

举例说明：

- 集合推导式

```python
squared = {x**2 for x in [1, 1, 2]}
print(squared)

# Output: set([1, 4])1234
```

- 用集合推导式，创建字符串长度的集合

```python
strings = ['a','is','with','if','file','exception'] 

{len(s) for s in strings}  # 有长度相同的会只留一个，这在实际上也非常有用 

# {1, 2, 4, 9} 12345
```

- 一个由男人列表和女人列表组成的嵌套列表，取出姓名中带有两个以上含字母e的姓名，组成列表

```python
names = [['Tom','Billy','Jefferson','Andrew','Wesley','Steven','Joe'], ['Alice','Jill','Ana','Wendy','Jennifer','Sherry','Eva']]
tmp = [] 

# 用for循环实现
for lst in names:
    for name in lst: 
        if name.count('e') >= 2: 
            tmp.append(name)

print(tmp) 

# 用嵌套列表实现
[name for lst in names for name in lst if name.count('e')>=2] # 注意遍历顺序，这是实现的关键 

# ['Jefferson', 'Wesley', 'Steven', 'Jennifer']
```

## 匿名函数


当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。

在Python中，对匿名函数提供了有限支持。还是以`map()`函数为例，计算f(x)=x2时，除了定义一个`f(x)`的函数外，还可以直接传入匿名函数：

```python
>>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[1, 4, 9, 16, 25, 36, 49, 64, 81]
```

通过对比可以看出，匿名函数`lambda x: x * x`实际上就是：

```python
def f(x):
    return x * x
```

关键字`lambda`表示匿名函数，冒号前面的`x`表示函数参数。

匿名函数有个限制，就是只能有一个表达式，不用写`return`，返回值就是该表达式的结果。

用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：

```python
>>> f = lambda x: x * x
>>> f
<function <lambda> at 0x101c6ef28>
>>> f(5)
25
```

同样，也可以把匿名函数作为返回值返回，比如：

```python
def build(x, y):
    return lambda: x * x + y * y
```

## `.py`与`.pyc`文件区别

- 我们把源代码放在`.py`文件中，在执行`.py`文件时，`Python`会把`.py`源文件编译成中间文件`.pyc`形式（byte-compiled），这样做是为了加快下次执行文件的速度。
- 在运行python源文件时，我们应该首先查看是否具有`.pyc`文件。如果有的话，且`.py`文件的修改时间和`.pyc`的修改时间一样，就会读取`.pyc`文件；否则，`Python`解释器就会读取原来的`.py`文件。
- 其实，并不是运行所有`.py`文件都会产生`.pyc`文件，只有在import相关`.py`文件时，才会生成相应`.pyc`文件。	



最后：

- 这次面试给了我很大的思考，基本上都是基础题目，不是很难，但是由于平时依赖代码提示器和Google去解决问题，导致自己很多东西知道怎么做，但是不查资料就无法写出来，或者是有Bug。python的学习应该更加深入，希望自己下次能做的更好。