<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>GPM调度器 on Luenci</title>
    <link>http://localhost:1313/tags/gpm%E8%B0%83%E5%BA%A6%E5%99%A8/</link>
    <description>Recent content in GPM调度器 on Luenci</description>
    <generator>Hugo -- 0.129.0</generator>
    <language>en-us</language>
    <atom:link href="http://localhost:1313/tags/gpm%E8%B0%83%E5%BA%A6%E5%99%A8/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang的goroutine模型概述和调度</title>
      <link>http://localhost:1313/articles/1/01/golang%E7%9A%84goroutine%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0%E5%92%8C%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/articles/1/01/golang%E7%9A%84goroutine%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0%E5%92%8C%E8%B0%83%E5%BA%A6/</guid>
      <description>&lt;h1 id=&#34;g-p-m-模型概述&#34;&gt;G-P-M 模型概述&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;每一个OS线程都有一个固定大小的内存块(一般会是&lt;code&gt;2MB&lt;/code&gt;)来做栈，这个栈会用来存储当前正在被调用或挂起(指在调用其它函数时)的函数的内部变量。&lt;/li&gt;
&lt;li&gt;这个固定大小的栈同时很大又很小。因为&lt;code&gt;2MB&lt;/code&gt;的栈对于一个小小的&lt;code&gt;Goroutine&lt;/code&gt;来说是很大的内存浪费，而对于一些复杂的任务（如深度嵌套的递归）来说又显得太小。因此，Go语言做了它自己的『线程』。&lt;/li&gt;
&lt;li&gt;在Go语言中，每一个Goroutine是一个独立的执行单元，相较于每个OS线程固定分配&lt;code&gt;2M&lt;/code&gt;内存的模式，Goroutine的栈采取了动态扩容方式， &lt;strong&gt;初始时仅为&lt;code&gt;2KB&lt;/code&gt;&lt;/strong&gt;，随着任务执行按需增长，最大可达&lt;code&gt;1GB&lt;/code&gt;（64位机器最大是&lt;code&gt;1G&lt;/code&gt;，32位机器最大是&lt;code&gt;256M&lt;/code&gt;），且完全由Golang自己的调度器 Go Scheduler 来调度。&lt;/li&gt;
&lt;li&gt;此外，&lt;code&gt;GC&lt;/code&gt;还会周期性地将不再使用的内存回收，收缩栈空间。 因此，Go程序可以同时并发成千上万个Goroutine是得益于它&lt;strong&gt;强劲的调度器和高效的内存模型&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;任何用户线程最终肯定都是要交由OS线程来执行&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​    Goroutine（称为G）也不例外，但是G并不直接绑定OS线程运行，而是由Goroutine Scheduler中的 &lt;code&gt;P - Logical Processor &lt;/code&gt;（逻辑处理器）来作为两者的&lt;code&gt;『中介』&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;P 可以看作是一个抽象的资源或者一个上下文，一个P绑定一个OS线程，在Golang的实现里把OS线程抽象成一个数据结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;M，G实际上是由M通过P来进行调度运行的&lt;/strong&gt;，但是在G的层面来看，&lt;strong&gt;P提供了G运行所需的一切资源和环境&lt;/strong&gt;，因此在G看来P就是运行它的 “CPU”，由 G、P、M 这三种由Go抽象出来的实现，最终形成了Go调度器的基本结构：&lt;/p&gt;
&lt;h2 id=&#34;g-goroutine&#34;&gt;G: Goroutine&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;G有以下状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;非&lt;code&gt;GC&lt;/code&gt;状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;idle&lt;/code&gt;:&lt;code&gt;_Gidle for idle&lt;/code&gt;，意思是这个goroutine刚被创建出来，还未被进行初始化。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;runnable&lt;/code&gt;: &lt;code&gt;_Grunnable for runnable&lt;/code&gt;意思是这个goroutine已经在运行队列，在这种情况下，goroutine还未执行用户代码，M的执行栈还不是goroutine自己的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;running&lt;/code&gt;: &lt;code&gt;_Grunning for running&lt;/code&gt;，意思是goroutine可能正在执行用户代码，M的执行栈已经由该goroutine所拥有，此时对象g不在运行队列中。这个状态值要待分配给M和P之后，交由M和P来设定&lt;/li&gt;
&lt;li&gt;&lt;code&gt;syscall&lt;/code&gt;, &lt;code&gt;waiting&lt;/code&gt;, &lt;code&gt;dead&lt;/code&gt;, &lt;code&gt;copystack&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对应的&lt;code&gt;GC&lt;/code&gt;状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scan&lt;/code&gt;, &lt;code&gt;scanrunnable&lt;/code&gt;, &lt;code&gt;scan running&lt;/code&gt;, &lt;code&gt;scansyscall&lt;/code&gt;, &lt;code&gt;scanwaiting&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_Gscan&lt;/code&gt;系列，用于标记正在被&lt;code&gt;GC&lt;/code&gt;扫描的状态，这些状态是由&lt;code&gt;_Gscan=0x1000&lt;/code&gt;再加上&lt;code&gt;_GRunnable&lt;/code&gt;, &lt;code&gt;_Grunning&lt;/code&gt;, &lt;code&gt;_Gsyscall&lt;/code&gt;和&lt;code&gt;_Gwaiting&lt;/code&gt;的枚举值所产生的，这么做的好处是直接通过简单的运算即可知道被Scan之前的状态。当被标记为这系列的状态时，这些&lt;code&gt;goroutine&lt;/code&gt;都不会执行用户代码，并且它们的执行栈都是被做该&lt;code&gt;GC&lt;/code&gt;的&lt;code&gt;goroutine&lt;/code&gt;所拥有。不过&lt;code&gt;_Gscanrunning&lt;/code&gt;状态有点特别，这个标记是为了阻止正在运行的&lt;code&gt;goroutine&lt;/code&gt;切换成其它状态，并告诉这个G自己扫描自己的堆栈。正是这种巧妙的方式，使得&lt;code&gt;Go&lt;/code&gt;语言的&lt;code&gt;GC&lt;/code&gt;十分高效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个Goroutine对应一个G结构体，G 存储 Goroutine的运行堆栈、状态以及任务函数，可重用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;G并非执行体，每个G需要绑定到P才能被调度执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;p-processor&#34;&gt;P: Processor&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;表示逻辑处理器， 对G来说，P相当于CPU核，G只有绑定到P(&lt;code&gt;在P的local run中&lt;/code&gt;)才能被调度。对M来说，&lt;code&gt;P&lt;/code&gt;提供了相关的执行环境(&lt;code&gt;Context&lt;/code&gt;)，如内存分配状态(&lt;code&gt;mcache&lt;/code&gt;)，任务队列(&lt;code&gt;G&lt;/code&gt;)等，&lt;strong&gt;P的数量决定了系统内最大可并行的G的数量（前提：物理CPU核数 &amp;gt;= P的数量），P的数量由用户设置的&lt;code&gt;GoMAXPROCS&lt;/code&gt;决定，但是不论&lt;code&gt;GoMAXPROCS&lt;/code&gt;设置为多大，P的数量最大为256&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;golang runtime&lt;/code&gt;是有个&lt;code&gt;sysmon&lt;/code&gt;的协程，他会轮询的检测所有的&lt;code&gt;P上下文队列&lt;/code&gt;，**只要 G-M 的线程长时间在阻塞状态，那么就重新创建一个线程去从runtime P队列里获取任务。先前的阻塞的线程会被游离出去了，当他完成阻塞操作后会触发相关的callback回调，并加入回线程组里。**简单说，如果你没有特意配置&lt;code&gt;runtime.SetMaxThreads&lt;/code&gt;，那么在没有可复用的线程的情况下，会一直创建新线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;m-machine&#34;&gt;M: Machine&lt;/h2&gt;
&lt;p&gt;​    OS线程抽象，&lt;strong&gt;代表着真正执行计算的资源&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在绑定有效的P后，进入schedule循环；而schedule循环的机制大致是从Global队列、P的Local队列以及wait队列中获取G，切换到G的执行栈上并执行G的函数，调用&lt;code&gt;Goexit&lt;/code&gt;做清理工作并回到M，如此反复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;M并不保留G状态，这是G可以跨M调度的基础，M的数量是不定的，由Go Runtime调整，为了防止创建过多OS线程导致系统调度不过来，目前默认最大限制为10000个。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在绝大多数时候，其实&lt;code&gt;P&lt;/code&gt;的数量和&lt;code&gt;M&lt;/code&gt;的数量是相等。 每创建一个&lt;code&gt;p&lt;/code&gt;, 就会创建一个对应的&lt;code&gt;M&lt;/code&gt;只有少数情况下，&lt;code&gt;M&lt;/code&gt;的数量会大于&lt;code&gt;P&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;work-stealinghttpssupertechcsailmitedupapersstealpdf-的调度算法&#34;&gt;&lt;em&gt;&lt;a href=&#34;https://supertech.csail.mit.edu/papers/steal.pdf&#34;&gt;work-stealing&lt;/a&gt;&lt;/em&gt; 的调度算法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;每个P维护一个G的本地队列；&lt;/li&gt;
&lt;li&gt;当一个G被创建出来，或者变为可执行状态时，就把他放到P的可执行队列中；&lt;/li&gt;
&lt;li&gt;当一个G在M里执行结束后，P会从队列中把该G取出；如果此时P的队列为空，即没有其他G可以执行， M就随机选择另外一个P，从其可执行的G队列中取走一半。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://gitee.com/luenci/RepoImg/raw/master/img/202108091238404.png&#34; alt=&#34;image-20210809113044316&#34;  /&gt;
&lt;/p&gt;</description>
    </item>
    <item>
      <title>Runtime:Golang 处理系统调用阻塞方式</title>
      <link>http://localhost:1313/articles/1/01/runtimegolang-%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%98%BB%E5%A1%9E%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/articles/1/01/runtimegolang-%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%98%BB%E5%A1%9E%E6%96%B9%E5%BC%8F/</guid>
      <description>&lt;h1 id=&#34;runtimegolang-处理系统调用阻塞方式&#34;&gt;Runtime：Golang 处理系统调用阻塞方式&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;当一个Goroutine由于执行 &lt;code&gt;系统调用&lt;/code&gt; 而阻塞时，会将M从GPM中分离出去，然后P再找一个G和M重新执行，避免浪费CPU资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;h2 id=&#34;什么是-runtime&#34;&gt;什么是 runtime&lt;/h2&gt;
&lt;p&gt;​    runtime 描述了&lt;strong&gt;程序运行时候&lt;/strong&gt;执行的软件/指令， 在每种语言有着不同的实现。可大可小，在 C 中，runtime 是库代码， 等同于&lt;code&gt; C runtime library&lt;/code&gt;，一系列 &lt;code&gt;C &lt;/code&gt;程序运行所需的函数，在&lt;code&gt;Java&lt;/code&gt;中，&lt;code&gt;runtime&lt;/code&gt; 还提供了 &lt;code&gt;Java&lt;/code&gt; 程序运行所需的虚拟机等。&lt;/p&gt;
&lt;p&gt;​    总而言之，&lt;strong&gt;runtime 是一个通用抽象的术语，指的是计算机程序运行的时候所需要的一切代码库，框架，平台等&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;go中的-runtime&#34;&gt;Go中的 runtime&lt;/h2&gt;
&lt;p&gt;在 Go 中， 有一个 runtime 库，其实现了垃圾回收，并发控制， 栈管理以及其他一些 Go 语言的关键特性。 runtime 库是每个 Go 程序的一部分，也就是说编译 Go 代码为机器代码时也会将其也编译进来。所以 Go 官方将其定位偏向类似于 C 语言中的库。Go 中的 runtime 不像 Java runtime （JRE， java runtime envirement ) 一样，jre 还会提供虚拟机， Java 程序要在 JRE 下 才能运行。&lt;/p&gt;
&lt;p&gt;所以在 Go 语言中， runtime 只是提供支持语言特性的库的名称，也就是 Go 程序执行时候使用的库。&lt;/p&gt;
&lt;h2 id=&#34;p的状态切换&#34;&gt;P的状态切换&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/202205201526793.png&#34; alt=&#34;P的状态切换&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;​    从上图我们可以看出 &lt;code&gt;P&lt;/code&gt; 执行系统调用时会执行 &lt;code&gt;entersyscall()&lt;/code&gt; 函数（另还有一个类似的阻塞函数 &lt;a href=&#34;https://github.com/golang/go/blob/go1.15.6/src/runtime/proc.go#L3171-L3212&#34;&gt;&lt;code&gt;entersyscallblock()&lt;/code&gt;&lt;/a&gt; ，注意两者的区别）。当系统调用执行完毕切换回去会执行 &lt;a href=&#34;https://github.com/golang/go/blob/go1.15.6/src/runtime/proc.go#L3222-L3305&#34;&gt;&lt;code&gt;exitsyscall()&lt;/code&gt;&lt;/a&gt; 函数，下面我们看一下这两个函数的实现。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
