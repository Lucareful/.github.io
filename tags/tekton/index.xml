<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Tekton on Luenci</title>
    <link>http://localhost:1313/tags/tekton/</link>
    <description>Recent content in Tekton on Luenci</description>
    <generator>Hugo -- 0.129.0</generator>
    <language>en-us</language>
    <atom:link href="http://localhost:1313/tags/tekton/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Tekton 入门</title>
      <link>http://localhost:1313/articles/1/01/tekton-%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/articles/1/01/tekton-%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;h1 id=&#34;tekton-入门&#34;&gt;Tekton 入门&lt;/h1&gt;
&lt;h2 id=&#34;术语解释&#34;&gt;术语解释&lt;/h2&gt;
&lt;h3 id=&#34;cloud-native&#34;&gt;Cloud Native&lt;/h3&gt;
&lt;p&gt;​	云原生是一种软件开发方法，其中应用程序被分解为微服务，这些微服务被打包到容器中，容器在云中动态编排以优化资源利用&lt;/p&gt;
&lt;h3 id=&#34;continuous-delivery&#34;&gt;Continuous Delivery&lt;/h3&gt;
&lt;p&gt;​	持续交付是一种软件开发实践，团队可以安全、快速、可持续地向用户发布软件变更。&lt;/p&gt;
&lt;h3 id=&#34;tekton&#34;&gt;Tekton&lt;/h3&gt;
&lt;p&gt;​	Tekton 是一个用于创建持续交付系统的开源 kubernetes 原生的框架。你可以使用 tekton 跨多个云提供商或混合环境构建，测试和部署。Tekton 通过抽象出复杂的kubenetes概念和实现细节来简化应用程序管理。它提供了用于声明持续交付管道的 Kubernetes 自定义资源。&lt;/p&gt;
&lt;h2 id=&#34;基本构建块&#34;&gt;基本构建块&lt;/h2&gt;
&lt;p&gt;    其中Task、TaskRun、Pipeline、PipelineRun、PipelineResource、Condition作为其核心CRD，这里主要介绍它们。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Task：&lt;/strong&gt; 定义构建任务，它由一系列有序steps构成。每个step可以定义输入和输出，且可以将上一个step的输出作为下一个step的输入。每个step都会由一个container来执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是 Tekton 中不可分割的最小单位，正如同 Pod 在 Kubernetes 中的概念一样&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TaskRun：&lt;/strong&gt; Task用于定义具体要做的事情，并不会真正的运行，而TaskRun就是真正的执行者，并且会提供执行所需需要的参数，一个TaskRun就是一个Pod。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Pipeline：&lt;/strong&gt; 顾名思义就是流水线，它由一系列Tasks组成。就像Task中的step一样，上一个Task的输出可以作为下一个Task的输入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PipelineRun：&lt;/strong&gt; Pipeline的实际执行，创建后会创建Pod来执行Task，一个PipelineRun中有多个Task。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PipelineResource：&lt;/strong&gt; 主要用于定义Pipeline的资源，常见的如Git地址、Docker镜像等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Condition：&lt;/strong&gt; 它主要是在Pipeline中用于判断的，Task的执行与否通过Condition的判断结果来决定。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt; PipelineResource和Condition都会被废弃。但是在低版本中还是会继续使用，所以这里会简单介绍一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.jsdelivr.net/gh/Lucareful/RepoImg/img/image-20230301151952643.png&#34; alt=&#34;image-20230301151952643&#34;  /&gt;
&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
