<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>回溯算法和LRU on Luenci</title>
    <link>http://localhost:1313/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%92%8Clru/</link>
    <description>Recent content in 回溯算法和LRU on Luenci</description>
    <generator>Hugo -- 0.129.0</generator>
    <language>en-us</language>
    <atom:link href="http://localhost:1313/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%92%8Clru/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>回溯算法和LRU</title>
      <link>http://localhost:1313/articles/1/01/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%92%8Clru/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/articles/1/01/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%92%8Clru/</guid>
      <description>回溯算法实现（DFS） 回溯算法其实就是我们常说的 DFS 算法，本质上就是一种暴力穷举算法 递归遍历二叉树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def back_track(nums, track, res): # 结束条件 if len(nums)== len(track): # res.extend(track) # 正常 res.append(track)# 不正常 return None # 遍历选择列表 for num in nums: if num in track: continue track.append(num) back_track(nums, track.copy(), res) track.pop() return None if __name__ == &amp;#39;__main__&amp;#39;: nums =[1, 2, 3] track =[] res =[] back_track(nums, track, res) print(res) 某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动</description>
    </item>
  </channel>
</rss>
