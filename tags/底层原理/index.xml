<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>底层原理 on Luenci</title>
    <link>http://localhost:1313/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</link>
    <description>Recent content in 底层原理 on Luenci</description>
    <generator>Hugo -- 0.129.0</generator>
    <language>en-us</language>
    <atom:link href="http://localhost:1313/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>list, tuple, dictionary, set的底层细节（python）</title>
      <link>http://localhost:1313/articles/1/01/list-tuple-dictionary-set%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%86%E8%8A%82python/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/articles/1/01/list-tuple-dictionary-set%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%86%E8%8A%82python/</guid>
      <description>list, tuple, dictionary, set的底层细节 列表实现细节 python中的列表的英文名是list，因此很容易和其它语言(C++, Java等)标准库中常见的链表混淆。事实上CPython的列表根本不是列表（可能换成英文理解起来容易些：python中的list不是list）。在CPython中，列表被实现为长度可变的数组。可参考《Python高级编程（第2版）》 从细节上看，Python中的列表是由对其它对象的引用组成的连续数</description>
    </item>
    <item>
      <title>浅谈Python垃圾回收机制</title>
      <link>http://localhost:1313/articles/1/01/%E6%B5%85%E8%B0%88python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/articles/1/01/%E6%B5%85%E8%B0%88python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</guid>
      <description>目前垃圾回收比较通用的解决办法有三种，引用计数，标记清除以及分代回收。 引用计数 引用计数也是一种最直观，最简单的垃圾收集技术。 在 Python 中，大多数对象的生命周期都是通过对象的引用计数来管理的。 其原理非常简单，我们为每个对象维护一个 ref 的字段用来记录对象被引用的次数，每当对象被创建或者被引用时将该对象的引用次数加一，当对象的引用被销毁时该对象的引用次数减一，当对象的引用次数减到零时说明程序中已经没有任何对象持</description>
    </item>
  </channel>
</rss>
