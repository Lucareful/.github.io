<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>网络模型 on Luenci</title>
    <link>http://localhost:1313/tags/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</link>
    <description>Recent content in 网络模型 on Luenci</description>
    <generator>Hugo -- 0.129.0</generator>
    <language>en-us</language>
    <atom:link href="http://localhost:1313/tags/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux 网络模型</title>
      <link>http://localhost:1313/articles/1/01/linux-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/articles/1/01/linux-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;h1 id=&#34;linux-网络模型&#34;&gt;linux 网络模型&lt;/h1&gt;
&lt;h2 id=&#34;概念说明&#34;&gt;概念说明&lt;/h2&gt;
&lt;p&gt;在进行解释之前，首先要说明几个概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户空间和内核空间&lt;/li&gt;
&lt;li&gt;进程切换&lt;/li&gt;
&lt;li&gt;进程的阻塞&lt;/li&gt;
&lt;li&gt;文件描述符&lt;/li&gt;
&lt;li&gt;缓存 I/O&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;用户空间与内核空间&#34;&gt;用户空间与内核空间&lt;/h3&gt;
&lt;p&gt;​	现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。&lt;/p&gt;
&lt;p&gt;​	针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为&lt;strong&gt;内核空间&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为&lt;strong&gt;用户空间&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;进程切换&#34;&gt;进程切换&lt;/h3&gt;
&lt;p&gt;​	为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。&lt;/p&gt;
&lt;p&gt;从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保存处理机上下文，包括程序计数器和其他寄存器。&lt;/li&gt;
&lt;li&gt;更新PCB信息。&lt;/li&gt;
&lt;li&gt;把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。&lt;/li&gt;
&lt;li&gt;选择另一个进程执行，并更新其PCB。&lt;/li&gt;
&lt;li&gt;更新内存管理的数据结构。&lt;/li&gt;
&lt;li&gt;恢复处理机上下文。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;总而言之就是很耗资源&lt;/strong&gt;，具体的可以参考这篇文章：&lt;a href=&#34;http://guojing.me/linux-kernel-architecture/posts/process-switch/&#34;&gt;进程切换&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;进程的阻塞&#34;&gt;进程的阻塞&lt;/h3&gt;
&lt;p&gt;​	正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。&lt;strong&gt;当进程进入阻塞状态，是不占用CPU资源的&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;文件描述符fd&#34;&gt;文件描述符fd&lt;/h3&gt;
&lt;p&gt;​	文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。&lt;/p&gt;
&lt;p&gt;​	文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。&lt;/p&gt;
&lt;h3 id=&#34;缓存-io&#34;&gt;缓存 I/O&lt;/h3&gt;
&lt;p&gt;​	缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的**页缓存（ page cache ）**中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓存 I/O 的缺点：&lt;/strong&gt;
数据在传输过程中需要在应用程序地址空间和内核进行&lt;strong&gt;多次数据拷贝&lt;/strong&gt;操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。&lt;/p&gt;
&lt;h3 id=&#34;io拷贝&#34;&gt;IO拷贝&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;DMA 负责内核间的 IO 传输，CPU 负责内核和应用间的 IO 传输。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更多详情见：&lt;a href=&#34;https://cloud.tencent.com/developer/article/1759493&#34;&gt;一文彻底揭秘操作系统之「零拷贝」！ - 腾讯云开发者社区-腾讯云 (tencent.com)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;cpu-copy&#34;&gt;CPU COPY&lt;/h4&gt;
&lt;p&gt;​	通过计算机的组成原理我们知道, 内存的读写操作是需要 CPU 的协调数据总线,地址总线和控制总线来完成的因此在&amp;quot;拷贝&amp;quot;发生的时候,往往需要 CPU 暂停现有的处理逻辑,来协助内存的读写，这种我们称为 CPU COPY。CPU COPY 不但占用了 CPU 资源,还占用了总线的带宽。&lt;/p&gt;
&lt;h4 id=&#34;dma-copy&#34;&gt;DMA COPY&lt;/h4&gt;
&lt;p&gt;​	DMA(DIRECT MEMORY ACCESS) 是现代计算机的重要功能，它有一个重要特点：当需要与外设进行数据交换时, CPU 只需要初始化这个动作便可以继续执行其他指令,剩下的数据传输的动作完全由DMA来完成可以看到 DMA COPY 是可以避免大量的 CPU 中断的&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
