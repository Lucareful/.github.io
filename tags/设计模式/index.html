<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>设计模式 | Luenci</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="Luenci">
<link rel="canonical" href="http://localhost:1313/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.54405a410796490bc874ab6181fac9b675753cc2b91375d8f882566459eca428.css" integrity="sha256-VEBaQQeWSQvIdKthgfrJtnV1PMK5E3XY&#43;IJWZFnspCg=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Luenci (Alt + H)">Luenci</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/index.xml" title="RSS Feed">
                    <span>RSS Feed</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    设计模式
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">鸭子类型介绍
    </h2>
  </header>
  <div class="entry-content">
    <p>鸭子类型 定义 鸭子类型（英语：duck typing）在程序设计中是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由&#34;当前方法和属性的集合“决定。这个概念的名字来源于由詹姆斯·惠特科姆·莱利提出的鸭子测试（见下面的“历史”章节），“鸭子测试”可以这样表述： ​ “当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to 鸭子类型介绍" href="http://localhost:1313/articles/1/01/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">行为型模式
    </h2>
  </header>
  <div class="entry-content">
    <p>行为型模式 行为型模式，顾名思义，它主要关注的是对象的责任。
它们关注对象之间的交互以及对象的响应性 对象应该能够交互，同时仍然保持松散耦合 观察者模式 在观察者设计模式中，对象（主题）维护了一个依赖（观察者）列表，以便主题可以使用观察者定义的任何方法通知所有观察者它所发生的变化。
它定义了对象之间的一对多的依赖关系，从而使得一个对象中的任何更改都将自动通知给其他对象 它封装了主题的核心组件 UML图 主题(Subject):类Subject需要了解Observe。Subject类具有许多方法，诸如register()和deregister()等，Observer可以通过这些方法注册到Subject类中。因此，一个Subject可以处理多个Observe。 观察者(Observe)：它为关注主题的对象定义了一个接口。它定义了Observe需要实现的各个方法，以便在主题发生变化时能够获得相应的通知。 具体观察者(ConcreteObserver):它用来保存应该与Subject的状态保持一致的状态。它实现了Observe接口以保持其状态与主题中的变化相一致。 代码案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #!/usr/bin/env python # -*- coding: utf-8 -*- class Subject(object): def __init__(self): self.__observer = [] def register(self, observer): self.__observer.append(observer) def notifyAll(self, *args, **kwargs): for observer in self.__observer: observer.notify(self, *args, **kwargs) class Observer1(object): def __init__(self, subject): subject.register(self) def notify(self, subject, *args): print(f&#34;{type(self).__name__}:: Got, {args} from {subject}&#34;) class Observer2(object): def __init__(self, subject): subject.register(self) def notify(self, subject, *args): print(f&#34;{type(self).__name__}:: Got, {args} from {subject}&#34;) if __name__ == &#39;__main__&#39;: subject = Subject() observer1 = Observer1(subject) observer2 = Observer2(subject) subject.notifyAll(&#34;notify~~~&#34;) 观察者模式的优点和缺点 优点：
它使得彼此交互的对象之间保持送耦合 它使得我们可以在无需对主题或观察者进行任何修改的情况下高效地发送数据到其他对象 可以随时添加/删除观察者 缺点：
观察者接口必须由具体观察者实现，这涉及继承。无法进行组合，因为观察者接口可以实例化 如果实现不当的话，观察者可能会增加复杂性，并导致性能降低 在软件应用程序中，通知有时可能是不可靠的，并导致竞争条件或不一致性 ...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to 行为型模式" href="http://localhost:1313/articles/1/01/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">结构型模式
    </h2>
  </header>
  <div class="entry-content">
    <p>结构型模式 结构型模式用于设计对象和类的结构，从而使它们之间可以互相协作以获取更大的结构。
结构型模式描述如何将对象和类组合成更大的结构 结构型模式是一种能够简化设计工作的模式，因为它能够找出更简单的方法来认识或表示实体之间的关系。在面向对象世界中，实体指的是对象或类 类模式可以通过继承来描述对象，从而提供更有用的程序接口，而对象模式则描述了如何将对象联系起来从而组合成更大的对象。结构型模式是类和对象模式的综合体 门面设计模式 它为子系统的一组接口提供一个统一的接口，并定义一个高级接口来帮助客户端通过更加简单的方式使用子系统 门面模式解决的问题是，如何用的单个接口对象来表示复杂的子系统。实际上它并不是封装子系统，而是对底层子系统进行组合 它促进了实现与多个客户端的解耦 UML图 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #!/usr/bin/env python # -*- coding: utf-8 -*- class EventManager(object): def __init__(self): print(&#34;Event Manager:: Let me talk to the folks\\n&#34;) def arrange(self): self.hotelier = Hotelier() self.hotelier.bookHotel() self.florist = Florist() self.florist.setFlowerRequirements() self.caterer = Caterer() self.caterer.setCuisine() self.musiccian = Musician() self.musiccian.setMusicType() class Hotelier(object): def __init__(self): print(&#34;Arranging the hotel for Marriage ?&#34;) def __isAvailable(self): print(&#34;Is the Hotel free for the event on given day?&#34;) return True def bookHotel(self): if self.__isAvailable(): print(&#34;Register the Booking \\n\\n&#34;) class Florist(object): def __init__(self): print(&#34;Flower Decorations for the Event ? --&#34;) def setFlowerRequirements(self): print(&#34;Carnations, Rose and Lilies would be used for Decorations\\n\\n&#34;) class Caterer(object): def __init__(self): print(&#34;Food Arrangements for the Event --&#34;) def setCuisine(self): print(&#34;Chinese &amp; Continental Cuisine to be served \\n\\n&#34;) class Musician(object): def __init__(self): print(&#34;Musical Arrangements for the Marriage --&#34;) def setMusicType(self): print() class You(object): def __init__(self): print(&#34;you::whoa Marriage Arrangements !&#34;) def askEventManager(self): print(&#34;you:: Let is Contact the Event Manager\\n\\n&#34;) em = EventManager() em.arrange() def __del__(self): print(&#34;All preparations done!&#34;) if __name__ == &#39;__main__&#39;: you = You() you.askEventManager() out： you::whoa Marriage Arrangements ! you:: Let is Contact the Event Manager Event Manager:: Let me talk to the folks Arranging the hotel for Marriage ? Is the Hotel free for the event on given day? Register the Booking Flower Decorations for the Event ? -- Carnations, Rose and Lilies would be used for Decorations Food Arrangements for the Event -- Chinese &amp; Continental Cuisine to be served Musical Arrangements for the Marriage -- All preparations done! 小结 EventManager类是简化接口的门面 EventManager 通过组合创建子系统对象，如Hotelier，Florist等。 ...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to 结构型模式" href="http://localhost:1313/articles/1/01/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">创建型模式
    </h2>
  </header>
  <div class="entry-content">
    <p>预备知识 @abstractmethod：抽象方法，含abstractmethod方法的类不能实例化，继承了含abstractmethod方法的子类必须复写所有abstractmethod装饰的方法，未被装饰的可以不重写
@ property：方法伪装属性，方法返回值及属性值，被装饰方法不能有参数，必须实例化后调用，类不能调用
@ classmethod：类方法，可以通过实例对象和类对象调用，被该函数修饰的方法第一个参数代表类本身常用cls，被修饰函数内可调用类属性，不能调用实例属性
@staticmethod：静态方法，可以通过实例对象和类对象调用，被装饰函数可无参数，被装饰函数内部通过类名.属性引用类属性或类方法，不能引用实例属性
创建型模式 创建型模式的工作原理是基于对象的创建机制的。由于这些模式隔离了对象的创建细节。所以使得代码能够与要创建的对象的类型互相独立。
它们的运行机制基于对象的创建方式 它们将对象创建的细节隔离开来 代码与所创建的对象的类型无关 单例模式 单例模式提供了这样一种机制，即确保类有且只有一个特定类型的对象，并提供全局访问点
UML图 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 In [1]: class Singleton(object): &#34;&#34;&#34; 单例模式 &#34;&#34;&#34; ...: def __new__(cls): ...: if not hasattr(cls, &#34;instance&#34;): ...: cls.instance = super(Singleton, cls).__new__(cls) ...: return cls.instance ...: In [2]: s = Singleton() In [3]: s Out[3]: &lt;__main__.Singleton at 0x7fc32793ed90&gt; In [4]: s2 = Singleton() In [5]: s2 Out[5]: &lt;__main__.Singleton at 0x7fc32793ed90&gt; In [21]: class Singletons(object): &#34;&#34;&#34; 懒汉式加载 &#34;&#34;&#34; ...: __instance = None ...: def __init__(self): ...: if not Singletons.__instance: ...: print(&#34;__init__ method called..&#34;) ...: else: ...: print(&#34;Instance alreadly created:&#34;,self.getInstance()) ...: @classmethod ...: def getInstance(cls): ...: if not cls.__instance: ...: cls.__instance = Singletons() ...: return cls.__instance ...: In [22]: a = Singletons() __init__ method called.. In [23]: a1 = Singletons() __init__ method called.. In [24]: a2 = Singletons() __init__ method called.. In [25]: a.getInstance() __init__ method called.. Out[25]: &lt;__main__.Singletons at 0x7fc327b020d0&gt; In [26]: a Out[26]: &lt;__main__.Singletons at 0x7fc327e48ca0&gt; In [27]: a1 Out[27]: &lt;__main__.Singletons at 0x7fc32763a250&gt; In [1]: class MyMetaClass(type): &#34;&#34;&#34; 元类实现单例模式 &#34;&#34;&#34; ...: _instances = {} ...: def __call__(cls,*args,**kwargs): ...: print(&#34;**** Here`s my MetaClass ****&#34;) ...: if cls not in cls._instances: ...: cls._instances[cls] = super(MyMetaClass,cls).__call__(*args,**kwargs) ...: return cls._instances[cls] In [2]: class test(metaclass=MyMetaClass): ...: pass ...: In [3]: a = test() **** Here`s my MetaClass **** In [4]: a2 = test() **** Here`s my MetaClass **** In [5]: id(a) Out[5]: 139837183079520 In [6]: id(a2) Out[6]: 139837183079520 虽然单例模式在许多情况下效果很好，但是由于单例模式具有全局访问权限，可能会存在一些问题
全局变量可能在某处已经被更改，但是开发人员仍然认为它们没有发生变化，而改变量还在应用程序的其他位置被使用 可能会对同一个对象创建多个应用（此单例类被多次实例化，实际只实例化一次就可以） 所有依赖于全局变量的类都会由于一个类的改变而紧密耦合为全局数据，从而可能在无意中影响另一个类 ...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to 创建型模式" href="http://localhost:1313/articles/1/01/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">设计模式
    </h2>
  </header>
  <div class="entry-content">
    <p>设计模式 设计模式设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。大部分设计模式要解决的都是代码的可扩展性问题。设计模式相对于设计原则来说，没有那么抽象，而且大部分都不难理解，代码实现也并不复杂。这一块的学习难点是了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用。 经典的设计模式有 23 种。随着编程语言的演进，一些设计模式（比如 Singleton）也随之...</p>
  </div>
  <footer class="entry-footer">Luenci</footer>
  <a class="entry-link" aria-label="post link to 设计模式" href="http://localhost:1313/articles/1/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"></a>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:1313/">Luenci</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
