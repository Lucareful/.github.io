<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>进程概念 on Luenci</title>
    <link>http://localhost:1313/tags/%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5/</link>
    <description>Recent content in 进程概念 on Luenci</description>
    <generator>Hugo -- 0.129.0</generator>
    <language>en-us</language>
    <atom:link href="http://localhost:1313/tags/%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>python的进程概念</title>
      <link>http://localhost:1313/articles/1/01/python%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/articles/1/01/python%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5/</guid>
      <description>&lt;h1 id=&#34;进程&#34;&gt;进程&lt;/h1&gt;
&lt;h2 id=&#34;进程概念&#34;&gt;进程概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进程（Process）是资源分配的最小单位，是线程的容器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序是固定不变的，而进程会根据运行需要，让操作系统动态分配各种资源的CPU的时间片轮转，在不同的时间段切换执行不同的进程，但是切换进程是比较耗时的；就引来了轻量级进程，也就是所谓的线程，一个进程中包括多个线程（代码流，其实也就是进程中同时跑的多个方法体）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序：例&lt;code&gt;xxx.py&lt;/code&gt;这是程序，是一个静态的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程：一个程序运行起来后，代码+用到的资源称之为进程，它是操作系统分配资源的基本单元。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程状态&#34;&gt;进程状态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;工作中，任务数往往大于cpu的核数，即一定有一些任务正在执行，而另外一些任务在等待cpu进行执行，因此导致了有了不同的状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;就绪态：运行的条件都已经满足，正在等在cpu执行&lt;/li&gt;
&lt;li&gt;执行态：cpu正在执行其功能&lt;/li&gt;
&lt;li&gt;等待态：等待某些条件满足，例如一个程序sleep了，此时就处于等待态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程的创建---multiprocessing&#34;&gt;进程的创建 - multiprocessing&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;multiprocessing模块就是跨平台版本的多进程模块，提供了一个Process类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;·创建子进程跟创建线程十分类似，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start0方法后动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Process语法结构如下：
&lt;code&gt;Process([group [，target[，name，[args[，kwargs]]]）&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;target：如果传递了函数的引用，这个子进程就执行这里（函数）的代码&lt;/li&gt;
&lt;li&gt;args：给target指定的函数传递的参数，以元组的方式传递&lt;/li&gt;
&lt;li&gt;kwargs：给target指定的函数传递命名参数&lt;/li&gt;
&lt;li&gt;name：给进程设定一个名字，可以不设定&lt;/li&gt;
&lt;li&gt;group：指定进程组，大多数情况下用不到&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Process创建的实例对象的常用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;start()：后动子进程实例（创建子进程）&lt;/li&gt;
&lt;li&gt;is_alive：判断进程子进程是否还在活着&lt;/li&gt;
&lt;li&gt;join([timeout]）：是否等待子进程执行结束，或等待多少秒o&lt;/li&gt;
&lt;li&gt;terminate：不管任务是否完成，立即终止子进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Process创建的实例对象的常用属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name：当前进程的别名，默认为Process-N，N为从1开始递增的整数&lt;/li&gt;
&lt;li&gt;pid：当前进程的pid（进程号）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;linux&lt;/code&gt;系统可使用&lt;code&gt;kill&lt;/code&gt;命令结束进程&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
